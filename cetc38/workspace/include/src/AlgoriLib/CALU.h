/*************************************************
  Copyright (C), 
  File name:      CALU.h
  Author:       Version: 
                Date: 
  Description:    // 用于详细说明此程序文件完成的主要功能，与其他模块
                  // 或函数的接口，输出值、取值范围、含义及参数间的控
                  // 制、顺序、独立或依赖等关系
  Others:         // 其它内容的说明
  Function List:  // 主要函数列表，每条记录应包括函数名及功能简要说明
    1. ....
  History:        // 修改历史记录列表，每条修改记录应包括修改日期、修改
                  // 者及修改内容简述  
    1. Date:	2007-7-24
       Author:	GRui
       Modification: add ACCTo32(), ACCToD16(), ACCToF32().
       
    2. Date:	2007-8-6
       Author:	GRui
       Modification: add ConjCFix16(), PermuteCFix16(), CountOne32(),
       				CountOneD16(), Float16(), Float32(), Fix32(), Not32(),
       				Xor32(), NOr32(), NAnd32(), Or32(), And32(), CountZero32(),
       				CountZeroD16(), OnePosi32(), OnePosiD16(), Max32(), 
       				Min32(), MaxD16(), MinD16(), MaxF32(), MinF32(),
       				MaxMin16(), IsHT32(), IsHTD16(), IsHTF32(), IsHE32(),
       				IsHED16(), IsHEF32(), IsHE16HL(), IsHE16LH(), 
       				IsHT16HL(), IsHT16LH()
       
	3. Date:	2007-8-13
       Author:	GRui
       Modification: add BIsHT32(), BIsHE32(), BIsHT16(), BIsHE16(), 
       				BIsHTF32(), BIsHEF32(), BIsEQF32()
       				
	4. Date:	2007-8-22
       Author:	GRui
       Modification: add ACC32OnCON(), ACCD16OnCON(), ACCF32OnCON()
       
	5. Date:	2007-9-3
       Author:	GRui
       Modification: 在ACCToF32()的参数列表中添加了8位指数信息。
       
	6. Date:	2007-9-10
       Author:	GRui
       Modification: 在ACCAddF32(),ACCSubF32(), ACCF32OnCON()的参数列表中添加了8位指数信息。
		
	7. Date:	2007-10-8
       Author:	GRui
       Check: AbsFlo32()
       
	8. Date:	2007-10-18
       Author:	GRui
       Added: Neg32(), NegD16(), NegF32()
       
	9. Date:	2007-12-17
       Author:	GRui
       Added: 为便于opcode 15的实现，添加InAdd16ToH(), InAdd16ToL(), InSub16ToH(), 
       				InSub16ToL(), InAddSub16ToHL(), InAddSub16ToLH()
    10. Date:	2008-3-30
       Author:	baohua
       依据指令集修改了fix32()函数。 
       
    11. Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCTo16()函数,模拟硬件实现截位输出。
       
    12. Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCTo32()函数,模拟硬件实现截位输出。
    
    13. Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCToF32()函数,模拟硬件实现截位输出。
       
    14. Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCAdd16Once()函数,修改为累加受饱和控制。
       
    15. Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCSub16Once()函数,修改为累加受饱和控制。
     
    16. Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCAddF32()函数,修改为累加受饱和控制，及标志位输出方式。
    
    17. Date:	2008-7-23 
       Author:	baohua
       Added: 修改了ACCD16OnCON()函数,修改为bug :(DSPU16s)(CONCLow << 1)。 
    
    18.Date:	2008-7-23 
       Author:	baohua
       Added: 依据LXM/zuren修改，修改了ACCAddF32()函数,修改为累加受结果输入指数为0时，做0处理。
    
    19.Date:	2008-8-1 
       Author:	baohua
       Added:   依据LXM/Guoerhui修改，修改了ACCAddF32()函数,分段赋值出现输入不符合格式情况，做0处理，非数除外。
    
    
    20.Date:	2008-8-15 
       Author:	baohua
       Added:   依据LXM/Guoerhui修改，修改了fix32()函数.
    
    21.Date:	2008-8-15 
       Author:	baohua
       Added:   依据LXM/Guoerhui修改，修改了float32()函数.
       
    22.Date:	2008-8-15 
       Author:	baohua
       Added:   依据LXM/Guoerhui修改，修改了float16()函数  
    
    23.Date:	2008-8-16 
       Author:	baohua
       Added:   依据LXM修改，修改了ACCAdd32()函数，受饱和控制 。 
       
    24.Date:	2008-8-16 
       Author:	baohua
       Added:   依据LXM修改，修改了ACCSub32()函数 ，受饱和控制 。 
       
    25.Date:	2008-9-28 
       Author:	baohua
       Added:   依据LXM修改，修改了AddF32()函数右规错误。
       
    26.Date:	2008-9-28 
       Author:	baohua
       Added:   依据LXM修改，修改了ACCAddF32()算法。
       
    27.Date:	2008-9-28 
       Author:	baohua
       Added:   依据LXM修改，修改了AddF32InAcc()函数右规错误。
    
    28.Date:	2008-10-6 
       Author:	baohua
       Added:   依据LXM修改，修改了AddF32()函数左规错误。 
                即2008.10.6修改为带保护位左移 。
    
    29.Date:	2008-10-8 
       Author:	baohua
       Added:   依据Grui要求，修改了ACCto32()函数,添加了一个参数。 
       
    30.Date:	2008-10-8 
       Author:	baohua
       Added:   依据Grui要求，修改了ACCtoD16()函数,添加了一个参数。
       
    31.Date:	2008-10-8 
       Author:	baohua
       Added:   依据Grui要求，修改了ACCtoF32()函数,添加了一个参数。  
       
    32.Date:	2008-10-10 
       Author:	baohua
       Added:   依据Lxm要求，修改了AddF32()函数,饱和位的取值情况。 
       
    33.Date:	2008-10-13 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32Half()函数,将指数相差1作为特殊情况处理。
       
    34.Date:	2008-10-13 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32()函数,做了一个简单的替换。
       
    35.Date:	2008-10-15 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32Half()函数,修改指数差1的问题。
          
    36.Date:	2008-10-17 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32()函数,修改结果指数值小于等于左归位数下溢出情况的问题。
           
    37.Date:	2008-10-17 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32Half()函数,修改结果指数值小于等于左归位数下溢出情况的问题。       
          
    38.Date:	2008-10-17 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32Half()函数,修改结结果指数在除以2之前值为1，除以2后下溢出。
    
       
    39.Date:	2008-10-18 
       Author:	baohua
       Added:   依据运算结果，修改了Absfloat32()函数,增加非数无效标志位。
       
    40.Date:	2008-10-18 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了U32ToAcc()函数,增加非数无效标志位。
       
    41.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHE32()函数.
          
          
    42.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHEF32()函数.
       
       
    43.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHE16()函数.
       
    44.Date:	2008-10-22 
       Author:	baohua
       Added:   依据运算结果，修改了AddF32Half()函数,33位补码求原码。
       
    45.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHE16HL()函数.

	46.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHE16LH()函数.

    47.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHT16HL()函数.

	48.Date:	2008-10-22 
       Author:	baohua
       modify： 本条未作修改 
       Added:   依据运算结果，修改了IsHT16LH()函数.
       
    49.
       Date:	2008-10-30 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了ACCTo32()函数.
       
    50.
       Date:	2008-10-30 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了ACCTo16()函数.
       
    51.
       Date:	2008-10-30 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了ACCAddF32()函数,都置标志位 .
       
    52.
       Date:	2008-10-31 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了AddF32Half()函数,标志位 .
       
    53.
       Date:	2008-10-31 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了AbsFlo32()函数,标志位 .
       
    54.
       Date:	2008-10-31 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了ACCToF32()函数,增加3种情况 
       
    55.
       Date:	2008-11-10 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了AddF32()函数,增加1种特殊情况 
       
    56.
       Date:	2008-11-10 
       Author:	baohua
       modify：  
       Added:   依据运算结果标志，修改了AddF32Half()函数,增加1种特殊情况
       
    57.
       Date:	2009-11-19 
       Author:	baohua
       modify：  
       Added:   依据运西电的运算结果，修改了Float32()修正参数错误,见2009.11.19日期修改标识 
    
    58.
       Date:	2008-12-24 
       Author:	baohua
       modify：  
       Added:   Fix32()函数，修改处(1)输入无穷大置标志位，并且不再清除 
                (2) 输入无穷大置,饱和情况下，输出最大值，不饱和时，正常截位取得结果 
          
    59.
       Date:	2008-12-04 
       Author:	baohua
       modify：  
       Added:   Fix32()函数，修改处修改记录58中第(2)项作出更加详细的约束，即，idiffexpidiffexp>54 移位溢出，结果为0。 
          
    60.
       Date:	2012-7-18 
       Author:	GRui
       modify： 1) rename IsHT32() to IsHT32_SZ(); rename IsHTD16() to IsHTD16_SZ(); rename IsHTF32() to IsHTF32_SZ();
                   rename IsHE32() to IsHE32_MN()
                2) change DSPU32 ACCTo32(DSP_BIT40 p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)
                   to     DSPU32 ACCTo32(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)
                3) change DSPU32 ACCToD16(DSP_BIT40 p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)
                   to     DSPU32 ACCToD16(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos);
                4) change DSPU32 ACCToF32(DSP_BIT40 p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 u8Exp,bool bolIsNAN)
                   to     DSPU32 ACCToF32(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 u8Exp,bool bolIsNAN);
       Added:   在BWDSP1042标签下新增系列函数(75个)。
       
       
       61.
       Date:	2012-8-10
       Author:	GRui
               
       删除：  1042标签下凡是没有标注"found"的函数待确认后均可能被删除（约17条）。
               另删除：AccMax2Fix32MN(), AccMin2Fix32MN()
       
       新增：  AccIsFix32MN(), AccMaxR2Fix32MN(), AccMinR2Fix32MN(), AddQ8(),SubQ8(),AddAbs32(),AddAbsF32(),ACCAddQ8(),ACCSubQ8(),ACCQ8OnCON(),	
               ACFIsNEQ32(), ACFIsNEQD16(),ACFIsNEQF32(),ACFIsNEQQ8(),AccMaxS3Fix16(),AccMinS3Fix16(),AccIsFlo32MN(),AccMaxR2Flo32MN(),AccMinR2Flo32MN(),	
               AccMaxR2Fix16(), AccMinR2Fix16(), AccMaxR3Fix16(),AccMinR3Fix16(),AccMaxRFix8(),AccMinRFix8(),
               AccMaxR2Fix16(), AccMinR2Fix16(), IsEQ16SZ(),IsEQ16HL(),AccAnd32(),AccAddHH32(),Fix16HTMax(),Fix16HTMin()
       
       修改参数：ACFIsHTQ8(),ACFIsHEQ8(),ACFIsEQQ8(),AccMaxFix32(),AccMaxFlo32(),AccMinFix32(),AccMinFlo32(),
                 AccMaxFix8(),AccMinFix8(), AccMax5Fix16(), AccMin5Fix16(),AccMax4Fix16(),AccMin4Fix16(),
                 AccMaxFix16Manh(),AccMinFix16Manh(),
                         
       修改函数说明：IsNEQ32_SZ(), IsHT32_MN(), IsNEQ32_MN(),IsNEQD16_SZ(),IsNEQD16_MN(),IsNEQF32_SZ(),IsNEQF32_MN(),
                     ACFIsHTD16(), ACFIsHED16(), ACFIsEQD16(), ACCABSQ8(), Sub32CA()
               
       62.
       Date:	2012-8-17
       Author:	GRui
       
       修改参数：Add32CA(), Sub32CA()
       
       63.
       Date:	2012-9-12
       Author:	GRui
       
       移动以下函数的定义到CSHF.h，以下函数在BWDSP100中均已实现: 
       CountZero32(), CountZeroD16(), CountOne32(), CountOneD16(), OnePosi32(), OnePosiD16(), And32(), Or32(),
       NAnd32(), NOr32(), Xor32(), Not32(), Float16(), Abs32(), AbsD16(), AbsFlo32(), PermuteCFix16(), ConjCFix16(),
       Float32(), Fix32()。
       
       64.
       Date:	2012-12-26
       Author:	zhaoxiang
       
       修改参数：Add32CA(), Sub32CA()，ACCToQ8()
       
       在Add32CA(), Sub32CA()的参数p_u32CA前加‘&’；
       将ACCToQ8()中p_u40ACC改为p_u48ACC。
       
       65.
       Date:	2013-1-1 
       Author:	GRui            
       
       新增：   ACCAddF64H(), ACCAddF64L(), AddAbs16(), ACCToF64L(), ACCToF64H()
       
       66.
       Date:	2013-1-2
       Author:	GRui
       
       修改：
       AccMinR2Fix16()接口定义命名有冲突，修改其中一个的函数名为AccMinR2Fix16Reg()
       AccMaxR2Fix16()接口定义命名有冲突，修改其中一个的函数名为AccMaxR2Fix16Reg()
       
       67.
       Date:	2013-04-15
       Author:	zhaoxiang
       
       修改参数： MaxMin16()
       新增函数：MaxManhRmACC(),MinManhRmACC(),MaxManhRmRnACC(),MinManhRmRnACC()
       
       68.
       Date:	2013-04-25
       Author:	zhaoxiang
       
       新增函数：ConditionalAssignD16(),MaxACC(),MinACC()
       
       
       69.
       Date:	2013-05-24
       Author:	zhaoxiang
       
       新增函数：BIsMCnd16()
       
       70.
       Date:	2013-05-31
       Author:	zhaoxiang
       
       修改函数：AddQ8()和SubQ8()的注释，增加这两个函数的有符号数加减功能（原来这两个函数只做无符号数）。
    
    	 71.
       Date:	2013-06-24
       Author:	zhaoxiang
       
       修改函数：ACCToF64L(), ACCToF64H()，ACCAddF64H(), ACCAddF64L()的注释和参数类型
       新增函数：ACCAddF64HToDFIRR(),ACCAddF64LToDFIRR()
       
       72.
       Date:	2013-10-18
       Author:	zhaoxiang
       
       修改函数：LShift32ACF()参数
       
       
       72.
       Date:	2013-12-30
       Author:	zhaoxiang
       修改函数：ACCAddF64LToDFIRR()参数名称
       新增函数：ACCSubF64H(), ACCSubF64L(), ACCSubF64HToDFIRR(), ACCSubF64LToDFIRR()
       
       73
       Date:	2014-1-23
       Author:	zhaoxiang
       修改函数: AccMinFlo32(),AccMaxFlo32(),Sub32CA(),Add32CA()新增参数
       新增函数：BNotIsMCnd16()

	   74
	   Date:	2014-3-26
	   Author:	zhaoxiang
	   修改函数: ACCSubF64L(),ACCAddF64L(),ACCToF64L(),ACCToF64H()新增参数
	   
	   75
	   Date:	2014-4-4
	   Author:	zhaoxiang
	   修改函数: ACCAddF64L(),ACCSubF64L(),ACCToF64H(),ACCToF64L()修改参数

	   76
	   Date:	2014-10-13
	   Author:	zhaoxiang
	   新增函数:ACCAddAMACC() ACCSubAMACC()

	   77
	   Date:	2014-12-29 
	   Author:	zhaoxiang
	   新增：AddOReg(),AddD16Reg(),SubOReg(),SubD16Reg()
	   
	   78
	   Date:	2015-6-4 
	   Author:	zhaoxiang
	   新增： ACCAddAbs16(),ACCSelfAdd()
	   
	   79
	   Date:	2015-7-7 
	   Author:	liuyu
	   新增： ACCSelfSub()
	   
	   
	   80
	   Date:	2015-7-14 
	   Author:	zhaoxiang
	   修改函数: ACCAddAbs16()、ACCSelfAdd()、ACCSelfSub()增加8位指数参数
       
    ***********************************************************/

//---------------------------------------------------------------------------
#ifndef CALU_H
#define CALU_H

/*---------------------------Include Files-------------------------*/
#include "dsptypes.h"  

/******************************************************************
	函数名：		Add32

	描述:			32位定点数据相加。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 Add32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Sub32

	描述:			32位定点数据相减。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 Sub32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
函数名：		Add16

描述:			16位定点数据相加。

参数:			p_u16Src1 -- 源操作数1。
                p_u32Src2 -- 源操作数2。
				p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
				p_u32ALUCR -- ALU控制寄存器。

返回值：		计算结果。

注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。


修改记录: 
	--------------------------------------
	日期			作者			修改处
*******************************************************************/  
extern DSPU16 Add16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
函数名：		Sub16

描述:			16位定点数据相减。

参数:			p_u16Src1 -- 源操作数1。
                p_u32Src2 -- 源操作数2。
				p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
				p_u32ALUCR -- ALU控制寄存器。

返回值：		计算结果。

注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。


修改记录: 
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern DSPU16 Sub16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		AddD16

	描述:			输入数据的高低16位分别作定点数据相加。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		SubD16

	描述:			输入数据的高低16位分别作定点数据相减。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Add32Half

	描述:			32位定点数据相加，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Add32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Sub32Half

	描述:			32位定点数据相减，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Sub32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Add16Half

	描述:			16位定点数据相加，再求平均。

	参数:			p_u16Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU16 Add16Half(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Sub16Half

	描述:			16位定点数据相减，再求平均。

	参数:			p_u16Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU16 Sub16Half(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		AddD16Half

	描述:			输入数据的高低16位分别作定点数据相加，再求平均。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		SubD16Half

	描述:			输入数据的高低16位分别作定点数据相减，再求平均。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR); 
    

    
extern DSPU16 Abs16(DSPU16 p_u16Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    

    

    
/******************************************************************
	函数名：		ACCAdd32

	描述:			32位定点累加。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAdd32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		ACCSub32

	描述:			32位定点累减。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSub32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);  
        
/******************************************************************
	函数名：		AddF32

	描述:			32位浮点数据相加。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		SubF32

	描述:			32位浮点数据相减。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 SubF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		AddF32

	描述:			32位浮点数据相加，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddF32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		AddF32

	描述:			32位浮点数据相减，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 SubF32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		ACCAddD16

	描述:			源操作数的高低16位定点数据分别累加，累加结果寄存器分为两个20位寄存器以适应短字操作。					
					定点数据累加过程：16位数据扩展为20位数据，再与ACC中的20位数据累加。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCAddD16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		ACCSubD16

	描述:			源操作数的高低16位定点数据分别累减，累加结果寄存器分为两个20位寄存器以适应短字操作。					
					定点数据累减过程：16位数据扩展为20位数据，再与ACC中的20位数据累减。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCSubD16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		ACCAddF32

	描述:			32位浮点累加。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:		p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pEXP -- 指向8位指数的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR); //未完全实现 
    
/******************************************************************
	函数名：		ACCSubF32

	描述:			32位浮点累减。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pEXP -- 指向8位指数的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR); //未完全实现
    
/******************************************************************
	函数名：		AddD16CJ

	描述:			实现16位定点复数运算：(a + bi) + j(c + di)

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16CJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		SubD16CJ

	描述:			实现16位定点复数运算：(a + bi) - j(c + di)

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16CJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		AddD16HalfCJ

	描述:			实现16位定点复数运算：[(a + bi) + j(c + di)] / 2

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16HalfCJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		SubD16HalfCJ

	描述:			实现16位定点复数运算：[(a + bi) - j(c + di)] / 2

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16HalfCJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		ACCTo32

	描述:			  累加结果寄存器ACC截位输出为32位定点数据。

	参数:			  p_u40ACC -- 40位累加结果。
					    p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					    p_u32ALUCR -- ALU控制寄存器。
					    p_intCutPos -- 截位信息。
					

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；


	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCTo32(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos);
    
/******************************************************************
	函数名：		ACCToD16

	描述:			  累加结果寄存器ACC截位输出为高低16位定点数据。

	参数:			  p_u40ACC -- 40位累加结果。
					    p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					    p_u32ALUCR -- ALU控制寄存器。
					    p_intCutPos -- 截位信息。
					    

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；


	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToD16(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos);
    
/******************************************************************
	函数名：		ACCToF32

	描述:			累加结果寄存器ACC截位输出为32位浮点数据。

	参数:			p_u40ACC -- 40位累加结果。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。
					p_u8Exp -- 8位指数信息。

	返回值：		计算结果。

	注意事项:		根据计算结果设置相关标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToF32(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 u8Exp,bool bolIsNAN);
    

    

    

          

    


    

    

    

    

    

    

    

    

          

    
/******************************************************************
	函数名：		Max32

	描述:			求两个定点32位数据中的最大值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Max32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Min32

	描述:			求两个定点32位数据中的最小值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Min32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR); 
          
/******************************************************************
	函数名：		MaxD16

	描述:			分别求两个32位源操作数中高低16位的最大值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		MinD16

	描述:			分别求两个32位源操作数中高低16位的最小值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MinD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		MaxF32

	描述:			求两个浮点32位数据中的最大值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		MinF32

	描述:			求两个浮点32位数据中的最小值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MinF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		MaxMin16

	描述:			求浮点32位源操作数中高低16的最大值和最小值。

	参数:			p_u32Src -- 源操作数，包括高低16定点数据；
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	
					p_bolBigToH -- 结果的放置方式。
						true: 最大值放高16位，最小值放低16位；
						true: 最大值放低16位，最小值放高16位；						

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxMin16(DSPU32 p_u32Src, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR, bool p_bolBigToH);
         
/******************************************************************
	函数名：		IsHED16

	描述:			两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令手册中HRm=HRm>=HRn? HRm:HRn{k}的说明。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHED16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		IsHEF32

	描述:			如果p_u32Src1 >= p_u32Src2，则输出p_u32Src1,同时将1移到ALUCFR的最低位，
					否则输出p_u32Src2, 同时将0移到ALUCFR的最低位,
					然后ALUCFR本身左移一位。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHEF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		IsHE16HL

	描述:			p_u32Src的高16位同低16位进行比较，如果高16位大于等于低16位，
					则返回高16位, 否则返回低16位。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHE16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg,DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		IsHE16LH

	描述:			p_u32Src的高16位同低16位进行比较，如果低16位大于等于高16位，
					则返回低16位, 否则返回高16位。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHE16LH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		IsHT16HL

	描述:			p_u32Src的高16位同低16位进行比较，如果高16位大于低16位，
					则将高16位减低16位之差放入目的寄存器Rs的高16位, 否则输出0。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHT16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		IsHT16LH

	描述:			p_u32Src的高16位同低16位进行比较，如果低16位大于高16位，
					则将低16位减高16位之差放入目的寄存器Rs的高16位, 否则输出0。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHT16LH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		BIsHT32

	描述:			源操作数p_u32Src1是否大于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位定点数据。
					p_u32Src2 -- 源操作数2，32位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHT32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		BIsHE32

	描述:			源操作数p_u32Src1是否大于等于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位定点数据。
					p_u32Src2 -- 源操作数2，32位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于等于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHE32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		BIsHT16

	描述:			源操作数p_u16Src1是否大于源操作数p_u16Src2?

	参数:			p_u16Src1 -- 源操作数1，16位定点数据。
					p_u16Src2 -- 源操作数2，16位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u16Src1大于源操作数p_u16Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHT16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 p_u32ALUCR);  
    
/******************************************************************
	函数名：		BIsHE16

	描述:			源操作数p_u16Src1是否大于等于源操作数p_u16Src2?

	参数:			p_u16Src1 -- 源操作数1，16位定点数据。
					p_u16Src2 -- 源操作数2，16位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u16Src1大于等于源操作数p_u16Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHE16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		BIsHTF32

	描述:			源操作数p_u32Src1是否大于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHTF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		BIsHTF32

	描述:			源操作数p_u32Src1是否大于等于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于等于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHEF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		BIsHTF32

	描述:			源操作数p_u32Src1是否等于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1等于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsEQF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		ACC32OnCON

	描述:			32位定点累加或累减，受累加控制寄存器CON的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后
					CON左移一位。ALU0~ALU7每一个都配备一个32位累加控制寄存器。
					

	参数:			p_u32Src -- 源操作数，32位定点数据。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACC32OnCON(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		ACCD16OnCON

	描述:			高低16位定点累加或累减，受累加控制寄存器CON高低16位的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后CON高低16位
					分别左移一位。ALU0~ALU7每一个都配备一个32位累加控制寄存器。
					

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCD16OnCON(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR); 
   
/******************************************************************
	函数名：		ACCF32OnCON

	描述:			32位浮点累加或累减，受累加控制寄存器CON的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后
					CON左移一位。ALU0~ALU7每一个都配备一个32位累加控制寄存器。
					

	参数:			p_u32Src -- 源操作数，32位浮点数据。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pEXP -- 指向8位指数信息的指针。
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCF32OnCON(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		Neg32

	描述:			求32位定点数的负数。

	参数:			p_u32Src -- 源操作数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 Neg32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		NegD16

	描述:			求高低16位定点数的负数。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 NegD16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		NegF32

	描述:			求32位浮点数的负数。

	参数:			p_u32Src -- 32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 NegF32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
    
/******************************************************************
	函数名：		InAdd16ToH

	描述:			32位数据内部的高低16位相加，结果存于32位结果的高16位，低16位清零。
						对应指令形式：HHRs = HHRm + LHRm; HHRs = (HHRm + LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放计算结果，低16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAdd16ToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);
    
/******************************************************************
	函数名：		InAdd16ToL

	描述:			32位数据内部的高低16位相加，结果存于32位结果的低16位，高16位清零。
						对应指令形式：LHRs = HHRm + LHRm; LHRs = (HHRm + LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放计算结果，高16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAdd16ToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);
	
/******************************************************************
	函数名：		InSub16ToH

	描述:			32位数据内部的高低16位相减，结果存于32位结果的高16位，低16位清零。
						对应指令形式：HHRs = HHRm - LHRm; HHRs = (HHRm - LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放计算结果，低16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16ToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);
	
/******************************************************************
	函数名：		InSub16ToL

	描述:			32位数据内部的高低16位相减，结果存于32位结果的低16位，高16位清零。
						对应指令形式：LHRs = HHRm - LHRm; LHRs = (HHRm - LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放计算结果，高16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16ToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);
	
/******************************************************************
	函数名：		InAddSub16ToHL

	描述:			32位数据内部的高低16位相加，结果存于32位结果的高16位。
						32位数据内部的高低16位相减，结果存于32位结果的低16位。
						对应指令形式：HHRs = HHRm +/- LHRm; HHRs = (HHRm +/- LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放相加的结果，低16位存放相减的结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16ToHL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);
	
/******************************************************************
	函数名：		InAddSub16ToLH

	描述:			32位数据内部的高低16位相加，结果存于32位结果的低16位。
						32位数据内部的高低16位相减，结果存于32位结果的高16位。
						对应指令形式：LHRs = HHRm +/- LHRm; LHRs = (HHRm +/- LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放相加的结果，高16位存放相减的结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16ToLH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);
    
/*------------------------工大视频监控评估------------------------*/
  
/******************************************************************
	函数名：		IsEQ32

	描述:		先将比较标志寄存器本身右移一位，
	        如果p_u32Src1 == p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最高位置1；
				  否则，返回p_u32Src2，同时比较标志寄存器最高位置0。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQ32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);
  
/******************************************************************
	函数名：		IsEQ32L

	描述:		先将比较标志寄存器本身左移一位，
	        如果p_u32Src1 == p_u32Src2，比较标志寄存器的最低位置1；
				  否则，比较标志寄存器最低位置0。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		无。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void IsEQ32L(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);
  
/******************************************************************
	函数名：		IsHT32L

	描述:		先将比较标志寄存器本身左移一位，
	        如果p_u32Src1 > p_u32Src2，比较标志寄存器的最低位置1；
				  否则，比较标志寄存器最低位置0。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		无。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void IsHT32L(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);
  
/******************************************************************
	函数名：		IsHE32L

	描述:		先将比较标志寄存器本身左移一位，
	        如果p_u32Src1 >= p_u32Src2，比较标志寄存器的最低位置1；
				  否则，比较标志寄存器最低位置0。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		无。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void IsHE32L(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		IsHT32_SZ
	
	对应指令形式:  Rm=Rm>Rn?(Rm-Rn):0(U,k)
                 Rm=Rm>Rn?(Rm-Rn):0(k)

	描述:			如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录: rename IsHT32 to IsHT32_SZ
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHT32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		IsHTD16_SZ

	对应指令形式: HRm=HRm>HRn?(HRm-HRn):0(U,k)
                HRm=HRm>HRn?(HRm-HRn):0(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTD16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		IsHTF32_SZ

	对应指令形式: FRm=FRm> FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		IsHE32_MN
	
	对应指令形式:  Rm=Rm>=Rn?Rm:Rn(U,k)
                 Rm=Rm>=Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 >= p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHE32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*------------------------BWDSP1042------------------------*/
/*found*****************************************************************
	函数名：		InSub16LHToH
	
	对应指令形式: HHRs=LHRm-HHRm(U)
	              HHRs=LHRm-HHRm
	              HHRs=(LHRm-HHRm)/2(U)
	              HHRs=(LHRm-HHRm)/2

	描述:			32位数据内部的低高16位相减，结果存于32位结果的高16位，低16位清零。
						

	参数:			p_u32Src -- 32位数据，对应Rm，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放计算结果，低16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16LHToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);

/*found*****************************************************************
	函数名：		InSub16LHToL
	
	对应指令形式: LHRs=LHRm-HHRm(U)
	              LHRs=LHRm-HHRm
	              LHRs=(LHRm-HHRm)/2(U)
	              LHRs=(LHRm-HHRm)/2

	描述:			32位数据内部的低高16位相减，结果存于32位结果的低16位，高16位清零。						

	参数:			p_u32Src -- 32位数据，对应Rm，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放计算结果，高16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16LHToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);

/*found*****************************************************************
	函数名：		InAddSub16LHToH

	对应指令形式: HHRs=LHRm+/-HHRm (U) 	              
	              HHRs=LHRm+/-HHRm 
	              HHRs=(LHRm+/-HHRm)/2 (U) 
	              HHRs=(LHRm+/-HHRm)/2 

	描述:			32位数据内部的低16位加高16位，结果存于32位结果的高16位；
						32位数据内部的低16位减高16位，结果存于32位结果的低16位。

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16LHToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);

/*found*****************************************************************
	函数名：		InAddSub16LHToL

	对应指令形式: LHRs=LHRm+/-HHRm (U)	              
	              LHRs=LHRm+/-HHRm 
	              LHRs=(LHRm+/-HHRm)/2 (U) 
	              LHRs=(LHRm+/-HHRm)/2 

	描述:			32位数据内部的低16位加高16位，结果存于32位结果的低16位；
						32位数据内部的低16位减高16位，结果存于32位结果的高16位。

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16LHToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf);

/*found*****************************************************************
	函数名：		ACCToQ8
	
	对应指令形式: ORs=OACCm(U,cut=C)
                ORs=OACCm(cut=C)

	描述:			  累加结果寄存器ACC截位输出为4个8位定点数据。

	参数:			  p_u48ACC -- 48位累加结果。
					    p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					    p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数
					    p_intCutPos -- 截位信息。
					    

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；


	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToQ8(const DSP_BIT48 &p_u48ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos);  // 使用常引用提高传参效率

/*found*****************************************************************
	函数名：		IsHE32_SZ
	
	对应指令形式:  Rm=Rm>=Rn?(Rm-Rn):0(U,k)
                 Rm=Rm>=Rn?(Rm-Rn):0(k)

	描述:		如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHE32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQ32_SZ
	
	对应指令形式:  Rm=Rm==Rn?(Rm-Rn):0(U,k)
                 Rm=Rm==Rn?(Rm-Rn):0(k)

	描述:		如果p_u32Src1 == p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQ32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsNEQ32_SZ
	
	对应指令形式:  Rm=Rm!=Rn?(Rm-Rn):0(U,k)
                 Rm=Rm!=Rn?(Rm-Rn):0(k)

	描述:		如果p_u32Src1 != p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQ32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHT32_MN
	
	对应指令形式:  Rm=Rm>Rn?Rm:Rn(U,k)
                 Rm=Rm>Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 > p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHT32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQ32_MN
	
	对应指令形式:  Rm=Rm==Rn?Rm:Rn(U,k)
                 Rm=Rm==Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 == p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQ32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsNEQ32_MN
	
	对应指令形式:  Rm=Rm!=Rn?Rm:Rn(U,k)
                 Rm=Rm!=Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 != p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQ32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHED16_SZ

	对应指令形式: HRm=HRm>=HRn?(HRm-HRn):0(U,k)   
                HRm=HRm>=HRn?(HRm-HRn):0(k) 

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHED16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQD16_SZ

	对应指令形式: HRm=HRm==HRn?(HRm-HRn):0(U,k)
                HRm=HRm==HRn?(HRm-HRn):0(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQD16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsNEQD16_SZ

	对应指令形式: HRm=HRm!=HRn?(HRm-HRn):0(U,k)
                HRm=HRm!=HRn?(HRm-HRn):0(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQD16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHTD16_MN

	对应指令形式: HRm=HRm>HRn?HRm:HRn(U,k)
                HRm=HRm>HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTD16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHED16_MN

	对应指令形式: HRm=HRm>=HRn?HRm:HRn(U,k)
                HRm=HRm>=HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHED16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQD16_MN

	对应指令形式: HRm=HRm==HRn?HRm:HRn(U,k)
                HRm=HRm==HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQD16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsNEQD16_MN

	对应指令形式: HRm=HRm!=HRn?HRm:HRn(U,k)
                HRm=HRm!=HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQD16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHEF32_SZ

	对应指令形式: FRm=FRm>=FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHEF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQF32_SZ

	对应指令形式: FRm=FRm== FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 == p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsNEQF32_SZ

	对应指令形式: FRm=FRm!= FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 != p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHTF32_MN

	对应指令形式: FRm=FRm> FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 > p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsHEF32_MN

	对应指令形式: FRm=FRm>= FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 >= p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHEF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQF32_MN

	对应指令形式: FRm=FRm== FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 == p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsNEQF32_MN

	对应指令形式: FRm=FRm!=FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 != p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACCAddSubD16
	
	对应指令形式: HACCs = LHRm_HHRn (U)
                HACCs = HHRm_LHRn (U)
                HACCs +/-= LHRm_HHRn (U)
                HACCs -/+= LHRm_HHRn (U)
                HACCs +/-= HHRm_LHRn (U)
                HACCs -/+= HHRm_LHRn (U)

	描述:		双16位拼接无符号定点数累加累减。运算结果放在累加结果寄存器(ACC)。
          

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_ACC -- 48位累加结果寄存器中的值。                                   
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_u32Mode -- 模式选择。
					    0： Rm低16位数据放置在ACC高位，Rn高16位数据放置在ACC低位，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              1： Rm高16位数据放置在ACC高位，Rn低16位数据放置在ACC低位，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              2： Rm低16位数据与ACC高位累加，Rn高16位数据与ACC低位累减，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              3： Rm低16位数据与ACC高位累减，Rn高16位数据与ACC低位累加，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              4： Rm高16位数据与ACC高位累加，Rn低16位数据与ACC低位累减，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              5： Rm高16位数据与ACC高位累减，Rn低16位数据与ACC低位累加，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACCAddSubD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU32 p_u32Mode);

/*found*****************************************************************
	函数名：		LShift32ACF
	
	对应指令形式: Rs=Rm shift ACFk(c)

	描述:		将寄存器Rm数据逻辑左移，低位移入ACFk中的值，移入的数据为ACFk[C:0]。并将移位结果存入Rs中。

	参数:		p_u32Rm -- 源操作数1。
					p_u32ALUCFR -- ACF寄存器。
					p_u32Len -- 移位数，即C。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。						
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 LShift32ACF(DSPU32 p_u32Rm, DSPU32 &p_u32ALUCFR, DSPU32 p_u32Len, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg);

/*found*****************************************************************
	函数名：		LShiftD16ACF
	
	对应指令形式: HRs=HRm shift ACFk(c)

	描述:		双16位无符号定点数移位，将寄存器Rm数据逻辑左移，低位移入ACFk中的值，移入的数据为ACFk[C:0]。并将移位结果存入Rs中。

	参数:		p_u32Rm -- 源操作数1。
					p_u32ALUCFR -- ACF寄存器。
					p_u32Len -- 移位数，即C。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。						
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 LShiftD16ACF(DSPU32 p_u32Rm, DSPU32 p_u32ALUCFR, DSPU32 p_u32Len, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg);

/*found*****************************************************************
	函数名：		ACFIsHT32
	
	对应指令形式: ACFs=Rm>Rn?1:0(U)
                ACFs=Rm>Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm > p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHT32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsHE32
	
	对应指令形式: ACFs=Rm>=Rn?1:0(U)
                ACFs=Rm>=Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm >= p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHE32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsEQ32
	
	对应指令形式: ACFs=Rm==Rn?1:0(U)
                ACFs=Rm==Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm == p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQ32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsHTD16

	对应指令形式: ACFs=HRm>HRn?1:0(U)
                ACFs=HRm>HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm>HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm>LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHTD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACFIsHED16

	对应指令形式: ACFs=HRm>=HRn?1:0(U)
                ACFs=HRm>=HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm>=HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm>=LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHED16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACFIsEQD16

	对应指令形式: ACFs=HRm==HRn?1:0(U)
                ACFs=HRm==HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm==HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm==LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACFIsHTQ8
	
	对应指令形式: ACFk=ORm>ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]>Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]>Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]>Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]>Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHTQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsHEQ8
	
	对应指令形式: ACFk=ORm>=ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]>=Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]>=Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]>=Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]>=Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHEQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsEQQ8
	
	对应指令形式: ACFk=ORm==ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]==Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]==Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]==Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]==Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsHTF32
	
	对应指令形式: ACFs=FRm>FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm > p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHTF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsHEF32
	
	对应指令形式: ACFs=FRm>=FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm >= p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHEF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsEQF32
	
	对应指令形式: ACFs=FRm==FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm == p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACCABSQ8
	
	对应指令形式: ACCs = ABS(ORm-ORn)(U)
                ACCs += ABS(ORm-ORn)(U)

	描述:		将Rm、Rn分别分成4个8位数，对应相减得到4个结果，分别与原ACC中的对应值累加后送入ALU对应的ACC中（ACC平均分成4段，每段12位）。
          

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_ACC -- 48位累加结果寄存器。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					

	返回值：		

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。                 // GRQ: 标志位设置？待新版指令集确定。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACCABSQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg);

/*found*****************************************************************
	函数名：		Add32CA
	
	对应指令形式: ACCs=Rm+Rn+Ca
	              ACCs=Rm+Rn+Ca(U)
	              ACCs=Rm+Rn（U）
                ACCs=Rm+Rn

	描述:			32位定点数进位加法指令，结果输出至ACC中，其中Ca是ACCs 中的进位标志位，Ca的取值为0或者1；
	          该指令运算结果影响溢出标志位。溢出时，标志寄存器中的溢出标志位设置为“1”，否则标志寄存器中的溢出标志位设置为“0”。
   					该指令运算结果影响进位标志位。当运算有进位时，Ca为1，否则为0。

	参数:			p_u32Rm -- 源操作数1。
					  p_u32Rn -- 源操作数2。
					  p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					  
					  p_ACC -- 累加寄存器中的值，共48位。
					  p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					  p_u32CA -- ACC 中的进位标志寄存器，仅最低位有效。
					  p_CaIn -- 0 不使用CA寄存器
					            1 使用CA寄存器

	返回值：		

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern void Add32CA(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 &p_u32CA, DSPU32 p_CaIn);
    
/*found*****************************************************************
	函数名：		Sub32CA
	
	对应指令形式: ACCs=Rm-Rn-Ca(U)
                ACCs=Rm-Rn-Ca
                ACCs=Rm-Rn(U)
                ACCs=Rm-Rn

	描述:			32位定点数进位减法指令，结果输出至ACC中，其中Ca是ACCs 中的进位标志位，Ca的取值为0或者1；  // GRQ：待新版指令集确定
	          该指令运算结果影响溢出标志位。溢出时，标志寄存器中的溢出标志位设置为“1”，否则标志寄存器中的溢出标志位设置为“0”。
   					该指令运算结果影响进位标志位。当运算有进位时，Ca为1，否则为0。  // GRQ

	参数:			p_u32Rm -- 源操作数1。
					  p_u32Rn -- 源操作数2。
					  p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					  
					  p_ACC -- 累加寄存器中的值，共48位。
					  p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					  p_u32CA -- ACC 中的进位标志寄存器，仅最低位有效。
					  p_CaIn -- 0 不使用CA寄存器
					            1 使用CA寄存器
					  

	返回值：		

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern void Sub32CA(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 &p_u32CA, DSPU32 p_CaIn);

/*found*****************************************************************
	函数名：		ACCABSD16
	
	对应指令形式: ACCs = ABS(HRm-HRn)
                ACCs += ABS(HRm-HRn)

	描述:		将Rm、Rn分别分成2个16位数，对应相减得到2个结果，分别与原ACC中的对应值累加后送入ALU对应的ACC中
	       （使用ACC的低40位，平均分成2段，ACC高8位清零）。
          

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_ACC -- 48位累加结果寄存器。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。  // 使用什么标志寄存器？待新版指令集确定。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACCABSD16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg);

/*found*****************************************************************
	函数名：		AccMaxFix32
	
	对应指令形式: ACCs=MAX_S(Rm,Rn,ACCs)
	              ACCs=MAX_S(Rm,Rn)
	              ACCs=MAX_S(Rm,ACCs)

	描述:		有符号定点数选大，将Rm、Rn、ACCs[31..0]中的最大值放在ACC[31..0]，
	        同时将最大值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选大
					    1 -- Rm、Rn二者选大
					    2 -- Rm、ACCs[31..0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？
                                                                       // 性能调优阶段各库函数均需进行清理p_u32ALUCR和p_pStatReg，明确是否用到这两个参数。
	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFix32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel);

/*found*****************************************************************
	函数名：		AccMaxFlo32
	
	对应指令形式: ACCs=MAX_S(FRm,FRn,ACCs)
	              ACCs=MAX_S(FRm,FRn)
	              ACCs=MAX_S(FRm,ACCs)

	描述:		浮点数选大，将Rm、Rn、ACCs[31..0]中的最大值放在ACC[31..0]，
	        同时将最大值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选大
					    1 -- Rm、Rn二者选大
					    2 -- Rm、ACCs[31..0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFlo32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel, DSPU32 *p_pStatReg);

/*found*****************************************************************
	函数名：		AccMinFix32
	
	对应指令形式: ACCs=MIN_S(Rm,Rn,ACCs)
	              ACCs=MIN_S(Rm,Rn)
	              ACCs=MIN_S(Rm,ACCs)

	描述:		有符号定点数选小，将Rm、Rn、ACCs[31..0]中的最小值放在ACC[31..0]，
	        同时将最小值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选小的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选小
					    1 -- Rm、Rn二者选小
					    2 -- Rm、ACCs[31..0]二者选小
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？                 
                                                                       // 性能调优阶段各库函数均需进行清理p_u32ALUCR和p_pStatReg
	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFix32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel);

/*found*****************************************************************
	函数名：		AccMinFlo32
	
	对应指令形式: ACCs=MIN_S(FRm,FRn,ACCs)
	              ACCs=MIN_S(FRm,FRn)
	              ACCs=Min_S(FRm,ACCs)

	描述:		有符号定点数选大，将Rm、Rn、ACCs[31..0]中的最大值放在ACC[31..0]，
	        同时将最大值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选大
					    1 -- Rm、Rn二者选大
					    2 -- Rm、ACCs[31..0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFlo32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel, DSPU32 *p_pStatReg);

/*found*****************************************************************
	函数名：		AccMaxFix8
	
	对应指令形式: LOACCs=MAX_S(ORm,ORn,LOACCs)(U)
	              LOACCs=MAX_S(ORm,ORn)(U)
	              LOACCs=MAX_S(ORm,LOACCs)(U)

	描述:		无符号定点数选大，取Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]中的最大值放在ACC[7:0]；
					ACC的其他位清零；
	        该指令不影响标志位。
	        最大值对应序号放在ACCs[?:?]，对序号的定义如下；(GRQ)
	        		ACCs[7:0]对应的序号为ACCs[?:?]原来的值。
	        		当寄存器堆选择为A面时，9位序号的第[9]位为0，9位序号的第[9]位为1；
              Rm[31:24]对应序号的第[8:7]位为{2'b11}；Rm[23:16]对应序号的第[8:7]位为{2'b10}；
              Rm[15:8]对应序号的第[8:7]位为{2'b01}；Rm[7:0]对应序号的第[8:7]位为{2'b00}；
              Rn[31:24]对应序号的第[8:7]位为{2'b11}；Rn[23:16]对应序号的第[8:7]位为{2'b10}；
              Rn[15:8]对应序号的第[8:7]位为{2'b01}；Rn[7:0]对应序号的第[8:7]位为{2'b00}；
              Rm寄存器对应序号的低6位为m；Rn寄存器对应序号的低6位为n。              
	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]九者选大
					    1 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]八者选大
					    2 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、ACCs[7:0]五者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel);

/*found*****************************************************************
	函数名：		AccMinFix8
	
	对应指令形式: LOACCs=MIN_S(ORm,ORn,LOACCs)(U)
	              LOACCs=MIN_S(ORm,ORn)(U)
	              LOACCs=Min_S(ORm,LOACCs)(U)

	描述:		无符号定点数选小，取Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]中的最小值放在ACC[7:0]；
					ACC的其他位清零；
	        该指令不影响标志位。
	        最小值对应序号放在ACCs[?:?]，对序号的定义如下；(GRQ)
	        		ACCs[7:0]对应的序号为ACCs[?:?]原来的值。
	        		当寄存器堆选择为A面时，9位序号的第[9]位为0，9位序号的第[9]位为1；
              Rm[31:24]对应序号的第[8:7]位为{2'b11}；Rm[23:16]对应序号的第[8:7]位为{2'b10}；
              Rm[15:8]对应序号的第[8:7]位为{2'b01}；Rm[7:0]对应序号的第[8:7]位为{2'b00}；
              Rn[31:24]对应序号的第[8:7]位为{2'b11}；Rn[23:16]对应序号的第[8:7]位为{2'b10}；
              Rn[15:8]对应序号的第[8:7]位为{2'b01}；Rn[7:0]对应序号的第[8:7]位为{2'b00}；
              Rm寄存器对应序号的低6位为m；Rn寄存器对应序号的低6位为n。              
	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]九者选大
					    1 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]八者选大
					    2 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、ACCs[7:0]五者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel);

/*found*****************************************************************
	函数名：		AccMax5Fix16
	
	对应指令形式: LHACCs=MAX_S(HRm,HRn,LHACCs); 

	描述:		取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]
	        对序号的定义如下；
	        		ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
              Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；              
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax5Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMin5Fix16
	
	对应指令形式: LHACCs=MIN_S(HRm,HRn,LHACCs)

	描述:		取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]
	        对序号的定义如下；
	        		ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
              Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；              
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin5Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMax4Fix16
	
	对应指令形式: LHACCs=MAX_S(HRm,HRn)

	描述:		有符号定点数选大，取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]
	        对序号的定义如下；
              Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；     
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax4Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMin4Fix16
	
	对应指令形式: LHACCs=MIN_S(HRm,HRn); 

	描述:		有符号定点数选小，取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]中的最小值及对应的序号放在ACCs中的指定位置；
	        对序号的定义如下；
	        		Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；     
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin4Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMax3Fix16
	
	对应指令形式: LHACCs=MAX_OS(HHRm,HHRn,LHACCs)
	              LHACCs=MAX_OS(LHRm,LHRn,LHACCs)

	描述:		有符号定点数选大，取Rm[31:16]、Rn[31:16]、ACCs[15:0]或Rm[15:0]、Rn[15:0]、ACCs[15:0]中的最大值及对应的序号放在ACCs中的指定位置，
	        其中最大值放在ACCs[15..0]，最大值对应序号放在ACCs[21..16]；
	        对序号的定义如下；
	        		Rm[31:16]、Rm[15:0]对应的序号均为{m};
              Rn[31:16]、Rn[15:0]对应的序号均为{n};
              ACCs[15:0]对应的序号为ACCs[21:16]中的原值。
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_bolHH -- 指示Rm[31:16]、Rn[31:16]或Rm[15:0]、Rn[15:0]参与选大
					    true:  Rm[31:16]、Rn[31:16]参与选大
					    false: Rm[15:0]、Rn[15:0]参与选大
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, bool p_bolHH, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMin3Fix16
	
	对应指令形式: LHACCs=MIN_OS(HHRm,HHRn,LHACCs)
	              LHACCs=MIN_OS(LHRm,LHRn,LHACCs)

	描述:		有符号定点数选小，取Rm[31:16]、Rn[31:16]、ACCs[15:0]或Rm[15:0]、Rn[15:0]、ACCs[15:0]中的最小值及对应的序号放在ACCs中的指定位置，
	        其中最小值放在ACCs[15..0]，最小值对应序号放在ACCs[21..16]；
	        对序号的定义如下；
	        		Rm[31:16]、Rm[15:0]对应的序号均为{m};
              Rn[31:16]、Rn[15:0]对应的序号均为{n};
              ACCs[15:0]对应的序号为ACCs[21:16]中的原值。
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_bolHH -- 指示Rm[31:16]、Rn[31:16]或Rm[15:0]、Rn[15:0]参与选小
					    true:  Rm[31:16]、Rn[31:16]参与选小
					    false: Rm[15:0]、Rn[15:0]参与选小
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, bool p_bolHH, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMax2Fix16
	
	对应指令形式: LHACCs=MAX_OS(HHRm,HHRn)
	              LHACCs=MAX_OS(LHRm,LHRn)

	描述:		有符号定点数选大，取Rm[31:16]、Rn[31:16]或Rm[15:0]、Rn[15:0]中的最大值及对应的序号放在ACCs中的指定位置，
	        其中最大值放在ACCs[15..0]，最大值对应序号放在ACCs[21..16]；
	        对序号的定义如下；
	        		Rm[31:16]、Rm[15:0]对应的序号均为{m};
              Rn[31:16]、Rn[15:0]对应的序号均为{n};
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_bolHH -- 指示Rm[31:16]、Rn[31:16]或Rm[15:0]、Rn[15:0]参与选大
					    true:  Rm[31:16]、Rn[31:16]参与选大
					    false: Rm[15:0]、Rn[15:0]参与选大
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax2Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, bool p_bolHH, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMin2Fix16
	
	对应指令形式: LHACCs=MIN_OS(HHRm,HHRn)
	              LHACCs=MIN_OS(LHRm,LHRn)

	描述:		有符号定点数选小，取Rm[31:16]、Rn[31:16]或Rm[15:0]、Rn[15:0]中的最小值及对应的序号放在ACCs中的指定位置，
	        其中最小值放在ACCs[15..0]，最小值对应序号放在ACCs[21..16]；
	        对序号的定义如下；
	        		Rm[31:16]、Rm[15:0]对应的序号均为{m};
              Rn[31:16]、Rn[15:0]对应的序号均为{n};
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_bolHH -- 指示Rm[31:16]、Rn[31:16]或Rm[15:0]、Rn[15:0]参与选小
					    true:  Rm[31:16]、Rn[31:16]参与选小
					    false: Rm[15:0]、Rn[15:0]参与选小
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin2Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, bool p_bolHH, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMax2Fix32Abs
	
	对应指令形式: ACCs=MAX_S(abs(Rm+1)+abs(Rm),ACCs)
	              ACCs=MAX_S(abs(Rm+1)+abs(Rm))

	描述:		有符号定点数选大，Rm+1的绝对值和Rm的绝对值相加，其结果与ACCs[31:0]选大，选大结果存放在ACC[31:0]，最大值对应序号放在ACCs[37..32]；
	        Rm+1的绝对值和Rm的绝对值相加结果对应的序号为m，ACCs的序号为ACCs[37:32]的原值；
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rm+1中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax2Fix32Abs(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMin2Fix32Abs
	
	对应指令形式: ACCs=MIN_S(abs(Rm+1)+abs(Rm),ACCs)

	描述:		有符号定点数选小，Rm+1的绝对值和Rm的绝对值相加，其结果与ACCs[31:0]选小，选小结果存放在ACC[31:0]，最小值对应序号放在ACCs[37..32]；
	        Rm+1的绝对值和Rm的绝对值相加结果对应的序号为m，ACCs的序号为ACCs[37:32]的原值；
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rm+1中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin2Fix32Abs(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMax2Flo32Abs
	
	对应指令形式: FACCs=MAX_S(abs(FRm+1)+abs(FRm),FACCs)
	              FACCs=MAX_S(abs(FRm+1)+abs(FRm))

	描述:		浮点数选大，Rm+1的绝对值和Rm的绝对值相加，其结果与ACCs[31:0]选大，选大结果存放在ACC[31:0]，最大值对应序号放在ACCs[37..32]；
	        Rm+1的绝对值和Rm的绝对值相加结果对应的序号为m，ACCs的序号为ACCs[37:32]的原值；
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rm+1中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax2Flo32Abs(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMin2Flo32Abs
	
	对应指令形式: FACCs=MIN_S(abs(FRm+1)+abs(FRm),FACCs)

	描述:		浮点数选小，Rm+1的绝对值和Rm的绝对值相加，其结果与ACCs[31:0]选小，选小结果存放在ACC[31:0]，最小值对应序号放在ACCs[37..32]；
	        Rm+1的绝对值和Rm的绝对值相加结果对应的序号为m，ACCs的序号为ACCs[37:32]的原值；
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rm+1中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin2Flo32Abs(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMaxFix16Manh
	
	对应指令形式: LHACCs=MAX_S(manh(CHRm),manh(CHRn))

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最大值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
		          abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFix16Manh(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinFix16Manh
	
	对应指令形式: LHACCs=MIN_S(manh(CHRm),manh(CHRn))

	描述:		有符号定点数选小，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最小值存放在ACC[15:0]，最小值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
		          abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFix16Manh(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccIsFix32MN
	
	对应指令形式: ACCs=Rm_Rn

	描述:		将Rm[6:0]送到ACC[38:32]，Rn送到ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccIsFix32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMaxR2Fix32MN
	
	对应指令形式: ACCs=MAX_R(Rm_Rn,ACCs)

	描述:		有符号定点数选大，将Rn[31:0]值与ACCs[31:0]进行选大，如果ACCs值大，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，Rn[31:0]取代ACCs[31:0]；
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Fix32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinR2Fix32MN
	
	对应指令形式: ACCs=Min_R(Rm_Rn,ACCs) 

	描述:		有符号定点数选小，将Rn值与ACCs[31:0]进行选小，如果ACCs值小，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，Rn[31:0]取代ACCs[31:0]；
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                     

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Fix32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMaxFix8Sel
	
	对应指令形式: LOACCs=Max_OS(ORm,ORn,LOACCs)
	              LOACCs=Max_OS(ORm,ORn)

	描述:		无符号定点数选大，将Rm[23:16]、Rm[7:0]、Rn[23:16]、Rn[7:0]、ACCs[7:0]的最大值放在ACCs[7:0]，
	        最大值对应的序号放在ACCs的[15:8]，对序号的定义如下；                    
	          参与选大的值      对应序号
	            Rm[23:16]  -->  Rm[31:24]
	            Rm[7:0]    -->  Rm[15:8]
	            Rn[23:16]  -->  Rn[31:24]
	            Rn[7:0]    -->  Rn[15:8]
	            ACCs[7:0]  -->  ACCs[15:8]
	        			        		
	        ACC的高位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_bolCompAcc -- 控制ACC是否参与选大
					    true -- Rm[23:16]、Rm[7:0]、Rn[23:16]、Rn[7:0]、ACCs[7:0]五者选大
					    false -- Rm[23:16]、Rm[7:0]、Rn[23:16]、Rn[7:0]、ACCs[7:0]四者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFix8Sel(DSPU32 p_u32Rm, DSPU32 p_u32Rn, bool p_bolCompAcc, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMinFix8Sel
	
	对应指令形式: LOACCs=MIN_OS(ORm,ORn,LOACCs)
	              LOACCs=MIN_OS(ORm,ORn)

	描述:		无符号定点数选小，将Rm[23:16]、Rm[7:0]、Rn[23:16]、Rn[7:0]、ACCs[7:0]的最小值放在ACCs[7:0]， // signed or unsigned?
	        最小值对应的序号放在ACCs的[15:8]，对序号的定义如下；                        // 对序号的定义?
	          参与选小的值      对应序号
	            Rm[23:16]  -->  Rm[31:24]
	            Rm[7:0]    -->  Rm[15:8]
	            Rn[23:16]  -->  Rn[31:24]
	            Rn[7:0]    -->  Rn[15:8]
	            ACCs[7:0]  -->  ACCs[15:8]
	        			        		
	        ACC的高位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_bolCompAcc -- 控制ACC是否参与选小
					    true -- Rm[23:16]、Rm[7:0]、Rn[23:16]、Rn[7:0]、ACCs[7:0]五者选小
					    false -- Rm[23:16]、Rm[7:0]、Rn[23:16]、Rn[7:0]、ACCs[7:0]四者选小
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFix8Sel(DSPU32 p_u32Rm, DSPU32 p_u32Rn, bool p_bolCompAcc, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMax5Fix8
	
	对应指令形式: LHACCs=Max_OS(ORm,ACCs)

	描述:		无符号定点数选大，将Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、ACCs[7:0]的最大值放在ACCs[7:0]， // signed or unsigned?
	        最大值对应的序号放在ACCs[15:8]，对序号的定义如下；                        
	            Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]对应的序号低6位存放的是m的值，高2位存放的是最大值的位置信息m0。
	            如果最大值为Rm[7:0]，m0=0；
	            如果最大值为Rm[15:8]，则m0=1；
	            如果最大值为Rm[23:16]，则m0=2；
	            如果最大值为Rm[31:24]，则m0=3；
              ACCs[7:0]对应的序号为ACCs[15:8]。
	        			        		
	        ACC的高位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax5Fix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：		AccMin5Fix8
	
	对应指令形式: LHACCs=Min_OS(ORm,ACCs)

	描述:		无符号定点数选小，将Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、ACCs[7:0]的最小值放在ACCs[7:0]， // signed or unsigned?
	        最小值对应的序号放在ACCs[15:8]，对序号的定义如下；                        
	            Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]对应的序号低6位存放的是m的值，高2位存放的是最小值的位置信息m0。
	            如果最小值为Rm[7:0]，m0=0；
	            如果最小值为Rm[15:8]，则m0=1；
	            如果最小值为Rm[23:16]，则m0=2；
	            如果最小值为Rm[31:24]，则m0=3；
              ACCs[7:0]对应的序号为ACCs[15:8]。
	        			        		
	        ACC的高位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin5Fix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR); 

/******************************************************************
	函数名：		AccAdd32Sel
	
	对应指令形式: Rs=Rm+ACCn[37:32]      
                Rs=Rm+HHACCn  
                Rs=Rm+LHOACCn    

	描述:		见参数p_u32Mode说明。

	参数:		p_u32Rm -- 寄存器Rm中的值。					
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                          
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32Mode -- 模式选择
					    1 -- Rm寄存器内容与累加器ACCn[37:32]做无符号数加法，其结果送到Rs寄存器。
					    2 -- Rm寄存器内容与累加器ACCn[31:16]做无符号数加法，其结果送到Rs寄存器。
					    3 -- Rm寄存器内容与累加器ACCn[15:0]做无符号数加法，其结果送到Rs寄存器。

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccAdd32Sel(DSPU32 p_u32Rm, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 p_u32Mode);


/******************************************************************
	函数名：		Sigma32Out
	
	对应指令形式: xRs=sigma{x,y,z,t}Rm   

	描述:		将{x,y,z,t}Rm中的32位定点有符号数分别相加后送到x宏的Rs寄存器上。

	参数:		p_u32XRm -- X宏中寄存器Rm的值。			
					p_u32YRm -- Y宏中寄存器Rm的值。	
					p_u32ZRm -- Z宏中寄存器Rm的值。	
					p_u32TRm -- T宏中寄存器Rm的值。			
					

	返回值：		计算结果。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Sigma32Out(DSPU32 p_u32XRm, DSPU32 p_u32YRm, DSPU32 p_u32ZRm, DSPU32 p_u32TRm);

/******************************************************************
	函数名：		SigmaD16Out
	
	对应指令形式: xHRs=sigma{x,y,z,t}HRm

	描述:		将{x,y,z,t}Rm中的双16位定点有符号数分别相加后送到x宏的Rs寄存器上。该指令分配到运算宏外的两个单独的加法器上执行。

	参数:		p_u32XRm -- X宏中寄存器Rm的值。			
					p_u32YRm -- Y宏中寄存器Rm的值。	
					p_u32ZRm -- Z宏中寄存器Rm的值。	
					p_u32TRm -- T宏中寄存器Rm的值。			
					

	返回值：		计算结果。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 SigmaD16Out(DSPU32 p_u32XRm, DSPU32 p_u32YRm, DSPU32 p_u32ZRm, DSPU32 p_u32TRm);

/******************************************************************
	函数名：		SigmaD32Out
	
	对应指令形式: xRs+1:s=sigma{x,y,z,t}Rm+1:m

	描述:		将{x,y,z,t}Rm+1:m中的32位定点有符号数分别相加后送到x宏的Rs+1:s寄存器上。

	参数:		p_XRm -- X宏中寄存器Rm+1:m的值。			
					p_YRm -- Y宏中寄存器Rm+1:m的值。	
					p_ZRm -- Z宏中寄存器Rm+1:m的值。	
					p_TRm -- T宏中寄存器Rm+1:m的值。			
					p_Rs -- 输出寄存器Rs+1:s的值。
					

	返回值：	

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void SigmaD32Out(DSP_BIT64 &p_XRm, DSP_BIT64 &p_YRm, DSP_BIT64 &p_ZRm, DSP_BIT64 &p_TRm, DSP_BIT64 &p_Rs);

/******************************************************************
	函数名：		SigmaQ16Out
	
	对应指令形式: xHRs+1:s=sigma{x,y,z,t}HRm+1:m

	描述:		将{x,y,z,t}Rm中的双16位定点有符号数分别相加后送到x宏的Rs+1:s寄存器上。

	参数:		p_XRm -- X宏中寄存器Rm+1:m的值。			
					p_YRm -- Y宏中寄存器Rm+1:m的值。	
					p_ZRm -- Z宏中寄存器Rm+1:m的值。	
					p_TRm -- T宏中寄存器Rm+1:m的值。			
					p_Rs -- 输出寄存器Rs+1:s的值。
					

	返回值：	

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void SigmaQ16Out(DSP_BIT64 &p_XRm, DSP_BIT64 &p_YRm, DSP_BIT64 &p_ZRm, DSP_BIT64 &p_TRm, DSP_BIT64 &p_Rs);



/*found*****************************************************************
	函数名：		AddQ8
	
	对应指令形式: ORs=ORm+ORn(U)
								ORs=ORm+ORn

	描述:		4个8位定点数分别相加。

	参数:		p_u32Src1 -- 源操作数1，对应Rm，包含四个8位定点数据。
					p_u32Src2 -- 源操作数2，对应Rn，包含四个8位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器,第0位为1时为有符号定点加，第0位为0时为无符号定点加。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddQ8(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		SubQ8
	
	对应指令形式: ORs=ORm-ORn(U)
								ORs=ORm-ORn

	描述:		4个8位定点数分别相减。

	参数:		p_u32Src1 -- 源操作数1，对应Rm，包含四个8位定点数据。
					p_u32Src2 -- 源操作数2，对应Rn，包含四个8位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器,第0位为1时为有符号定点减，第0位为0时为无符号定点减。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubQ8(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AddAbs32
	
	对应指令形式: Rs=abs(Rm)+abs(Rn)

	描述:		将寄存器Rm、Rn中的32位定点有符号数分别求绝对值并相加，结果赋给目的寄存器Rs。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddAbs32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AddAbsF32
	
	对应指令形式: FRs=abs(FRm)+abs(FRn) 

	描述:		将寄存器Rm、Rn中的32位浮点数分别求绝对值并相加，结果赋给目的寄存器Rs。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddAbsF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACCAddQ8

	对应指令形式: OACCs =ORn (U)
                OACCs =ORn{U,con=Rm}
                OACCs+=ORn (U)
                OACCs+=ORn{U,con=Rm}

	描述:		源操作数内的四个8位定点数据分别累加。
	        累加过程：累加结果寄存器分为四个?位寄存器以适应短字操作，源操作数内的8位数据扩展为?位数据，再与ACC中的?位数据累加。
	        GRQ: 累加过程待确认。

	参数:		p_u32Src -- 源操作数，对应Rn。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCAddQ8(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACCSubQ8

	对应指令形式: OACCs-=0Rn (U)
                OACCs-=0Rn{U,con=Rm}

	描述:		源操作数内的四个8位定点数据分别累减。
	        累减过程：累加结果寄存器分为四个?位寄存器以适应短字操作，源操作数内的8位数据扩展为?位数据，再与ACC中的?位数据累减。
	        GRQ: 累减过程待确认。

	参数:		p_u32Src -- 源操作数，对应Rn。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCSubQ8(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACCQ8OnCON
	
	对应指令形式: OACCs+=0Rn{conc}
                OACCs+=0Rn{U,conc,con=Rm}

	描述:		源操作数内的四个8位定点数分别累加或累减，受累加控制寄存器CON内四个8位字段的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后CON内四个8位字段
					分别左移一位。ALU0~ALU7每一个都配备一个32位累加控制寄存器。
					

	参数:		p_u32Src -- 源操作数，包括四个8位定点数据。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果；
					    更新累加控制寄存器。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCQ8OnCON(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR); 

/*found*****************************************************************
	函数名：		ACFIsNEQ32
	
	对应指令形式: ACFs=Rm!=Rn?1:0(U)
                ACFs=Rm!=Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm != p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQ32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsNEQD16

	对应指令形式: ACFs=HRm!=HRn?1:0(U)
                ACFs=HRm!=HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm!=HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm!=LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ACFIsNEQF32
	
	对应指令形式: ACFs=FRm!=FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm != p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		ACFIsNEQQ8
	
	对应指令形式: ACFk=ORm!=ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]!=Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]!=Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]!=Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]!=Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR);

/*found*****************************************************************
	函数名：		AccMaxS3Fix16
	
	对应指令形式: LHACCs=MAX_S(HRm,LHACCs)

	描述:		16位定点有符号数选大操作：取Rm[31:16]、Rm[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]；
	        8位序号按照如下定义：
              Rm[31:16]对应序号的[5:0]为m,第[6]位为 1,第[7]位为寄存器页面选择；
              Rm[15:0]对应序号的[5:0]为m,第[6]位为 0,第[7]位为寄存器页面选择；
              ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxS3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinS3Fix16
	
	对应指令形式: LHACCs=Min_S(HRm,LHACCs)

	描述:		16位定点有符号数选小操作：取Rm[31:16]、Rm[15:0]、ACCs[15:0]最小值放在ACCs[15:0]，最小值对应序号放在ACCs[23:16]；
	        8位序号按照如下定义：
              Rm[31:16]对应序号的[5:0]为m,第[6]位为 1,第[7]位为寄存器页面选择；
              Rm[15:0]对应序号的[5:0]为m,第[6]位为 0,第[7]位为寄存器页面选择；
              ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinS3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccIsFlo32MN
	
	对应指令形式: FACCs=FRm_Rn

	描述:		将Rm[6:0]送到ACC[38:32]，FRn送到ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccIsFlo32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMaxR2Flo32MN
	
	对应指令形式: FACCs=MAX_R(FRm_Rn,FACCs) 

	描述:		将FRn[31:0]值与ACCs[31:0]进行选大，如果ACCs值大，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，FRn[31:0]取代ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Flo32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinR2Flo32MN
	
	对应指令形式: FACCs=MIN_R(FRm_Rn,FACCs) 

	描述:		将FRn值与ACCs[31:0]进行选小，如果ACCs值小，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，FRn[31:0]取代ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Flo32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMaxR2Fix16Reg
	
	对应指令形式: LHACCs=MAX_R(HRm,HRn)

	描述:		取Rm[15:0]、Rn[15:0]最大值放在ACCs[15:0]，最大值对应序号Rm[23:16]或Rn[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Fix16Reg(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinR2Fix16Reg
	
	对应指令形式: LHACCs=Min_R(HRm,HRn)

	描述:		取Rm[15:0]、Rn[15:0]最小值放在ACCs[15:0]，最小值对应序号Rm[23:16]或Rn[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Fix16Reg(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMaxR3Fix16
	
	对应指令形式: LHACCs=MAX_R(HRm,HRn,LHACCs)

	描述:		取Rm[15:0]、Rn[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号Rm[23:16]、Rn[23:16]或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinR3Fix16
	
	对应指令形式: LHACCs=Min_R(HRm,HRn,LHACCs)

	描述:		取Rm[15:0]、Rn[15:0]、ACCs[15:0]最小值放在ACCs[15:0]，最小值对应序号Rm[23:16]、Rn[23:16]或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMaxRFix8
	
	对应指令形式: LOACCs=Max_R(ORm,ORn,LOACCs)(U)
	              LOACCs=MAX_R(ORm,ORn)(U)                
                LOACCs=Max_R(ORm,LOACCs)(U)

	描述:		将Rm[7:0]、Rn[7:0]、ACCs[7:0]的最大值放在ACCs[7:0]，最大值对应的Rm[?:?]、Rn[?:?]、ACCs[?:?]作为序号放在ACCs的[?:?]
					ACC的其他位清零；
	        该指令不影响标志位。          
	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm[7:0]、Rn[7:0]、ACCs[7:0]三者选大
					    1 -- Rm[7:0]、Rn[7:0]二者选大
					    2 -- Rm[7:0]、ACCs[7:0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxRFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel);

/*found*****************************************************************
	函数名：		AccMinRFix8
	
	对应指令形式: LOACCs=Min_R(ORm,ORn,LOACCs)(U)
	              LOACCs=Min_R(ORm,ORn)(U)                
                LOACCs=Min_R(ORm,LOACCs)(U)

	描述:		将Rm[7:0]、Rn[7:0]、ACCs[7:0]的最小值放在ACCs[7:0]，最小值对应的Rm[?:?]、Rn[?:?]、ACCs[?:?]作为序号放在ACCs的[?:?]
					ACC的其他位清零；
	        该指令不影响标志位。          
	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32CompSel -- 选择参与选小的数据
					    0 -- Rm[7:0]、Rn[7:0]、ACCs[7:0]三者选小
					    1 -- Rm[7:0]、Rn[7:0]二者选小
					    2 -- Rm[7:0]、ACCs[7:0]二者选小
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinRFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel);

/*found*****************************************************************
	函数名：		AccMaxR2Fix16
	
	对应指令形式: LHACCs=MAX_R(HRm,LHACCs)

	描述:		取Rm[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号Rm[23:16]、或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Fix16(DSPU32 p_u32Rm, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccMinR2Fix16
	
	对应指令形式: LHACCs=MIN_R(HRm,LHACCs)

	描述:		取Rm[15:0]、ACCs[15:0]最小值放在ACCs[15:0]，最小值对应序号Rm[23:16]、或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Fix16(DSPU32 p_u32Rm, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQ16SZ
	
	对应指令形式: HHRs=HHRm==LHRm?(HHRm-LHRm):0(U,k) 
	              HHRs=HHRm==LHRm?(HHRm-LHRm):0(k)
	              LHRs=HHRm==LHRm?(HHRm-LHRm):0(U,k) 
	              LHRs=HHRm==LHRm?(HHRm-LHRm):0(k)

	描述:			如果高16位等于低16位，则输出(HHRm-LHRm),并且ACF左移一位之后最低位置1；
	          否则输出0,并且ACF左移一位之后最低位置0。

	参数:		p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsEQ16SZ(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		IsEQ16HL
	
	对应指令形式: HHRs=HHRm==LHRm?HHRm:LHRm(U,k)
	              HHRs=HHRm==LHRm?HHRm:LHRm(k)
                LHRs=HHRm==LHRm?HHRm:LHRm(U,k)                
                LHRs=HHRm==LHRm?HHRm:LHRm(k)

	描述:			如果高16位等于低16位，则输出(HHRm-LHRm),并且ACF左移一位之后最低位置1；
	          否则输出0,并且ACF左移一位之后最低位置0。

	参数:		p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsEQ16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccAnd32
	
	对应指令形式: ACCs=ACCs & Rm

	描述:			将ACCs[31:0]的值与Rm按位与后赋给ACCs[31:0],同时将ACCs的高位清零。

	参数:		p_u32Src -- 源操作数1。
					p_ACC -- 48位累加结果寄存器中的值。 
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccAnd32(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AccAddHH32
	
	对应指令形式: Rs=HHACCm+Rm(U)

	描述:			将ACCm[31:16]与Rm中的32位无符号数据相加，结果赋给目的寄存器Rs。

	参数:		p_u32Src -- 源操作数1。
					p_ACC -- 48位累加结果寄存器中的值。 
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 AccAddHH32(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		Fix16HTMax
	
	对应指令形式: LHRs=LHRm>max(LACCk,HACCk)+LRn ?(LHRm-max(LACCk,HACCk):0
                HHRs=LHRm>max(LACCk,HACCk)+LRn ?(HHRm-max(LACCk,HACCk):0
                LHRs=LHRm>max(LACCk,HACCk)+HRn ?(LHRm-max(LACCk,HACCk):0
                HHRs=LHRm>max(LACCk,HACCk)+HRn ?(HHRm-max(LACCk,HACCk):0

	描述:		条件赋值指令。
          例如：如果LHRm>max(LACCk,HACCk)+LHRn比较结果为真，输出LHRm-max(LACC,HACC)，同时比较标志寄存器ACF最低位置‘1’，ACF左移一位；
          否则输出‘0’，同时标志寄存器ACK最低位置‘0’，ACF左移一位。
          

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_u32Dest -- 输出结果，对应Rs。
					p_u32ALUCFR -- ACF寄存器。
					p_ACC -- 48位累加结果寄存器中的值。					                                   
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_u32Mode -- 模式选择。
					    0： 对应微操作LHRs=LHRm>max(LACCk,HACCk)+LRn ?(LHRm-max(LACCk,HACCk):0
              1： 对应微操作HHRs=LHRm>max(LACCk,HACCk)+LRn ?(HHRm-max(LACCk,HACCk):0
              2： 对应微操作LHRs=LHRm>max(LACCk,HACCk)+HRn ?(LHRm-max(LACCk,HACCk):0
              3： 对应微操作HHRs=LHRm>max(LACCk,HACCk)+HRn ?(HHRm-max(LACCk,HACCk):0
					

	返回值：	  

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void Fix16HTMax(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 &p_u32Dest, DSPU32 &p_u32ALUCFR, const DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU32 p_u32Mode);

/*found*****************************************************************
	函数名：		Fix16HTMin
	
	对应指令形式: LHRs=HHRm>min(LACCk,HACCk)+LRn ?(LHRm-min(LACCk,HACCk):0
                HHRs=HHRm>min(LACCk,HACCk)+LRn ?(HHRm-min(LACCk,HACCk):0
                LHRs=HHRm>min(LACCk,HACCk)+HRn ?(LHRm-min(LACCk,HACCk):0
                HHRs=HHRm>min(LACCk,HACCk)+HRn ?(HHRm-min(LACCk,HACCk):0  

	描述:		条件赋值指令。
          例如：如果LHRm>max(LACCk,HACCk)+LHRn比较结果为真，输出LHRm-max(LACC,HACC)，同时比较标志寄存器ACF最低位置‘1’，ACF左移一位；
          否则输出‘0’，同时标志寄存器ACK最低位置‘0’，ACF左移一位。
          

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_u32Dest -- 输出结果，对应Rs。
					p_u32ALUCFR -- ACF寄存器。
					p_ACC -- 48位累加结果寄存器中的值。					                                   
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_u32Mode -- 模式选择。
					    0： 对应微操作LHRs=HHRm>min(LACCk,HACCk)+LRn ?(LHRm-min(LACCk,HACCk):0
              1： 对应微操作HHRs=HHRm>min(LACCk,HACCk)+LRn ?(HHRm-min(LACCk,HACCk):0
              2： 对应微操作LHRs=HHRm>min(LACCk,HACCk)+HRn ?(LHRm-min(LACCk,HACCk):0
              3： 对应微操作HHRs=HHRm>min(LACCk,HACCk)+HRn ?(HHRm-min(LACCk,HACCk):0
					

	返回值：	  

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void Fix16HTMax(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 &p_u32Dest, DSPU32 &p_u32ALUCFR, const DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU32 p_u32Mode);


//----------------------------------------------------------------------------------------------

/******************************************************************
	函数名：	  ACCAddF64H

	对应指令形式: DFHACCs=DFHRm+DFHRn

	描述:		完成两个64位浮点数据高32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_FACC -- 64位浮点数累加结果寄存器，其中高16位只用11位做指数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64H(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT80 &p_FACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCAddF64L

	对应指令形式: DFLACCs=DFLRm+DFLRn

	描述:		完成两个64位浮点数据低32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_FACC -- 64位浮点数累加结果寄存器，其中高16位只用11位做指数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_DFIRR -- DFIRR寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64L(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
/******************************************************************
	函数名：		AddAbs16

	对应指令形式: LHRs=abs(HHRm)+abs(LHRm)

	描述:		两个16位有符号定点数分别求绝对值并相加。

	参数:		p_u32Src -- 源操作数，其高16位和低16位分别是两个16位有符号定点数。					
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddAbs16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCToF64L

	对应指令形式: DFLRs=DFLACCm

	描述:		输出64位浮点数据相加结果的低32位。与其他指令组合共同完成64位浮点相加运算。

	参数:		
					p_FACC -- 80位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_DFIRR -- DFIRR寄存器
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；					

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToF64L(const DSP_BIT80 p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
/******************************************************************
	函数名：	  ACCToF64H

	对应指令形式: DFHRs=DFHACCm

	描述:		输出64位浮点数据相加结果的高32位。与其他指令组合共同完成64位浮点相加运算。

	参数:		
					p_FACC -- 80位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_DFIRR -- DFIRR寄存器
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；					

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToF64H(const DSP_BIT80 p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
/*found*****************************************************************
	函数名：		MaxManhRmACC
	
	对应指令形式: LHACCs=MAX_S(manh(CHRm),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、ACCs[15:0]最大值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MaxManhRmACC(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		MinManhRmACC
	
	对应指令形式: LHACCs=Min_S(manh(CHRm),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、ACCs[15:0]最小值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MinManhRmACC(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		MaxManhRmRnACC
	
	对应指令形式: LHACCs=MAX_S(manh(CHRm),manh(CHRn),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最大值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	        		abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MaxManhRmRnACC(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		MinManhRmRnACC
	
	对应指令形式: LHACCs=Min_S(manh(CHRm),manh(CHRn),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最小值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	        		abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MinManhRmRnACC(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		ConditionalAssignD16

	对应指令形式: LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0
								HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0
								LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0
								HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0
								LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0
								HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0
								LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0
								HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0

	描述:		16位条件赋值运算。
					详细内容参考指令集手册20130402中双字指令7的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_Mode -- 模式选择，与8条指令依次对应0~7。
								0:	LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0
								1:	HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0
								2:	LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0
								3:	HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0
								4:	LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0
								5:	HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0
								6:	LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0
								7:	HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。
							2. 根据计算结果设置ACF寄存器.

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 ConditionalAssignD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_Mode, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		MaxACC

	对应指令形式: HHRs=max(LACCk,HACCk)(U,cut=C)
								HHRs=max(LACCk,HACCk)(cut=C)

								LHRs= max(LACCk,HACCk)(U,cut=C)
								LHRs= max(LACCk,HACCk)(cut=C)

	描述:		16位条件赋值运算。
					详细内容参考指令集手册20130402中双字指令7的说明。

	参数:		p_ACC -- 累加寄存器中的值，共48位。
					p_u32Imm -- 立即数,对应指令中的C。
					p_Mode -- 模式选择
									0:	HHRs=max(LACCk,HACCk)(U,cut=C)
											HHRs=max(LACCk,HACCk)(cut=C)

									1:	LHRs= max(LACCk,HACCk)(U,cut=C)
											LHRs= max(LACCk,HACCk)(cut=C)
					
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，第0位为1表示有符号数，为0表示无符号数。		
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxACC(const DSP_BIT48 &p_ACC, DSPU32 p_u32Imm, DSPU32 p_Mode, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		MinACC

	对应指令形式: HHRs=min(LACCk,HACCk)(U,cut=C)
								HHRs=min(LACCk,HACCk)(cut=C)

								LHRs=min(LACCk,HACCk)(U,cut=C)
								LHRs=min(LACCk,HACCk)(cut=C)

	描述:		16位条件赋值运算。
					详细内容参考指令集手册20130402中双字指令7的说明。

	参数:		p_ACC -- 累加寄存器中的值，共48位。
					p_u32Imm -- 立即数,对应指令中的C。
					p_Mode -- 模式选择
									2:	HHRs=min(LACCk,HACCk)(U,cut=C)
											HHRs=min(LACCk,HACCk)(cut=C)

									3:	LHRs= min(LACCk,HACCk)(U,cut=C)
											LHRs= min(LACCk,HACCk)(cut=C)
					
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，第0位为1表示有符号数，为0表示无符号数。		
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MinACC(const DSP_BIT48 &p_ACC, DSPU32 p_u32Imm, DSPU32 p_Mode, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);


/******************************************************************
	函数名：		BIsMCnd16

	描述:			多个条件执行同时满足才进行跳转。可以把多个条件判断语句的结果放到Rm中的固定某些位上，
						比较这些位是否满足等于C，完成多个条件同时满足才进行跳转的功能。
						详见指令集20130507.
	对应指令形式：
							If {x,y,z,t}HHRm[HHRn]==C BN <pro>
							If {x,y,z,t}LHRm[LHRn]==C BN <pro>

	参数:			p_u16Src1 -- 源操作数1，16位定点数据，对应HHRm或LHRm。
					  p_u16Src2 -- 源操作数2，16位定点数据，对应HHRn或LHRn。
					  p_u16Imm -- 立即数C，16位定点数据。

	返回值：		若HHRm[HHRn]==C，返回true，	否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsMCnd16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU16 p_u16Imm);

/******************************************************************
	函数名：	  ACCAddF64HToDFIRR

	对应指令形式: DFHACCs=DFHRm+DFHRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据高32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64HToDFIRR(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT64 &p_DFIRR);

/******************************************************************
	函数名：	  ACCAddF64LToDFIRR

	对应指令形式: DFLACCs=DFLRm+DFLRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据低32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64LToDFIRR(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT64 &p_DFIRR);

/******************************************************************
	函数名：	  ACCSubF64H

	对应指令形式: DFHACCs=DFHRm-DFHRn

	描述:		完成两个64位浮点数据高32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_FACC -- 64位浮点数累加结果寄存器，其中高16位只用11位做指数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64H(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT80 &p_FACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCSubF64L

	对应指令形式: DFLACCs=DFLRm-DFLRn

	描述:		完成两个64位浮点数据低32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_FACC -- 64位浮点数累加结果寄存器，其中高16位只用11位做指数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_DFIRR --DFIRR寄存器
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64L(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCSubF64HToDFIRR

	对应指令形式: DFHACCs=DFHRm-DFHRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据高32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64HToDFIRR(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT64 &p_DFIRR);

/******************************************************************
	函数名：	  ACCSubF64LToDFIRR

	对应指令形式: DFLACCs=DFLRm-DFLRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据低32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64LToDFIRR(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT64 &p_DFIRR);

/******************************************************************
	函数名：		BnotIsMCnd16

	描述:			    多个条件执行同时满足才进行跳转。可以把多个条件判断语句的结果放到Rm中的固定某些位上，
						比较这些位是否满足等于C，完成多个条件同时满足才进行跳转的功能。
						详见指令集20130507.
	对应指令形式：
							If {x,y,z,t}HHRm[HHRn]!=C BN <pro>
							If {x,y,z,t}LHRm[LHRn]!=C BN <pro>

	参数:			  p_u16Src1 -- 源操作数1，16位定点数据，对应HHRm或LHRm。
					  p_u16Src2 -- 源操作数2，16位定点数据，对应HHRn或LHRn。
					  p_u16Imm -- 立即数C，16位定点数据。

	返回值：		若HHRm[HHRn]!=C，返回true，	否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BNotIsMCnd16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU16 p_u16Imm);


/******************************************************************
	函数名：		ACCAddAMACC

	描述:			第s个ALU的累加器ACC中的40位浮点数与第s个乘法器中的40位浮点数寄存器AMACC中的浮点数进行40位浮点累加。
					ACCs+=AMACC

	参数:		p_AMACC -- 乘法器中的40位浮点数寄存器
					p_pACC -- 指向40位累加结果的指针。
					p_pEXP -- 指向8位指数的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddAMACC(DSP_BIT40 p_AMACC, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR); 

/******************************************************************
	函数名：		ACCSubAMACC

	描述:			第s个ALU的累加器ACC中的40位浮点数与第s个乘法器中的40位浮点数寄存器AMACC中的浮点数进行40位浮点累减。
					ACCs-=AMACC

	参数:		p_AMACC -- 乘法器中的40位浮点数寄存器
					p_pACC -- 指向40位累加结果的指针。
					p_pEXP -- 指向8位指数的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubAMACC(DSP_BIT40 p_AMACC, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR); 

/*found*****************************************************************
	函数名：		AddOReg

	指令形式：      HRs+1:s=ORm+ORn
	                HRs+1:s=ORm+ORn(U)

	描述:			8位有符号/无符号数相加,存入4个16位数中，
					Rm[7:0]与Rn[7:0]进行有符号数相加，结果存入函数返回值Rs[15:0]中；
					Rm[15:8]与Rn[15:8]进行有符号数相加，结果存入函数返回值Rs[31:16]中；
					详细说明见指令集20141226。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 AddOReg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		AddD16Reg

	指令形式：      Rs+1:s =HRm+HRn
	                Rs+1:s =HRm+HRn(U)

	描述:			16位有符号/无符号数相加，
					Rm[15:0]与Rn[15:0]由16位有符号数扩展为32位有符号数后，进行有符号数相加，结果存入Rs中
					详细说明见指令集20141211。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		Rs

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 AddD16Reg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		SubOReg

	指令形式：      HRs+1:s=ORm-ORn
	                HRs+1:s=ORm-ORn(U)

	描述:			8位有符号/无符号数相减,存入4个16位数中，
					Rm[7:0]与Rn[7:0]进行有符号数相减，结果存入函数返回值Rs[15:0]中；
					Rm[15:8]与Rn[15:8]进行有符号数相减，结果存入函数返回值Rs[31:16]中；
					详细说明见指令集20141226。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 SubOReg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/*found*****************************************************************
	函数名：		SubD16Reg

	指令形式：      Rs+1:s =HRm-HRn
	                Rs+1:s =HRm-HRn(U)

	描述:			16位有符号/无符号数相减，
					Rm[15:0]与Rn[15:0]由16位有符号数扩展为32位有符号数后，进行有符号数相减，结果存入Rs中
					详细说明见指令集20141211。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		Rs

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 SubD16Reg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCAddAbs16

	对应指令形式: HACCm=ABS(HRn)
	              HACCm+=ABS(HRn)

	描述:		将Rn寄存器的高低16位分别取绝对值，赋给ACCm的高低20位。若16位数据是0x8000，取绝对值后认为是正的0x08000，再赋到ACC中。

	参数:		p_u32Src -- 对应指令中的Rn。
					p_pACC -- p_pACC -- 指向40位累加结果的指针。
					p_EXP -- 48位ACC的高8位指数,此操作为定点操作，返回结果8位指数应为0
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddAbs16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_EXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCSelfAdd

	对应指令形式: LHACCm=HHACC+LHACC
								LHACCm=HHACC+LHACC(U)

	描述:		将ACC的高低20位相加，结果存入ACC低20位，高20位清0。

	参数:		p_pACC -- p_pACC -- 指向40位累加结果的指针。
					p_EXP -- 48位ACC的高8位指数,此操作为定点操作，返回结果8位指数应为0
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSelfAdd(DSP_BIT40 *p_pACC, DSPU8 *p_EXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);

/******************************************************************
	函数名：	  ACCSelfSub

	对应指令形式: LHACCm=HHACC-LHACC
				  LHACCm=LHACC-HHACC
                  LHACCm=-HHACC-LHACC
				  

	描述:		将ACC的高低20位相加，结果存入ACC低20位，高20位保持不变。

	参数:		p_pACC -- p_pACC -- 指向40位累加结果的指针。
					p_EXP -- 48位ACC的高8位指数,此操作为定点操作，返回结果8位指数应为0
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSelfSub(DSP_BIT40 *p_pACC, DSPU8 *p_EXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,int flag);

#endif 
