
#include "sc_iss.h"

/*---------------------------------------------------SHF Operations---------------------------------------------------*/
bool sc_iss::like_shiftr_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_shiftr_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_shiftr_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
			{
				DSPU32  u32Value;
		    	struct  SPLIT_VALUE
		    	{
		    		DSPU32    	u6SrcN: 6;
			    	DSPU32    	u6SrcM: 6;
					DSPU32    	u6Dest: 6;
					DSPU32    	u8Opcode: 8;
					DSPU32      u1MultiWord: 1;
					DSPU32      u4Units: 4;
		 		   	DSPU32      u1Line: 1;
				} details;
			} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{				
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if(p_u32Opcode == op_expan_chreg_c)
				{
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;
		DSPU32 GPLYValue;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}


				if((p_u32Opcode == op_jlh_32_c) || (p_u32Opcode == op_jlh_d16_c) ||(p_u32Opcode == op_jlh_q8_c))
				{
					//读取伽罗华系数
					GPLYValue = u32ro_GPLYR[i];
					m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0] = GPLYValue;	
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR, GPLYValue;
		DSP_BIT64 u64Res;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		u32Result = 0;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				if((p_u32Opcode == op_jlh_32_c) || (p_u32Opcode == op_jlh_d16_c) ||(p_u32Opcode == op_jlh_q8_c))
				{
					//读取伽罗华系数
					GPLYValue = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];	
				}

				u32Status = 0;
				switch (p_u32Opcode)
        		{
					// get result
					case op_shiftr_32_c:  //Rs=Rm ashift Rn
						u32Result = AShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                   		break;
					case op_arshift_32_c: //Rs=Rm arshift Rn
						u32Result = ArShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_shift0_32_c:  //Rs=Rm lshift Rn                 
						u32Result = LShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_lrshift_32_c: //Rs=Rm lrshift Rn 
						u32Result = LrShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_rot_32_c:   //Rs=Rm rot Rn                     
						u32Result = Rot32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_rrot_32_c: //Rs=Rm rrot Rn
						u32Result = Rrot32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_shiftr_c16_c:   //CHRs=CHRm ashift Rn       
						u32SHFCR = GSetBit(u32SHFCR, 0);
						u32SrcB = GSignExtend(u32SrcB, 5);  // GRQ: attention
						u32Result = AShiftD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_shift1_32_c:   //Rs=Rm lshift Rn {1}               
						u32Result = LShift32Fill1(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_minv_32_c:     //Rs=Rm minv Rn              
						u32Result = MaskInv(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_mclr_32_c:     //Rs=Rm mclr Rn                
						u32Result = MaskClr(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_mset_32_c:     //Rs=Rm mset Rn               
						u32Result = MaskSet(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_lxor_32_c:     //Rs=Rm LXOR Rn               
						u32Result = LXOR(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_rxor_32_c:     //Rs=Rm RXOR Rn                
						u32Result = RXOR(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_count0_32_c:   //Rs= Rm cnt0 Rn              
						u32Result = CountZero32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_count0_16_c:    //HRs= HRm cnt0 Rn             
						u32Result = CountZeroD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_onecount_reg_c:  //Rs= Rm cnt1 Rn         
						u32Result = CountOne32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_onecount_hreg_c:  //HRs= HRm cnt1 Rn       
						u32Result = CountOneD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_oneposi_reg_c:    //Rs= Rm pos1 Rn         
						u32Result = OnePosi32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_oneposi_hreg_c:    //HRs= HRm pos1 Rn       			
						u32Result = OnePosiD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_and_32_c:       //Rs=Rm & Rn              
						u32Result = And32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_or_32_c:       //Rs=Rm | Rn                 
						u32Result = Or32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_nand_32_c:     //Rs=Rm &! Rn              
						u32Result = NAnd32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_nor_32_c:       //Rs=Rm |! Rn              
						u32Result = NOr32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_xor_32_c:       //Rs=Rm ^ Rn              
						u32Result = Xor32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
					case op_jlh_32_c:       //Rs=Rm @* Rn(U)                 
						u32Result = JLH_32(u32SrcA, u32SrcB, GPLYValue, &u32Status, u32SHFCR);
						break;
					case op_jlh_d16_c:      //HRs=HRm @* HRn(U)                
						u32Result = JLH_D16(u32SrcA, u32SrcB, GPLYValue, &u32Status, u32SHFCR);
						break;
					case op_jlh_q8_c:       //ORs=ORm @*ORn(U)                 	
						u32Result = JLH_Q8(u32SrcA, u32SrcB, GPLYValue, &u32Status, u32SHFCR);
						break;
					case op_expan_chreg_c:  //CRs+1:s=EXPAND(CHRm,Rn)
						u32SHFCR = GSetBit(u32SHFCR, 0);
						ExpandC16(u64Res, u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						break;
               		default:
						PrintToCerr("like_shiftr_32_cores: opcode not found\n");
                    	u32Result = 0;
        		}
				
				if(p_u32Opcode == op_expan_chreg_c)
				{
					wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
				else
				{
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
				
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				// Log info for data forward
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
				u32GenResultIdx++;
		
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_not_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_not_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_not_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32DestIdx;
		union INSTR_WORD
			{
				DSPU32  u32Value;
		    	struct  SPLIT_VALUE
		    	{
		    		DSPU32    	u6Rev0: 6;
			    	DSPU32    	u6SrcM: 6;
					DSPU32    	u6Dest: 6;
					DSPU32    	u8Opcode: 8;
					DSPU32      u1MultiWord: 1;
					DSPU32      u4Units: 4;
		 		   	DSPU32      u1Line: 1;
				} details;
			} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{				
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA;
		DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{				
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				u32Status = 0;
				u32Result = Not32(u32SrcA, &u32Status, u32SHFCR);
				
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				// Log info for data forward
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
				u32GenResultIdx++;
		
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_shiftr_32_imm_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("like_shiftr_32_imm_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("like_shiftr_32_imm_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32DestIdx,u32Imm;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u6Imm: 6;
                    DSPU32      u6SrcM: 6;
                    DSPU32      u6Dest: 6;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0], 6);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if((p_u32Opcode == op_like_h16_to_f32_c ) && ((u32Imm & 3) == 2))
				{
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32Imm, u32Result;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;                

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;
		DSPU16 u16Temp;
		DSP_BIT64 u64Temp;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
		u32Result = 0;
		u64Temp.u32Low = 0;
		u64Temp.u32High = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {   
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                switch (p_u32Opcode)
                {
                    // get result
                    case op_shiftr_32_imm_c:  //Rs=Rm ashift a
                        u32Result = AShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        break;
                    case op_shift1_32_imm_c:   //Rs=Rm lshift a (1)                
                        u32Result = LShift32Fill1(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        break;
                    case op_shift0_32_imm_c:   //Rs=Rm lshift a                      
                        u32Result = LShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        break;
                    case op_rot_32_imm_c:       //Rs=Rm rot a           
                        u32Result = Rot32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        break;                   
                	case op_like_h16_to_f32_c:  
						u32SHFCR = GSetBit(u32SHFCR, 0);
						if ( (u32SrcB & 3) == 0 )  //FRs=Float HHRm
						{
							u16Temp = u32SrcA >> 16;
							u32Result = Float16(u16Temp, &u32Status, u32SHFCR);
						}
						else if ( (u32SrcB & 3) == 1 ) //FRs=Float LHRm
						{
							u16Temp = u32SrcA;
							u32Result = Float16(u16Temp, &u32Status, u32SHFCR);
						}
						else if ( (u32SrcB & 3) == 2 ) //CFRs+1:s=Float CHRm
						{
							
							FloatC16(u64Temp, u32SrcA, &u32Status, u32SHFCR);
						}
						break;
					case op_get_exp_mant_c:                  
						if(((u32SrcB>>1) & 1) == 0)
						{
							if ( (u32SrcB & 1) == 0 ) // Rs=exp FRm
							{
								u32Result = ExtractExp(u32SrcA, &u32Status, u32SHFCR);
							}
							else // Rs=mant FRm
							{
								u32Result = ExtractMant(u32SrcA, &u32Status, u32SHFCR);
							}
						}
						else
						{
							if ( (u32SrcB & 1) == 0 ) // Rs=INV_0 Rm
							{
								u32Result = INV32(u32SrcA, &u32Status, u32SHFCR);
							}
							else // HRs=INV_0 HRm
							{
								u32Result = INVD16(u32SrcA, &u32Status, u32SHFCR);
							}
						}
                        break; 
                    default:
                        PrintToCerr("like_shiftr_32_imm_cores: opcode not found\n");
                        u32Result = 0;
                }
    			
				if(p_u32Opcode == op_like_h16_to_f32_c && (u32SrcB & 3) == 2)      
				{
					wr_u32r_R_new(i, u32DestIdx,u64Temp.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx+1,u64Temp.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}      
				else
				{
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                }
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::expan_hhreg_etc_mode1_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("expan_hhreg_etc_mode1_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("expan_hhreg_etc_mode1_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u6SrcN: 6;
                    DSPU32      u6SrcM: 6;
                    DSPU32      u1Sign: 1;
					//DSPU32		u1Rev0:  1;
					DSPU32		u1HLSel:  1;
                    DSPU32      u3Mode: 3;
                    DSPU32      u1Flag: 1;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Sign;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1HLSel;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                // get the value of R[u32SrcNIdx] of current macro
                // data forward or directly
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32SrcMIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32Sign, u32Mode;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR, u32SrcMValue, u32HLSel;
        DSPU16 u16Src;
		bool IsHigh = false;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32HLSel = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5]; 

        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				
				if (u32Sign == 1)
				{
					u32SHFCR = GSetBit(u32SHFCR, 0);
				}				
                
                u32Status = 0;
				switch (u32Mode)
                {
                    // get result
                    case 1: 
						if(u32HLSel==1)
						{
							//u16Src取Rm的高16位
							u16Src = u32SrcA >> 16;
						}
						else
						{                        
							//u16Src取Rm的低16位
							u16Src = u32SrcA;
						}
						// Rm=EXPAND(HHRm,Rn)(U)  Rm=EXPAND(HHRm,Rn)
						// Rm=EXPAND(LHRm,Rn)(U)  Rm=EXPAND(LHRm,Rn)
						u32Result = Expand16(u16Src, u32SrcB, &u32Status, u32SHFCR);
                        break;
                    case 3: 
						if(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx == m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx)
						{
							//u32SrcMValue = u32SrcA;
							u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
						}
						else
						{
							u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
						}
						if(u32HLSel==1)
						{
							// HHRm=COMPACT(Rm,Rn)(U)
							// HHRm=COMPACT(Rm,Rn)
							u32Result = Compact32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							u32Result = u32SrcMValue & 0xFFFF | (u32Result << 16); // GRQ
						}
						else
						{
							// LHRm=COMPACT(Rm,Rn)(U)
							// LHRm=COMPACT(Rm,Rn)
							u32Result = Compact32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							u32Result = u32SrcMValue & 0xFFFF0000 | u32Result;
						}
                        break; 
					case 6:
						if(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx == m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx)
						{
							u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
							//u32SrcMValue = u32SrcA;
						}
						else
						{
							u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
						}
						if(u32HLSel==1)
						{
							IsHigh = true;
						}
						//u32SrcB为Rn，这里只用到Rn的[3:0]位
						u32SrcB = u32SrcB & 0xf;
						
						//LORm=COMPACT(CHRm,Rn)(U),LORm=COMPACT(CHRm,Rn)
						//HORm=COMPACT(CHRm,Rn)(U),HORm=COMPACT(CHRm,Rn)(U)
						u32Result = Compact16To8(u32SrcA, u32SrcB, IsHigh, &u32Status, u32SHFCR);
						if(u32HLSel==1)
						{
							u32Result = u32SrcMValue & 0xFFFF | (u32Result & 0xFFFF0000); // GRQ
						}
						else
						{
							u32Result = u32SrcMValue & 0xFFFF0000 | (u32Result & 0xFFFF); // GRQ
						}
						break;  
					case 7:
						if(u32HLSel==1)
						{
							IsHigh = true;
						}
						//u32SrcB为Rn，这里只用到Rn的[3:0]位
						u32SrcB = u32SrcB & 0xf;
						//HRm=EXPAND(LORM,Rn)(U), HRm=EXPAND(LORM,Rn)
						//HRm=EXPAND(HORM,Rn)(U), HRm=EXPAND(HORM,Rn)
						u32Result = Expand8To16(u32SrcA, u32SrcB, IsHigh, &u32Status, u32SHFCR);
						break;
                    default:
                        PrintToCerr("expan_hhreg_etc_mode1_cores: mode not found\n");
                        u32Result = 0;
                }
                
				wr_u32r_R_new(i, u32SrcMIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32SrcMIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::expan_hhreg_etc_mode0_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("expan_hhreg_etc_mode0_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("expan_hhreg_etc_mode0_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u5Imm: 5;
                    DSPU32		u1Rev: 1;
                    DSPU32      u6SrcM: 6;
                    DSPU32      u1Sign: 1;
					DSPU32      u1HLSel: 1;
                    DSPU32      u3Mode: 3;
                    DSPU32      u1Flag: 1;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1HLSel;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1Sign;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32Result, u32Imm;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
                
                m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;
				
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32SrcMIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32Sign, u32Mode;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR, u32HLSel, u32SrcMValue;
        DSPU16 u16SrcM;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32HLSel = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {           
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                if (u32Sign == 1)
                {
                    u32SHFCR = GSetBit(u32SHFCR, 0);
                }
                
                u32Status = 0;
                switch (u32Mode)
                {
                    // get result
                    case 0: // Rm=EXPAND(HHRm,a)(U)
                        if (u32HLSel == 1)
                        {
                            u16SrcM = u32SrcA >> 16;
                        }
                        else
                        {
                            u16SrcM = u32SrcA;
                        }
                        u32Result = Expand16(u16SrcM, u32SrcB, &u32Status, u32SHFCR);

                        break;
                    case 2: // LHRm=COMPACT(Rm,a)(U)
                        u32Result = Compact32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);	
						if(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx == m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx)
						{
							u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
							//u32SrcMValue = u32SrcA;
						}
						else
						{
							u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
						}
						
                        if (u32HLSel == 1)
                        {
                            u32Result = u32SrcMValue & 0xFFFF | (u32Result << 16);
                        }
                        else
                        {
                            u32Result = u32SrcMValue & 0xFFFF0000 | u32Result;
                        }
                        
                        break; 
                
                    default:
                        PrintToCerr("expan_hhreg_etc_mode0_cores: mode not found\n");
                        u32Result = 0;
                }
                
				wr_u32r_R_new(i, u32SrcMIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32SrcMIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}

bool sc_iss::compact_expan_etc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("compact_expan_etc_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("compact_expan_etc_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u4Imm: 4;
                    DSPU32		u2Rev: 2;
                    DSPU32      u6SrcM: 6;
                    DSPU32      u1Sign: 1;
					DSPU32      u1HLSel: 1;
                    DSPU32      u3Flag: 3;
                    DSPU32      u1Sel: 1;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1HLSel;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1Sign;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32Result, u32Imm;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
                
                m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;
				
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32SrcMIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32Sign, u32Mode;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR, u32HLSel,u32SrcMValue;
		bool IsHigh = false;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32HLSel = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		
        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
                
                u32Status = 0;
				if(u32Sign == 1)
				{
					u32SHFCR = GSetBit(u32SHFCR, 0);
				}			

				if (u32HLSel == 1)
                {
                    IsHigh = true;
                }

				if(u32Mode == 4) //模式为100
				{
					if(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx == m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx)
					{
						//u32SrcMValue = u32SrcA;
						u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
					}
					else
					{
						u32SrcMValue = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
					}
					//LORm=COMPACT(HRm,a)(U), HORm=COMPACT(HRm,a)(U)
					//LORm=COMPACT(HRm,a), HORm=COMPACT(HRm,a)
					u32Result = Compact16To8(u32SrcA, u32SrcB, IsHigh, &u32Status, u32SHFCR);
					if(u32HLSel==1)
					{
						u32Result = u32SrcMValue & 0xFFFF | (u32Result & 0xFFFF0000); // GRQ
					}
					else
					{
						u32Result = u32SrcMValue & 0xFFFF0000 | (u32Result & 0xFFFF); // GRQ
					}
				}
				else if(u32Mode == 5)//模式为101
				{
					//HRm=EXPAND(LORM,a)(U),HRm=EXPAND(HORM,a)(U)
					//HRm=EXPAND(LORM,a),HRm=EXPAND(HORM,a)
					u32Result = Expand8To16(u32SrcA, u32SrcB, IsHigh, &u32Status, u32SHFCR);
				}
                
				wr_u32r_R_new(i, u32SrcMIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32SrcMIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::cpat_creg_imm_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("cpat_creg_imm_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("cpat_creg_imm_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32DestIdx, u1Rev0;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u5Imm: 5;
                    DSPU32      u1Rev0: 1;
                    DSPU32      u6SrcM: 6;
                    DSPU32      u6Dest: 6;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u1Rev0;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u1Rev0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if(u1Rev0 == 0)
				{
					SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				else
				{
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32Result,u1Rev0;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.        
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u1Rev0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
				
				if(u1Rev0 == 0)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx + 1) )
					{
						// data forward to get the value of R[u32SrcMIdx] of current macro
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
					}
					else
					{
						// read the value of R[u32SrcMIdx] from register heap directly
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx + 1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}      
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = 0;
				}

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR, u32Imm;
		DSPU32  u1Rev0;
		DSP_BIT64 u64Temp;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u1Rev0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];      

        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                u32SHFCR = GSetBit(u32SHFCR, 0);
				if(u1Rev0 == 0)
				{
    	            u32Result = CompactC32(u32SrcB, u32SrcA, u32Imm, &u32Status, u32SHFCR); // GRQ: B, A?
     				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				} 
				else
				{
					u64Temp.u32Low = 0;
					u64Temp.u32High = 0;
					ExpandC16(u64Temp,u32SrcA,u32Imm,&u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u64Temp.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx+1, u64Temp.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}          
				
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_bclr_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("like_bclr_32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("like_bclr_32_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32DestIdx;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u5Imm: 5;
                    DSPU32      u1Flag: 1;
                    DSPU32      u6SrcM: 6;
                    DSPU32      u6Dest: 6;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32Result, u32Imm;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
                
                m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32UseImm;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32UseImm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                switch (p_u32Opcode)
                {
                    case op_bclr_32_c:
                        if (u32UseImm == 1) //Rs= Rm bclr a
                        {
                            u32Result = BitClr(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        }
                        else //Rs= Rm bclr
                        {
                            u32Result = BitClrAll(u32SrcA, &u32Status, u32SHFCR);
                        }   
                        break;
                    case op_bset_32_c:
                        if (u32UseImm == 1)  //Rs= Rm bset a
                        {
                            u32Result = BitSet(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        }
                        else  //Rs= Rm bset
                        {
                            u32Result = BitSetAll(u32SrcA, &u32Status, u32SHFCR);
                        }
                        break;
                    case op_binv_32_c:
                        if (u32UseImm == 1)  //Rs= Rm binv a
                        {
                            u32Result = BitInv(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                        }
                        else  //Rs= Rm binv
                        {
                            u32Result = BitInvAll(u32SrcA, &u32Status, u32SHFCR);
                        }
                        break;
					case op_oneposi_imm_c:
						if ( u32UseImm == 1 )
						{
							u32Result = OnePosi32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						}
						else
						{
							u32Result = OnePosiD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						}
						break;
					case op_zerocount_imm_c:
						if ( u32UseImm == 1 )
						{
							u32Result = CountZero32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						}
						else
						{
							u32Result = CountZeroD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						}
						break;
					case op_onecount_imm_c:
						if ( u32UseImm == 1 )
						{
							u32Result = CountOne32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						}
						else
						{
							u32Result = CountOneD16(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
						}
						break;
                }                                               
                
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::exp_is_imm_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("exp_is_imm_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("exp_is_imm_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32DestIdx;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u4Rev0: 4;
                DSPU32      u8Imm: 8;
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u8Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 3; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32DestIdx, u32Imm, u32Result;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
                {
                    // data forward to get the value of R[u32DestIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;                

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                u32Result = SetExp(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
                
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_fix_flo32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("like_fix_flo32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("like_fix_flo32_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32DestIdx, u1Flag;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcMIdx: 6;
				DSPU32		u2Rev2: 2;
                DSPU32      u4Flag: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcMIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0], 8); // GRQ
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u1Flag = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if((u1Flag  == 2) || (u1Flag == 3))
				{
					SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                	SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32DestIdx, u32SrcMIdx, u32Result, u32Mode;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32DestIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
				
				if((u32Mode  == 2) || (u32Mode == 3))
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
					{
						// data forward to get the value of R[u32DestIdx] of current macro
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
					}
					else
					{
						// read the value of R[u32SrcMIdx] from register heap directly
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = 0;
				}					

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcA1, u32Mode;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;
		DSP_BIT64 u64Temp;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {            
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcA1 = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];

                u32Status = 0;
                if (u32Mode == 0)
                {
                    u32SHFCR = GSetBit(u32SHFCR, 0);
                    u32Result = Fix32(u32SrcA, 0, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                }
                else if (u32Mode == 1)
                {
                    u32Result = Float32(u32SrcA, 0, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                }
				else if (u32Mode == 2)
                {
					u64Temp.u32High = 0;
					u64Temp.u32Low = 0;
                    FixC32(u64Temp, u32SrcA, u32SrcA1, 0, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx+1, u64Temp.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx, u64Temp.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                }
				else if (u32Mode == 3)
                {
					u64Temp.u32High = 0;
					u64Temp.u32Low = 0;
                    FloatC32(u64Temp, u32SrcA, u32SrcA1, 0, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx+1, u64Temp.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx, u64Temp.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                }
				else if(u32Mode == 4)
				{
					//FRs=Float Rm(U)
					u32Result = UnsignFix32ToFlo32(u32SrcA,&u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
                
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::abs_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("abs_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("abs_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcNIdx, u32DestIdx;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u6SrcN: 6;
                    DSPU32      u2Imm: 2;
                    DSPU32      u4Rev0: 4;
                    DSPU32      u6Dest: 6;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcNIdx, u32Result;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR, u32Imm;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

                u32Status = 0;
                u32SHFCR = GSetBit(u32SHFCR, 0);
                switch (u32Imm)
                {
                    case 0:
                        u32Result = Abs32(u32SrcA, &u32Status, u32SHFCR);
                        break;
                    case 1:
                        u32Result = AbsD16(u32SrcA, &u32Status, u32SHFCR);
                        break;
                    case 2:
                        u32Result = AbsFlo32(u32SrcA, &u32Status, u32SHFCR);
                        break;
                    default : 
                        PrintToCerr("abs_cores: Invalid parameter\n");
                }
                
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::conj_c16_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("conj_c16_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("conj_c16_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcNIdx, u32DestIdx;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u1Neg: 1;
                DSPU32      u1Rev0: 1;
                DSPU32      u1Permute: 1;
                DSPU32      u1Rev1: 1;
                DSPU32      u1Conj: 1;
                DSPU32      u1Rev2: 1;          
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Neg;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Permute;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1Conj;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcNIdx, u32Result;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32Flag, u32Status, u32SrcA, u32Permute, u32Conj, u32DestIdx;
        DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;
		bool bolNeg;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        bolNeg = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Permute = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Conj = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {    
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

                u32Status = 0;
                u32SHFCR = GSetBit(u32SHFCR, 0);
                if ( u32Permute == 1 )
                {
                    u32Result = PermuteCFix16(u32SrcA, &u32Status, u32SHFCR, bolNeg);
                }
                else if ( u32Conj == 1 )
                {
                    u32Result = ConjCFix16(u32SrcA, &u32Status, u32SHFCR, bolNeg);
                }
                else
                {
                    if (bolNeg)
                    {
                        u32Result = SubD16SHF(0, u32SrcA, &u32Status, u32SHFCR);
                    }
                    else
                    {
                        u32Result = AddD16SHF(0, u32SrcA, &u32Status, u32SHFCR);
						u32Result = u32SrcA;
                    }
                }
                
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

                // Log info for data forward
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::c16_to_cf32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{       
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("c16_to_cf32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("c16_to_cf32_cores: parameter is invalid\n");
        return false;
    }
   
    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32DestIdx, u32Units;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6Imm: 6;
                DSPU32      u6SrcM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        //m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }

    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcMIdx, u32Units, u32Result, u32Imm;
    
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }    
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32SHFIdx, u32SHFCR, u32SrcA, u32SrcA1,u32SrcB, u32Flag, u32GenResultIdx;
        DSPU32 u32DestIdx, u32Units, u32Status;
		DSP_BIT64 u64res;

        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcA1 = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				u64res.u32Low = 0;
				u64res.u32High = 0;
				u32SHFCR = GSetBit(u32SHFCR, 0);
				AShiftC32(u64res, u32SrcA, u32SrcA1, u32SrcB, &u32Status, u32SHFCR);
				
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				wr_u32r_R_new(i, u32DestIdx+1, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_shiftr_c32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{       
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("like_shiftr_c32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("like_shiftr_c32_cores: parameter is invalid\n");
        return false;
    }
   
    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32SrcNIdx, u32DestIdx, u32Units;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u6SrcM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                switch (p_u32Opcode)
                {
                    case op_shiftr_c32_c:
                        SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                        SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                        SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                        SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                        SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);   
                        break;
                    case op_cpat_creg_c:
                        SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                        SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                        SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                        SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                        break;

                
                }                            
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }

    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result;
		DSPU32 u32SrcNIdxSel, u32SrcMIdxSel;
    
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32SrcMIdxSel = 0;
		u32SrcNIdxSel = 0;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                for (int k = 0; k < 2; k++)
                {
                    m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
                    switch (p_u32Opcode)
                    {
                        case op_shiftr_c32_c:
                            u32SrcMIdxSel = u32SrcMIdx + k;
                            u32SrcNIdxSel = u32SrcNIdx;
                            break;
                        case op_cpat_creg_c:
                            u32SrcMIdxSel = u32SrcMIdx + k;
                            u32SrcNIdxSel = u32SrcNIdx;
                            break;   
                 
                    }
                                                            
                    if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
                    }
                    else
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                    }

                    if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
                    }
                    else
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                    }
                    
                } // for (k = 0; k < 2; k++)
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }    
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32SHFIdx, u32SHFCR, u32SrcA, u32SrcB, u32Result, u32Flag, u32GenResultIdx;
        DSPU32 u32DestIdx, u32SrcMIdx, u32SrcNIdx, u32Units, u32Status;
        DSPU32 u32Temp;

        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
        
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32Result = 0;
                for (int k = 0; k < 2; k++)
                {
                    u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k + 1);
                    u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
                    u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
                    u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];
                    
                    u32Status = 0;
                    switch (p_u32Opcode)
                    {                        
                        case op_shiftr_c32_c: //213
                            u32SHFCR = GSetBit(u32SHFCR, 0);
                            u32Result = AShift32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							wr_u32r_R_new(i, u32DestIdx + k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
	  		            	SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx + k, u32Result);
 		               		u32GenResultIdx++;
                            break;
                        case op_cpat_creg_c: // 215
							u32SHFCR = GSetBit(u32SHFCR, 0);
                            u32Temp = Compact32(u32SrcA, u32SrcB, &u32Status, u32SHFCR);                  
							if (k == 0)
                            {
                                u32Result = u32Result & 0xFFFF0000 | u32Temp;
                            }
                            else
                            {
                                u32Result = u32Result & 0xFFFF | (u32Temp << 16);
                            }
                            break;

                    }
                                                            
                    u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                    u32ri_SHFFR[i][u32SHFIdx] = u32Flag;                    

                } // for (k = 0; k < 2; k++)

				if (p_u32Opcode == op_cpat_creg_c)
				{
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
	                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
 	               	u32GenResultIdx++;
				}
				
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_lxor_d32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("like_lxor_d32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("like_lxor_d32_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32SrcNIdx, u32DestIdx, u32Units;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u6SrcM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                for (int k = 0; k < 2; k++)
                {
                    SetGenRegIdx(u32SrcMIdx + k, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                    SetGenRegIdx(u32SrcNIdx + k, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                    SetGenRegIdx(u32DestIdx + k, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                }
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Forward;
    
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                for (int k = 0; k < 2; k++)
                {
                    m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
                    if ( GenRegForward(u32Forward, p_u32SLKIdx, i, u32SrcMIdx + k) )
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Forward;
                    }
                    else
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdx + k, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                    }

                    if ( GenRegForward(u32Forward, p_u32SLKIdx, i, u32SrcNIdx + k) )
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Forward;
                    }
                    else
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdx + k, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                    }

                } // for (k = 0; k < 2; k++)
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32SHFIdx1, u32SHFIdx2, u32Flag, u32GenResultIdx;
        DSPU32 u32DestIdx, u32Units, u32Status;
        DSPU32 u32SHFCR0, u32SrcA0, u32SrcB0, u32SHFCR1, u32SrcA1, u32SrcB1;
        DSPU64 u64SrcM, u64SrcN, u64Result;
    	
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
        u32GenResultIdx = 0;
		u64Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx1 = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFIdx2 = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 2);
                
                u32SHFCR0 = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][u32SHFIdx1];
                u32SrcA0 = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB0 = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
                u32SHFCR1 = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][u32SHFIdx2];
                u32SrcA1 = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
                u32SrcB1 = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
            
                u64SrcM = u32SrcA1;
                u64SrcM = (u64SrcM << 32) | u32SrcA0;
                u64SrcN = u32SrcB1;
                u64SrcN = (u64SrcN << 32) | u32SrcB0;

                u32Status = 0;
                if (p_u32Opcode == op_lxor_d32_c)
                {
                    u64Result = LXOR64(u64SrcM, u64SrcN, &u32Status, u32SHFCR1);
                }
                else if (p_u32Opcode == op_rxor_d32_c)
                {
                    u64Result = RXOR64(u64SrcM, u64SrcN, &u32Status, u32SHFCR1);
                }                

                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx1], u32Status);
                u32ri_SHFFR[i][u32SHFIdx1] = u32Flag;
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx2], u32Status);
                u32ri_SHFFR[i][u32SHFIdx2] = u32Flag;

                // attention: wr_u32r_R()
				wr_u32r_R_new(i, u32DestIdx, u64Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u64Result);
                u32GenResultIdx++;

                // attention SetWBGenRegInfo()
                // attention: wr_u32r_R()
				wr_u32r_R_new(i, u32DestIdx + 1, (u64Result >> 32), PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo( p_u32Slot, u32GenResultIdx, i, u32DestIdx + 1, (u64Result >> 32) );
                u32GenResultIdx++;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}

//zhaoxiang-----------------------------------------------------------------------------------
bool sc_iss::insert_to_sacc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("insert_to_sacc_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("insert_to_sacc_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32SrcNIdx, u32SACC, u32Units, u32Mode;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u6SrcM: 6;
				//DSPU32		u1Rev: 1;
				DSPU32		u4Mode: 4;
				DSPU32		u2SACCs: 2;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2SACCs;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SACC = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32SACC, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				
				//设置SACC数据相关
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
				//设置SACC读相关
				if((u32Mode>3) && (u32Mode<14) && (u32Mode != 8))
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
				}
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
    {
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32Mode, u32SACCIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if((u32Mode > 3) && (u32Mode < 14) )
				{
					//zx need data forward of SACC
					u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrDestH[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32High;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
    {
		DSP_BIT64 u64Temp;
		DSPU32 u32Units, u32SACCIdx;
		DSPU32 u32Mode, u32Status, u32SHFCR,SrcA, SrcB, u32Flag;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u64Temp.u32Low = 0;
				u64Temp.u32High = 0;
				u32Status = 0;
				if(u32Mode == 0 || u32Mode == 1 || u32Mode == 2 || u32Mode == 3)
				{
					InsertToSACC(u64Temp, SrcA, SrcB, u32Mode, &u32Status, u32SHFCR);
				}
				else if(u32Mode == 4 || u32Mode == 5 || u32Mode == 6 || u32Mode == 7)
				{
					u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];
					u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					SACCInsert(u64Temp, SrcA, SrcB, u32Mode, &u32Status, u32SHFCR);
				}
				else if(u32Mode == 8)
				{
					u64Temp.u32High = SrcA;
					u64Temp.u32Low = SrcB;
				}
				else if(u32Mode == 9)
				{
					u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];
					u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					u64Temp.u32High = SrcA;
				}
				else if(u32Mode == 10)
				{
					u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];
					u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					u64Temp.u32Low = SrcA;
				}
				else if(u32Mode == 11)
				{
					//SACCs+=Rm(Rn)
					u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];
					u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					SACCAddReg32(u64Temp,SrcA, SrcB, &u32Status, u32SHFCR);
				}
				else if(u32Mode == 12)
				{
					//HSACCs+=HRm(Rn)
					u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];
					u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					SACCAddReg16(u64Temp,SrcA, SrcB, &u32Status, u32SHFCR);
				}
				else if(u32Mode == 13)
				{
					//OSACCs+=ORm(Rn)
					u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];
					u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					SACCAddReg8(u64Temp,SrcA, SrcB, &u32Status, u32SHFCR);
				}

                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SACCIdx], u32Status);
                u32ri_SHFFR[i][u32SACCIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SACCIdx].u32Low = u64Temp.u32Low;
				u64ri_SHF_SACC[i][u32SACCIdx].u32High = u64Temp.u32High;
			}
		}
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::abs2_sacc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("abs2_sacc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("abs2_sacc_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32SrcNIdx, u32SACC, u32Units;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u6SrcM: 6;
				DSPU32		u4k: 4;
				DSPU32		u2SACCs: 2;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4k;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2SACCs;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SACC = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32SACC, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                
				//设置SACC数据相关
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SrcA, u32SrcB, u32SACCIdx, u4k, u32Flag;
		DSP_BIT64 u64Temp;
		DSPU32 u32Status, u32SHFCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u4k = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				u32Status = 0;
				u64Temp.u32Low = 0;
				u64Temp.u32High = 0;		
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				
				if(p_u32Opcode == op_abs2_sacc_c)
				{
					ABS2SACC(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 0, u4k);
				}
				else if(p_u32Opcode == op_abs3_sacc_c)
				{
					ABS2SACC(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 1, u4k);
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SACCIdx], u32Status);
                u32ri_SHFFR[i][u32SACCIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SACCIdx].u32Low = u64Temp.u32Low;
				u64ri_SHF_SACC[i][u32SACCIdx].u32High = u64Temp.u32High;
			}
		}
	}
	return true;
}

bool sc_iss::sacc_xor_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("sacc_xor_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("sacc_xor_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SACC, u32Units;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u9Rev: 9;
				DSPU32		u1Mode: 1;
				DSPU32		u2SACCs: 2;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2SACCs;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SACC = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32SACC, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                
				//设置SACC数据相关
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
				//设置SACC读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
			
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcNIdx, u32Result, u32SACCIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);	
				
				m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32Low;
				m_arrResSLK[p_u32SLKIdx].arrDestH[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32High;

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if(p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		DSPU32 u32SACCIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32r_SHFER[i][u32SACCIdx];
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SHFER, u32SrcB, u32SACCIdx, u32Flag;
		DSP_BIT64 u64Temp;
		DSPU32 u32Status, u32SHFCR, u1Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u1Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				u32Status = 0;
				u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
				u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];		
				
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				u32SHFER = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				
				if(u1Mode == 0)
				{
					SACCXor32(u64Temp, u32SrcB, u32SHFER, &u32Status, u32SHFCR);
				}
				else 
				{
					SACCXor16(u64Temp, u32SrcB, u32SHFER, &u32Status, u32SHFCR);
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SACCIdx], u32Status);
                u32ri_SHFFR[i][u32SACCIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SACCIdx].u32Low = u64Temp.u32Low;
				u64ri_SHF_SACC[i][u32SACCIdx].u32High = u64Temp.u32High;
			}
		}
	}
	return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::sigma_sacc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("sigma_sacc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("sigma_sacc_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SACC, u32Units,u32n;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u6SrcN: 6;
                DSPU32      u2n: 2;
				DSPU32		u8d:8;
				DSPU32		u2SACCs: 2;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2n;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u8d;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2SACCs;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SACC = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32SACC, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				if(p_u32Opcode != op_sigma_b1_to_sacc_c  && p_u32Opcode != op_sigma_b1_add_sacc_c)
				{
					SetGenRegIdx(u32SrcNIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				
                //设置SACC数据相关
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
				//设置SACC读相关
				if(p_u32Opcode == op_sigma_b1_add_sacc_c || p_u32Opcode == op_sigma_b2_add_sacc_c
					|| p_u32Opcode == op_sigma_b4h_add_sacc_c || p_u32Opcode == op_sigma_b4l_add_sacc_c)
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
				}

				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				// 根据所访问的STAB中块的序号设置掩码
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcNIdx, u32Result, u32SACCIdx, u32n, u32d;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32d = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				
				if(p_u32Opcode != op_sigma_b1_to_sacc_c  && p_u32Opcode != op_sigma_b1_add_sacc_c)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx+1) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = rd_u32r_R_new(i, u32SrcNIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

				if(p_u32Opcode == op_sigma_b1_add_sacc_c || p_u32Opcode == op_sigma_b2_add_sacc_c
					|| p_u32Opcode == op_sigma_b4h_add_sacc_c || p_u32Opcode == op_sigma_b4l_add_sacc_c)
				{
					m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrDestH[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32High;
				}
				
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_SHF_Tab(i, u32SACCIdx, u32n, u32d);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SrcB, u32SACCIdx, u32Flag, u32Tab;
		DSPU32 u32Status, u32SHFCR;
		DSP_BIT64 u64Temp, u64Src;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				u32Status = 0;
				u64Temp.u32Low = 0;
				u64Temp.u32High	= 0;
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Tab = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				switch (p_u32Opcode)
                    {                        
                        case op_sigma_b1_to_sacc_c:
                            SigmaSR(u64Temp, u32SrcB, u32Tab, 0, &u32Status, u32SHFCR);
                            break;
                        case op_sigma_b2_to_sacc_c:
							u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
							u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
							SigmaBR(u64Temp, u64Src, u32Tab, 0, &u32Status, u32SHFCR);
                            break;
						case op_sigma_b4h_to_sacc_c:
							u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
							u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
							SigmaQRHH(u64Temp, u64Src, u32Tab, 0, &u32Status, u32SHFCR);
                            break;
						case op_sigma_b4l_to_sacc_c:
							u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
							u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
							SigmaQRLH(u64Temp, u64Src, u32Tab, 0, &u32Status, u32SHFCR);
                            break;
						case op_sigma_b1_add_sacc_c:
							u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
							u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];   
							SigmaSR(u64Temp, u32SrcB, u32Tab, 1, &u32Status, u32SHFCR);
                            break;
						case op_sigma_b2_add_sacc_c:
							u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
							u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];

							u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
							u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];   
							
							SigmaBR(u64Temp, u64Src, u32Tab, 1, &u32Status, u32SHFCR);
                            break;
						case op_sigma_b4h_add_sacc_c:
							u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
							u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];

							u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
							u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];   
							SigmaQRHH(u64Temp, u64Src, u32Tab, 1, &u32Status, u32SHFCR);
                            break;
						case op_sigma_b4l_add_sacc_c:
							u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
							u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];

       						u64Temp.u32Low = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
							u64Temp.u32High = m_arrResSLK[p_u32SLKIdx].arrDestH[i][0];                   
							SigmaQRLH(u64Temp, u64Src, u32Tab, 1, &u32Status, u32SHFCR);
                            break;
                    }
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SACCIdx], u32Status);
                u32ri_SHFFR[i][u32SACCIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SACCIdx].u32Low = u64Temp.u32Low;
				u64ri_SHF_SACC[i][u32SACCIdx].u32High = u64Temp.u32High;
			}
		}
	}
	
	return true;
}

 
//-----------------------------------------------------------------------------------
bool sc_iss::tab_reg_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("tab_reg_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("tab_reg_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u2Mode, u32ShfIdx,u32n;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u2k: 2;
                DSPU32      u2n: 2;
				DSPU32		u2Mode: 2;
				DSPU32		u6SrcM: 6;
				DSPU32		u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2k;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2n;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u2Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ShfIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ShfIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
				switch (p_u32Opcode)
				{
					case op_tab_to_reg_c:
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						if(u2Mode == 2)
						{
							SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);  //2015-9-18 对读地址进行修改
						}						
						break;
					case op_tab_to_horeg_c:
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						if(u2Mode == 3)
						{
							SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						}
						break;
				}

				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				// 根据所访问的STAB中块的序号设置掩码
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32TabIdx, u32DestIdx;
		DSPU32 u32Rm,u32TabAddr,u32Mode,u32n,u32Rs;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		u32TabAddr = 0;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				
				u32TabIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				if(p_u32Opcode == op_tab_to_reg_c)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						u32Rm = u32Result;
					}
					else
                	{
                    	// read the value of R[u32SrcMIdx] from register heap directly
                    	u32Rm = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                	}

					if(u32Mode==1)//模式1是Rm的[15：8]为地址
					{
						u32TabAddr = ((u32Rm>>8) & 0xff);
					}
					else   //模式0和2都是Rm的[7：0]为地址
					{
						u32TabAddr = (u32Rm & 0xff);
					}
					
					if(u32Mode==2)  //模式2需要修改Rm的地址，故需要携带至EX级计算
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Rm;
					}
					
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr);
				}//end if(p_u32Opcode == op_tab_to_reg_c)
				else if(p_u32Opcode == op_tab_to_horeg_c)
				{
					DSPU32 TempL, TempH, Temp0, Temp1, Temp2, Temp3;
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						u32Rm = u32Result;
					}
					else
                	{
                    	// read the value of R[u32SrcMIdx] from register heap directly
                    	u32Rm = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                	}
					if(u32Mode==3)
					{
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
						{
							u32Rs = u32Result;
						}
						else
                		{
                    		// read the value of R[u32SrcMIdx] from register heap directly
                    		u32Rs = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                		}
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Rs;
					}
					switch (u32Mode)
					{
					case 0:
						u32TabAddr = ((u32Rm>>16) & 0xff);
						TempL = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0x0000ffff;
						u32TabAddr = ((u32Rm>>24) & 0xff);
						TempH = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xffff0000;
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = (TempL | TempH);
						break;
					case 1:
						u32TabAddr = (u32Rm & 0xff);
						TempL = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0x0000ffff;
						u32TabAddr = ((u32Rm>>8) & 0xff);
						TempH = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xffff0000;
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = (TempL | TempH);
						break;
					case 2:
					case 3:
						u32TabAddr = (u32Rm & 0xff);
						Temp0 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff;
						u32TabAddr = ((u32Rm>>8) & 0xff);
						Temp1 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff00;
						u32TabAddr = ((u32Rm>>16) & 0xff);
						Temp2 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff0000;
						u32TabAddr = ((u32Rm>>24) & 0xff);
						Temp3 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff000000;
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = (Temp0 | Temp1 | Temp2 |Temp3);
						break;
					}//end switch
				}//end if(p_u32Opcode == op_tab_to_horeg_c)
              
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32SHFIdx,u32Status,u32SHFCR,u32Rm, u32Result;
		DSPU32 u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		if(p_u32Opcode == op_tab_to_reg_c && u32Mode==2)
		{
			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				// whether current macro(unit) is used.
				if ( GIsBitSet(u32Units, i) )
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
					u32Status = 0;

					u32SHFCR = GSetBit(u32SHFCR, 0);

					u32Result = STabRdAddrSet(u32Rm, &u32Status, u32SHFCR);

					m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Result;
					m_arrResSLK[p_u32SLKIdx].arrDestL[i][1] = u32Status;
				}
			}
		}
		
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SrcA, u32Rs, u32DestIdx, u32Mode, u32Status, u32SHFCR, u32Result;
		DSPU32 u32SHFIdx, u32Flag, u32Rm, u32RmIdx;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		u32Result = 0;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Status = 0;
				
				if((p_u32Opcode == op_tab_to_horeg_c) && (u32Mode == 3))
				{
					
					u32Rs = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u32Result = TABToOReg(u32SrcA, u32Rs, &u32Status, u32SHFCR);
					
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
				else
				{
					wr_u32r_R_new(i, u32DestIdx, u32SrcA, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}

				if(p_u32Opcode == op_tab_to_reg_c && u32Mode == 2)
				{
					u32RmIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
					u32Status = m_arrResSLK[p_u32SLKIdx].arrDestL[i][1];

					wr_u32r_R_new(i, u32RmIdx, u32Rm, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
				
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				
				
				
			}//end if ( GIsBitSet(u32Units, i) )
		}//end for
	}//end if (p_u32Phase == PHASE_WB)
	return true;
}

//---------------------------------------------------------------------------------------------
bool sc_iss::write_tab_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("write_tab_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("write_tab_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32ShfIdx, u32Mode,u32n;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u2k: 2;
                DSPU32      u2n: 2;
				DSPU32		u2Mode: 2;
				DSPU32		u6SrcM: 6;
				DSPU32		u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2k;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2n;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32ShfIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1]; 
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ShfIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
				switch (p_u32Opcode)
				{
					case op_reg_to_tab_c:
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);

						if(u32Mode == 2)
						{
							SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						}
						
						m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_AC = true;
						// 根据所访问的STAB中块的序号设置掩码
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
						break;
					case op_horeg_to_tab_c:
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						
						if (u32Mode==3)
						{
							//设置Tab表读相关
							m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
							//设置Tab表写相关
							m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_EX = true;
						}
						else
						{
							m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_AC = true;
						}		
						
						// 根据所访问的STAB中块的序号设置掩码
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
						break;
					case op_otab_add_const_c:
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						//设置Tab表写相关
						m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_EX = true;
						//设置Tab表读相关
						m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
						// 根据所访问的STAB中块的序号设置掩码
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
						break;
				}
				
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32DestIdx, u32Mode, u32TabIdx, u32n;
		DSPU32 u32Rm, u32Rs, u32TabAddr;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1]; 

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32TabIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				
				if(p_u32Opcode == op_otab_add_const_c)
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = (u32SrcMIdx>>2) & 0xF;

					//m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = ((u32SrcMIdx & 0x3F) << 2) | (u32Mode & 3);

				}
				else
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						u32Rm = u32Result;
					}
					else
            		{
                		// read the value of R[u32SrcMIdx] from register heap directly
                		u32Rm = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
            		}					
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Rm;
				}				

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
				{
					u32Rs = u32Result;
				}
				else
            	{
                	// read the value of R[u32SrcMIdx] from register heap directly
                	u32Rs = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
            	}
				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Rs;

				if(((p_u32Opcode == op_horeg_to_tab_c) && (u32Mode == 3)) || (p_u32Opcode == op_otab_add_const_c))
				{
					DSPU32 Temp0, Temp1, Temp2, Temp3;
					u32TabAddr = (u32Rs & 0xff);
					Temp0 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff;
					u32TabAddr = ((u32Rs>>8) & 0xff);
					Temp1 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff00;
					u32TabAddr = ((u32Rs>>16) & 0xff);
					Temp2 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff0000;
					u32TabAddr = ((u32Rs>>24) & 0xff);
					Temp3 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xff000000;
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = (Temp0 | Temp1 | Temp2 |Temp3);
				}
				else
				{
					if(p_u32Opcode == op_reg_to_tab_c)
					{
						//取目的地址
						
						if(u32Mode==1)
						{
							u32TabAddr = (u32Rs>>8) & 0xff;
						}
						else
						{
							u32TabAddr = u32Rs & 0xff;
						}
						
						//写tab表
						wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0xf, u32Rm);
					}
					else if(p_u32Opcode == op_horeg_to_tab_c)
					{
						switch (u32Mode)
						{
						case 0:  //HSTABn(HORs) = HRm(k)
							u32TabAddr = (u32Rs>>24) & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0xc, u32Rm);
							u32TabAddr = (u32Rs>>16) & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0x3, u32Rm);
							break;
						case 1: //HSTABn(LORs) = HRm(k)
							u32TabAddr = (u32Rs>>8) & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0xc, u32Rm);
							u32TabAddr = u32Rs & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0x3, u32Rm);
							break;
						case 2: //OSTABn(ORs)  = ORm(U,k)
							u32TabAddr = u32Rs & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0x1, u32Rm);
							u32TabAddr = (u32Rs>>8) & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0x2, u32Rm);
							u32TabAddr = (u32Rs>>16) & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0x4, u32Rm);
							u32TabAddr = (u32Rs>>24) & 0xff;
							wr_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr, 0x8, u32Rm);
							break;
						}
					}
				}
              
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if(p_u32Phase == PHASE_EX)
	{
		DSPU32 u32SHFIdx, u32Units, u32Rm, u32Rs, u32DestIdx, u32Mode, u32n, u32RmTmp;
		DSPU32 u32TabAddr, u32TabValue, u32Result, u32SHFCR, u32Status, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		u32TabAddr = 0;
		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Status = 0;
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32Rs = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				
				if(p_u32Opcode == op_horeg_to_tab_c)
				{
					if(u32Mode==3)
					{
						//OSTABn(ORs) += ORm(U,k)
						u32TabValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
						u32RmTmp = u32Rm & 0x0F0F0F0F;
						u32Result = TABToOReg(u32TabValue, u32RmTmp, &u32Status, u32SHFCR);

						u32TabAddr = u32Rs & 0xff;
						wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x1, u32Result);
						u32TabAddr = (u32Rs>>8) & 0xff;
						wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x2, u32Result);
						u32TabAddr = (u32Rs>>16) & 0xff;
						wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x4, u32Result);
						u32TabAddr = (u32Rs>>24) & 0xff;
						wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x8, u32Result);

					}
				}
				else if(p_u32Opcode == op_otab_add_const_c)//OSTABn(ORs) +=C(U,k)
				{					
					u32TabValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
					//此时Rm=C
					u32Result = OTABAccConst(u32TabValue, u32Rm,  &u32Status, u32SHFCR);
					u32TabAddr = u32Rs & 0xff;
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x1, u32Result);
					u32TabAddr = (u32Rs>>8) & 0xff;
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x2, u32Result);
					u32TabAddr = (u32Rs>>16) & 0xff;
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x4, u32Result);
					u32TabAddr = (u32Rs>>24) & 0xff;
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr, 0x8, u32Result);

				}
				else if(p_u32Opcode == op_reg_to_tab_c && u32Mode==2)
				{
					u32SHFCR = GSetBit(u32SHFCR, 0);

					u32Result = STabRdAddrSet(u32Rs, &u32Status, u32SHFCR);

					m_arrResSLK[p_u32SLKIdx].arrDestL[i][1] = u32Result;
				}
				m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Status;
				//u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				//u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			}//end if ( GIsBitSet(u32Units, i) )
		}//end for
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32Status,u32Mode;
		DSPU32 u32SHFIdx,u32RsIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				u32Status = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				if(p_u32Opcode == op_reg_to_tab_c && u32Mode==2)
				{
					u32RsIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
					u32Result = m_arrResSLK[p_u32SLKIdx].arrDestL[i][1];

					wr_u32r_R_new(i, u32RsIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::rlshift_sc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("rlshift_sc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("rlshift_sc_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u2Mode, u2Flag, u32ShfIdx;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u2k: 2;
                DSPU32      u2Flag: 2;
				DSPU32		u2Mode: 2;
				DSPU32		u6SrcM: 6;
				DSPU32		u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2k;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable    
		u32ShfIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u2Flag = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u2Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];		
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ShfIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
				if(u2Mode == 0)
				{
				    SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
 				}
				else    if(u2Mode == 1)
				{
					if(u2Flag == 1)
					{
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					}
				    else if(u2Flag == 2)
					{
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					}

					//设置SACC数据相关
					//设置SACC读相关
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
 				} 
				else    if(u2Mode == 2)
				{
					if(u2Flag == 0)
					{
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					}
				    else if(u2Flag == 1)
					{
						SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					}

					//设置SACC数据相关
					//设置SACC读相关
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
 				} 
	       }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32ShfIdx,u2Flag,u2Mode,u32SrcMIdx,u32Units;
		DSPU32 u32Result,u32Rm, GPLYValue;

		u2Flag = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u2Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					u32Rm = u32Result;
				}
				else
        		{
            		// read the value of R[u32SrcMIdx] from register heap directly
            		u32Rm = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
        		}					
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Rm;

				if(u2Mode == 1 || u2Mode == 2)
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u64ro_SHF_SACC[i][u32ShfIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u64ro_SHF_SACC[i][u32ShfIdx].u32High;

					if((u2Mode == 1 && u2Flag == 1) || (u2Mode == 2 && u2Flag == 0))
					{
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
						}
						else
        				{
            				// read the value of R[u32SrcMIdx] from register heap directly
            				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
        				}
					}
				}

				if(u2Mode == 2)
				{
					//读取伽罗华系数
					GPLYValue = u32ro_GPLYR[i];
					m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0] = GPLYValue;	
				}
			}//end if
		}//end for

	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32ShfIdx,u2Flag,u2Mode,u32SrcMIdx,u32Units;
		DSPU32 u32Result,u32Rm,u32SHFER,u32Status,u32SHFCR, GPLYValue;
		DSP_BIT64 u64SACC, u64Src;

		u2Flag = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u2Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Status = 0;
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				if(u2Mode==0)
				{
					u32SHFER = u32r_SHFER[i][u32ShfIdx];
					switch (u2Flag)
					{
					case 0: //Rs=Rm shift_R SCk
						u32Result = RShift32_SC(u32Rm, u32SHFER, &u32Status, u32SHFCR);
						break;
					case 1: //Rs=Rm shift_L SCk
						u32Result = LShift32_SC(u32Rm, u32SHFER, &u32Status, u32SHFCR);
						break;
					case 2: //HRs=HRm shift_R SCk
						u32Result = RShiftD16_SC(u32Rm, u32SHFER, &u32Status, u32SHFCR);
						break;
					case 3: //HRs=HRm shift_L SCk
						u32Result = LShiftD16_SC(u32Rm, u32SHFER, &u32Status, u32SHFCR);
						break;
					}
					u32r_SHFER[i][u32ShfIdx] = u32SHFER;
				}
				else if(u2Mode==1)
				{
					u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
					
					if(u2Flag == 1) //Rs=Rm+1:m S_XOR SACCk
					{
						u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
						u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
						u32Result = SXOR32To32(u64SACC, u64Src, &u32Status, u32SHFCR);
					}
					else if(u2Flag == 2)//Rs=Rm S_XOR HSACCk
					{
						u32Result = SXOR16To32(u64SACC, u32Rm, &u32Status, u32SHFCR);
					}
				}
				else if(u2Mode==2)
				{
					
					GPLYValue = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];	
				
					u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
					if(u2Flag == 0) //ORs=ORm+1:m S*.OSACCk
					{
						u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
						u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
						u32Result = SHF_SStar(u64SACC, u64Src, GPLYValue, &u32Status, u32SHFCR);
					}
					else //ORs= ORm S@. OSACCk
					{
						u32Result = SHF_SAt(u64SACC, u32Rm, GPLYValue, &u32Status, u32SHFCR);
					}
				}
				m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Status;
				m_arrResSLK[p_u32SLKIdx].arrDestL[i][1] = u32Result;
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32ShfIdx,u32DestIdx,u32Units,u2Mode;
		DSPU32 u32Flag,u32Result,u32Status;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u2Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Status = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
				u32Result = m_arrResSLK[p_u32SLKIdx].arrDestL[i][1];

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32ShfIdx], u32Status);
				u32ri_SHFFR[i][u32ShfIdx] = u32Flag;

				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
			}
		}
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::vmin_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("vmin_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("vmin_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32ShfIdx;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u2k: 2;
                DSPU32      u1Rev: 1;
				DSPU32		u3Flag: 3;
				DSPU32		u6SrcM: 6;
				DSPU32		u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2k;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx =  m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32ShfIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ShfIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				//设置SACC数据相关
				//设置SACC读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32ShfIdx,u32SrcMIdx,u32Units;
		DSPU32 u32Result;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				
				//将Rm、Rm+1放入m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0]和m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1]
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;  
				}
				else
        		{
            		// read the value of R[u32SrcMIdx] from register heap directly
            		m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
        		}
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;  
				}
				else
        		{
            		// read the value of R[u32SrcMIdx] from register heap directly
            		m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
        		}	
				
				//将SACC读入m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0]和m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1]
				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u64ro_SHF_SACC[i][u32ShfIdx].u32Low;
				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u64ro_SHF_SACC[i][u32ShfIdx].u32High;
			}//end if
		}//end for
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32ShfIdx,u3Flag,u32Units,u32DestIdx;
		DSPU32 u32Result,u32SCF,u32SHFCR, u32SHFFlag,u32Status;;
		DSP_BIT64 u64SACC, u64Src;
	
		u3Flag = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		u32Result = 0;
		u32SCF = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];

				u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];

				u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];

				if(u3Flag==0) //ORs=Vmin2(ORm+1:m,LSACCk)(U)
				{
					u32Result = Vmin2L(u64SACC, u64Src, &u32SCF, u32SHFCR);
				}
				else if(u3Flag==1) //ORs=Vmin2(ORm+1:m,HSACCk)(U)
				{
					u32Result = Vmin2H(u64SACC, u64Src, &u32SCF, u32SHFCR);
				}
				else if(u3Flag==2) //ORs=Vmin3(ORm+1:m,SACCk)(U)
				{
					u32Result = Vmin3(u64SACC, u64Src, &u32SCF, u32SHFCR);
				}

				//写SCF寄存器
				u32_SHF_SCF[i][u32ShfIdx] = u32SCF & 0xF; 

				u32Status = 0;
				u32SHFFlag = SetSHFFlags(u32ri_SHFFR[i][u32ShfIdx], u32Status);
				u32ri_SHFFR[i][u32ShfIdx] = u32SHFFlag;

				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
			}
		}
	}
	return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::sigma_sc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("sigma_sc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("sigma_sc_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32SACC, u32Units, u32Mode,u32IsAdd, u32n;
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32		u2SACCs: 2;
				DSPU32      u2n: 2;
				DSPU32		u2Mode: 2;
				DSPU32		u6SrcM: 6;
				DSPU32		u1IsAdd: 1;
				DSPU32		u5Rev5: 5;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2n;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2SACCs;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1IsAdd;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SACC = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32IsAdd = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
            
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32SACC, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				if(u32Mode != 0)
				{
					SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}				
                
				//设置SACC数据相关
				//设置SACC读相关
				if(u32IsAdd)
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
				}
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;

				
				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				// 根据所访问的STAB中块的序号设置掩码
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
            }
        }

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32ShfIdx;
		DSPU32 u32SLTAR,u32n,u32TabAddr,IsAdd,u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		IsAdd = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				
				if(u32Mode != 0)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}		
				}
				
				//若为累加操作，将SACC读出存入m_arrResSLK[p_u32SLKIdx].arrSrcB[i][2]、m_arrResSLK[p_u32SLKIdx].arrSrcB[i][3]
				if(IsAdd)
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][2] = u64ro_SHF_SACC[i][u32ShfIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][3] = u64ro_SHF_SACC[i][u32ShfIdx].u32High;
				}

				//读SLTAR
				u32SLTAR = u32r_SHF_SLTAR[i][u32ShfIdx];

				u32TabAddr = u32SLTAR & 0xff;
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_SHF_Tab(i, u32ShfIdx, u32n, u32TabAddr);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32ShfIdx, u32Status, u32SHFCR, u32SHFFlag;
		DSPU32 u32Mode,IsAdd;
		DSPU32 u32Rm,u32TabValue;
		DSP_BIT64 u64SACC,u64Src;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		IsAdd = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				u32Status = 0;
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];				
				u32ShfIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u64SACC.u32Low = 0;
				u64SACC.u32High = 0;
				u32TabValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				if(IsAdd)
				{
					u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][2];
					u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][3];
				}
				u32SHFCR = GSetBit(u32SHFCR, 0);

				switch (u32Mode)
				{
				case 0:
					//SACCs += Sigma_b1(Rm，STABn(SC))
					//SACCs = Sigma_b1(Rm，STABn(SC))
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					SigmaSR(u64SACC, u32Rm, u32TabValue, IsAdd, &u32Status, u32SHFCR);					
					break;
				case 1:
					//SACCs = Sigma_b2(Rm+1:m，STABn(SC))
					//SACCs += Sigma_b2(Rm+1:m，STABn(SC))
					u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
					SigmaBR(u64SACC, u64Src, u32TabValue, IsAdd, &u32Status, u32SHFCR);	
					break;
				case 2:
					//SACCs = Sigma_b4(Rm+1:m，HHSTABn(SC))
					//SACCs += Sigma_b4(Rm+1:m，HHSTABn(SC))
					u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
					SigmaQRHH(u64SACC, u64Src, u32TabValue, IsAdd, &u32Status, u32SHFCR);
					break;
				case 3:
					//SACCs = Sigma_b4(Rm+1:m，LHSTABn(SC))
					//SACCs += Sigma_b4(Rm+1:m，LHSTABn(SC))
					u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
					SigmaQRLH(u64SACC, u64Src, u32TabValue, IsAdd, &u32Status, u32SHFCR);
					break;
				}
				//写回SACC
				u64ri_SHF_SACC[i][u32ShfIdx].u32Low = u64SACC.u32Low;
				u64ri_SHF_SACC[i][u32ShfIdx].u32High = u64SACC.u32High;

				u32SHFFlag = SetSHFFlags(u32ri_SHFFR[i][u32ShfIdx], u32Status);
				u32ri_SHFFR[i][u32ShfIdx] = u32SHFFlag;
			}
		}
	}
	return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::shf_add_sub_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("shf_add_sub_32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("shf_add_sub_32_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx;
        union INSTR_WORD
            {
                DSPU32  u32Value;
                struct  SPLIT_VALUE
                {
                    DSPU32      u6SrcN: 6;
                    DSPU32      u6SrcM: 6;
					DSPU32		u1Half:  1;
                    DSPU32      u1Sign: 1;					
                    DSPU32      u3Mode: 3;
                    DSPU32      u1Flag: 1;
                    DSPU32      u8Opcode: 8;
                    DSPU32      u1MultiWord: 1;
                    DSPU32      u4Units: 4;
                    DSPU32      u1Line: 1;
                } details;
            } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Sign;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1Half;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                // get the value of R[u32SrcNIdx] of current macro
                // data forward or directly
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32Sign, u32Mode;
        DSPU32 u32SHFIdx, u32GenResultIdx, u32SHFCR, u32SrcMValue;
		DSP_BIT64 u64Temp;
		DSPU32 u1Half;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u1Half = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {       
                // get the index of the first ALU allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                if (u32Sign == 1)
                {
                    u32SHFCR = GSetBit(u32SHFCR, 0);
                }
                
                u32Status = 0;
				u64Temp.u32Low = 0;
				u64Temp.u32High = 0;
				u32SrcMValue = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.EX_WB.m_right.arrSrcPageIdx[i]);
                switch (u32Mode)
                {
                    // get result
                    
                    case 0:
                        if(u1Half == 0)
                        {
								SHF_Add_Sub32(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 0);
                        }
						else
						{
								SHF_Add_Sub32(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 1);
                        }

						if ( GIsBitSet(u32SHFCR, 3) && (u32Sign == 1) )
						{
							m_arrChgBKF_SHF[i] = true;
							DSPU32 BKFTmp0 = 0;
							DSPU32 BKFTmp1 = 0;
							BKFTmp0 = BKF_I32(u64Temp.u32High);
							BKFTmp1 = BKF_I32(u64Temp.u32Low);
							m_arrSHF_BKFlag[i][u32SHFIdx] = (BKFTmp0 > BKFTmp1)?BKFTmp0:BKFTmp1;
						}
                        break;
                    case 1: // 
						if(u1Half == 0)
                        {
								SHF_Add_SubD16(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 0);
                        }
						else
						{
								SHF_Add_SubD16(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 1);
                        }
						if ( GIsBitSet(u32SHFCR, 3) && (u32Sign == 1) )
						{
							m_arrChgBKF_SHF[i] = true;
							DSPU32 BKFTmp0 = 0;
							DSPU32 BKFTmp1 = 0;
							BKFTmp0 = BKF_DI16(u64Temp.u32High);
							BKFTmp1 = BKF_DI16(u64Temp.u32Low);
							m_arrSHF_BKFlag[i][u32SHFIdx] = (BKFTmp0 > BKFTmp1)?BKFTmp0:BKFTmp1;
						}
						break;
                    case 3: // 
                    	u32SHFCR = GSetBit(u32SHFCR, 0);
                        if(u1Half == 0)
                        {
								SHF_Add_SubC32(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 0);
                        }
						else
						{
								SHF_Add_SubC32(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 1);
                        }
						if ( GIsBitSet(u32SHFCR, 3) )
						{
							m_arrChgBKF_SHF[i] = true;
							DSPU32 BKFTmp0 = 0;
							DSPU32 BKFTmp1 = 0;
							BKFTmp0 = BKF_DI16(u64Temp.u32High);
							BKFTmp1 = BKF_DI16(u64Temp.u32Low);
							m_arrSHF_BKFlag[i][u32SHFIdx] = (BKFTmp0 > BKFTmp1)?BKFTmp0:BKFTmp1;
						}
                        break;
                    case 4: // 
                    	u32SHFCR = GSetBit(u32SHFCR, 0);
                        if(u1Half == 0)
                        {
								SHF_Add_SubConjC32(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 0);
                        }
						else
						{
								SHF_Add_SubConjC32(u64Temp, u32SrcA, u32SrcB, &u32Status, u32SHFCR, 1);
                        }
						if ( GIsBitSet(u32SHFCR, 3) )
						{
							m_arrChgBKF_SHF[i] = true;
							DSPU32 BKFTmp0 = 0;
							DSPU32 BKFTmp1 = 0;
							BKFTmp0 = BKF_DI16(u64Temp.u32High);
							BKFTmp1 = BKF_DI16(u64Temp.u32Low);
							m_arrSHF_BKFlag[i][u32SHFIdx] = (BKFTmp0 > BKFTmp1)?BKFTmp0:BKFTmp1;
						}
                        break;                    
                
                    default:
                        PrintToCerr("expan_hhreg_etc_mode1_cores: mode not found\n");
                }
                
				wr_u32r_R_new(i, u32SrcMIdx, u64Temp.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				wr_u32r_R_new(i, u32SrcNIdx, u64Temp.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
        
            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::shf_fr_zero_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("shf_fr_zero_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("shf_fr_zero_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SHFs, u32Mode;

		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
				DSPU32      u4Mode: 4;
				DSPU32      u4Rev0: 4;
				DSPU32      u8M: 8;
				DSPU32      u2Rev1: 2;
				DSPU32    	u8Opcode: 8;
				DSPU32   	u1MultiWord: 1;
				DSPU32   	u4Units: 4;
 			   	DSPU32   	u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u8M;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SHFs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].u8SHFs= u32SHFs;           
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		//设置SACC数据相关
		if(u32Mode==0)
		{
			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				// whether current macro(unit) is used.
				if ( GIsBitSet(u32Units, i) )
				{
					//设置SACC写相关
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
				}
			}
						
		}
		
		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SHFs, u32Flag, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SHFs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		if(u32Mode==4)
		{
			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				if ( GIsBitSet(u32Units, i) )
				{
					for (int k = 0; k < SHF_NUM_OF_UNIT; k++)
					{
						if ( GIsBitSet(u32SHFs, k) )
						{
							u32r_SHF_SLTAR[i][k] = 0;							
							
						}
					}

				} //if ( GIsBitSet(u32Units, i) )

			} //for (i = 0; i < NUM_OF_UNITS; i++)
		}
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32SHFs, u32Flag, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SHFs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		if(u32Mode==3)
		{
			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				if ( GIsBitSet(u32Units, i) )
				{
					for (int k = 0; k < SHF_NUM_OF_UNIT; k++)
					{
						if ( GIsBitSet(u32SHFs, k) )
						{
							u32r_SHFER[i][k] = 0;							
						}
					}

				} //if ( GIsBitSet(u32Units, i) )

			} //for (i = 0; i < NUM_OF_UNITS; i++)
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SHFs, u32Flag, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SHFs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < SHF_NUM_OF_UNIT; k++)
				{
					if ( GIsBitSet(u32SHFs, k) )
					{
						if(u32Mode == 0)
						{
							u64ri_SHF_SACC[i][k].u32High = 0;
							u64ri_SHF_SACC[i][k].u32Low = 0;
						}
						else if(u32Mode==2)
						{
							u32_SHF_SCF[i][k] = 0;
						}
						
						if(u32Mode==1)
						{
							u32ri_SHFFR[i][k] = 0;
						}
						else
						{
							u32Flag = SetSHFFlags(u32ri_SHFFR[ i ][ k ], 0);
							u32ri_SHFFR[ i ][ k ] = u32Flag;
						}
						
					}
				}

			} //if ( GIsBitSet(u32Units, i) )

		} //for (i = 0; i < NUM_OF_UNITS; i++)
		
	} // if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_shffr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("wr_shffr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("wr_shffr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u6SrcM :6;
				DSPU32 u12Addr :12;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6SrcM;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u12Addr - SPEC_ADDR_SHFFR;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(
						u32SrcMIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{

				if (GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx))
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i,
							u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SrcA, u32CalcResIdx, u32Flag;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				u32ri_SHFFR[i][u32CalcResIdx] = u32SrcA & 0x7F7F;
			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//------------------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_sltar_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("wr_sltar_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("wr_sltar_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32CalcResIdx, u32Mode;

		union INSTR_WORD_SHF
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u6SrcM :6;
				DSPU32 u12Addr :12;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word_shf;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word_shf.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word_shf.details.u6SrcM;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word_shf.details.u12Addr - SPEC_ADDR_SLTAR;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word_shf.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32SrcValueA, u32SHFIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				u32SHFIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				if (GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx))
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					u32SrcValueA = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					u32SrcValueA = rd_u32r_R_new(i, u32SrcMIdx,
							PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				u32r_SHF_SLTAR[i][u32SHFIdx] = u32SrcValueA & 0xff;
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_scf_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("wr_scf_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("wr_scf_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32CalcResIdx, u32Mode;

		union INSTR_WORD_SHF
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u6SrcM :6;
				DSPU32 u12Addr :12;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word_shf;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word_shf.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word_shf.details.u6SrcM;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word_shf.details.u12Addr - SPEC_ADDR_SCF;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word_shf.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)


		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				if (GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx))
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i,
							u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SrcA, u32CalcResIdx, u2Mode, u32Flag;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32_SHF_SCF[i][u32CalcResIdx] = u32SrcA & 0xF;

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//----------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_shfer_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("wr_shfer_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("wr_shfer_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32CalcResIdx, u32Mode;

		union INSTR_WORD_SHF
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u6SrcM :6;
				DSPU32 u12Addr :12;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word_shf;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word_shf.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word_shf.details.u6SrcM;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word_shf.details.u12Addr - SPEC_ADDR_SHFER;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word_shf.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{

				if (GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx))
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i,
							u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32SrcA, u32CalcResIdx;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32r_SHFER[i][u32CalcResIdx] = u32SrcA & 0x3;
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32CalcResIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

bool sc_iss::rd_shffr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_shffr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_shffr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_SHFFR;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32DestIdx, u32GenResultIdx;
		DSPU32 u32Result, u32Status, u32CalcResIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;
				u32Result = u32ro_SHFFR[i][u32CalcResIdx];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx,
						u32Result);
				u32GenResultIdx++;
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_sltar_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot,
		DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_sltar_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_sltar_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_SLTAR;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32CalcResIdx;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32r_SHF_SLTAR[i][u32CalcResIdx];
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32DestIdx, u32GenResultIdx;
		DSPU32 u32Result, u32Status, u32CalcResIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;
				u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx,
						u32Result);
				u32GenResultIdx++;
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_scf_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_scf_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_scf_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_SCF;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32DestIdx, u32GenResultIdx;
		DSPU32 u32Result, u32Status, u32CalcResIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;
				u32Result = u32_SHF_SCF[i][u32CalcResIdx];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx,
						u32Result);
				u32GenResultIdx++;
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_shfer_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot,
		DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_shfer_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_shfer_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_SHFER;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32CalcResIdx;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] =
						u32r_SHFER[i][u32CalcResIdx];
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32DestIdx, u32GenResultIdx;
		DSPU32 u32Result, u32Status, u32CalcResIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetSHFIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32CalcResIdx], 0);
				u32ri_SHFFR[i][u32CalcResIdx] = u32Flag;
				u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx,
						u32Result);
				u32GenResultIdx++;
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)
	return true;
}


bool sc_iss::like_expand_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_expand_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_expand_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32  u32Value;
			struct  SPLIT_VALUE
			{
				DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
				DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{				
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;
		DSP_BIT64 u64Res;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		u32Result = 0;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
								
				//Rs+1:s=EXPAND(HRm,Rn)(U)
				Expand16To32(u64Res,u32SrcA,u32SrcB,&u32Status,u32SHFCR);

				wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);


				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				// Log info for data forward
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
				u32GenResultIdx++;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

bool sc_iss::shf_tab_add_reg16_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("shf_tab_add_reg16_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("shf_tab_add_reg16_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32SrcSIdx, u32Units, u32Mode, u32n, u32k;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct  SPLIT_VALUE
			{
				DSPU32		u2k: 2;
				DSPU32      u2n: 2;
				DSPU32		u2Mode: 2;
				DSPU32		u6SrcM: 6;
				DSPU32		u6SrcS: 6;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
				DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2k;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2n;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6SrcS;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable      
		u32k = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcSIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];		

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32k, m_arrDCResNeeded[p_u32Slot].u8SHFs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{               
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcSIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						
				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				//设置Tab表写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_EX = true;
				// 根据所访问的STAB中块的序号设置掩码
				if(u32Mode == 0)
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
				}
				else //u32Mode == 1
				{   //该模式下n只可以取0、1。
					u32n = u32n & 0x1;
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<(u32n*2));
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<(u32n*2+1));
				}
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcSIdx, u32Result, u32Rs,u32Mode;
		DSPU32 u32TabAddr, u32TabIdx, u32n;
		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];		
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];	
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcSIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32TabIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcSIdx) )
				{
					u32Rs = u32Result;
				}
				else
				{
					u32Rs = rd_u32r_R_new(i, u32SrcSIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Rs;
				
				DSPU32 Temp0, Temp1,u32nTmp;
				if(u32Mode == 0)
				{
					u32TabAddr = (u32Rs & 0xff);
					Temp0 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xffff;
					u32TabAddr = ((u32Rs>>8) & 0xff);
					Temp1 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xffff0000;
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = (Temp0 | Temp1);
				}
				else if(u32Mode == 1)
				{
					u32TabAddr = (u32Rs & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					Temp0 = rd_SHF_Tab(i, u32TabIdx, u32nTmp, u32TabAddr) & 0xffff;
					u32TabAddr = ((u32Rs>>16) & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					Temp1 = rd_SHF_Tab(i, u32TabIdx, u32nTmp, u32TabAddr) & 0xffff0000;
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = (Temp0 | Temp1);
				}
				
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32Rm, u32Imm, u32Status, u32SHFCR, u32SHFIdx, u32TabValue;
		DSPU32 u32Result, u32Mode, u32Rs, u32TabAddr, u32n,u32nTmp;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{	
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32TabValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
				u32Rs = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32Status = 0;
				u32Imm = 0;

				//HSTABn(LORs) +=HRm(U,k),	HSTABn(EHRs) +=HRm(U,k)
				u32Result = STabAddReg(u32TabValue,u32Rm,u32Imm,&u32Status,u32SHFCR,0);
				
				if(u32Mode == 0)
				{
					u32TabAddr = (u32Rs & 0xff);
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr,0x3,u32Result);
					u32TabAddr = ((u32Rs>>8) & 0xff);
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr,0xC,u32Result);
				}
				else if(u32Mode == 1)
				{
					u32TabAddr = (u32Rs & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					wr_SHF_Tab(i, u32SHFIdx, u32nTmp, u32TabAddr,0x3,u32Result);
					u32TabAddr = ((u32Rs>>16) & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					wr_SHF_Tab(i, u32SHFIdx, u32nTmp, u32TabAddr,0xC,u32Result);
				}

				m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Status;

			}//if ( GIsBitSet(u32Units, i) )
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32Status;
		DSPU32 u32SHFIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
	
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				
				u32Status = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

bool sc_iss::shf_tab_add_imm_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("shf_tab_add_imm_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("shf_tab_add_imm_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcSIdx, u32Units, u32Mode, u32n, u32k;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct  SPLIT_VALUE
			{
				DSPU32		u2k: 2;
				DSPU32      u2n: 2;
				DSPU32		u2Mode: 2;
				DSPU32		u2Rev0: 2;
				DSPU32		u4Imm: 4;
				DSPU32		u6SrcS: 6;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
				DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2k;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2n;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Imm;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6SrcS;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable      
		u32k = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcSIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];		

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32k, m_arrDCResNeeded[p_u32Slot].u8SHFs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{               
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcSIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);

				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				//设置Tab表写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_EX = true;
				// 根据所访问的STAB中块的序号设置掩码
				if(u32Mode == 2)
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<u32n);
				}
				else //u32Mode == 3
				{
					//该模式下n只可以取0、1。
					u32n = u32n & 0x1;
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<(u32n*2));
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<(u32n*2+1));
				}
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcSIdx, u32Result, u32Rs,u32Mode;
		DSPU32 u32TabAddr, u32TabIdx, u32n;
		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];		
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];	
		u32SrcSIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;


		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32TabIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				//Imm
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcSIdx) )
				{
					u32Rs = u32Result;
				}
				else
				{
					u32Rs = rd_u32r_R_new(i, u32SrcSIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Rs;

				DSPU32 Temp0, Temp1, u32nTmp;
				if(u32Mode == 2)
				{
					u32TabAddr = (u32Rs & 0xff);
					Temp0 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xffff;
					u32TabAddr = ((u32Rs>>8) & 0xff);
					Temp1 = rd_SHF_Tab(i, u32TabIdx, u32n, u32TabAddr) & 0xffff0000;
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = (Temp0 | Temp1);
				}
				else if(u32Mode == 3)
				{
					u32TabAddr = (u32Rs & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					Temp0 = rd_SHF_Tab(i, u32TabIdx, u32nTmp, u32TabAddr) & 0xffff;
					u32TabAddr = ((u32Rs>>16) & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					Temp1 = rd_SHF_Tab(i, u32TabIdx, u32nTmp, u32TabAddr) & 0xffff0000;
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = (Temp0 | Temp1);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32Rm, u32Imm, u32Status, u32SHFCR, u32SHFIdx, u32TabValue;
		DSPU32 u32Result, u32Mode, u32Rs, u32TabAddr, u32n,u32nTmp;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{	
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Imm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32TabValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
				u32Rs = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32Status = 0;
				u32Rm = 0;

				//HSTABn(LORs) +=C(U,k),	HSTABn(EHRs) +=C(U,k)
				u32Result = STabAddReg(u32TabValue,u32Rm,u32Imm,&u32Status,u32SHFCR,1);

				if(u32Mode == 2)
				{
					u32TabAddr = (u32Rs & 0xff);
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr,0x3,u32Result);
					u32TabAddr = ((u32Rs>>8) & 0xff);
					wr_SHF_Tab(i, u32SHFIdx, u32n, u32TabAddr,0xC,u32Result);
				}
				else if(u32Mode == 3)
				{
					u32TabAddr = (u32Rs & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					wr_SHF_Tab(i, u32SHFIdx, u32nTmp, u32TabAddr,0x3,u32Result);
					u32TabAddr = ((u32Rs>>16) & 0x1ff);
					u32nTmp = u32n*2;
					if(u32TabAddr & 0x100)
					{
						u32nTmp = u32n*2+1;
						u32TabAddr = u32TabAddr - 0x100;
					}
					wr_SHF_Tab(i, u32SHFIdx, u32nTmp, u32TabAddr,0xC,u32Result);
				}

				m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Status;

			}//if ( GIsBitSet(u32Units, i) )
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32Status;
		DSPU32 u32SHFIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				u32Status = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

#if 0 

bool sc_iss::shf_add8or16_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("shf_add8or16_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("shf_add8or16_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32  u32Value;
			struct  SPLIT_VALUE
			{
				DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
				DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{				
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32SHFIdx, u32Result, u32GenResultIdx, u32SHFCR;
		DSP_BIT64 u64Res;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		u32Result = 0;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				if(p_u32Opcode == op_shf_add_8_c || p_u32Opcode == op_shf_add_16_c)
				{
					u32SHFCR = GSetBit(u32SHFCR, 0);
				}

				if(p_u32Opcode == op_shf_add_8_c || p_u32Opcode == op_shf_add_8_u_c)
				{
					//HRs+1:s=ORm+ORn,HRs+1:s=ORm+ORn(U)
					//AddOReg(u64Res,u32SrcA,u32SrcB,&u32Status,u32SHFCR);
				}
				else  //if(p_u32Opcode == op_shf_add_16_c || p_u32Opcode == op_shf_add_16_u_c)
				{
					//Rs+1:s =HRm+HRn,Rs+1:s =HRm+HRn(U)
					//AddD16Reg(u64Res,u32SrcA,u32SrcB,&u32Status,u32SHFCR);
				}

				wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);


				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				// Log info for data forward
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
				u32GenResultIdx++;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

#endif
