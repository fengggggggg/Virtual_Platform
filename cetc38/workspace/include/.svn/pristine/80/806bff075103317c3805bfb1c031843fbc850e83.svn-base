#include "CSHF.h"
#include "GlobleDef.h"
#include "Cfloat32.h"
#include <bitset>
#include <math.h>
#include <stdio.h>
#include <cstdlib>

using namespace std;


DSPU16 Neg16(DSPU16 p_u16Src, DSPU32 *p_pStatReg,DSPU32 p_u32SHFCR) {	 
	 
	*p_pStatReg &=0xff00;
	unsigned int OpBits = 16;

	DSPU16 uDest;
	
	bool u1Saturation = false; 
	u1Saturation = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation); 
			
	if (p_u16Src == 0x8000) {
		if(u1Saturation){
			uDest = 0x7fff;
		}
		else{
			uDest = ~p_u16Src + 1;
		}
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
	} else {
		uDest = ~p_u16Src + 1;
	}
	
	return uDest;

}

DSPU32 gmpy(DSPU32 src1, DSPU32 src2, DSPU32 polynomial, DSPU32 Num) {
	DSPU32 pp = 0;
	DSPU32 mask, mask2, numMask, tpp, poly, u32src1, u32src2;

	u32src1 = src1;
	u32src2 = src2;
	poly = polynomial;
	mask = 0x80000000; // multiply by computing
	mask2 = 0x80000000;

	if (Num == 16) {
		poly = polynomial&0xffff;
		u32src1 = src1&0xffff;
		u32src2 = src2&0xffff;
		mask = 0x8000; // multiply by computing
		mask2 = 0x8000;
	} else if (Num == 8) {
		poly = polynomial&0xff;
		u32src1 = src1&0xff;
		u32src2 = src2&0xff;
		mask = 0x80; // multiply by computing
		mask2 = 0x80;
	}
	
	else {
		numMask = 0xffffffff >> (32-Num);
		poly = polynomial&numMask;
		u32src1 = src1&numMask;
		u32src2 = src2&numMask;
		mask = 0x80000000 >> (32-Num); // multiply by computing
		mask2 = 0x80000000 >> (32-Num);
	}
	// partial products.
	for (DSPU32 i=0; i<Num-1; i++) {
		if (u32src2 & mask)
			pp ^= u32src1;

		mask >>= 1;
		tpp = pp << 1;//pp = 0x80000000, tpp=0x100000000
		//if (pp & 0x80000000)
		if (pp & mask2)
			pp = poly ^ tpp;// tpp=0x100000000
		else
			pp = tpp;
	}
	if (u32src2 & 0x1)
		pp ^= u32src1;
	return (pp); // leave it asserted left.
}

/******************************************************************
 ��������		AShift32

 ����:		32λ������������λ(�������������չ)��

 ����:		p_u32Src -- ����λ��������
 p_u32BitToShift -- �ƶ�λ�����з������Ĳ�����ʽ��
 ����ʾ���ƣ�����ʾ���ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:	���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AShift32(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32* p_pStatReg, DSPU32 p_u32SHFCR) {
	int i32BitNum = 6;
	unsigned int BitMask = 0x0000003f;
	
	bool LeftShift = !TestBit(p_u32BitToShift,i32BitNum - 1);

	DSPI32 i32ToShift;
	DSPI32 i32Result;
	DSPI32 i32Dest = 0;

	bool bolOverflow = false;
	bool bolSign= TestBit(p_u32Src, 31);
	bool bolStau = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation);	

	if (LeftShift) {
		p_u32BitToShift = p_u32BitToShift & BitMask;


		i32ToShift = (DSPI32)p_u32BitToShift;
		i32Result = p_u32Src;
		
		for (int i = 0; i < i32ToShift; i++) {
			i32Result = ((i32Result << 1)&0xffffffff);
			if ((bool)(TestBit(i32Result, 31)) != bolSign) {
				bolOverflow = true;
			}			
		}
	} else {		
		p_u32BitToShift = p_u32BitToShift | ~BitMask;			
		i32ToShift = (DSPI32)p_u32BitToShift;		
		i32ToShift = (-i32ToShift)&0xffffffff;	
		
		i32Result = p_u32Src;
		for (int i = 0; i < i32ToShift; i++) {
			i32Result = i32Result >> 1;
			if(bolSign)
			{SetBit(i32Result , 31);}
		}		
	}

	if (bolOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);

		if (bolSign) {
			SetBit(i32Result , 31);
			if(bolStau){				
				i32Result = 0x80000000;			
			}
			
		} else {
			ClearBit(i32Result , 31);
			if(bolStau){				
				i32Result = 0x7fffffff;			
			}
		}
	}
	i32Dest = i32Result & 0xffffffff; 	

	return i32Dest;
}

extern DSPU32 ArShift32(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {	

	int i32BitNum = 6;
	unsigned int BitMask = 0x0000003f;	
	bool RightShift = !TestBit(p_u32BitToShift,i32BitNum - 1);	

	DSPI32 i32ToShift;
	DSPI32 i32Result;
	DSPI32 i32Dest = 0;	

	bool bolOverflow = false;
	bool bolSign= TestBit(p_u32Src, 31);
	bool bolStau = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation);	

	//right
	if (RightShift) {
		
		p_u32BitToShift = p_u32BitToShift & BitMask;
		i32ToShift = (DSPI32)p_u32BitToShift;	
		i32Result = p_u32Src;	
		
		for (int i = 0; i < i32ToShift; i++) {
			i32Result = i32Result >> 1;
			if(bolSign)
				SetBit(i32Result , 31);			
		}		

	} else {
			
		p_u32BitToShift = p_u32BitToShift | ~BitMask;
		i32ToShift = (DSPI32)p_u32BitToShift;
		
		i32ToShift = (-i32ToShift)&0xffffffff;
		i32Result = p_u32Src;
			
		for (int i = 0; i < i32ToShift; i++) {
			i32Result = ((i32Result << 1)&0xffffffff);
			if ((bool)(TestBit(i32Result, 31)) != bolSign) {
				bolOverflow = true;
			}			
		}
	}

	if (bolOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);

		if (bolSign) {
			SetBit(i32Result , 31);
			if(bolStau){				
				i32Result = 0x80000000;			
			}
			
		} else {
			ClearBit(i32Result , 31);
			if(bolStau){				
				i32Result = 0x7fffffff;			
			}
		}
	}
	i32Dest = i32Result & 0xffffffff; 	

	return i32Dest;
}


/******************************************************************
 ��������		LShift32

 ����:			32λ�������߼���λ(���Ʋ��������չ)��

 ����:			p_u32Src -- ����λ��������
 p_u32BitToShift -- �ƶ�λ�����з������Ĳ�����ʽ��
 ����ʾ���ƣ�����ʾ���ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 LShift32(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	bool LeftShift = !TestBit(p_u32BitToShift, 5);
	unsigned int BitMask = 0x0000003f;

	DSPI32 i32ToShift = 0,i32ToShiftTemp = 0;
	DSPU32 u32Result = 0,u32BitToShift = 0;

	if (LeftShift) {
		u32BitToShift = p_u32BitToShift & BitMask;
		i32ToShift = (DSPI32)u32BitToShift;
		u32Result = p_u32Src;
		for (int i = 0; i < i32ToShift; i++) {
			u32Result = ((u32Result << 1)&0xffffffff);
		}

	} else {
		u32BitToShift = p_u32BitToShift | (~BitMask);		
		i32ToShiftTemp = (DSPI32)u32BitToShift;		
		i32ToShift = (-i32ToShiftTemp)&0xffffffff;		
		u32Result = p_u32Src;
		for (int i = 0; i < i32ToShift; i++) {
			u32Result = u32Result >> 1;
		}
		
	}
	u32Result &= 0xffffffff;
	
	return u32Result;
}

extern DSPU32 LrShift32(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	bool sign = TestBit(p_u32BitToShift, 5);
	unsigned int BitMask = 0x0000003f;
	unsigned int u32ToShift = 0,u32Result = 0;

	if (sign) {
		u32ToShift = (~p_u32BitToShift+1) & BitMask;;
		u32Result = p_u32Src << u32ToShift;
		if(u32ToShift > 31){
			u32Result = 0;
		}
	

	} else {
		u32ToShift = p_u32BitToShift & BitMask;			
		u32Result = p_u32Src >> u32ToShift;		
	}
	u32Result &= 0xffffffff;
	
	return u32Result;
}

/******************************************************************
 ��������		Rot32

 ����:			32λ������ѭ����λ��

 ����:			p_u32Src -- ����λ��������
 p_u32BitToShift -- �ƶ�λ�����з������Ĳ�����ʽ��
 ����ʾ���ƣ�����ʾ���ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Rot32(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	
	bool LeftShift = !TestBit(p_u32BitToShift, 5);
	unsigned int BitMask = 0x0000003f;

	DSPI32 i32ToShift;
	DSPU32 u32Result;
 
	if (LeftShift) {
		
		p_u32BitToShift = p_u32BitToShift & BitMask;
		i32ToShift = (DSPI32)p_u32BitToShift;
		u32Result = p_u32Src;
		bool bolMSB = false;
		for (int i = 0; i < i32ToShift; i++) {
			//waring commemt by baohua 2012.
			bolMSB = TestBit(u32Result,31);			
			u32Result = ((u32Result << 1)&0xffffffff);
			u32Result |= (DSPU32)bolMSB;
		}

	} else {
		p_u32BitToShift = p_u32BitToShift | ~BitMask;
		i32ToShift = (DSPI32)p_u32BitToShift;
		i32ToShift = (-i32ToShift)&0xffffffff;	
		u32Result = p_u32Src;
		bool bolLSB = false;
		for (int i = 0; i < i32ToShift; i++) {
			bolLSB = TestBit(u32Result,0);
			u32Result = ((u32Result >> 1)&0xffffffff);			
			if(bolLSB){
				SetBit(u32Result,31);
			}
			u32Result&=0xffffffff;
			
		}
	}

	return u32Result;
}

extern DSPU32 Rrot32(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	
	bool sign = TestBit(p_u32BitToShift, 5);
	unsigned int BitMask = 0x0000003f;

	DSPI32 i32ToShift,i32BitToShift;
	DSPU32 u32Result;
	bool bolMSB = false,bolLSB = false;

	u32Result = p_u32Src;

	if (sign) {

		i32BitToShift = p_u32BitToShift | ~BitMask;
		i32ToShift = (DSPI32)i32BitToShift;
		i32ToShift = (-i32ToShift)&0xffffffff;		
		for (int i = 0; i < i32ToShift; i++) {
			bolMSB = TestBit(u32Result,31);			
			u32Result = ((u32Result << 1)&0xffffffff);
			u32Result |= (DSPU32)bolMSB;
		}

	} else {
		
		i32ToShift = p_u32BitToShift & 0X3f;
		for (int i = 0; i < i32ToShift; i++) {
			bolLSB = TestBit(u32Result,0);
			u32Result = ((u32Result >> 1)&0xffffffff);			
			if(bolLSB){
				SetBit(u32Result,31);
			}
			u32Result&=0xffffffff;			
		}
	}
	return u32Result;
}

DSPU16 AShift16(DSPU16 p_u16Src, DSPU32 p_u32BitToShift, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	DSPI16 i16BitNum = 5;
	unsigned int BitMask = 0x0000001f;
	
	bool LeftShift = !TestBit(p_u32BitToShift,i16BitNum - 1);

	DSPI16 i16ToShift;
	DSPI16 i16Result;

	bool bolOverflow = false;
	bool bolSign= TestBit(p_u16Src, 15);
	bool bolStau = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation);	

	if (LeftShift) {
		
		p_u32BitToShift = p_u32BitToShift & BitMask;
		i16ToShift = (DSPI16)p_u32BitToShift;
		i16Result = p_u16Src;
		for (int i = 0; i < i16ToShift; i++) {
			i16Result = ((i16Result << 1)&0xffff);
			if ((bool)(TestBit(i16Result, 15)) != bolSign) {
				bolOverflow = true;
			}
		}

	} else {
		p_u32BitToShift = p_u32BitToShift | ~BitMask;
		i16ToShift = (DSPI16)p_u32BitToShift;
		i16ToShift = (-i16ToShift)&0xffffffff;
		i16Result = p_u16Src;
		for (int i = 0; i < i16ToShift; i++) {
			i16Result = i16Result >> 1;
		}
	}

	if (bolOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
		if (bolSign) {
			SetBit(i16Result , 15);
			
			if(bolStau){
				i16Result = 0x8000;				
			}
		} else {
			ClearBit(i16Result , 15);
			if(bolStau){
				i16Result = 0x7fff;				
			}
		}
	}
	
	i16Result&=0xffff;
	return i16Result;
}

/******************************************************************
 ��������		AShiftD16

 ����:			�ߵ�16λ������������λ(�������������չ)��

 ����:			p_u32Src -- ����λ������������ߵ�16λ�������ݡ�
 p_u32BitToShift -- �ƶ�λ�����з������Ĳ�����ʽ��
 ����ʾ���ƣ�����ʾ���ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AShiftD16(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
	DSPU16 u16LowerSrc = (DSPU16)p_u32Src;

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = AShift16(u16UpperSrc, p_u32BitToShift, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = AShift16(u16LowerSrc, p_u32BitToShift, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		LShift32Fill1

 ����:	32λ�������߼���λ(���Ʋ��������չ)����λ���ճ���λ����1��
 ����:	p_u32Src -- ����λ��������
 p_u32BitToShift -- �ƶ�λ�����з������Ĳ�����ʽ������ʾ���ƣ�����ʾ���ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 LShift32Fill1(DSPU32 p_u32Src, DSPU32 p_u32BitToShift,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
		
	bool LeftShift = !TestBit(p_u32BitToShift, 5);
	unsigned int BitMask = 0x0000003f;

	DSPI32 i32ToShift;
	DSPU32 u32Result;

	if (LeftShift) {
		
		
		p_u32BitToShift = p_u32BitToShift & BitMask;
		i32ToShift = (DSPI32)p_u32BitToShift;
		u32Result = p_u32Src;
		for (int i = 0; i < i32ToShift; i++) {
			u32Result = u32Result << 1;
			u32Result |= 0x00000001;
		}
		u32Result&=0xffffffff;

	} else {
		p_u32BitToShift = p_u32BitToShift | ~BitMask;
		i32ToShift = (DSPI32)p_u32BitToShift;
		i32ToShift = (-i32ToShift)&0xffffffff;
		u32Result = p_u32Src;
		for (int i = 0; i < i32ToShift; i++) {
			u32Result = u32Result >> 1;
			u32Result |= 0x80000000;
		}
		u32Result&=0xffffffff;
	}
	return u32Result;
}

/******************************************************************
 ��������		Expand16

 ����:			16λ�������չΪ32λ��������

 ����:			p_u16Src -- ���չ16λ��������
 p_u32Pos -- ��ʾ���չ��16λ������32λĿ�ļĴ���Rs��������λ�ã�
 ���ݴ���16������16����
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 �Ƿ�������λ�չ��p_u32SHFCR����

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Expand16(DSPU16 p_u16Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	DSPU32 u5Pos = p_u32Pos & 0x1f;
	if (u5Pos > 16) {
		u5Pos = 16;
	}

	DSPU32 u32Src;
	if (bolSigned) {
		u32Src = (DSPI16)p_u16Src;
	} else {
		u32Src = (DSPU32)p_u16Src;
	}

	return u32Src << u5Pos;

}
/******************************************************************
 ��������		CompactC32

 ����:			32λ���㸴��ѹ��Ϊ16λ���㸴����

 ����:			p_u32Src1 -- ��ѹ��������1��
 p_u32Src2 -- ��ѹ��������2��
 p_u32Pos -- ѹ������16λ�������32λԴ�������е��ĸ�λ�Σ�
 ���ݴ���16������16����
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 CompactC32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u32Pos,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	bool bolSrcSign1= TestBit (p_u32Src1, 31);
	bool bolSrcSign2= TestBit (p_u32Src2, 31);

	
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);

	p_u32Pos = p_u32Pos & 0x1f; //5λ 
	if (p_u32Pos > 16) {
		p_u32Pos = 16;
	}

	DSPU16 u16UpperRes = 0;
	DSPU16 u16LowerRes = 0;
	DSPU32 u32result = 0;
	if (!bolSigned) 
	{
		DSPU32 u32UpperRes = p_u32Src1 >> p_u32Pos; 
		DSPU32 u32LowerRes = p_u32Src2 >> p_u32Pos; 
		u16UpperRes = (DSPU16)(u32UpperRes & 0xffff);
		u16LowerRes = (DSPU16)(u32LowerRes & 0xffff); 
		if ( (u32UpperRes>>16) != 0) 
		{
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolSatu) {
				u16UpperRes = 0xffff;
			}
		}

		if ( (u32LowerRes>>16) != 0) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);

			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolSatu) {
				u16LowerRes = 0xffff;
			}
		}
		u32result = (((DSPU32)u16UpperRes)<<16) | (DSPU32)u16LowerRes; //�ϳɽ��� 
	} else  
	{
		DSPI32 i32UpperRes = ((DSPI32)p_u32Src1)>>p_u32Pos;
		DSPI32 i32LowerRes = ((DSPI32)p_u32Src2)>>p_u32Pos;
		u16UpperRes = (DSPU16)(i32UpperRes & 0xffff);
		u16LowerRes = (DSPU16)(i32LowerRes & 0xffff);
		
		if ( ((!bolSrcSign1) && (i32UpperRes>>15)!=0 ) || ((bolSrcSign1)
				&& ((i32UpperRes>>15)!=(int)0xffffffff))) {//add int to delet waring by baohua 2013.5.20
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolSatu) {
				if (!bolSrcSign1) {
					u16UpperRes = 0x7fff;
				} else {
					u16UpperRes = 0x8000;
				}
			}
		}
		
		if ( ((!bolSrcSign2) && (i32LowerRes>>15)!=0 ) || ((bolSrcSign2)
				&& ((i32LowerRes>>15)!=(int)0xffffffff))) {//add int to delet waring by baohua 2013.5.20
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolSatu) {
				if (!bolSrcSign2) {
					u16LowerRes = 0x7fff;
				} else {
					u16LowerRes = 0x8000;
				}
			}
		}
		u32result = (((DSPU32)u16UpperRes)<<16) | (DSPU32)u16LowerRes;
	}
	return u32result;
}
/******************************************************************
 ��������		Compact32

 ����:			32λ������ѹ��Ϊ16λ��������

 ����:			p_u32Src -- ��ѹ�������ݡ�
 p_u32Pos -- ѹ������16λ�������32λԴ�������е��ĸ�λ�Σ�
 ���ݴ���16������16����
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU16 Compact32(DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	bool bolSrcSign= TestBit (p_u32Src, 31);
	p_u32Pos = p_u32Pos & 0x1f; //5λ 
	if (p_u32Pos > 16) {
		p_u32Pos = 16;
	}

	DSPU16 u16Dest = (DSPU16)(p_u32Src >> p_u32Pos);
	DSPI32 i32Src = p_u32Src;	
	bool bolHghSrc = false;	
	for(int i = 0; i< p_u32Pos;i++)
	{
		if((TestBit(i32Src,31))&&(TestBit(p_u32SHFCR, SHF_Ctl_Signed))){
			bolHghSrc = true;}						
		i32Src = i32Src >>1;
		
		if(bolHghSrc){		
			SetBit(i32Src,31);
			bolHghSrc = false;
		}
	}	
	
	DSPU32 u32Src = p_u32Src >> p_u32Pos;
	bool bolSignedOverflow = ((unsigned int)(i32Src >> 15) != 0x0)
			&& ((unsigned int)(i32Src >> 15) != 0xffffffff);
	bool bolUnsignedOverflow = (u32Src >> 16) != 0x0;	
	

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);
	if (bolSigned) {
		if (bolSignedOverflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolSatu) {
				if (bolSrcSign) {
					u16Dest = 0x8000;
				} else {
					u16Dest = 0x7fff;
				}
			}
		}
	} else {
		if (bolUnsignedOverflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolSatu) {
				u16Dest = 0xffff;
			}
		}
	}
	
	return u16Dest;
}

/******************************************************************
 ��������		BitClr

 ����:			��32λ�������е�ĳһλ���㡣

 ����:			p_u32Src -- Դ��������
 p_u32Pos -- Ҫ������λ��,��5λ��Ч��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 BitClr(DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	ClearBit(p_u32Src, p_u32Pos);

	return p_u32Src;

}

/******************************************************************
 ��������		BitClrAll

 ����:			��32λ�������е�����λ���㡣

 ����:			p_u32Src -- Դ��������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 BitClrAll(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	return 0;
}

/******************************************************************
 ��������		BitSet

 ����:			��32λ�������е�ĳһλ��1��

 ����:			p_u32Src -- Դ��������
 p_u32Pos -- Ҫ��1��λ��,��5λ��Ч��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 BitSet(DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	SetBit(p_u32Src, p_u32Pos);
	return p_u32Src;

}

/******************************************************************
 ��������		BitSetAll

 ����:			��32λ�������е�����λ��1��

 ����:			p_u32Src -- Դ��������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 BitSetAll(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	return 0xffffffff;
}

/******************************************************************
 ��������		BitInv

 ����:			��32λ�������е�ĳһλȡ����

 ����:			p_u32Src -- Դ��������
 p_u32Pos -- Ҫȡ����λ�á�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 BitInv(DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	p_u32Src = p_u32Src ^ ( 1 << p_u32Pos);
	return p_u32Src;
}

/******************************************************************
 ��������		BitInvAll

 ����:			��32λ�������е�����λȡ����

 ����:			p_u32Src -- Դ��������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 BitInvAll(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {	

	p_u32Src = ~p_u32Src;

	return p_u32Src;
}

/******************************************************************
 ��������		Mask

 ����:		   ������Σ���32λ������е�"1"��λ�ã�
 ȷ��Rs�Ĵ�����Ӧλ�Ƿ���Rmλ��ȡ����
 ����32λ������еĵ�xλΪ1��
 ��ô����Դ�Ĵ���Rm�ĵ�xλ�ȡ��Ŀ�ļĴ���Rs�ĵ�xλ��
 ���˱���ε���Щλ֮�⣬
 Ŀ�ļĴ���Rs����λӦ�ò���Ӱ�죬
 ��Ӧ�ð�Ŀ�ļĴ���RsҲȡ����λ����

 ����:			p_u32Src -- Դ��������
 p_u32Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Mask(DSPU32 p_u32Src, DSPU32 p_u32Rs, DSPU32 p_u32Mask,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	for (int i = 0; i < 32; i ++) {
		if (TestBit(p_u32Mask, i)) {
			if (TestBit(p_u32Src ,i)) {
				SetBit(p_u32Rs, i);
			} else {
				ClearBit(p_u32Rs, i);
			}
		}
	}
	return p_u32Rs;
}

/******************************************************************
 ��������		MaskClr

 ����:			����������㡣��ָ���ĺ����ǣ�����p_u32Mask�еĵ�xλΪ1��
 ��ô�ͽ�p_u32Src�ĵ�xλ���㣬�����������ء�

 ����:			p_u32Src -- Դ��������
 p_u32Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 MaskClr(DSPU32 p_u32Src, DSPU32 p_u32Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	p_u32Src = p_u32Src & ~p_u32Mask;

	return p_u32Src;
}

/******************************************************************
 ��������		MaskSet

 ����:		    ���������1����ָ���ĺ����ǣ�����p_u32Mask�еĵ�xλΪ1��
 ��ô�ͽ�p_u32Src�ĵ�xλ��1�������������ء�

 ����:			p_u32Src -- Դ��������
 p_u32Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 MaskSet(DSPU32 p_u32Src, DSPU32 p_u32Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	//��0����   
	p_u32Src = p_u32Src | p_u32Mask;

	return p_u32Src;
}

/******************************************************************
 ��������		MaskInv

 ����:			�������ȡ������ָ���ĺ����ǣ�����p_u32Mask�еĵ�xλΪ1��
 ��ô�ͽ�p_u32Src�ĵ�xλȡ���������������ء�

 ����:			p_u32Src -- Դ��������
 p_u32Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 MaskInv(DSPU32 p_u32Src, DSPU32 p_u32Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	p_u32Src = p_u32Src ^ p_u32Mask;

	return p_u32Src;
}

/******************************************************************
 ��������		LXOR

 ����:			p_u32Src����������λ���ݽ����������㣬
 ������������������λ��p_u32Maskȷ����

 ����:			p_u32Src -- Դ��������
 p_u32Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 ��ϸ˵����ָ��ֲᡣ

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 LXOR(DSPU32 p_u32Src, DSPU32 p_u32Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	DSPU32 u32XOResult = 0;
	for (int i = 0; i < 32; i++) {
		if (TestBit(p_u32Mask, i) && TestBit(p_u32Src, i)) {
			u32XOResult = u32XOResult ^ 1;
		}
	}

	DSPU32 u32Result = (p_u32Src << 1) | u32XOResult;

	return u32Result;
}

/******************************************************************
 ��������		RXOR

 ����:			p_u32Src����������λ���ݽ����������㣬
 ������������������λ��p_u32Maskȷ����

 ����:			p_u32Src -- Դ��������
 p_u32Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 ��ϸ˵����ָ��ֲᡣ

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 RXOR(DSPU32 p_u32Src, DSPU32 p_u32Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	DSPU32 u32XOResult = 0;
	for (int i = 0; i < 32; i++) {
		if (TestBit(p_u32Mask, i) && TestBit(p_u32Src, i)) {
			u32XOResult = u32XOResult ^ 1;
		}
	}
	DSPU32 u32Result = (p_u32Src >> 1) | (u32XOResult << 31);

	return u32Result;
}


/******************************************************************
 ��������		SetExp

 ����:			������p_u32FloNum��ָ�������з��Ź̶�ֵp_u32Exp����ֵΪ-127~127 ��

 ����:			p_u32FloNum -- 32λ�������ݡ�
 p_u32Exp -- �����õ�ָ�����з���������Χ-127~127��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SetExp(DSPU32 p_u32FloNum, DSPU32 p_u32Exp, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	Cfloat32 cf32Src(p_u32FloNum);

	DSPU8 u8Exp = (DSPU8)(p_u32Exp & 0x000000ff);
	DSPI8 i8Exp = (DSPI8)u8Exp;
	
	DSPI8 unbisisNum = 0x7f;
	DSPI32 u32unbisisExp = i8Exp + unbisisNum;

	cf32Src.SetExp(u32unbisisExp);

	return cf32Src.GetU32();
}



/******************************************************************
 ��������		ExtractExp

 ����:			��ȡ32λ������p_u32Src��ָ����

 ����:			p_u32Src -- 32λ��������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		��������ָ����

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 ExtractExp(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	Cfloat32 cf32Src(p_u32Src);

	DSPI32 i32result = (DSPI32)cf32Src.GetExp();
	i32result -= 127;

	return i32result;
}

/******************************************************************
 ��������		ExtractMant

 ����:			��ȡ32λ������p_u32Src��β����

 ����:			p_u32Src -- 32λ��������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		��������λ����

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 ExtractMant(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	Cfloat32 cf32Src(p_u32Src);

	DSPU32 u32Frac = cf32Src.GetFrac();
	
	u32Frac |= (1 << 23);
	
	if (cf32Src.GetNega()) {
		u32Frac = ~u32Frac + 1;
		u32Frac |= 0xff000000;
	}

	return u32Frac;
}
/******************************************************************
 ��������		Fext

 ����:			��ԼĴ��������ݷ���(Fetch and Extand)

 ����:			��p_u32Src�Ĵ���ȡ��һ�����ݷ���p_u32Rs�Ĵ�����
 ��Rm��ȡ�������ݳ���Ϊq��������ʼλ��Ϊp�����ݷ���Rs����ʼλ��Ϊf
 fλ��p_u32Pos��14-10��qλ��p_u32Pos��9-5��pλ��p_u32Pos��4-0λ 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		���ݷ��ú���ֵ��
 �Ƿ�����ά��ԭֵ��

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Fext(DSPU32 p_u32Src, DSPU32 p_u32Rs, DSPU32 p_u32Pos,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	DSPU32 u32Rm = p_u32Src;
	DSPU32 u32Rs = p_u32Rs;
	DSPU32 u32Imm = p_u32Pos;

	DSPU8 u5p = (DSPU8)(u32Imm & 0x1f);
	DSPU8 u5q = (DSPU8)((u32Imm >> 5) & 0x1f);
	//������ȡ����Ϊ0,������Ϊ1 
	if (u5q == 0) {
		u5q =1;
	}
	
	if (u5q > 32 - u5p) {
		u5q = 32 - u5p;
	}
	DSPU8 u5f = (DSPU8)((u32Imm >> 10) & 0x1f);

	unsigned frontRmMask;
	
	if (u5p + u5q == 32) {
		frontRmMask = 0;
	} else {
		frontRmMask = 0xffffffff << (u5p + u5q);
	}
	unsigned endRmMask;
	
	if (u5p == 0) {
		endRmMask = 0;
	} else {
		endRmMask = 0xffffffff >> (32 - u5p);
	}
	//DSPU32 middleRmMask = 0xffffffff & ~frontRmMask & ~endRmMask;
	DSPU32 middleRm = u32Rm & ~frontRmMask & ~endRmMask;

	
	if (u5q > 32 - u5f) {
		u5q = 32 - u5f;
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
	}

	unsigned frontRsMask;
	if (u5f + u5q == 32) {
		frontRsMask = 0;
	} else {
		frontRsMask = 0xffffffff << (u5f + u5q);
	}
	unsigned endRsMask;
	if (u5f == 0) {
		endRsMask = 0;
	} else {
		endRsMask = 0xffffffff >> (32 - u5f);
	}
	DSPU32 middleRsMask = 0xffffffff & ~frontRsMask & ~endRsMask;
	u32Rs = u32Rs & ~middleRsMask;

	if (u5f >= u5p) {
		middleRm = middleRm << (u5f - u5p);
	} else {
		middleRm = middleRm >> (u5p - u5f);
	}
	u32Rs = u32Rs | middleRm;

	return u32Rs;
}

/******************************************************************
 ��������		Fextz

 ����:			��ԼĴ��������ݷ���(Fetch and Extand with Zero)

 ����:			��p_u32Src�Ĵ���ȡ��һ�����ݷ���p_u32Rs�Ĵ�����
 ��Rm��ȡ�������ݳ���Ϊq��������ʼλ��Ϊp�����ݷ���Rs����ʼλ��Ϊf
 fλ��p_u32Pos��14-10��qλ��p_u32Pos��9-5��pλ��p_u32Pos��4-0λ 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		���ݷ��ú���ֵ��
 �Ƿ�����������ֵ��

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Fextz(DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) // baohua delete a parameter p_u32Rs  2008.08.04
{
	

	DSPU32 u32Rm = p_u32Src;
	DSPU32 u32Rs = 0;
	DSPU32 u32Imm = p_u32Pos;

	DSPU8 u5p = (DSPU8)(u32Imm & 0x1f);
	DSPU8 u5q = (DSPU8)((u32Imm >> 5) & 0x1f);
	if (u5q == 0) {
		u5q = 1;
	}
	if (u5q > 32 - u5p) {
		u5q = 32 - u5p;
	}
	DSPU8 u5f = (DSPU8)((u32Imm >> 10) & 0x1f);

	unsigned frontRmMask;
	if (u5p + u5q == 32) {
		frontRmMask = 0;
	} else {
		frontRmMask = 0xffffffff << (u5p + u5q);
	}
	unsigned endRmMask;
	if (u5p == 0) {
		endRmMask = 0;
	} else {
		endRmMask = 0xffffffff >> (32 - u5p);
	}
	//DSPU32 middleRmMask = 0xffffffff & ~frontRmMask & ~endRmMask;
	DSPU32 middleRm = u32Rm & ~frontRmMask & ~endRmMask;

	if (u5q > 32 - u5f) {
		u5q = 32 - u5f;
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
		//add by zhaoxiang 2008.08.04
	}

	unsigned frontRsMask;
	if (u5f + u5q == 32) {
		frontRsMask = 0;
	} else {
		frontRsMask = 0xffffffff << (u5f + u5q);
	}
	unsigned endRsMask;
	if (u5f == 0) {
		endRsMask = 0;
	} else {
		endRsMask = 0xffffffff >> (32 - u5f);
	}
	//DSPU32 middleRsMask = 0xffffffff & ~frontRsMask & ~endRsMask;
	//u32Rs = u32Rs & ~middleRsMask;         baohua delete it   2008.08.04

	if (u5f >= u5p) {
		middleRm = middleRm << (u5f - u5p);
	} else {
		middleRm = middleRm >> (u5p - u5f);
	}
	//u32Rs = 0;                        baohua delete it  2008.08.04
	u32Rs = u32Rs | middleRm;

	return u32Rs;
}

/******************************************************************
 ��������		Fexts

 ����:			��ԼĴ��������ݷ���(Fetch and Extand with Signed bit)

 ����:			��p_u32Src�Ĵ���ȡ��һ�����ݷ���p_u32Rs�Ĵ�����
 ��Rm��ȡ�������ݳ���Ϊq��������ʼλ��Ϊp�����ݷ���Rs����ʼλ��Ϊf
 fλ��p_u32Pos��14-10��qλ��p_u32Pos��9-5��pλ��p_u32Pos��4-0λ 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		���ݷ��ú���ֵ��
 �Ƿ��������ս�ȡ������λ���з���λ�չ��

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Fexts(DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	DSPU32 u32Rm = p_u32Src;
	DSPU32 u32Rs = 0;
	DSPU32 u32Imm = p_u32Pos;

	DSPU8 u5p = (DSPU8)(u32Imm & 0x1f);
	DSPU8 u5q = (DSPU8)((u32Imm >> 5) & 0x1f);
	if (u5q == 0) {
		u5q =1;
	}
	if (u5q > 32 - u5p) {
		u5q = 32 - u5p;
	}
	DSPU8 u5f = (DSPU8)((u32Imm >> 10) & 0x1f);

	unsigned frontRmMask;
	if (u5p + u5q == 32) {
		frontRmMask = 0;
	} else {
		frontRmMask = 0xffffffff << (u5p + u5q);
	}
	unsigned endRmMask;
	if (u5p == 0) {
		endRmMask = 0;
	} else {
		endRmMask = 0xffffffff >> (32 - u5p);
	}
	//DSPU32 middleRmMask = 0xffffffff & ~frontRmMask & ~endRmMask;
	DSPU32 middleRm = u32Rm & ~frontRmMask & ~endRmMask;

	if (u5q > 32 - u5f) {
		u5q = 32 - u5f;
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
		//add by zhaoxiang 2008.08.04
	}

	unsigned frontRsMask;
	if (u5f + u5q == 32) {
		frontRsMask = 0;
	} else {
		frontRsMask = 0xffffffff << (u5f + u5q);
	}
	unsigned endRsMask;
	if (u5f == 0) {
		endRsMask = 0;
	} else {
		endRsMask = 0xffffffff >> (32 - u5f);
	}
	//DSPU32 middleRsMask = 0xffffffff & ~frontRsMask & ~endRsMask;
	bool bolMiddleRmSign = ((middleRm << (32 - u5p - u5q)) & 0x80000000) != 0;

	if (u5f >= u5p) {
		middleRm = middleRm << (u5f - u5p);
	} else {
		middleRm = middleRm >> (u5p - u5f);
	}
	//u32Rs = 0;          baohua delete it 2008.08.04
	u32Rs = u32Rs | middleRm;
	if (bolMiddleRmSign) {
		u32Rs |= frontRsMask;
	}

	return u32Rs;
}
/******************************************************************
 ��������		LXOR64

 ����:			p_u64Src����������λ���ݽ����������㣬
 ������������������λ��p_u64Maskȷ����

 ����:			p_u64Src -- Դ��������
 p_u64Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 ��ϸ˵����ָ��ֲᡣ

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU64 LXOR64(DSPU64 p_u64Src, DSPU64 p_u64Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	bool bolXOResult = 0;
	DSPU32 upperSrc = (DSPU32)(p_u64Src >> 32);
	DSPU32 lowerSrc = (DSPU32)p_u64Src;
	DSPU32 upperMask = (DSPU32)(p_u64Mask >> 32);
	DSPU32 lowerMask = (DSPU32)p_u64Mask;

	for (int i = 0; i < 32; i++) {
		if (TestBit(upperSrc, i) && TestBit(upperMask, i)) {
			bolXOResult = !bolXOResult;
		}
	}
	for (int i = 0; i < 32; i++) {
		if (TestBit(lowerSrc, i) && TestBit(lowerMask, i)) {
			bolXOResult = !bolXOResult;
		}
	}

	DSPU64 u64Result = (p_u64Src << 1) |(DSPU32) bolXOResult;

	return u64Result;
}
/******************************************************************
 ��������		RXOR64

 ����:			p_u64Src����������λ���ݽ����������㣬
 ������������������λ��p_u64Maskȷ����

 ����:			p_u64Src -- Դ��������
 p_u64Mask -- λ�����롣
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 ��ϸ˵����ָ��ֲᡣ

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU64 RXOR64(DSPU64 p_u64Src, DSPU64 p_u64Mask, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	bool bolXOResult = 0;
	DSPU32 upperSrc = (DSPU32)(p_u64Src >> 32);
	DSPU32 lowerSrc = (DSPU32)p_u64Src;
	DSPU32 upperMask = (DSPU32)(p_u64Mask >> 32);
	DSPU32 lowerMask = (DSPU32)p_u64Mask;

	for (int i = 0; i < 32; i++) {
		if (TestBit(upperSrc, i) && TestBit(upperMask, i)) {
			bolXOResult = !bolXOResult;
		}
	}
	for (int i = 0; i < 32; i++) {
		if (TestBit(lowerSrc, i) && TestBit(lowerMask, i)) {
			bolXOResult = !bolXOResult;
		}
	}

	DSPU64 u64Result = (p_u64Src >> 1) | ((DSPU64)bolXOResult << 63);

	return u64Result;
}

//------------------------------------------------------------------------------
DSPU32 Append(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR, DSPU32 p_u32Mode) {
	

	DSPU32 AppendRes = 0;

	switch (p_u32Mode) {
	
	case 0:
		AppendRes = (p_u32Src1&0xFFFF0000)|(p_u32Src2>>16);
		break;
	case 1:
		AppendRes = ((p_u32Src1<<16)&0xFFFF0000)|(p_u32Src2&0x0000FFFF);
		break;
	
	case 2:
		AppendRes = (p_u32Src1&0xFFFF0000)|(p_u32Src2&0x0000FFFF);
		break;
	
	case 3:
		AppendRes = ((p_u32Src1<<16)&0xFFFF0000)|((p_u32Src2>>16)&0x0000FFFF);
		break;

	}

	return AppendRes;
}

/*------------------------BWDSP1042------------------------*/

/*found*****************************************************************
 ��������		InsertToSACC

 ��Ӧָ����ʽ:  SACCs=Rm Insert Rn
 SACCs=Rm Insert_1 Rn 
 SACCs=Rm Insert_0 Rn
 SACCs=Rm delete Rn

 ����:			��Rm����Rnָ����λ���ϲ�����ɾ�����ݣ�������������SACC�Ĵ�����

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32SrcM -- Դ������Rm��
 p_u32SrcN -- Դ������Rn��
 p_u32Mode -- ģʽѡ����
 0 -- ����Rn�ڲ�ȷ���ķ�ʽ������Ӧ���ݣ�Rn[4..0]Ϊ��ʼλ�ã�Rn[8:5]+1Ϊ���ݳ��ȣ�Rn[31:16]Ϊ���������ݣ�
 �������ݳ���С��16�������ݴӵ�16λ��ʼ����λ��ȡ��Ӧ�������ݡ�
 1 -- ��Rm��ӦRn�ڲ�Ϊ��1����λ�����������롮1������������32λ����Rs����λ��������32λ������������Rs+1��
 2 -- ��Rm��ӦRn�ڲ�Ϊ��1����λ�����������롮0������������32λ����Rs����λ��������32λ������������Rs+1��
 3 -- ��Rn�ڲ�Ϊ��1����λ����ɾ��Rm��Ӧλ���ϵ����ݲ���Ӧ���ƣ���λ���� ��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void InsertToSACC(DSP_BIT64 &p_SACC, DSPU32 p_u32SrcM, DSPU32 p_u32SrcN,
		DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	

	int iTemp1=0, iTemp2=0;
	int iBeg = 0;
	int iLen = 0;
	DSPU32 iData =0;
	DSPU32 iInData =0;

	bitset<64> bitvec64;
	bitset<32> bitvec32Low;
	bitset<32> bitvec32High;

	bitvec64.reset();
	bitvec32Low.reset();
	bitvec32High.reset();
	switch (p_u32Mode) {

	case 0:

		iBeg = p_u32SrcN & 0x1f;
		iLen = ((p_u32SrcN >> 5 ) & 0xf) +1;
		
		for (int i = 0; i < iBeg +1; i++) {
			if (TestBit(p_u32SrcM, i))
				bitvec64.set(i);
		}
		
		iData = p_u32SrcN >> 16;
		iInData = iData << (32-iLen); 
		iInData = iInData >>(32 - iLen);
	
		iTemp1 = iBeg + 1;
		iTemp2 = iTemp1 + iLen;
		for (int i = iTemp1, iAdd = 0; i < iTemp2; i++) {
			if (TestBit(iInData, iAdd)) {
				bitvec64.set(i);
			}
			iAdd++;
		}
		
		iTemp1 = iBeg + 1 + iLen;
		iTemp2 = iTemp1 + 32 - iBeg -1;
		for (int i = iTemp1, iAdd = iBeg + 1; i < iTemp2; i++) {
			if (TestBit(p_u32SrcM, iAdd)) {
				bitvec64.set(i);
			}
			iAdd++;
		}
		
		for (int i = 0; i < 64; i++) {
			if (i < 32)
				bitvec32Low[i] = bitvec64[i];

			else
				bitvec32High[i-32] = bitvec64[i];

		}

		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();
		break;
		
	case 1:		
		for (int i = 0, insert = 0; i < 32; i++) {

			if (TestBit(p_u32SrcM, i)) {
				bitvec64.set(insert);
			}

			if (TestBit(p_u32SrcN, i)) {
				insert=insert+1;
				bitvec64.set(insert);

			}
			insert++;
		}
		
		for (int i = 0; i < 64; i++) {
			if (i < 32)
				bitvec32Low[i] = bitvec64[i];

			else
				bitvec32High[i-32] = bitvec64[i];

		}
		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();

		break;

		
	case 2:		
		for (int i = 0, insert = 0; i < 32; i++) {

			if (TestBit(p_u32SrcM, i)) {
				bitvec64.set(insert);
			}

			if (TestBit(p_u32SrcN, i)) {
				
				insert++;
			}
			insert ++;
		}
		
		for (int i = 0; i < 64; i++) {
			if (i < 32)
				bitvec32Low[i] = bitvec64[i];

			else
				bitvec32High[i-32] = bitvec64[i];

		}

		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();

		break;

		
	case 3:
		for (int i = 0, insert = 0; i < 32; i++) {

			
			if (!TestBit(p_u32SrcN, i)) {

				if (TestBit(p_u32SrcM, i)) {
					bitvec32Low.set(insert);
				}

				insert+=1;
			}

		}
		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = 0;
		bitvec32Low.reset();

		break;

	}

}

/*found*****************************************************************
 ��������		SACCInsert

 ��Ӧָ����ʽ:  SACCs += Insert Rm(Rn)
 SACCs += Insert_1 Rm+1:m
 SACCs += Insert_0 Rm+1:m
 SACCs += delete Rm+1:m

 ����:			��SACC����Rn��Rm+1:mָ����λ���ϲ�����ɾ�����ݡ�

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Src1 -- Դ������Rm����32λ
 p_u32Src2 -- Դ������Rn����32λ
 p_u32Mode -- ģʽѡ����
 0 -- ����Rn�ڲ�ȷ��λ����SACC������Ӧ����Rm��Rn[4:0]Ϊ��ʼλ�ã�Rn[9:5]Ϊ���ݳ��ȡ�
 1 -- ��SACCs��ӦRm+1:mΪ��1����λ���ϲ��롮1�������ơ�
 2 -- ��SACCs��ӦRm+1:mΪ��1����λ���ϲ��롮0�������ơ�
 3 -- ��SACCs��ӦRm+1:mΪ��1����λ����ɾ��SACC���ݲ����ƣ���λ���㡣 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����
 

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SACCInsert(DSP_BIT64 &p_SACC, DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	int iBeg = 0;
	int iLen = 0;


	bitset<64> bitvec64;
	bitset<64> bitSrc64;
	bitset<128> bitvec128;
	bitset<32> bitvec32Low;
	bitset<32> bitvec32High;

	bitvec64.reset();
	bitSrc64.reset();
	bitvec128.reset();
	bitvec32Low.reset();
	bitvec32High.reset();

	
	for (int i = 0; i<64; i++) {
		if (i<32) {
			if (TestBit(p_SACC.u32Low, i)) {
				bitvec64.set(i);
			}
		} else {
			if (TestBit(p_SACC.u32High, i-32)) {
				bitvec64.set(i);
			}
		}
	}
	
	for (int i = 0; i<64; i++) {
		if (i<32) {
			if (TestBit(p_u32Src2, i)) {
				bitSrc64.set(i);
			}
		} else {
			if (TestBit(p_u32Src1, i-32)) {
				bitSrc64.set(i);
			}
		}
	}
	
	switch (p_u32Mode) {	
	case 4:
		
		iBeg = (p_u32Src2 & 0x1f) +1;
		iLen = ((p_u32Src2 >> 5 ) & 0x1f) +1;
		
		for (int i = 0; i < iBeg; i++) {
			bitvec128[i] = bitvec64[i];
		}
	
		for (int i = iBeg, iAdd = 0; i < iBeg+iLen; i++) {
			if (TestBit(p_u32Src1, iAdd)) {
				bitvec128.set(i);
			}
			iAdd++;
		}

		for (int i = iBeg+iLen, iAdd = iBeg; iAdd<64; i++) {
			bitvec128[i] = bitvec64[iAdd];
			iAdd++;
		}

		for (int i = 0; i<64; i++) {
			if (i<32) {
				bitvec32Low[i]= bitvec128[i];
			} else {
				bitvec32High[i-32]= bitvec128[i];
			}
		}

		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();
		bitvec128.reset();

		break;
		
		//bitSrc64
	case 5:		
		for (int i = 0, iAdd = 0; i < 64; i++) {
			bitvec128[iAdd] = bitvec64[i];	

			
			if (bitSrc64[i]==0) {
				
				bitvec128[iAdd] = bitvec64[i];
			}		
			if (bitSrc64[i]==1) {
				iAdd+=1;
				bitvec128[iAdd] = 1;
				
			}
			iAdd++;
		}
		//part four��ȡ��64λ
		for (int i = 0; i<64; i++) {
			if (i<32) {
				bitvec32Low[i]= bitvec128[i];
			} else {
				bitvec32High[i-32]= bitvec128[i];
			}
		}
		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();
		bitvec128.reset();
		break;

	case 6:
		for (int i = 0, iAdd = 0; i < 64; i++) {
			bitvec128[iAdd] = bitvec64[i];	
			
			if (!bitSrc64.test(i)) {
				bitvec128[iAdd] = bitvec64[i];
			}
		
			if (bitSrc64.test(i)) {
				iAdd+=1;
				bitvec128[iAdd] = 0;
			}
			iAdd++;
		}
		
		for (int i = 0; i<64; i++) {
			if (i<32) {
				bitvec32Low[i]= bitvec128[i];
			} else {
				bitvec32High[i-32]= bitvec128[i];
			}
		}
		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();
		bitvec128.reset();

		break;
		
	case 7:
		for (int i = 0, iAdd = 0; i < 64; i++) {

			if (!bitSrc64.test(i)) {				
				bitvec128[iAdd] = bitvec64[i];
				iAdd++;
			}
		}
		
		for (int i = 0; i<64; i++) {
			if (i<32) {
				bitvec32Low[i]= bitvec128[i];
			} else {
				bitvec32High[i-32]= bitvec128[i];
			}
		}
		p_SACC.u32Low = bitvec32Low.to_ulong();
		p_SACC.u32High = bitvec32High.to_ulong();

		bitvec64.reset();
		bitvec32Low.reset();
		bitvec32High.reset();
		bitvec128.reset();
		break;
	}
}

/*found*****************************************************************
 ��������		Vmin2L

 ��Ӧָ����ʽ:  ORs=Vmin2(ORm+1:m,LSACCk)(U)

 ����:		ѡ�� Rm[7:0]+ACCn[1:0]��Rm[15:8]+ACCn[3:2]�е���Сֵ������Rs[7:0];
 ѡ�� Rm[23:16]+ACCn[5:4]��Rm[31:24]+ACCn[7:6]��Сֵ������Rs[15:8];
 ѡ�� Rm+1[7:0]+ACCn[9:8]��Rm+1[15:8]+ACCn[11:10]�е���Сֵ������Rs[23:16];
 ѡ��Rm+1[23:16]+ACCn[13:12]��Rm+1[31:24]+ACCn[15:14]��Сֵ������Rs[31:24]��
 
 ָ������Ӱ���Ƚϴ�С��־λ��
 ��(Rm[7:0]+ACCn[1:0])<(Rm[15:8]+ACCn[3:2])ʱ����0λ��־λ����Ϊ1����������Ϊ0��                  // ��־λָ�ĸ��Ĵ�����
 ��(Rm[23:16]+ACCn[5:4]) < (Rm[31:24]+ACCn[7:6])ʱ����1λ��־λ����Ϊ1��������1λ����Ϊ0��
 ��(Rm+1[7:0]+ACCn[1:0])<(Rm+1[15:8]+ACCn[3:2])ʱ����2λ��־λ����Ϊ1����������Ϊ0��
 ��(Rm+1[23:16]+ACCn[5:4]) < (Rm+1[31:24]+ACCn[7:6])ʱ����3λ��־λ����Ϊ1��������3λ����Ϊ0��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_Src -- 64λ���룬p_Src.Low32��ӦRm��p_Src.High32��ӦRm+1��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/

extern DSPU32 Vmin2L(const DSP_BIT64 p_SACC, DSP_BIT64 p_Src, DSPU32 *p_pSCF,
		DSPU32 p_u32SHFCR) {

	DSPU32 iAddTemp_1, iAddTemp_2;
	DSPU32 iRes_1 = 0, iRes_2 = 0, iRes_3 = 0, iRes_4 = 0;
	
	unsigned int OpBits = 8;
	DSPU32 iAdd_1 = 0,iAdd_2 = 0;
	bool bolOvfFlag ;

	//case1: 
	
	iAdd_1 =  p_Src.u32Low & 0xff;
	iAdd_2 = p_SACC.u32Low & 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_1, OpBits);
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 =  (p_Src.u32Low >> 8 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 2) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_2, OpBits);
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 0);
		iRes_1 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 0);
		iRes_1 = iAddTemp_2;
	}
	iRes_1 &= 0xff;//Rs[7:0]

	//case2: 
	
	iAdd_1 = (p_Src.u32Low >> 16 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 4) & 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	 bolOvfFlag = TestBit(iAddTemp_1, OpBits );
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 = (p_Src.u32Low >> 24 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 6) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }


	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 1);
		iRes_2 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 1);
		iRes_2 = iAddTemp_2;
	}
	iRes_2 &= 0xff;
	iRes_2 <<= 8; //Rs[15:8]

	//case3:
	
	iAdd_1 = p_Src.u32High & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 8)& 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	 bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 = (p_Src.u32High >> 8 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 10) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	
	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	 

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 2);
		iRes_3 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 2);
		iRes_3 = iAddTemp_2;
	}
	iRes_3 &= 0xff;
	iRes_3 <<= 16;//Rs[7:0]

	//case4: 
		
	iAdd_1 = (p_Src.u32High >> 16 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 12) & 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 = (p_Src.u32High >> 24 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 14) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	 
	 

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 3);
		iRes_4 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 3);
		iRes_4 = iAddTemp_2;
	}
	iRes_4 &= 0xff;
	iRes_4 <<= 24; //Rs[15:8]


	return (iRes_1 | iRes_2 | iRes_3 | iRes_4);
}

/*found*****************************************************************
 ��������		Vmin2H

 ��Ӧָ����ʽ:  ORs=Vmin2(ORm+1:m,HSACCk)(U)

 ����:		ѡ�� Rm[7:0]+ACCn[17:16]��Rm[15:8]+ACCn[19:18]�е���Сֵ������Rs[7:0];
 ѡ�� Rm[23:16]+ACCn[21:20]��Rm[31:24]+ACCn[23:22]��Сֵ������Rs[15:8];
 ѡ�� Rm+1[7:0]+ACCn[25:24]��Rm+1[15:8]+ACCn[27:26]�е���Сֵ������Rs[23:16];
 ѡ�� Rm+1[23:16]+ACCn[29:28]��Rm+1[31:24]+ACCn[31:30]��Сֵ������Rs[31:24]��
 
 ָ������Ӱ���Ƚϴ�С��־λ��
 ��(Rm[7:0]+ACCn[1:0])<(Rm[15:8]+ACCn[3:2])ʱ����0λ��־λ����Ϊ1����������Ϊ0��                  // ��־λָ�ĸ��Ĵ�����
 ��(Rm[23:16]+ACCn[5:4]) < (Rm[31:24]+ACCn[7:6])ʱ����1λ��־λ����Ϊ1��������1λ����Ϊ0��
 ��(Rm+1[7:0]+ACCn[1:0])<(Rm+1[15:8]+ACCn[3:2])ʱ����2λ��־λ����Ϊ1����������Ϊ0��
 ��(Rm+1[23:16]+ACCn[5:4]) < (Rm+1[31:24]+ACCn[7:6])ʱ����3λ��־λ����Ϊ1��������3λ����Ϊ0��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_Src -- 64λ���룬p_Src.Low32��ӦRm��p_Src.High32��ӦRm+1��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Vmin2H(const DSP_BIT64 p_SACC, DSP_BIT64 p_Src, DSPU32 *p_pSCF,
		DSPU32 p_u32SHFCR) {

	DSPU32 iAddTemp_1, iAddTemp_2;
	DSPU32 iRes_1 = 0, iRes_2 = 0, iRes_3 = 0, iRes_4 = 0;
	
	unsigned int OpBits = 8;
	DSPU32 iAdd_1 = 0,iAdd_2 = 0;
	

	bool bolOvfFlag ;
	//case1: 

	iAdd_1 =  p_Src.u32Low & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 16) & 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;	

	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 =  (p_Src.u32Low >> 8 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 18) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_2, OpBits );  
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 0);
		iRes_1 = iAddTemp_1;
	}
	

	else {
		ClearFlag(*p_pSCF, 0);
		iRes_1 = iAddTemp_2;
	}
	iRes_1 &= 0xff;//Rs[7:0]
	

	//case2: 
	iAdd_1 =  (p_Src.u32Low >> 16 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 20) & 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	 bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 =  (p_Src.u32Low >> 24 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 22) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	
	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 1);
		iRes_2 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 1);
		iRes_2 = iAddTemp_2;
	}
	iRes_2 &= 0xff;
	iRes_2 <<= 8; //Rs[15:8]

	//case3: 

	iAdd_1 = p_Src.u32High & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 24)& 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 = (p_Src.u32High >> 8 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 26) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 2);
		iRes_3 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 2);
		iRes_3 = iAddTemp_2;
	}
	iRes_3 &= 0xff;
	iRes_3 <<= 16;//Rs[23:16]

	//case4: 

	iAdd_1 =(p_Src.u32High >> 16 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 28) & 0x3;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	 
	iAdd_1 = (p_Src.u32High >> 24 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 30) & 0x3;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	

	 bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }
	 

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 3);
		iRes_4 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 3);
		iRes_4 = iAddTemp_2;
	}
	iRes_4 &= 0xff;
	iRes_4 <<= 24; //Rs[15:8]


	return (iRes_1 | iRes_2 | iRes_3 | iRes_4);
}

/*found*****************************************************************
 ��������		Vmin3

 ��Ӧָ����ʽ:  ORs=Vmin3(ORm+1:m,SACCk)(U)

 ����:		ѡ�� Rm[7:0]+ACCn[2:0]��Rm[15:8]+ACCn[5:3]�е���Сֵ������Rs[7:0];
 ѡ�� Rm[23:16]+ACCn[8:6]��Rm[31:24]+ACCn[11:9]��Сֵ������Rs[15:8];
 ѡ�� Rm+1[7:0]+ACCn[14:12]��Rm[15:8]+ACCn[17:15]�е���Сֵ������Rs[23:16];
 ѡ�� Rm[23:16]+ACCn[20:18]��Rm[31:24]+ACCn[23:21]��Сֵ������Rs[31:24]��
 
 ָ������Ӱ���Ƚϴ�С��־λ��
 ��(Rm[7:0]+ACCn[2:0])<(Rm[15:8]+ACCn[5:3])ʱ����0λ��־λ����Ϊ1����������Ϊ0��
 ��(Rm[23:16]+ACCn[8:6]) < (Rm[31:24]+ACCn[11:9]) ʱ����2λ��־λ����Ϊ1����������Ϊ0��
 ��(Rm+1[7:0]+ACCn[14:12])<(Rm+1[15:8]+ACCn[17:15])ʱ����2λ��־λ����Ϊ1����������Ϊ0��
 ��(Rm+1[23:16]+ACCn[20:18]) < (Rm+1[31:24]+ACCn[23:21]) ʱ����3λ��־λ����Ϊ1����������Ϊ0��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_Src -- 64λ���룬p_Src.Low32��ӦRm��p_Src.High32��ӦRm+1��
 p_pSCF -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Vmin3(const DSP_BIT64 p_SACC, DSP_BIT64 p_Src, DSPU32 *p_pSCF,
		DSPU32 p_u32SHFCR) {

	DSPU32 iAddTemp_1, iAddTemp_2;
	DSPU32 iRes_1 = 0, iRes_2 = 0, iRes_3 = 0, iRes_4 = 0;
	
	unsigned int OpBits = 8;
	DSPU32 iAdd_1 = 0,iAdd_2 = 0;
	

	bool bolOvfFlag ;


	//case1: 

	iAdd_1 =  p_Src.u32Low & 0xff;
	iAdd_2 =  p_SACC.u32Low & 0x7;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	

	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	iAdd_1 =  (p_Src.u32Low >> 8 ) & 0xff;
	iAdd_2 =  (p_SACC.u32Low >> 3) & 0x7;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }
	 

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 0);
		iRes_1 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 0);
		iRes_1 = iAddTemp_2;
	}
	iRes_1 &= 0xff;//Rs[7:0]

	//case2: 
	iAdd_1 = (p_Src.u32Low >> 16 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 6) & 0x7;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	
	iAdd_1 =  (p_Src.u32Low >> 24 ) & 0xff;
	iAdd_2 =  (p_SACC.u32Low >> 9) & 0x7;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }
	 

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 1);
		iRes_2 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 1);
		iRes_2 = iAddTemp_2;
	}
	iRes_2 &= 0xff;
	iRes_2 <<= 8; //Rs[15:8]

	//case3: 
	iAdd_1 = p_Src.u32High & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 12)& 0x7;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 	
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }

	iAdd_1 =  (p_Src.u32High >> 8 ) & 0xff;
	iAdd_2 =  (p_SACC.u32Low >> 15) & 0x7;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }
	 

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 2);
		iRes_3 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 2);
		iRes_3 = iAddTemp_2;
	}
	iRes_3 &= 0xff;
	iRes_3 <<= 16;//Rs[7:0]

	//case4: 

	iAdd_1 = (p_Src.u32High >> 16 ) & 0xff;
	iAdd_2 = (p_SACC.u32Low >> 18) & 0x7;
	iAddTemp_1 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_1, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_1 = 0xff;
	 }
	 
	 
	iAdd_1 =  (p_Src.u32High >> 24 ) & 0xff;
	iAdd_2 =  (p_SACC.u32Low >> 21) & 0x7;
	iAddTemp_2 = iAdd_1 + iAdd_2;
	
	bolOvfFlag = TestBit(iAddTemp_2, OpBits ); 
	 
	if(bolOvfFlag){
	 	iAddTemp_2 = 0xff;
	 }

	if (iAddTemp_1 < iAddTemp_2) {
		SetFlag(*p_pSCF, 3);
		iRes_4 = iAddTemp_1;
	}

	else {
		ClearFlag(*p_pSCF, 3);
		iRes_4 = iAddTemp_2;
	}
	iRes_4 &= 0xff;
	iRes_4 <<= 24;

	return (iRes_1 | iRes_2 | iRes_3 | iRes_4);
}

/*found*****************************************************************
 ��������		RShift32_SC
 
 ��Ӧָ����ʽ:  Rs=Rm shift_R SCk

 ����:	  ��Rm�Ĵ�������1λ������λ�ɱ�־�Ĵ�������SCn[0]���䣬�Ƴ������ݷ��õ���־�Ĵ���SCn[0]�ϣ���λ���Ľ������뵽Ŀ�ļĴ���Rs�С�

 ����:		p_u32Rm -- ����λ����������ӦRm��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 RShift32_SC(DSPU32 p_u32Rm, DSPU32 &p_u32SC, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	DSPU32 iTemp = p_u32Rm & 0x1;
	DSPU32 srcTemp;
	srcTemp = p_u32Rm >> 1;

	if (TestBit(p_u32SC, 0))
		{SetBit(srcTemp, 31);}
	else
		{ClearBit(srcTemp, 31);}

	if (iTemp == 1)
		{SetBit(p_u32SC, 0);}

	else
		{ClearBit(p_u32SC, 0);}

	return srcTemp;

}

/*found*****************************************************************
 ��������		LShift32_SC
 
 ��Ӧָ����ʽ:  Rs=Rm shift_L SCk

 ����:	  ��Rm�Ĵ�������1λ������λ�ɱ�־�Ĵ����������䣬�Ƴ������ݷ��õ���־�Ĵ���SCn[0]�ϣ���λ���Ľ������뵽Ŀ�ļĴ���Rs�С�

 ����:		p_u32Rm -- ����λ����������ӦRm��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 LShift32_SC(DSPU32 p_u32Rm, DSPU32 &p_u32SC, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU32 iTemp;
	DSPU32 srcTemp;

	iTemp = (p_u32Rm >> 31)&0x1;	

	srcTemp = p_u32Rm << 1;
	if (TestBit(p_u32SC, 0))
		SetBit(srcTemp, 0);
	else {
		ClearBit(srcTemp, 0);
	}
	if (iTemp == 1) {
		SetBit(p_u32SC, 0);
	}

	else {
		ClearBit(p_u32SC, 0);
	}

	return srcTemp;
}

/*found*****************************************************************
 ��������		RShiftD16_SC
 
 ��Ӧָ����ʽ:  HRs=HRm shift_R SCk  

 ����:	  ��Rm�Ĵ������16λͬʱ����1λ�����16λ������λ�ɱ�־�Ĵ�����2λ�������䣬�Ƴ������ݷ��õ���־�Ĵ�����2λ�ϣ���λ���Ľ������뵽Ŀ�ļĴ���Rs�С�

 ����:		p_u32Rm -- ����λ����������ӦRm��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 RShiftD16_SC(DSPU32 p_u32Rm, DSPU32 &p_u32SC, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	DSPU16 l_RmSrc;
	DSPU16 h_RmSrc;
	DSPU16 l_Bit;
	DSPU16 h_Bit;

	DSPU32 Res;

	l_RmSrc = (DSPU16)(p_u32Rm & 0xffff);
	h_RmSrc = (DSPU16)((p_u32Rm >> 16) & 0xffff);

	l_Bit = l_RmSrc & 0x1; 
	h_Bit = h_RmSrc & 0x1;


	l_RmSrc >>= 1;
	h_RmSrc >>= 1;

	if (TestBit(p_u32SC,0))
		SetBit(l_RmSrc,15);
	else
		ClearBit(l_RmSrc,15);

	if (TestBit(p_u32SC,1))
		SetBit(h_RmSrc,15);
	else
		ClearBit(h_RmSrc,15);


	if (TestBit(l_Bit,0))
		SetBit(p_u32SC,0);
	else
		ClearBit(p_u32SC,0);

	if (TestBit(h_Bit,0))
		SetBit(p_u32SC,1);
	else
		ClearBit(p_u32SC,1);

	Res = h_RmSrc;
	Res <<= 16;
	Res |= l_RmSrc & 0xffff;

	return Res;
}

/*found*****************************************************************
 ��������		LShiftD16_SC
 
 ��Ӧָ����ʽ:  HRs=HRm shift_L SCk

 ����:	  ��Rm�Ĵ������16λͬʱ����1λ�����16λ������λ�ɱ�־�Ĵ�����2λ�������䣬�Ƴ������ݷ��õ���־�Ĵ�����2λ�ϣ���λ���Ľ������뵽Ŀ�ļĴ���Rs�С�

 ����:		p_u32Rm -- ����λ����������ӦRm��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 LShiftD16_SC(DSPU32 p_u32Rm, DSPU32 &p_u32SC, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU16 l_RmSrc;
	DSPU16 h_RmSrc;
	DSPU16 l_Bit;
	DSPU16 h_Bit;

	DSPU32 Res;

	l_RmSrc = (DSPU16)(p_u32Rm & 0xffff);
	h_RmSrc = (DSPU16)((p_u32Rm >> 16) & 0xffff);

	l_Bit = (l_RmSrc >> 15) & 0x1; 
	h_Bit = (h_RmSrc >> 15) & 0x1;

	l_RmSrc <<= 1;
	h_RmSrc <<= 1;
	
	if (TestBit(p_u32SC,0))
		SetBit(l_RmSrc,0);
	else
		ClearBit(l_RmSrc,0);

	if (TestBit(p_u32SC,1))
		SetBit(h_RmSrc,0);
	else
		ClearBit(h_RmSrc,0);

	if (TestBit(l_Bit,0))
		SetBit(p_u32SC,0);
	else
		ClearBit(p_u32SC,0);

	if (TestBit(h_Bit,0))
		SetBit(p_u32SC,1);
	else
		ClearBit(p_u32SC,1);

	Res = h_RmSrc;
	Res <<= 16;
	Res |= l_RmSrc & 0xffff;

	return Res;
}

/*found*****************************************************************
 ��������		SXOR32To32
 
 ��Ӧָ����ʽ:  Rs=Rm+1:m S_XOR SACCk    

 ����:	  ����SACCk�ڲ���1����λ�ã�ȷ��Rm+1:m���ɵ����������л�������������������������λ�ã��γ�32λ��������
 Rs(0)=(Rm+1(0)*SACC(31) @(Rm(31)*SACC(30))@....@(Rm(1)*SACC(0));
 Rs(1)=(Rm+1(1)*SACC(31)) @(Rm+1(0)*SACC(30))@....@(Rm(1)*SACC(0));
 ��;
 Rs(31)=(Rm+1(30)*SACC(31)) @(Rm(29)*SACC(30))@....@(Rm(31)*SACC(0));



 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_Src -- 64λ���룬p_Src.Low32��ӦRm��p_Src.High32��ӦRm+1��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/

extern DSPU32 SXOR32To32(const DSP_BIT64 p_SACC, DSP_BIT64 p_Src,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	bitset<32> b_SACC32;
	bitset<64> b_src64;
	bitset<32> b_Res32;
	DSPU32 Res;

	b_SACC32.reset();
	b_src64.reset();
	b_Res32.reset();

	for (int i = 0; i < 64; i++) {
		if (i < 32) {
			if (TestBit(p_Src.u32Low,i))
				b_src64.set(i);
		}

		else {
			int tmp = i-32;
			if (TestBit(p_Src.u32High,tmp))
				b_src64.set(i);
		}
	}

	for (int i = 0; i < 32; i++) {
		if (TestBit(p_SACC.u32Low,i))
			b_SACC32.set(i);
	}

	DSPU32 u32temp1, u32temp2, u32temp3;
	for (int i = 0; i < 32; i++) {
		for (int j = 0; j < 32; j++) {
			//b_Res32[i] = b_Res32[i] ^ (b_src64[i+j] * b_SACC32[j]);
			u32temp1 = b_src64[i+j+1];
			u32temp2 = b_SACC32[j];
			u32temp3 = b_Res32[i];

			u32temp3 ^= u32temp1 * u32temp2;

			if (u32temp3 !=0) {
				b_Res32.set(i);
			}

			else {
				b_Res32.reset(i);
			}
		}
	}

	Res = b_Res32.to_ulong();
	
	b_SACC32.reset();
	b_src64.reset();
	b_Res32.reset();

	return Res;
}

/*found*****************************************************************
 ��������		SXOR16To32
 
 ��Ӧָ����ʽ:  Rs=Rm S_XOR HSACCk

 ����:	  ��SACCk����16λ���ݸ�ʽ��Ϊ������ݣ��ֱ����ڲ���16λ�͵�16λ�����еġ�1��λ�ã�ȷ��Rm���ɵ����������л�������������������������λ�ã�Rs����λΪ��16λ���ݻ�����������������Rsż��λΪ��16λ������������������
 Rs(0)=(Rm(15)*SACC(15)xor(Rm(14)*SACC(14))xor....xor(Rm(0)*SACC(0));
 Rs(1)=(Rm(15)*SACC(31))xor(Rm(14)*SACC(30))xor....xor(Rm(0)*SACC(16));
 Rs(2)=(Rm(16)*SACC(15))xor(Rm(15)*SACC(14))xor....xor(Rm(1)*SACC(0));
 Rs(3)=(Rm(16)*SACC(31))xor(Rm(15)*SACC(30))xor....xor(Rm(1)*SACC(16));
 ��;
 Rs(30)=(Rm(30)*SACC(15))xor(Rm(29)*SACC(14))xor....xor(Rm(16)*SACC(0));
 Rs(31)=(Rm(30)*SACC(31))xor(Rm(29)*SACC(30))xor....xor(Rm(16)*SACC(16));

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Src -- 32λ���룬��ӦRm��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	  ����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SXOR16To32(const DSP_BIT64 p_SACC, DSPU32 p_u32Src,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU16 u16SACCHgh[16];
	DSPU16 u16SACCLow[16];
	DSPU16 u16Src[16];
	DSPU16 u16MulRes[16];
	DSPU32 u32XorRes[32];
	DSPU32 Res;

	for (int i = 0; i < 32; i++) {
		if (i <16) {
			if (TestBit(p_SACC.u32Low,i)) {
				u16SACCLow[i] = 1;
			} else {
				u16SACCLow[i] = 0;
			}

		} else {
			if (TestBit(p_SACC.u32Low,i)) {
				u16SACCHgh[i-16] = 1;
			} else {
				u16SACCHgh[i-16] = 0;
			}
		}
	}
	int count = 0   ;
	//��ζ�u32XorRes[]��ֵ
	for (int i = 0; i < 32; i++) {
		//0,2,4...30
		if (fmod((double)i, 2)==0) {			

			count = i/2+1;
			
			for (int icnt = count, m=0; icnt<count+16; icnt++) {
				if (TestBit(p_u32Src,icnt)) {
					u16Src[m]=1;
				} else {
					u16Src[m]=0;
				}
				m++;
			}

			//Mul			
			for (int icnt = 0; icnt<16; icnt++) {
				u16MulRes[icnt] = u16Src[icnt]*u16SACCLow[icnt];
			}

			//xor
			u32XorRes[i] = u16MulRes[0];
			for (int icnt = 1; icnt<16; icnt++) {
				u32XorRes[i] ^= u16MulRes[icnt];
			}

		}

		//1,3,5...31
		else {
			count = (i-1)/2+1;		
			
			for (int icnt = count, m=0; icnt<count+16; icnt++) {
				if (TestBit(p_u32Src,icnt)) {
					u16Src[m]=1;
				} else {
					u16Src[m]=0;
				}
				m++;
			}

			//Mul			
			for (int icnt = 0; icnt<16; icnt++) {
				u16MulRes[icnt] = u16Src[icnt]*u16SACCHgh[icnt];
			}

			//xor
			u32XorRes[i] = u16MulRes[0];
			for (int icnt = 1; icnt<16; icnt++) {
				u32XorRes[i] ^= u16MulRes[icnt];
			}

		}
	}

	for (int i = 0; i < 32; i++) {

		if (u32XorRes[i] ==1) {
			SetBit(Res,i);
		} else {
			ClearBit(Res,i);
		}
	}

	return Res;
}

/*found*****************************************************************
 ��������		ABS2SACC
 
 ��Ӧָ����ʽ:  SACCs=abs(BRm-BRn[2k+1:2k])
 SACCs=abs(BRm-BRn[3k+2:3k])

 ����:	   ��p_u32Mode����˵����

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Rm -- ����λ����������ӦRm��
 p_u32Rn -- ����λ����������ӦRn��
 p_u32Mode -- ģʽѡ����
 0 -- SACCs=abs(BRm-BRn[2k+1:2k])����Rm[1:0]- Rn[2k+1:2k], Rm[3:2]- Rn[2k+1:2k], ��, Rm[31:30]- Rn[2k+1:2k],�ֱ�ȡ����ֵ��
 ����������������SACCs��Ӧλ��������Ӱ����־λ��
 1 -- SACCs=abs(BRm-BRn[3k+2:3k])����Rm[2:0]- Rn[3k+2:3k], Rm[5:3]- Rn[3k+2:3k], ��,Rm[29:27]- Rn[3k+2:3k],�ֱ�ȡ����ֵ��
 ������������ƴ�Ӻ���ֵ��SACCs��SACCs�������λ���㡣������Ӱ����־λ��
 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void ABS2SACC(DSP_BIT64 &p_SACC, DSPU32 p_u32Rm, DSPU32 p_u32Rn,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR, DSPU32 p_u32Mode, DSPU32 p_u32K) {
	
	DSPU32 iTmp1, iTmp2, iRes, iResTemp;

	iRes = 0;
	int count = 0;
	int SH_CNT = 0;

	switch (p_u32Mode) {
	case 0:
		//BRn[2k+1:2k]
		SH_CNT = p_u32K * 2;
		
		if(p_u32K >15){
			p_SACC.u32High = 0;
			p_SACC.u32Low = 0;
		}
		else{
			iTmp2 = (p_u32Rn >> SH_CNT) & 0x3;
	
			for (int i = 0; i < 16; i ++) {	
				count = 2*i;			
				iTmp1 = (p_u32Rm >> count) & 0x3;			
				iResTemp = abs((int)(iTmp1 - iTmp2));
				iRes |= (iResTemp << count);
			}
			p_SACC.u32High = 0;
			p_SACC.u32Low = iRes;
		}
		break;

	case 1:
		//BRn[3k+2:3k]
		SH_CNT = p_u32K * 3;
		if(p_u32K >9){
			p_SACC.u32High = 0;
			p_SACC.u32Low = 0;
		}
		else{
			iTmp2 = (p_u32Rn >> SH_CNT) & 0x7;
			
	
			for (int i = 0; i < 10; i ++) {
				count = 3*i;
				iTmp1 = (p_u32Rm >> count) & 0x7;
				iResTemp = abs((int)(iTmp1 - iTmp2));
				iRes |= (iResTemp << count);
			}
			p_SACC.u32High = 0;
			p_SACC.u32Low = iRes;
		}

		break;


	}

}

/*found*****************************************************************
 ��������		SACCXor32
 
 ��Ӧָ����ʽ:  SACCk=��Rm XOR SACCk��SC[0]    //SACCs=(Rn XOR SACCs)SC[0]

 ����:	   SACC[31]=SACC[30] XOR Rm[31];
 ��;
 SACC[2]=SACC[1] XOR Rm[2];
 SACC[1]=SACC[0] XOR Rm[1];
 SACC[0]=SC[0] XOR Rm[0];

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Rm -- ����λ����������ӦRm��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��                
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SACCXor32(DSP_BIT64 &p_SACC, DSPU32 p_u32Rm, DSPU32 p_u32SC,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU32 iTmp1, iRes = 0,tmp = 0;
	iRes = (p_u32SC & 0x1) ^ (p_u32Rm & 0x1);

	for (int i = 1; i < 32; i++) {
		tmp = i - 1;
		iTmp1 = ((p_SACC.u32Low >> (tmp)) & 0x1) ^ ((p_u32Rm >> i) & 0x1);
		iRes |= iTmp1 << i;
	}

	p_SACC.u32High = 0;
	p_SACC.u32Low = iRes;
}

/*found*****************************************************************
 ��������		SACCXor16
 
 ��Ӧָ����ʽ:  HSACCk = (HRm XOR SACCk��SC[1:0]  // HSACCs = (HRn XOR SACCs)SC[1:0] 

 ����:	   SACC[31]=SACC[30] XOR Rm[31];
 ��;
 SACC[17]=SACC[17] XOR Rm[1];
 SACC[16]=SACC[16] XOR SC[1];
 
 SACC[15]=SACC[15] XOR Rm[15];
 ��;
 SACC[2]=SACC[1] XOR Rm[2];
 SACC[1]=SACC[0] XOR Rm[1];
 SACC[0]=SC[0] XOR Rm[0];

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Rm -- ����λ����������ӦRm��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��                
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SACCXor16(DSP_BIT64 &p_SACC, DSPU32 p_u32Rm, DSPU32 p_u32SC,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	int iCnt = 0;
	DSPU32 iTempLow = 0,iTempHgh = 0, iRes1 = 0, iRes2 = 0, iRes = 0;
	//SACC[0]=SC[0] XOR Rm[0];
	iRes1 = (p_u32SC & 0x1) ^ (p_u32Rm & 0x1);
	//SACC[16]=  SC[1]]XOR Rm[16];
	iRes2 = (((p_u32Rm >> 16) & 0x1) ^ ((p_u32SC >> 1) & 0x1)) << 16;

	for (int i = 1; i < 16; i++) {
		iCnt = i - 1;
		iTempLow = ((p_SACC.u32Low >> iCnt)&0x1) ^ ((p_u32Rm >> i) & 0x1);
		iRes |= iTempLow << i;
	}

	for (int i = 17; i < 32; i++) {
		iCnt = i - 1;
		iTempHgh = ((p_SACC.u32Low >> iCnt)&0x1)  ^ ((p_u32Rm >> i) & 0x1);
		iRes |= iTempHgh << i;
	}

	p_SACC.u32High = 0;
	p_SACC.u32Low = iRes | iRes1| iRes2;
}

/*found*****************************************************************
 ��������		INV32

 ��Ӧָ����ʽ:  Rs=INV_0 Rm (U) 

 ����:			��Rm�Ĵ���32λ�޷�������ǰ��˳���ߵ���ֵ��Ŀ�ļĴ���Rs

 ����:		p_u32Src -- Դ����������ӦRm��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 INV32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	/*״̬�Ĵ�����*/
	

	DSPU32 iRes = 0;

	for (int i = 0; i < 32; i++) {
		if (TestBit(p_u32Src, i))
			SetBit(iRes, 31-i);

	}
	return iRes;
}

/*found*****************************************************************
 ��������		INVD16

 ��Ӧָ����ʽ:  Rs=INV_0 Rm (U) 

 ����:			��Rm�Ĵ������ݷֳ�˫16λ�޷������ݣ���������ǰ��˳���ߵ���ֵ��Ŀ�ļĴ���HRs��

 ����:		p_u32Src -- Դ����������ӦRm��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 INVD16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU16 u16ResLow = 0;
	DSPU16 u16ResHigh = 0;

	DSPU16 u16SrcLow = 0;
	DSPU16 u16SrcHigh = 0;

	u16SrcHigh = p_u32Src >> 16;
	u16SrcLow = p_u32Src & 0xffff;

	for (int i = 0; i < 16; i++) {
		if (TestBit(u16SrcHigh, i))
			SetBit(u16ResHigh, 15-i);

	}

	for (int i = 0; i < 16; i++) {
		if (TestBit(u16SrcLow, i))
			SetBit(u16ResLow, 15-i);
	}
	DSPU32 iRes = (u16ResHigh << 16) | u16ResLow;
	return iRes;

}

/*found*****************************************************************
 ��������		Fext32ToGPR

 ��Ӧָ����ʽ:  Rs=Rm fext Rn
 Rs=Rm fext Rn(z)
 Rs=Rm fext Rn(s)

 ����:		����Rn�Ĵ�������ȷ�����ݲü���ʽ��ȡ�����ݳ���ΪRn[4:0]��������ʼλ��ΪRn[9:5]�����ݷ���Rs�Ĵ�����ʼλ��fΪ[14��10]��
 ��ʱ��������ʼλ�á�С�ڵ���32�����������õ���ʼλ�á�+�����ݳ��ȡ�����32�����ݶε����߳����˱߽磬Ҫ����λ��������־��λ��

 ����:		p_u32SrcM -- 32λ���룬��ӦRm��
 p_u32SrcN -- 32λ���룬��ӦRn��
 p_u32Mode -- ģʽѡ��
 0 -- �Ƿ�����������ֵ��
 1 -- �Ƿ�����ά��ԭֵ��
 2 -- �Ƿ��������ս�ȡ������λ���з���λ�չ��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void Fext32ToGPR(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 &p_u32Dest,
		DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	DSPU32 u32Rm = p_u32SrcM;
	DSPU32 u32Rs = p_u32Dest;
	DSPU32 u5Rn = p_u32SrcN;

	DSPU8 u5Beg = (DSPU8)(u5Rn & 0x1f);//��ʼλ��
	DSPU8 u5Len = (DSPU8)((u5Rn >> 5) & 0x1f);//���ݳ���

	if (u5Len == 0) {
		u5Len =1;
	}
 
	if (u5Len > 32 - u5Beg) {
		u5Len = 32 - u5Beg;
	}

	DSPU8 u5Pos = (DSPU8)((u5Rn >> 10) & 0x1f);

	unsigned frontRmMask;
  
	if (u5Beg + u5Len == 32) {
		frontRmMask = 0;
	} else {
		frontRmMask = 0xffffffff << (u5Beg + u5Len);
	}

	unsigned endRmMask;
	if (u5Beg == 0) {
		endRmMask = 0;
	} else {
		endRmMask = 0xffffffff >> (32 - u5Beg);
	}

	//DSPU32 middleRmMask = 0xffffffff & ~frontRmMask & ~endRmMask;
	DSPU32 middleRm = u32Rm & ~frontRmMask & ~endRmMask;//����Rm���м�ֵ

	if (u5Len > 32 - u5Pos) {
		u5Len = 32 - u5Pos;
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
		//��λ
	}

	unsigned frontRsMask;
	if (u5Pos + u5Len == 32) {
		frontRsMask = 0;
	} else {
		frontRsMask = 0xffffffff << (u5Pos + u5Len);
	}
	unsigned endRsMask;
	if (u5Pos == 0) {
		endRsMask = 0;
	} else {
		endRsMask = 0xffffffff >> (32 - u5Pos);
	}
	DSPU32 middleRsMask = 0xffffffff & ~frontRsMask & ~endRsMask;
	bool bolMiddleRmSign = ((middleRm << (32 - u5Beg - u5Len)) & 0x80000000)
			!= 0;//����λ

	if (u5Pos >= u5Beg) {
		middleRm = middleRm << (u5Pos - u5Beg);
	} else {
		middleRm = middleRm >> (u5Beg - u5Pos);
	}

	switch (p_u32Mode) {
	case 0:

		u32Rs = middleRm;

		break;

	case 1:

		u32Rs = u32Rs & ~middleRsMask;
		u32Rs = u32Rs | middleRm;

		break;

	case 2:

		u32Rs = middleRm;

		if (bolMiddleRmSign) {
			u32Rs |= frontRsMask;
		}

		break;
	}

}

/*found*****************************************************************
 ��������		Fext32ToSACC

 ��Ӧָ����ʽ:  SACCs=Rm fext Rn
 SACCs=Rm fext Rn(z)
 SACCs=Rm fext Rn(s)

 ����:		����Rn�Ĵ�������ȷ�����ݲü���ʽ��ȡ�����ݳ���ΪRn[4:0]��������ʼλ��ΪRn[9:5]�����ݷ���Rs�Ĵ�����ʼλ��fΪ[14��10]��
 ��ʱ��������ʼλ�á�С�ڵ���32�����������õ���ʼλ�á�+�����ݳ��ȡ�����32�����ݶε����߳����˱߽磬Ҫ����λ��������־��λ��

 ����:		p_u32SrcM -- 32λ���룬��ӦRm��
 p_u32SrcN -- 32λ���룬��ӦRn��
 p_SACC -- 64λSACC�Ĵ�����
 p_u32Mode -- ģʽѡ��
 0 -- �Ƿ�����������ֵ��
 1 -- �Ƿ�����ά��ԭֵ��
 2 -- �Ƿ��������ս�ȡ������λ���з���λ�չ��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void Fext32ToReg(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSP_BIT64 &p_SACC,
		DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	DSPU32 u32Rm = p_u32SrcM;
	DSPU32 u5Rn = p_u32SrcN;

	DSPU8 u5Beg = (DSPU8)(u5Rn & 0x1f);//���ݳ���[4-0]
	DSPU8 u5Len = (DSPU8)((u5Rn >> 5) & 0x1f);//��ʼλ��[9-5]

	bitset<64> b64SaccRes;
	bitset<64> b64SaccScr;
	b64SaccRes.reset();
	b64SaccScr.reset();
 
	if (u5Len == 0) {
		u5Len =1;
	}
 
	if (u5Len > 32 - u5Beg) {
		u5Len = 32 - u5Beg;
	}
	DSPU8 u5Pos = (DSPU8)((u5Rn >> 10) & 0x3f);

	unsigned frontRmMask;
  
	if (u5Beg + u5Len == 32) {
		frontRmMask = 0;
	} else {
		frontRmMask = 0xffffffff << (u5Beg + u5Len);
	}

	unsigned endRmMask;
	if (u5Beg == 0) {
		endRmMask = 0;
	} else {
		endRmMask = 0xffffffff >> (32 - u5Beg);
	}

	//DSPU32 middleRmMask = 0xffffffff & ~frontRmMask & ~endRmMask;
	DSPU32 middleRm = u32Rm & ~frontRmMask & ~endRmMask;//����Rm���м�ֵ

	DSPU32 shifterRm = middleRm >> u5Beg;//shifterRm�ĵ�u5LenΪ��Чֵ

	bool bolSignShfRm = false;
	if ((shifterRm >> (u5Len-1)) ==1) {
		bolSignShfRm = true;
	}

	if (u5Len > 64 - u5Pos) {
		u5Len = 64 - u5Pos;
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);

	}

	switch (p_u32Mode) {

	case 0:

		for (int i=0; i<u5Len; i++) {

			if (TestBit(shifterRm,i)) {
				b64SaccScr.set(i+u5Pos);
			}
		}

		break;
	case 1:

		for (int i=0; i<64; i++) {

			if (i < 32) {
				if (TestBit(p_SACC.u32Low,i)) {
					b64SaccScr.set(i);
				}

			}

			else {
				if (TestBit(p_SACC.u32High,i-32)) {
					b64SaccScr.set(i);
				}

			}

		}

		for (int i=0; i<u5Len; i++) {

			if (TestBit(shifterRm,i)) {
				b64SaccScr[i+u5Pos]=1;
			} else
				b64SaccScr[i+u5Pos]=0;
		}

		break;

	case 2:

		for (int i=0; i<u5Len; i++) {

			if (TestBit(shifterRm,i)) {
				b64SaccScr.set(i+u5Pos);
			}
		}

		if (bolSignShfRm) {
			if (u5Len+u5Pos<64) {
				for (int i=u5Len+u5Pos; i<64; i++)
					b64SaccScr.set(i);
			}
		}

		break;

	}

	bitset<32> u32ResHigh;
	bitset<32> u32ResLow;
	u32ResHigh.reset();
	u32ResLow.reset();
	for (int i=0; i<64; i++) {
		if (i<32)
			u32ResLow[i]= b64SaccScr[i];

		else
			u32ResHigh[i-32]= b64SaccScr[i];

	}
	p_SACC.u32Low = u32ResLow.to_ulong();
	p_SACC.u32High = u32ResHigh.to_ulong();
}

/*found*****************************************************************
 ��������		Fext64ToGPR

 ��Ӧָ����ʽ:  Rs=Rm+1:m fext Rn
 Rs=Rm+1:m fext Rn(z)
 Rs=Rm+1:m fext Rn(s)

 ����:		��Rm+1��Rm�Ĵ�����һ��64λ���ݣ�Ҫ������ȡ�����ݳ���ΪRn[4:0]��������ʼλ��ΪRn[9:5]�����ݷ�����ʼλ��ΪRn[14��10]��Rs�Ĵ����ϡ�

 ����:		p_Src -- 64λ���룬��ӦRm+1:m��
 p_u32SrcN -- 32λ���룬��ӦRn��
 p_u32Dest -- ��ӦRs��
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)��
 p_u32Mode -- ģʽѡ��
 0 -- �Ƿ�����������ֵ��
 1 -- �Ƿ�����ά��ԭֵ��
 2 -- �Ƿ��������ս�ȡ������λ���з���λ�չ��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void Fext64ToGPR(const DSP_BIT64 &p_Src, DSPU32 p_u32SrcN,
		DSPU32 &p_u32Dest, DSPU32 p_u32SC, DSPU32 p_u32Mode,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU32 u5Rn = p_u32SrcN;
	DSPU32 u32Dat;
	DSPU32 u32Rs = p_u32Dest;
	bitset<64> b_src64;
	bitset<32> b_src32;
	b_src64.reset();
	b_src32.reset();


	for (int i = 0; i < 64; i++) {
		if (i < 32) {
			if (TestBit(p_Src.u32Low,i))
				b_src64.set(i);
		}

		else {
			int tmp = i-32;
			if (TestBit(p_Src.u32High,tmp))
				b_src64.set(i);
		}
	}

	DSPU8 u5Beg = (DSPU8)(u5Rn & 0x1f);
	DSPU8 u5Len = (DSPU8)((u5Rn >> 5) & 0x1f);
	
	for (int i = 0; i < u5Len; i++) {
		b_src32[i] = b_src64[i+u5Beg];
	}

	u32Dat = b_src32.to_ulong();
	
	DSPU8 u5Pos = (DSPU8)((u5Rn >> 10) & 0x1f);

	if (u5Len > 32 - u5Pos) {
		u5Len = 32 - u5Pos;
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);		
	}

	unsigned frontRsMask;
	if (u5Pos + u5Len == 32) {
		frontRsMask = 0;
	} else {
		frontRsMask = 0xffffffff << (u5Pos + u5Len);
	}
	unsigned endRsMask;
	if (u5Pos == 0) {
		endRsMask = 0;
	} else {
		endRsMask = 0xffffffff >> (32 - u5Pos);
	}
	DSPU32 middleRsMask = 0xffffffff & ~frontRsMask & ~endRsMask;
	bool bolDataSign = ((u32Dat << (32 - u5Len)) & 0x80000000) != 0;
	

	u32Dat = u32Dat << u5Pos;
	switch (p_u32Mode) {
	
	case 0:

		u32Rs = u32Dat;
		break;

		
	case 1:

		u32Rs = u32Rs & ~middleRsMask;
		u32Rs = u32Rs | u32Dat;

		break;


	case 2:

		u32Rs = u32Dat;

		if (bolDataSign) {
			u32Rs |= frontRsMask;
		}

		break;
	}

}

/*found*****************************************************************
 ��������		InsGPRToSACC

 ��Ӧָ����ʽ:  SACCs=Rm Insert Rn (p,q,f)    

 ����:		��Rn�Ĵ�������ʼλ��p����ȡ����Ϊq�����ݣ����뵽Rm�Ĵ���f������������SACCs��

 ����:		p_u32SrcM -- 32λ���룬��ӦRm��
 p_u32SrcN -- 32λ���룬��ӦRn��
 p_SACC -- 64λSACC�Ĵ�����
 p_u32P -- ��Ӧp��
 p_u32Q -- ��Ӧq��
 p_u32F -- ��Ӧf��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void InsGPRToSACC(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSP_BIT64 &p_SACC,
		DSPU32 p_u32P, DSPU32 p_u32Q, DSPU32 p_u32F, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	bitset<64> u64DatVec;
	u64DatVec.reset();

	DSPU32 p = p_u32P, q = p_u32Q, f = p_u32F;
	
	DSPU32 u32RnBeg = p, u32DatBeg = f+1;

	if ((p+q) > 32) {
		q = 32 - p;
	}
	

	for (DSPU32 i = 0; i <= f; i++) {
		if (TestBit(p_u32SrcM, i))
			u64DatVec.set(i);
	}


	for (DSPU32 i = 0; i < q; i++) {

		if (TestBit(p_u32SrcN, u32RnBeg)) {
			u64DatVec.set(u32DatBeg);
		}

		u32RnBeg ++;
		u32DatBeg ++;
	}

	if(f<32){

		for (DSPU32 i = f+1; i < 32; i++) {
	
			if (TestBit(p_u32SrcM, i)) {
				u64DatVec.set(u32DatBeg);
			}
			u32DatBeg++;
		}
	}

	
	bitset<32> u32DatVec;
	u32DatVec.reset();

	for (int i = 0; i < 32; i++) {
		u32DatVec[i] = u64DatVec[i];
	}
	p_SACC.u32Low = u32DatVec.to_ulong();
	

	u32DatVec.reset();

	for (int i = 32; i < 64; i++) {
		u32DatVec[i-32] = u64DatVec[i];
	}
	
	p_SACC.u32High = u32DatVec.to_ulong();
	u32DatVec.reset();

}

/*found*****************************************************************
 ��������		InsSACCToSACC

 ��Ӧָ����ʽ:  SACCs=SACCs Insert Rn (p,q,f)   

 ����:		��Rn�Ĵ�������ʼλ��p����ȡ����Ϊq�����ݣ����뵽SACCs�Ĵ���f������������SACCs��

 ����:		p_u32SrcN -- 32λ���룬��ӦRn��
 p_SACC -- 64λSACC�Ĵ�����
 p_u32P -- ��Ӧp��
 p_u32Q -- ��Ӧq��
 p_u32F -- ��Ӧf��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void InsSACCToSACC(DSPU32 p_u32SrcN, DSP_BIT64 &p_SACC, DSPU32 p_u32P,
		DSPU32 p_u32Q, DSPU32 p_u32F, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU32 u32P = p_u32P;
	DSPU32 u32Q = p_u32Q;
	DSPU32 u32F = p_u32F;

	bitset<32> u32SrcRnVec, u32DestVec;
	bitset<64> u64SrcVec;
	bitset<128> u128DestVec;
	u32SrcRnVec.reset();
	u32DestVec.reset();;
	u64SrcVec.reset();
	u128DestVec.reset();
	
	bool bolOverFlow = false;
		//intial 
	if ((u32P+u32Q) > 32) {
		u32Q = 32 - u32P;
	}
	for (DSPU32 i = 0; i < u32Q; i++) {
		if (TestBit(p_u32SrcN, i+u32P)) {
			u32SrcRnVec.set(i);
		}
	}

	for (int i = 0; i < 32; i++) {
		if (TestBit(p_SACC.u32Low, i)) {
			u64SrcVec.set(i);
		}
	}
	for (int i = 0; i < 32; i++) {
		if (TestBit(p_SACC.u32High, i)) {
			u64SrcVec.set(i+32);
		}
	}

	
	if((u32Q + u32F) > 64){
		bolOverFlow = true;
	}
	
	else if ((u32Q + u32F) <= 64)
	{

		if(((p_SACC.u32High>>(32-u32Q))!= 0) && (u32Q!=0))
		{
			bolOverFlow = true;			
		}
		
	}
	DSPU32  u32DestCnt = 0 ;
	//ovewrite
	for (DSPU32 i = 0; i <= u32F; i++) {
		u128DestVec[u32DestCnt] = u64SrcVec[i];
		u32DestCnt++;
	}

	for (DSPU32 i = 0; i < u32Q; i++) {
		u128DestVec[u32DestCnt] = u32SrcRnVec[i];
		u32DestCnt++;
	}

	for (DSPU32 i = u32F+1; i < 64; i++) {
		u128DestVec[u32DestCnt] = u64SrcVec[i];
		u32DestCnt++;
	}

	for (int i = 0; i < 32; i++) {
		u32DestVec[i] = u128DestVec[i];
	}

	p_SACC.u32Low = u32DestVec.to_ulong();
	u32DestVec.reset();
	for (int i = 32; i < 64; i++) {
		u32DestVec[i-32] = u128DestVec[i];
	}

	p_SACC.u32High = u32DestVec.to_ulong();

	if(bolOverFlow){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);		
	}
	
	u32SrcRnVec.reset();
	u32DestVec.reset();;
	u64SrcVec.reset();
	u128DestVec.reset();
}

/*found*****************************************************************
 ��������		CompactMN

 ��Ӧָ����ʽ:  Rs=Compact(Rm_Rn,a)   

 ����:		��{Rm[a:0],Rn[31:a+1]}ƴ�Ӻ���ֵ��Rs��

 ����:		p_u32SrcM -- 32λ���룬��ӦRm��
 p_u32SrcN -- 32λ���룬��ӦRn��
 p_u32A -- ��Ӧa��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 CompactMN(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 p_u32A,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {


	DSPU32 u32Res;
	DSPU32 u32A = p_u32A&0x1f;

	DSPU32 u32RmCom = (p_u32SrcM<<(31-u32A)&0xffffffff);
	//Rn[31:a+1]
	DSPU32 u32RnCom = (p_u32SrcN>>(u32A+1)&0xffffffff);	
	if(u32A >= 31){
		u32RnCom = 0;
	}
	u32Res = u32RmCom | u32RnCom;
	

	return u32Res;
}


/*found*****************************************************************
 ��������		AShift64SACC
 
 ::fininsh by baohua ,2012.9.4
 ��Ӧָ����ʽ: Rs+1:s=Rm+1:m aShift HSACCk 

 ����:		64λ������λ�����Ĵ���Rm+1�ͼĴ���Rm�ֱ���Ϊ�ߵ�32λ�ϳ�һ��64λ���ݣ�64λ��������λ�������չ���ţ�����ʱ��λ���㣩��
 ��λֵ�ɼĴ���HSACCk�ĵ�[38��32]λȷ����7λ��������λΪ����λ�����ı�ʾ���ƣ����ı�ʾ���ƣ�����Ӱ����־λ��

 ����:		p_Src -- 64λԴ����������ӦRm+1:m��
 p_SACC -- 64λSACC�Ĵ�����
 p_Dest -- 64λ����������
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)�� 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/

extern void AShift64SACC(const DSP_BIT64 p_Src, const DSP_BIT64 p_SACC,
		DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	int i32BitNum = 7;
	unsigned int BitMask = 0x0000007f;
	DSPU32 u32BitToShift;//��Ҫ��λ��λ��
	u32BitToShift = p_SACC.u32High & BitMask;

	DSPI32 i32ToShift;
	bool LeftShift = !TestBit(p_SACC.u32High,i32BitNum - 1);
	bool bolSign= TestBit(p_Src.u32High, 31);
	bool bolOverflow = false;
	bool bolStau = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation);
	bool bolSigned= true;

	bitset<64> bitSrc64;
	bitSrc64.reset();
	bitset<64> bitSrcRes64;
	bitSrcRes64.reset();

	for (int i = 0; i< 64; i++) {
		if (i < 32) {
			if (TestBit(p_Src.u32Low,i))
				bitSrc64.set(i);
		}

		else {
			if (TestBit(p_Src.u32High,i-32))
				bitSrc64.set(i);
		}

	}

	
	if (LeftShift) {

		i32ToShift = (DSPI32)u32BitToShift;
		
		for (int i = 0; i< 64; i++) {
			if (i<64-i32ToShift)
				bitSrcRes64[i+i32ToShift] = bitSrc64[i];
		}

		
		for (int i = 0; i<= i32ToShift; i++) {
			if (bitSrc64[63-i] != bolSign) {
				bolOverflow = true;
			}
		}
	
		bitSrcRes64[63] = bitSrc64[63];
	}


	if (!LeftShift) {

		i32ToShift = ~u32BitToShift + 1;
		i32ToShift &= BitMask;

		for (int i = 0; i< 64; i++) {			
			if (i<64-i32ToShift) {
				bitSrcRes64[i] = bitSrc64[i+i32ToShift];

			}
		}

		if (bolSign) {
			for (int i = 64-i32ToShift; i< 64; i++) {
				bitSrcRes64.set(i);
			}
		}

		bitSrcRes64[63] = bitSrc64[63];
	}

	bitset<32> b32ResHigh;
	bitset<32> b32ResLow;
	b32ResHigh.reset();
	b32ResLow.reset();

	for (int i = 0; i< 64; i++) {
		if (i < 32) {
			b32ResLow[i] = bitSrcRes64[i];
		}

		else {
			b32ResHigh[i-32] = bitSrcRes64[i];
		}
	}

	if (bolOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);	
		
		if(bolStau){
		
			if(bolSigned){
			
				if(bolSign){
					p_Dest.u32High = 0x80000000;
					p_Dest.u32Low = 0;				
				}
				else{
					p_Dest.u32High = 0x7fffffff;
					p_Dest.u32Low = 0xffffffff;				
				}		
			}			
			else{
				p_Dest.u32High = 0xffffffff;
				p_Dest.u32Low = 0xffffffff;
			}		
		
		}
		
		else{
		//c. ��������
			p_Dest.u32High = b32ResHigh.to_ulong();
			p_Dest.u32Low = b32ResLow.to_ulong();	
		}
	}
	
	else{
		//c. ��������
		p_Dest.u32High = b32ResHigh.to_ulong();
		p_Dest.u32Low = b32ResLow.to_ulong();
	
	}
}

/*found*****************************************************************
 ��������		LShift64SACC
 
 ::fininsh by baohua ,2012.9.5
 ��Ӧָ����ʽ: Rs+1:s=Rm+1:m  Lshift  HSACCk 

 ����:		64λ�߼���λ�����Ĵ���Rm+1�ͼĴ���Rm�ֱ���Ϊ�ߵ�32λ�ϳ�һ��64λ���ݣ�64λ���߼���λ������ʱ���չ����λ����
 ��λֵ�ɼĴ���HSACCk�ĵ�[38��32]λȷ����7λ��������λΪ����λ�����ı�ʾ���ƣ����ı�ʾ���ƣ�����Ӱ����־λ����λ�����µļĴ���λ���ϡ�0����

 ����:		p_Src -- 64λԴ����������ӦRm+1:m��
 p_SACC -- 64λSACC�Ĵ�����
 p_Dest -- 64λ����������
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)�� 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void LShift64SACC(const DSP_BIT64 p_Src, const DSP_BIT64 p_SACC,
		DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	int i32BitNum = 7;
	unsigned int BitMask = 0x0000007f;
	DSPU32 u32BitToShift;//��Ҫ��λ��λ��
	u32BitToShift = p_SACC.u32High & BitMask;

	DSPI32 i32ToShift;
	bool LeftShift = !TestBit(p_SACC.u32High,i32BitNum - 1);


	bitset<64> bitSrc64;
	bitSrc64.reset();
	bitset<64> bitSrcRes64;
	bitSrcRes64.reset();

	for (int i = 0; i< 64; i++) {
		if (i < 32) {
			if (TestBit(p_Src.u32Low,i))
				bitSrc64.set(i);
		}

		else {
			if (TestBit(p_Src.u32High,i-32))
				bitSrc64.set(i);
		}
	}

	if (LeftShift) {

		i32ToShift = (DSPI32)u32BitToShift;
		for (int i = 0; i< 64; i++) {
			if (i<64-i32ToShift)
				bitSrcRes64[i+i32ToShift] = bitSrc64[i];
		}

	}
 
	if (!LeftShift) {

		i32ToShift = ~u32BitToShift + 1;
		i32ToShift &= BitMask;

		for (int i = 0; i< 64; i++) {
			//��λ
			if (i<64-i32ToShift) {
				bitSrcRes64[i] = bitSrc64[i+i32ToShift];
			}
		}

	}

	bitset<32> b32ResHigh;
	bitset<32> b32ResLow;
	b32ResHigh.reset();
	b32ResLow.reset();

	for (int i = 0; i< 64; i++) {
		if (i < 32) {
			b32ResLow[i] = bitSrcRes64[i];
		}

		else {
			b32ResHigh[i-32] = bitSrcRes64[i];

		}
	}

	p_Dest.u32High = b32ResHigh.to_ulong();
	p_Dest.u32Low = b32ResLow.to_ulong();
}

/*found*****************************************************************
 ��������		Rot64SACC
 
 ::fininsh by baohua ,2012.9.5
 ��Ӧָ����ʽ: Rs+1:s=Rm+1:m  rot  HSACCk 

 ����:		64λѭ����λ�����Ĵ���Rm+1�ͼĴ���Rm�ֱ���Ϊ�ߵ�32λ�ϳ�һ��64λ���ݣ�64λ��ѭ����λ����λֵ�ɼĴ���HSACCk�ĵ�[38��32]λȷ����
 7λ��������λΪ����λ�����ı�ʾ���ƣ����ı�ʾ����

 ����:		p_Src -- 64λԴ����������ӦRm+1:m��
 p_SACC -- 64λSACC�Ĵ�����
 p_Dest -- 64λ����������
 p_u32SC -- �Ĵ���SC��λ��Ϊ4λ(��4λ��Ч)�� 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void Rot64SACC(const DSP_BIT64 p_Src, const DSP_BIT64 p_SACC,
		DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	int i32BitNum = 7;
	unsigned int BitMask = 0x0000007f;
	DSPU32 u32BitToShift;//��Ҫ��λ��λ��
	u32BitToShift = p_SACC.u32High & BitMask;

	DSPI32 i32ToShift;
	bool LeftShift = !TestBit(p_SACC.u32High,i32BitNum - 1);

	bitset<64> bitSrc64;
	bitSrc64.reset();
	bitset<64> bitSrcRes64;
	bitSrcRes64.reset();

	for (int i = 0; i< 64; i++) {
		if (i < 32) {
			if (TestBit(p_Src.u32Low,i))
				bitSrc64.set(i);
		}

		else {
			if (TestBit(p_Src.u32High,i-32))
				bitSrc64.set(i);
		}

	}

 
	if (LeftShift) {

		i32ToShift = (DSPI32)u32BitToShift;

		for (int i = 0; i< 64; i++) {
			if (i<64-i32ToShift) {
				bitSrcRes64[i+i32ToShift] = bitSrc64[i];
			} else {
				bitSrcRes64[i+i32ToShift-64] = bitSrc64[i];
			}
		}
	}

 
	if (!LeftShift) {

		i32ToShift = ~u32BitToShift + 1;
		i32ToShift &= BitMask;

		for (int i = 0; i< 64; i++) {
			//��λ
			if (i<64-i32ToShift) {
				bitSrcRes64[i] = bitSrc64[i+i32ToShift];
			}

			else {
				bitSrcRes64[i] = bitSrc64[i+i32ToShift-64];
			}
		}

	}

	bitset<32> b32ResHigh;
	bitset<32> b32ResLow;
	b32ResHigh.reset();
	b32ResLow.reset();


	for (int i = 0; i< 64; i++) {
		if (i < 32) {
			b32ResLow[i] = bitSrcRes64[i];
		}

		else {
			b32ResHigh[i-32] = bitSrcRes64[i];

		}
	}


	p_Dest.u32High = b32ResHigh.to_ulong();
	p_Dest.u32Low = b32ResLow.to_ulong();
}

/*found*****************************************************************
 ��������		SigmaSR

 ��Ӧָ����ʽ:  SACCs = Sigma_b1(Rn��STABn(d))
 SACCs += Sigma_b1(Rn��STABn (d))

 ����:		��Rn�е�32λ������λ��TAB���ж����32λ���ݷֱ�����-1����ָ������֮�����ӣ����������Ĵ���SACCs��
 SACCs=Rn[0]���-1��^TAB[0] +  Rn[1]���-1��^TAB[1]+ �� + Rn[31]���-1��^TAB[31]��                    
 

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Rn -- ��Ӧ�Ĵ���Rn��
 p_u32tab -- ��ӦSTABn(d)��					
 p_bolAcc -- �����Ƿ���SACC�е�ֵ�ۼӡ�
 true -- ��SACC�е�ֵ�ۼӡ�
 false -- ����SACC�е�ֵ�ۼӡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 
 *******************************************************************/
extern void SigmaSR(DSP_BIT64 &p_SACC, DSPU32 p_u32Rn, DSPU32 p_u32tab, bool p_bolAcc, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	int OpBits = 24;
	DSPU32 u32Dest = 0, u32AddDest = 0;
	DSPU32 u32Stab = p_u32tab;

	bool bolOverflow = false;
	bool bolUnderflow = false;	
	bool bolCarryFlag = false;
	bool bolUnsignedOverflow = false;

	bool bolSigned= true;

	bool bolSrc1Sign= false;
	bool bolSrc2Sign = false;
	bool bolDestSign = false;
	
	//Rn[0]���-1��^TAB[0] +  Rn[1]���-1��^TAB[1]+ �� + Rn[31]���-1��^TAB[31]
	for (int i = 0; i < 32; i++) {
		//Rn[i]��ӦλΪ1ʱ��Ч��TAB[i]��ӦλΪ1,����Ϊ-1��ʵ�ʲ����Ǽ���
		if (TestBit(p_u32Rn,i)&&TestBit(u32Stab,i)) {
			u32Dest -= 1;
		}
		//Rn[i]��ӦλΪ1ʱ��Ч��TAB[i]��ӦλΪ0,����Ϊ1��ʵ�ʲ����Ǽӷ�
		else if (TestBit(p_u32Rn,i)&&(!TestBit(u32Stab,i))) {
			u32Dest += 1;
		}
	}

	switch (p_bolAcc) {
	//SACCs = Sigma_b1(Rn��STABn(d))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn(d))
	case 1:

		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);
		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);


		bolDestSign= TestBit(u32AddDest, OpBits - 1);

		//�з��Ž�λ��־��������״̬�Ĵ���
		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		//�޷��Ž�λ��־
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		bolUnsignedOverflow = bolCarryFlag;
		
		//������־
		if (bolOverflow || bolUnderflow)  {
			SetFlag(*p_pStatReg,SHF_OverFlow);
			SetFlag(*p_pStatReg,SHF_FOverFlow);
			SetFlag(*p_pStatReg,SHF_SOVS);
			SetFlag(*p_pStatReg,SHF_SFVS);	

			if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)) {			
				if (bolOverflow) {
					u32AddDest = 0x7fffff;
				}
				if (bolUnderflow) {
					u32AddDest = 0x800000;
				}
			}
		}
		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;

		break;
	}
}

/*found*****************************************************************
 ��������		SigmaBR

 ��Ӧָ����ʽ:  SACCs = Sigma_b2(Rn+1:n��STABn(d))
 SACCs += Sigma_b2(Rn+1:n��STABn(d))

 ����:		Rn+1:n�ֳ�32���λ������TAB�����32λ������-1����ָ������֮���ۼӣ����������Ĵ���SACCs ��
 SACCs=Rn[1:0] ���-1��^TAB[0]+ Rn[3:2] ���-1��^TAB[1]+ �� + Rn[31:30] ���-1��^TAB[15]+Rn+1[1:0] ���-1��^TAB[16]
 + Rn[3:2] ���-1��^TAB[17]+ �� + Rn[31:30] ���-1��^TAB[31]��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_b64Src -- ��Ӧ�Ĵ���Rn+1:n��
 u32Low -- Rn
 u32High -- Rn+1
 p_u32tab -- ��ӦSTABn(d)��
 p_bolAcc -- �����Ƿ���SACC�е�ֵ�ۼӡ�
 true -- ��SACC�е�ֵ�ۼӡ�
 false -- ����SACC�е�ֵ�ۼӡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SigmaBR(DSP_BIT64 &p_SACC, const DSP_BIT64 &p_b64Src, DSPU32 p_u32tab, bool p_bolAcc, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	int OpBits = 24;
	DSPU32 u2Scr = 0, j = 0;
	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest = 0;
	u32Stab = p_u32tab;
	

	//^ָ������
	//Rm[1:0] ���-1��^TAB[0]+ Rm[3:2] ���-1��^TAB[1]+ �� + Rm[31:30] ���-1��^TAB[15]+Rm+1[1:0] ���-1��^TAB[16]+ Rm+1[3:2] ���-1��^TAB[17]+ �� + Rm+1[31:30] ���-1��^TAB[31]��
	for (int i = 0; i < 32; i++) {

		if (i<16) {

			u2Scr = (p_b64Src.u32Low >> (2*i)) & 0x3;

		}

		else {
			j = i-16;
			u2Scr = (p_b64Src.u32High >> (2*j)) & 0x3;

		}
		//TAB[i]��ӦλΪ1,����Ϊ-1��ʵ�ʲ����Ǽ���
		if (TestBit(u32Stab,i)) {
			u32Dest -= u2Scr;
		}
		//TAB[i]��ӦλΪ0,����Ϊ1��ʵ�ʲ����Ǽӷ�
		else if (!TestBit(u32Stab,i)) {
			u32Dest += u2Scr;
		}
	}
	
	bool bolSrc1Sign= false;
	bool bolSrc2Sign= false;
	bool bolDestSign= false;

	bool bolOverflow = false;
	bool bolUnderflow = false;
	
	bool bolCarryFlag = false;

	bool bolUnsignedOverflow = false;
	bool bolSigned= true;
	//bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed );


	switch (p_bolAcc) {
	//SACCs = Sigma_b1(Rm��STABn(SC))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;//2013.8.16
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);

		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);
		bolDestSign= TestBit(u32AddDest, OpBits - 1);


		//�з��Ž�λ��־��������״̬�Ĵ���
		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		//�޷��Ž�λ��־
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		bolUnsignedOverflow = bolCarryFlag;

		if (bolOverflow || bolUnderflow) {

			SetFlag(*p_pStatReg,SHF_OverFlow);
			SetFlag(*p_pStatReg,SHF_FOverFlow);
			SetFlag(*p_pStatReg,SHF_SOVS);
			SetFlag(*p_pStatReg,SHF_SFVS);	
			
			if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)){			
				if (bolOverflow) {
					u32AddDest = 0x7fffff;
				}
				if (bolUnderflow) {
					u32AddDest = 0x800000;
				}
			}
		}
		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;

		break;
	}
}
/*found*****************************************************************
 ��������		SigmaQRHH

 ��Ӧָ����ʽ:  SACCs = Sigma_b4(Rn+1:n��HHSTABn(d))
 SACCs += Sigma_b4(Rn+1:n��HHSTABn(d))

 ����:		Rn+1:n�ֳ�16��4λ��, �ֱ���TAB(d)�ĸ�16λ����-1����ָ������֮���ۼӣ����������Ĵ���SACCs ��
 SACCs=Rn[3:0] ���-1��^TAB[16]+ Rn[7:4] ���-1��^TAB[17] + �� + Rn[31:28] ���-1��^TAB[23]+Rn+1[3:0] ���-1��^TAB[24]
 + Rn[7:4] ���-1��^TAB[25] + �� + Rn[31:28] ���-1��^TAB[31]��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_b64Src -- ��Ӧ�Ĵ���Rn+1:n��
 u32Low -- Rn
 u32High -- Rn+1
 p_u32tab -- ��ӦSTABn(d)��
 p_bolAcc -- �����Ƿ���SACC�е�ֵ�ۼӡ�
 true -- ��SACC�е�ֵ�ۼӡ�
 false -- ����SACC�е�ֵ�ۼӡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SigmaQRHH(DSP_BIT64 &p_SACC, const DSP_BIT64 &p_b64Src, DSPU32 p_u32tab, bool p_bolAcc, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	int OpBits = 24;

	DSPU32 u2Scr = 0, j = 0, k=0;
	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest;
	u32Stab = p_u32tab;

	//^ָ������
	// SACCs=Rm[3:0] ���-1��^TAB[16]+ Rm[7:4] ���-1��^TAB[17] + �� + Rm[31:28] ���-1��^TAB[23]+Rm+1[3:0] ���-1��^TAB[24]+ Rm+1[7:4] ���-1��^TAB[25] + �� + Rm+1[31:28] ���-1��^TAB[31]��
	for (int i = 0; i < 16; i++) {

		if (i<8) {
			u2Scr = (p_b64Src.u32Low >> (4*i)) & 0xf;
		} else {
			j = i-8;
			u2Scr = (p_b64Src.u32High >> (4*j)) & 0xf;

		}
		//TAB[i]��ӦλΪ1,����Ϊ-1��ʵ�ʲ����Ǽ���
		k = i+16;
		if (TestBit(u32Stab,k)) {
			u32Dest -= u2Scr;
		}
		//TAB[i]��ӦλΪ0,����Ϊ1��ʵ�ʲ����Ǽӷ�
		else if (!TestBit(u32Stab,k)) {
			u32Dest += u2Scr;
		}
	}
	
		bool bolSrc1Sign= false;
		bool bolSrc2Sign= false;
		bool bolDestSign= false;
		//�з��Ž�λ��־��������״̬�Ĵ���
		bool bolOverflow = false;
		bool bolUnderflow = false;

		//�޷��Ž�λ��־
		bool bolCarryFlag = false;

		bool bolUnsignedOverflow = false;
		bool bolSigned= true;

		

	switch (p_bolAcc) {
	//SACCs = Sigma_b1(Rm��STABn(SC))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);
		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);
		bolDestSign= TestBit(u32AddDest, OpBits - 1);

		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;


		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		bolUnsignedOverflow = bolCarryFlag;
		

		if (bolOverflow || bolUnderflow) {
			SetFlag(*p_pStatReg,SHF_OverFlow);
			SetFlag(*p_pStatReg,SHF_FOverFlow);
			SetFlag(*p_pStatReg,SHF_SOVS);
			SetFlag(*p_pStatReg,SHF_SFVS);	

			if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)) {			
				if (bolOverflow) {
					u32AddDest = 0x7fffff;
				}
				if (bolUnderflow) {
					u32AddDest = 0x800000;
				}
			}
		}

		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;
		break;
	}
}
/*found*****************************************************************
 ��������		SigmaQRLH

 ��Ӧָ����ʽ:  SACCs = Sigma_b4 (Rn+1:n��LHSTABn(d))
 SACCs += Sigma_b4(Rn+1:n��LHSTABn(d))

 ����:		Rn+1:n�ֳ�16��4λ��, �ֱ���TAB(d)�ĵ�16λ����-1����ָ������֮���ۼӣ����������Ĵ���SACCs ��
 SACCs=Rn[3:0] ���-1��^TAB[0]+ Rn[7:4] ���-1��^TAB[1] + �� + Rn[31:28] ���-1��^TAB[7]+Rn+1[3:0] ���-1��^TAB[8]
 + Rn[7:4] ���-1��^TAB[9] + �� + Rn[31:28] ���-1��^TAB[15]��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_b64Src -- ��Ӧ�Ĵ���Rn+1:n��
 u32Low -- Rn
 u32High -- Rn+1
 p_u32tab -- ��ӦSTABn(d)��
 p_bolAcc -- �����Ƿ���SACC�е�ֵ�ۼӡ�
 true -- ��SACC�е�ֵ�ۼӡ�
 false -- ����SACC�е�ֵ�ۼӡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SigmaQRLH(DSP_BIT64 &p_SACC, const DSP_BIT64 &p_b64Src, DSPU32 p_u32tab, bool p_bolAcc, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	int OpBits = 24;

	DSPU32 u2Scr = 0, j = 0;
	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest = 0;
	u32Stab = p_u32tab;


	//^ָ������
	// SACCs=Rm[3:0] ���-1��^TAB[16]+ Rm[7:4] ���-1��^TAB[17] + �� + Rm[31:28] ���-1��^TAB[23]+Rm+1[3:0] ���-1��^TAB[24]+ Rm+1[7:4] ���-1��^TAB[25] + �� + Rm+1[31:28] ���-1��^TAB[31]��
	for (int i = 0; i < 16; i++) {

		if (i<8) {
			u2Scr = (p_b64Src.u32Low >> (4*i)) & 0xf;
		} else {
			j = i-8;
			u2Scr = (p_b64Src.u32High >> (4*j)) & 0xf;

		}
		//TAB[i]��ӦλΪ1,����Ϊ-1��ʵ�ʲ����Ǽ���		
		if (TestBit(u32Stab,i)) {
			u32Dest -= u2Scr;
		}
		//TAB[i]��ӦλΪ0,����Ϊ1��ʵ�ʲ����Ǽӷ�
		else if (!TestBit(u32Stab,i)) {
			u32Dest += u2Scr;
		}
	}
	
	bool bolSrc1Sign= false;
	bool bolSrc2Sign= false;	

	bool bolDestSign= false;	
	bool bolOverflow = false;
	bool bolUnderflow = false;

		//�޷��Ž�λ��־
	bool bolCarryFlag = false;
	bool bolUnsignedOverflow = false;
	bool bolSigned= true;

	switch (p_bolAcc) {
	//SACCs = Sigma_b1(Rm��STABn(SC))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);
		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);

		bolDestSign= TestBit(u32AddDest, OpBits - 1);
		//�з��Ž�λ��־��������״̬�Ĵ���
		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		//�޷��Ž�λ��־
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		bolUnsignedOverflow = bolCarryFlag;
		
		if (bolOverflow || bolUnderflow) {
			SetFlag(*p_pStatReg,SHF_OverFlow);
			SetFlag(*p_pStatReg,SHF_FOverFlow);
			SetFlag(*p_pStatReg,SHF_SOVS);
			SetFlag(*p_pStatReg,SHF_SFVS);	
			if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)) {
				
				if (bolOverflow) {
					u32AddDest = 0x7fffff;
				}
				if (bolUnderflow) {
					u32AddDest = 0x800000;
				}
			}
		}
		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;
		
		break;
	}
}
/*found*****************************************************************

 ��������		TABToReg

 ��Ӧָ����ʽ:  
 Rs = STABn(LLORm)(k)
 Rs = STABn(HLORm)(k)
 Rs = STABn(LHORm)(k)
 Rs = STABn(HHORm)(k)

 ����:TAB����λ���ڲ���Ӧ��RAM��4����λ����ÿ����λ����Ӧһ��TAB���ò���k��ʾ���֡�ÿ����λ������4��8bitRAM,
 ÿ��8bitRAM��Ϊ4�飨�ò���n{0��1��2��3}��ʾ���������4*4*256*8bit��
 ΢����Rs = STABn(LLORm)(k)��ָ��壺��Rm[7:0]Ϊ��ַ��ͬʱ��TABk�洢��4��RAM�еĵ�n��λ�ö��һ��32λ���ݸ���Ŀ�ļĴ�����Rs��
 ΢����Rs = STABn(HLORm)(k)��ָ��壺��Rm[15:8]Ϊ��ַ��ͬʱ��TABk�洢��4��RAM�еĵ�n��λ�ö��һ��32λ���ݸ���Ŀ�ļĴ�����Rs��
 ΢����Rs = STABn(LHORm)(k)��ָ��壺��Rm[23:16]Ϊ��ַ��ͬʱ��TABk�洢��4��RAM�еĵ�n��λ�ö��һ��32λ���ݸ���Ŀ�ļĴ�����Rs��
 ΢����Rs = STABn(HHORm)(k)��ָ��壺��Rm[31:24]Ϊ��ַ��ͬʱ��TABk�洢��4��RAM�еĵ�n��λ�ö��һ��32λ���ݸ���Ŀ�ļĴ�����Rs��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- Rs = STABn(LLORm)(k)
 1 -- Rs = STABn(HLORm)(k)
 2 -- Rs = STABn(LHORm)(k)
 3 -- Rs = STABn(HHORm)(k)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 
 *******************************************************************/
extern DSPU32 TABToReg(DSPU32 p_u32Rm, SHF_RAM *p_pRAM, DSPU32 p_u32N,
		DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU32 u32Dest;
	//a.1 ���ģʽȡֵ������arrElem��column
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;

	u32ArrRow = (p_u32N>>14)&0x3;//ȡSRAM�е�ֵ

	//ȡ��ͬ��ֵַ
	switch (p_u32Mode) {
	case 0:
		u32ArrColumn = p_u32Rm & 0xff;//Rm[7:0]Ϊ��ַ
		u32Dest = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];
		break;
	case 1:
		u32ArrColumn = (p_u32Rm >> 8) & 0xff;//Rm[15:8]Ϊ��ַ
		u32Dest = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];
		break;
	case 2:
		u32ArrColumn = (p_u32Rm >> 16) & 0xff;//Rm[23:16]Ϊ��ַ
		u32Dest = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];
		break;
	case 3:
		u32ArrColumn = (p_u32Rm >> 24) & 0xff;//Rm[31:24]Ϊ��ַ	
		u32Dest = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];
		break;
	}
	return u32Dest;
}

/*found*****************************************************************
 ��������		HRegToTAB

 ��Ӧָ����ʽ:  
 HSTABn(HORs) = HRm(k)
 HSTABn(LORs) = HRm(k)

 ����:		΢����HSTABn(HORs) = HRm(k)��ָ��壺Rm�Ĵ������ݷ�Ϊ2��16λ���ݣ�ÿһ�����ݴ��ŵĵ�ַΪRs�Ĵ����ڶ�Ӧ��2��8λ���ݹ��ɵĵ�ַ��
 ��TAB�洢���ж�Ӧ��λ��Ϊn����ָ���ĺ����ǽ�Rn��2��16λ���ݴ浽TAB�洢��4��RAM�еĶ�Ӧ�ĵ�ַ�ϡ���������Rm[15:0]��Ӧ��
 ��ַΪRs[23:16]����Ӧ��0���͵�1��RAM����������Rm[31:16]��Ӧ�ĵ�ַΪRs[31:24]����Ӧ��2���͵�3��RAM��
 ΢����HSTABn(LORs) = HRm(k)��ָ��壺Rm�Ĵ������ݷ�Ϊ2��16λ���ݣ�ÿһ�����ݴ��ŵĵ�ַΪRs�Ĵ����ڶ�Ӧ��2��8λ���ݹ��ɵĵ�ַ��
 ��TAB�洢���ж�Ӧ��λ��Ϊn����ָ���ĺ����ǽ�Rn��2��16λ���ݴ浽TAB�洢��4��RAM�еĶ�Ӧ�ĵ�ַ�ϡ���������Rm[15:0]��Ӧ��
 ��ַΪRs[7:0]����Ӧ��0���͵�1��RAM����������Rm[31:16]��Ӧ�ĵ�ַΪRs[15:8]����Ӧ��2���͵�3��RAM��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rs -- ��Ӧ�Ĵ���Rs��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- HSTABn(HORs) = HRm(k)
 1 -- HSTABn(LORs) = HRm(k)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void HRegToTAB(DSPU32 p_u32Rm, DSPU32 p_u32Rs, SHF_RAM *p_pRAM,
		DSPU32 p_u32N, DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU32 u32RmLow;
	DSPU32 u32RmHgh;

	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;

	u32ArrRow = (p_u32N>>14)&0x3;

	u32RmLow = (p_u32Rm &0xffff);//Rm�ĵ�16λ����
	u32RmHgh = ((p_u32Rm >> 16)&0xffff);//Rm�ĸ�16λ����

	switch (p_u32Mode) {

	//����Rm[15:0]��Ӧ�ĵ�ַΪRs[23:16]����Ӧ��0���͵�1��RAM��
	//��������Rm[31:16]��Ӧ�ĵ�ַΪRs[31:24]����Ӧ��2���͵�3��RAM��
	case 0:

		//���ŵ�16λ����
		//����Rm[15:0]��Ӧ�ĵ�ַΪRs[23:16]����Ӧ��0���͵�1��RAM��
		u32ArrColumn = ((p_u32Rs >> 16) & 0xff);

		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &= 0x0000ffff;//��Ӧ��0���͵�1��RAM��0
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= (u32RmLow<<16);//��Ӧ��0���͵�1��RAM��

		//���Ÿ�16λ����
		//����Rm[31:16]��Ӧ�ĵ�ַΪRs[31:24]����Ӧ��2���͵�3��RAM��
		u32ArrColumn = ((p_u32Rs >> 24) & 0xff);
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &= 0xffff0000;//��Ӧ��2���͵�3��RAM��0
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u32RmHgh;//��Ӧ��2���͵�3��RAM��

		break;

		//����Rm[15:0]��Ӧ�ĵ�ַΪRs[7:0]����Ӧ��0���͵�1��RAM��
		//��������Rm[31:16]��Ӧ�ĵ�ַΪRs[15:8]����Ӧ��2���͵�3��RAM��
	case 1:
		//���ŵ�16λ����
		//����Rm[15:0]��Ӧ�ĵ�ַΪRs[7:0]
		u32ArrColumn = p_u32Rs & 0xff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &= 0x0000ffff;//��Ӧ��0���͵�1��RAM��0
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= (u32RmLow<<16);//��Ӧ��0���͵�1��RAM��
		//���Ÿ�16λ����
		//����Rm[31:16]��Ӧ�ĵ�ַΪRs[15:8]
		u32ArrColumn = (p_u32Rs >> 8) & 0xff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &= 0xffff0000;//��Ӧ��2���͵�3��RAM��0
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u32RmHgh;//��Ӧ��2���͵�3��RAM��

		break;
	}
}

/*found*****************************************************************
 ��������		TABToHReg

 ::finish by baohua 2012.9.7
 ��Ӧָ����ʽ:  HRs = nHTABk(H0Rm)
 HRs = nHTABk(L0Rm)

 ����:		TAB����λ���ڲ���Ӧ��RAM��4����λ����ÿ����λ����Ӧһ��TAB���ò���k��ʾ���֡�ÿ����λ������4��8bitRAM,
 ÿ��8bitRAM��Ϊ4�飨�ò���n{0��1��2��3}��ʾ���������4*4*256*8bit��
 ΢����HRs = nTABk{H0Rm}��ָ��壺Rm�Ĵ���Ϊ32λ���ݣ��ֳ�4��8λ������Rm[31:24]��Rm[23:16]�ֱ�����ַ��
 ��TABk�洢��4��RAM�еĵ�n��λ�ö��2��16λ���ݸ���Ŀ�ļĴ���Rs�����е�0��1��RAM�Ķ��ַ��ΪRm[23:16]
 ���������������Rs�ĵ�16λ����2��3��RAM�Ķ��ַ��ΪRm[31:24]�����������������Rs�ĸ�16λ��
 ΢����HRs = nTABk{L0Rm}��ָ��壺Rm�Ĵ���Ϊ32λ���ݣ��ֳ�4��8λ������Rm[15:8]��Rm[7:0]�ֱ�����ַ��
 ��TABk�洢��4��RAM�еĵ�n��λ�ö��2��16λ���ݸ���Ŀ�ļĴ���Rs�����е�0��1��RAM�Ķ��ַ��ΪRmRm[7:0]
 ���������������Rs�ĵ�16λ����2��3��RAM�Ķ��ַ��ΪRm[15:8]�����������������Rs�ĸ�16λ��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- HRs = nHTABk(H0Rm)
 1 -- HRs = nHTABk(L0Rm)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 TABToHReg(DSPU32 p_u32Rm, SHF_RAM *p_pRAM, DSPU32 p_u32N,
		DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	//״̬�Ĵ����ı���
	

	DSPU32 u32Dest = 0;
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;

	u32ArrRow = (p_u32N>>14)&0x3;

	switch (p_u32Mode) {
	//SRAM���ı���Ŀǰ���մ���->�Ұ���0��1��2��3�����Ž��б��ţ�ָ���û������
	//�ñ�����SARM�����ݴ�����
	//��0��1��RAM�Ķ��ַ��ΪRm[23:16]���������������Rs�ĵ�16λ
	//��2��3��RAM�Ķ��ַ��ΪRm[31:24]�����������������Rs�ĸ�16λ
	case 0:

		//�����ڵ�16λ����		
		//ȡ��ʱ��ÿ��ȡ��32λ�����洢��ʱ��Ҳ��һ�δ�32λ
		//����Rs[15:0]��Ӧ�ĵ�ַΪRm[23:16]��ȡ����Կ�0��1����Ӧ�洢�����ĸ�16λ
		u32ArrColumn = (p_u32Rm >> 16) & 0xff;
		u32Dest = (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>16)&0xffff);//��0��1,��16λ	�����Ǵ��Ÿ�16λ

#ifdef STABTEST
#ifdef		STABLIM
		if ((p_u32Rm ==0x00000001) ||(p_u32Rm ==0x80000000)||(p_u32Rm
						==0x7fffffff)||(p_u32Rm ==0x00001000)) {
#endif
			//cout<<hex<<"mode0 Rs[15:0] "<<"r,u32ArrRow: "<<u32ArrRow<<endl;
			//cout<<hex<<"r��u32ArrColumn: "<<u32ArrColumn<<endl;
			//cout<<hex<<"r��p_pRAM->arrElem[u32ArrRow][u32ArrColumn]: "
			//<<p_pRAM->arrElem[u32ArrRow][u32ArrColumn]<<endl;

			//cout<<hex<<"r��u32Dest: "<<u32Dest<<endl;
#ifdef		STABLIM
		}
#endif
#endif
		//�����ڸ�16λ����
		//ȡ��ʱ��ÿ��ȡ��32λ�����洢��ʱ��Ҳ��һ�δ�32λ
		//Rs��[31��16]��Ӧ�ĵ�ַΪ[31:24]��ȡ����Կ�2��3����Ӧ�洢�����ĵ�16λ
		u32ArrColumn = (p_u32Rm >> 24) & 0xff;
		u32Dest |= (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn] )&0xffff)<<16);//��2��3����16λ

#ifdef STABTEST
#ifdef		STABLIM
		if ((p_u32Rm ==0x00000001) ||(p_u32Rm ==0x80000000)||(p_u32Rm
						==0x7fffffff)||(p_u32Rm ==0x00001000)) {
#endif
			//cout<<hex<<"mode0 Rs��[31��16] "<< "r��u32ArrRow: "<<u32ArrRow<<endl;
			//cout<<hex<<"r��u32ArrColumn: "<<u32ArrColumn<<endl;
			//cout<<hex<<"r��p_pRAM->arrElem[u32ArrRow][u32ArrColumn]: "
			//<<p_pRAM->arrElem[u32ArrRow][u32ArrColumn]<<endl;
			//cout<<hex<<"r��u32Dest: "<<u32Dest<<endl<<endl;
#ifdef		STABLIM
		}
#endif
#endif
		break;

		//��0��1��RAM�Ķ��ַ��ΪRm[7:0]���������������Rs�ĵ�16λ
		//��2��3��RAM�Ķ��ַ��ΪRm[15:8]�����������������Rs�ĸ�16λ
	case 1:
		//���ŵ�16λ����
		//����Rs[15:0]��Ӧ�ĵ�ַΪRm[7:0],ȡ����Կ�0��1����Ӧ�洢�����ĸ�16λ
		u32ArrColumn = p_u32Rm & 0xff;
		u32Dest = (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>16)&0xffff);
#ifdef STABTEST
		//��0��1,��16λ
#ifdef		STABLIM
		if ((p_u32Rm ==0x00000001) ||(p_u32Rm ==0x80000000)||(p_u32Rm
						==0x7fffffff)||(p_u32Rm ==0x00001000)) {
#endif
			//cout<<hex<<"mode1 Rs[15:0] "<<"r��u32ArrRow: "<<u32ArrRow<<endl;
			//cout<<hex<<"r��u32ArrColumn: "<<u32ArrColumn<<endl;
			//cout<<hex<<"r��p_pRAM->arrElem[u32ArrRow][u32ArrColumn]: "
			//<<p_pRAM->arrElem[u32ArrRow][u32ArrColumn]<<endl;

			//cout<<hex<<"r��u32Dest: "<<u32Dest<<endl;
#ifdef		STABLIM
		}
#endif
#endif
		//���Ÿ�16λ����
		//����Rs[31:16]��Ӧ�ĵ�ַΪRm[15:8]��ȡ����Կ�2��3����Ӧ�洢�����ĵ�16λ
		u32ArrColumn = (p_u32Rm >> 8) & 0xff;

		u32Dest |= (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn] )&0xffff)<<16);//��2��3����16λ���洢��Rs�ĸ�16λ
#ifdef STABTEST
#ifdef		STABLIM
		if ((p_u32Rm ==0x00000001) ||(p_u32Rm ==0x80000000)||(p_u32Rm
						==0x7fffffff)||(p_u32Rm ==0x00001000)) {
#endif
			//cout<<hex<<"mode1Rs[31:16] "<< "r��u32ArrRow: "<<u32ArrRow<<endl;
			//cout<<hex<<"r��u32ArrColumn: "<<u32ArrColumn<<endl;
			//cout<<hex<<"r��p_pRAM->arrElem[u32ArrRow][u32ArrColumn]: "
			//<<p_pRAM->arrElem[u32ArrRow][u32ArrColumn]<<endl;
			//cout<<hex<<"r��u32Dest: "<<u32Dest<<endl<<endl;
#ifdef		STABLIM
		}
#endif
#endif
		break;

	}
	return u32Dest;
}

/*found*****************************************************************
 ��������		ORegToTAB

 ��Ӧָ����ʽ:  
 OSTABn(ORs)  = ORm(U,k)
 OSTABn(ORs) += ORm(U,k)

 ����:		΢����OSTABn(ORs)  = ORm(U,k)��ָ��壺Rm�Ĵ������ݷ�Ϊ4��8λ���ݣ�ÿһ�����ݴ��ŵĵ�ַΪRs�Ĵ�����4��8λ���ݹ��ɵĵ�ַ��
 ��TAB�洢���ж�Ӧ��λ��Ϊn����ָ���ĺ����ǽ�Rn��4��8λ���ݴ浽TAB�洢��4��RAM�еĶ�Ӧ�ĵ�ַ��
 ģʽΪ11ʱ��΢����OSTABn(ORs) += ORm(U,k)��ָ��壺��TAB���4��8λ������Rm�е�4��8λ�����ӣ��������ص�TAB�洢���С�
 ���ӽ����Ƿ����ʹ����ɿ���״̬�Ĵ���ȷ��������Ӱ��������־λ��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rs -- ��Ӧ�Ĵ���Rs��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- OSTABn(ORs)  = ORm(U,k)
 1 -- OSTABn(ORs) += ORm(U,k)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�	
 
 *******************************************************************/
extern void ORegToTAB(DSPU32 p_u32Rm, DSPU32 p_u32Rs, SHF_RAM *p_pRAM,
		DSPU32 p_u32N, DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU8 u8Src0, u8Src1, u8Src2, u8Src3;
	DSPU8 u8Ram0, u8Ram1, u8Ram2, u8Ram3;
	DSPU8 u8Des0, u8Des1, u8Des2, u8Des3;

	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;
	u32ArrRow = p_u32N;

	bool bolSrc1Sign;
	bool bolSrc2Sign;
	bool bolDestSign;

	bool bolSatu;//����λ
	bool bolCarryFlag;
	bolSatu = TestBit(p_u32SHFCR,1);

	switch (p_u32Mode) {

	case 0:

		//��ַΪRs[7:0],��0����ӦRm�ĵ�8λ
		u32ArrColumn = p_u32Rs & 0xff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xffffff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= (p_u32Rm&0xff)<<24;//TAB0


		//��ַΪRs[15:8]
		u32ArrColumn = (p_u32Rs >> 8) & 0xff;
		
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xff00ffff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= ((p_u32Rm >> 8) & 0xff)<<16;//TAB1

		//��ַΪRs[23:16]
		u32ArrColumn = (p_u32Rs >> 16) & 0xff;
		
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xffff00ff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= ((p_u32Rm >> 16) & 0xff)<<8;//TAB2


		//��ַ��ΪRs[31:24]����ӦRm�ĸ�8λ
		u32ArrColumn = (p_u32Rs >> 24) & 0xff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xffffff00;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= ((p_u32Rm >> 24) & 0xff);//TAB3


		break;

		//��TAB���4��8λ������Rm�е�4��8λ�����ӣ��������ص�TAB�洢���С����ӽ����Ƿ����ʹ����ɿ���״̬�Ĵ���ȷ��������Ӱ��������־λ��
	case 1:
		u32ArrColumn = p_u32Rs & 0xff;
		u8Src0 = p_u32Rm&0xff;
		u8Ram0 = p_pRAM->arrElem[u32ArrRow][u32ArrColumn]>>24;

		u8Des0 = u8Src0 + u8Ram0;
		bolSrc1Sign = TestBit(u8Src0, 7);
		bolSrc2Sign = TestBit(u8Ram0, 7);
		bolDestSign = TestBit(u8Des0, 7);//�������Ӻ���Rs������λ

		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des0 = 0xff;
		}

		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xffffff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u8Des0<<24;

		u32ArrColumn = (p_u32Rs >> 8) & 0xff;
		u8Src1 = (p_u32Rm>>8)&0xff;
		u8Ram1 = ((p_pRAM->arrElem[u32ArrRow][u32ArrColumn]>>16)&0xff);//TAB1

		u8Des1 = u8Src1 + u8Ram1;

		bolSrc1Sign = TestBit(u8Src1, 7);
		bolSrc2Sign = TestBit(u8Ram1, 7);
		bolDestSign = TestBit(u8Des1, 7);//�������Ӻ���Rs������λ


		//�����޷��ţ�������λ�ͻᷢ������
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des1 = 0xff;
		}

		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xff00ffff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= (u8Des1<<16);//2013.7.16

		u32ArrColumn = (p_u32Rs >> 16) & 0xff;
		u8Src2 = (p_u32Rm>>16)&0xff;
		u8Ram2 = ((p_pRAM->arrElem[u32ArrRow][u32ArrColumn]>>8)&0xff);//TAB2
		

		u8Des2 = u8Src2 + u8Ram2;

		bolSrc1Sign = TestBit(u8Src2, 7);
		bolSrc2Sign = TestBit(u8Ram2, 7);
		bolDestSign = TestBit(u8Des2, 7);//�������Ӻ���Rs������λ

		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);



		//�޷��������ұ���������,��������ֵ
		if (bolCarryFlag) {

			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des2 = 0xff;
		}


		//���ɽ���
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xffff00ff;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u8Des2<<8;//2013.7.16

		u32ArrColumn = (p_u32Rs >> 24) & 0xff;
		u8Src3 = (p_u32Rm>>24)&0xff;
		u8Ram3 = ((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])&0xff);

		u8Des3 = u8Src3 + u8Ram3;

		//�����޷��ţ�������λ�ͻᷢ������
		bolSrc1Sign = TestBit(u8Src3, 7);
		bolSrc2Sign = TestBit(u8Ram3, 7);
		bolDestSign = TestBit(u8Des3, 7);//�������Ӻ���Rs������λ

		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);


		//�޷��������ұ���������,��������ֵ
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);
			if (bolSatu)
				u8Des3 = 0xff;
		}

		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] &=0xffffff00;
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u8Des3;//2013.7.16
		

		break;
	}
}

/*found*****************************************************************
 ��������		TABToOReg

 ::finish by baohua 2012.9.7
 ��Ӧָ����ʽ:  ORs = nOTABk(ORm)(U)
 ORs+= nOTABk(ORm)(U)

 ����:		TAB����λ���ڲ���Ӧ��RAM��4����λ����ÿ����λ����Ӧһ��TAB���ò���k��ʾ���֡�ÿ����λ������4��8bitRAM,
 ÿ��8bitRAM��Ϊ4�飨�ò���n{0��1��2��3}��ʾ���������4*4*256*8bit��
 ΢����ORs = nTABk{ORm}��ָ��壺Rm�Ĵ���Ϊ32λ���ݣ��ֳ�4��8λ������Rm�Ĵ���4��8λ���ݷֱ�����ַ��
 ��TABk�洢��4��RAM�еĵ�n��λ�ö��4��8λ���ݸ���Ŀ�ļĴ���Rs��
 ΢����ORs += nTABk{ORm}��ָ��壺Rm�Ĵ���Ϊ32λ���ݣ��ֳ�4��8λ������Rm�Ĵ���4��8λ���ݷֱ�����ַ��
 ��TABk�洢��4��RAM�еĵ�n��λ�ö��4��8λ���ݷֱ���Ŀ�ļĴ���Rs�е�4��8λ�������Ӻ󣬽�������Ŀ�ļĴ���Rs��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rs -- ��Ӧ�Ĵ���Rs�����Դ�����������
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- ORs = nOTABk(ORm)(U)
 1 -- ORs+= nOTABk(ORm)(U)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern int TABToORegBefore(DSPU32 p_u32Rm, DSPU32 p_u32Rs, SHF_RAM *p_pRAM,
		DSPU32 p_u32N, DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
		
	unsigned int OpBits = 8;

	DSPU32 u32ArrRow, u32ArrColumn, u32Dest = 0;
	u32ArrRow = (p_u32N>>14)&0x3;

	DSPU8 u8Res0, u8Res1, u8Res2, u8Res3;
	DSPU8 u8Ram0, u8Ram1, u8Ram2, u8Ram3;
	DSPU8 u8Des0, u8Des1, u8Des2, u8Des3;

	bool bolSrc1Sign;
	bool bolSrc2Sign;
	bool bolDestSign;

	bool bolSatu;
	bool bolCarryFlag;
	bolSatu = TestBit(p_u32SHFCR,1);

	switch (p_u32Mode) {

	case 0:

		u32ArrColumn = p_u32Rm & 0xff;

		u32Dest = ((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>24)&0xff;//TAB0

		u32ArrColumn = (p_u32Rm >> 8) & 0xff;
		u32Dest |= (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>16)&0xff)<<8;//TAB1

		u32ArrColumn = (p_u32Rm >> 16) & 0xff;
		u32Dest |= (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>8)&0xff)<<16;//TAB2

		u32ArrColumn = (p_u32Rm >> 24) & 0xff;
		u32Dest |= (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])&0xff) << 24);//TAB3

		break;

		//4��8λ������
	case 1:
		
		u32ArrColumn = p_u32Rm & 0xff;
		u8Res0 = p_u32Rs&0xff;
		
		u8Ram0 = (p_pRAM->arrElem[u32ArrRow][u32ArrColumn]>>24)&0xff;

		u8Des0 = u8Res0 + u8Ram0;

		bolSrc1Sign = TestBit(u8Res0, OpBits - 1);
		bolSrc2Sign = TestBit(u8Ram0, OpBits - 1);
		bolDestSign = TestBit(u8Des0, OpBits - 1);
		
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des0 = 0xff;
		}

		u32ArrColumn = (p_u32Rm >> 8) & 0xff;
		u8Res1 = (p_u32Rs>>8)&0xff;
		u8Ram1 = (p_pRAM->arrElem[u32ArrRow][u32ArrColumn]>>16)&0xff;

		u8Des1 = u8Res1 + u8Ram1;

		bolSrc1Sign = TestBit(u8Res1, OpBits - 1);
		bolSrc2Sign = TestBit(u8Ram1, OpBits - 1);
		bolDestSign = TestBit(u8Des1, OpBits - 1);


		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des1 = 0xff;
		}

		u32ArrColumn = (p_u32Rm >> 16) & 0xff;
		u8Res2 = (p_u32Rs>>16)&0xff;
		u8Ram2 = (p_pRAM->arrElem[u32ArrRow][u32ArrColumn]>>8)&0xff;

		u8Des2 = u8Res2 + u8Ram2;

		bolSrc1Sign = TestBit(u8Res2, OpBits - 1);
		bolSrc2Sign = TestBit(u8Ram2, OpBits - 1);
		bolDestSign = TestBit(u8Des2, OpBits - 1);

		
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des2 = 0xff;
		}
		
		u32ArrColumn = (p_u32Rm >> 24) & 0xff;
		u8Res3 = (p_u32Rs>>24)&0xff;
		u8Ram3 = ((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])&0xff);

		u8Des3 = u8Res3 + u8Ram3;

		
		bolSrc1Sign = TestBit(u8Res3, 7);
		bolSrc2Sign = TestBit(u8Ram3, 7);
		bolDestSign = TestBit(u8Des3, 7);

		
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
			SetFlag(*p_pStatReg, SHF_OV8BitS);

			if (bolSatu)
				u8Des3 = 0xff;
		}	

		u32Dest = (u8Des0)|(u8Des1<<8)|(u8Des2<<16)|(u8Des3<<24);

		break;

	}

	return u32Dest;
}

DSPU32 TABToOReg(DSPU32 p_u32tab, DSPU32 p_u32Rs, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){

	DSPU32 u32Dest = 0;

	DSPU8 u8Res0, u8Res1, u8Res2, u8Res3;
	DSPU8 u8Ram0, u8Ram1, u8Ram2, u8Ram3;
	DSPU8 u8Des0, u8Des1, u8Des2, u8Des3;

	bool bolSrc1Sign;
	bool bolSrc2Sign;
	bool bolDestSign;

	bool bolSatu;
	bool bolCarryFlag;
	bolSatu = TestBit(p_u32SHFCR,1);

	
	u8Res0 = p_u32Rs&0xff;
	u8Ram0 = p_u32tab&0xff;

	u8Des0 = u8Res0 + u8Ram0;

	bolSrc1Sign = TestBit(u8Res0, 7);
	bolSrc2Sign = TestBit(u8Ram0, 7);
	bolDestSign = TestBit(u8Des0, 7);//�������Ӻ���Rs������λ


	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);


	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des0 = 0xff;
	}

	u8Res1 = (p_u32Rs>>8)&0xff;
	u8Ram1 = (p_u32tab>>8)&0xff;
	u8Des1 = u8Res1 + u8Ram1;


	//���ñ�־λ
	bolSrc1Sign = TestBit(u8Res1, 7);
	bolSrc2Sign = TestBit(u8Ram1, 7);
	bolDestSign = TestBit(u8Des1, 7);//�������Ӻ���Rs������λ

	//�����޷��ţ�������λ�ͻᷢ������
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	//�޷��������ұ���������,��������ֵ
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des1 = 0xff;
	}


	u8Res2 = (p_u32Rs>>16)&0xff;
	u8Ram2 = (p_u32tab>>16)&0xff;
	u8Des2 = u8Res2 + u8Ram2;

	bolSrc1Sign = TestBit(u8Res2, 7);
	bolSrc2Sign = TestBit(u8Ram2,7);
	bolDestSign = TestBit(u8Des2, 7);

	
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des2 = 0xff;
	}

	u8Res3 = (p_u32Rs>>24)&0xff;
	u8Ram3 = (p_u32tab>>24)&0xff;
	u8Des3 = u8Res3 + u8Ram3;

	//���ñ�־λ
	bolSrc1Sign = TestBit(u8Res3, 7);
	bolSrc2Sign = TestBit(u8Ram3, 7);
	bolDestSign = TestBit(u8Des3, 7);

	//�����޷��ţ�������λ�ͻᷢ������
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	//�޷��������ұ���������,��������ֵ
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des3 = 0xff;
	}	
	u32Dest = (u8Des0)|(u8Des1<<8)|(u8Des2<<16)|(u8Des3<<24);

	return u32Dest;
}


DSPU32 OTABAccConst(DSPU32 p_u32tab, DSPU32 p_u32C, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	DSPU32 u32Dest = 0;

	DSPU8 u8Res0, u8Res1, u8Res2, u8Res3;
	DSPU8 u8Ram0, u8Ram1, u8Ram2, u8Ram3;
	DSPU8 u8Des0, u8Des1, u8Des2, u8Des3;

	bool bolSrc1Sign;
	bool bolSrc2Sign;
	bool bolDestSign;

	bool bolSatu;
	bool bolCarryFlag;
	bolSatu = TestBit(p_u32SHFCR,1);

	
	u8Res0 = p_u32C&0xff;
	u8Ram0 = p_u32tab&0xff;

	u8Des0 = u8Res0 + u8Ram0;

	bolSrc1Sign = TestBit(u8Res0, 7);
	bolSrc2Sign = TestBit(u8Ram0, 7);
	bolDestSign = TestBit(u8Des0, 7);

	
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des0 = 0xff;
	}

	u8Res1 = p_u32C&0xff;
	u8Ram1 = (p_u32tab>>8)&0xff;
	u8Des1 = u8Res1 + u8Ram1;

	
	bolSrc1Sign = TestBit(u8Res1, 7);
	bolSrc2Sign = TestBit(u8Ram1, 7);
	bolDestSign = TestBit(u8Des1, 7);

	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des1 = 0xff;
	}


	u8Res2 = p_u32C&0xff;
	u8Ram2 = (p_u32tab>>16)&0xff;
	u8Des2 = u8Res2 + u8Ram2;

	bolSrc1Sign = TestBit(u8Res2, 7);
	bolSrc2Sign = TestBit(u8Ram2,7);
	bolDestSign = TestBit(u8Des2, 7);

	
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des2 = 0xff;
	}

	u8Res3 = p_u32C&0xff;
	u8Ram3 = (p_u32tab>>24)&0xff;
	u8Des3 = u8Res3 + u8Ram3;

	
	bolSrc1Sign = TestBit(u8Res3, 7);
	bolSrc2Sign = TestBit(u8Ram3, 7);
	bolDestSign = TestBit(u8Des3, 7);

	
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des3 = 0xff;
	}	

	u32Dest = (u8Des0)|(u8Des1<<8)|(u8Des2<<16)|(u8Des3<<24);


	return u32Dest;
}

/*found*****************************************************************
 ��������		RegToTAB

 ��Ӧָ����ʽ:  
 STABn(LLORs) = Rm(k)
 STABn(HLORs) = Rm(k)
 STABn(LHORs) = Rm(k)
 STABn(HHORs) = Rm(k)

 ����:		Rm�Ĵ������ݷ�Ϊ4��8λ�޷������ݣ�ÿһ�����ݴ��ŵĵ�ַΪRs�Ĵ�����4��8λ���ݵ�ĳһ��(LLORs��HLORs��LHORs��HHORs)��
 ÿһ��TAB�洢����Ӧ��λ��Ϊn������Rm��4��8λ���ݴ浽4��RAMͬһ����ַ�ϡ�
 ����LLORs��ʾRs[7:0]��HLORs��ʾRs[15:8]��LHORs��ʾRs[23:16]��HHORs��ʾRs[31:24]��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rs -- ��Ӧ�Ĵ���Rs��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- STABn(LLORs) = Rm(k)
 1 -- STABn(HLORs) = Rm(k)
 2 -- STABn(LHORs) = Rm(k)
 3 -- STABn(HHORs) = Rm(k)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void RegToTAB(DSPU32 p_u32Rm, DSPU32 p_u32Rs, SHF_RAM *p_pRAM,
		DSPU32 p_u32N, DSPU32 p_u32Mode, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	

	//���ģʽȡֵ������arrElem��column
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;

	u32ArrRow = (p_u32N>>14)&0x3;//ȡ�е�ֵ

	switch (p_u32Mode) {
	//ʹ��Rs[7:0]Ѱַ
	case 0:
		u32ArrColumn = p_u32Rs & 0xff;//Rs[7:0]Ϊ��ַ
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] = p_u32Rm;
		break;
		//ʹ��Rs[15:8]Ѱַ
	case 1:
		u32ArrColumn = (p_u32Rs >> 8) & 0xff;//Rs[15:8]Ϊ��ַ
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] = p_u32Rm;
		break;
		//ʹ��Rs[23:16]Ѱַ
	case 2:
		u32ArrColumn = (p_u32Rs >> 16) & 0xff;//Rs[23:16]Ϊ��ַ
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] = p_u32Rm;
		break;
		//ʹ��Rs[31:24]Ѱַ
	case 3:
		u32ArrColumn = (p_u32Rs >> 24) & 0xff;//Rs[31:24]Ϊ��ַ	
		p_pRAM->arrElem[u32ArrRow][u32ArrColumn] = p_u32Rm;
		break;
	}

}

/*found*****************************************************************
 ��������		JLH_32

 ��Ӧָ����ʽ: Rs=Rm @* Rn(U)

 ����:			32λ�޷���������٤�޻��ˡ�

 ����:		p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 JLH_32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 polynomial,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	
	DSPU32 u32Dest = 0;
	u32Dest = gmpy(p_u32Src1, p_u32Src2, polynomial, 32);
	return u32Dest;
}

/*found*****************************************************************
 ��������		JLH_D16

 ��Ӧָ����ʽ: HRs=HRm @* HRn(U)

 ����:			16λ�޷���������٤�޻���

 ����:		p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 JLH_D16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 polynomial,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	
	DSPU32 u32DestHigh, u32DestLow, u32Dest;

	u32DestHigh = gmpy(p_u32Src1>>16, p_u32Src2>>16, polynomial, 16);
	u32DestLow= gmpy(p_u32Src1, p_u32Src2, polynomial, 16);

	u32Dest = ((u32DestHigh&0xffff)<<16)|(u32DestLow&0xffff);
	return u32Dest;
}

/*found*****************************************************************
 ��������		JLH_Q8

 ::finished by baohua
 ��Ӧָ����ʽ: ORs=ORm @*ORn(U)

 ����:			8λ�޷���������٤�޻���

 ����:		p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 JLH_Q8(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 polynomial,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU32 u32Dest0, u32Dest1, u32Dest2, u32Dest3, u32Dest;

	u32Dest0 = gmpy(p_u32Src1&0xff, p_u32Src2&0xff, polynomial, 8);
	u32Dest1 = gmpy((p_u32Src1>>8)&0xff, (p_u32Src2>>8)&0xff, polynomial, 8);
	u32Dest2 = gmpy((p_u32Src1>>16)&0xff, (p_u32Src2>>16)&0xff, polynomial, 8);
	u32Dest3 = gmpy((p_u32Src1>>24)&0xff, (p_u32Src2>>24)&0xff, polynomial, 8);

	u32Dest = ((u32Dest3&0xff)<<24) |((u32Dest2&0xff)<<16)|((u32Dest1&0xff)<<8)
			|(u32Dest0&0xff);
	return u32Dest;
}

/*found*****************************************************************
 ��������		SHF_SStar
 
 ��Ӧָ����ʽ:  ORs=ORm+1:m S*.OSACCk 

 ����:	  Rs[7..0]=(Rn[15..8]@*SACC[7..0]) XOR (Rn[23..16]@*SACC[15..8]) XOR
 (Rn[31..24]@*SACC[23..16] XOR (Rm[7..0]@*SACC[31..24])��Rs[15..8]=(Rn[23..16]@*SACC[7..0]) XOR (Rn[31..24]@*SACC[15..8]) XOR 
 (Rm[7..0]@*SACC[23..16] XOR (Rm[15..8]@*SACC[31..24])��Rs[23..16]=(Rn[31..24]@*SACC[7..0]) XOR (Rm[7..0]@*SACC[15..8]) XOR 
 (Rm[15..8]@*SACC[23..16] XOR (Rm[23..16]@*SACC[31..24])��
 Rs[31..24]=(Rm[7..0]@*SACC[7..0]) XOR (Rm[15..8]@*SACC[15..8]) XOR 
 (Rm[23..16]@*SACC[23..16] XOR (Rm[31..24]@*SACC[31..24])��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_Src -- 64λ���룬p_Src.Low32��ӦRm��p_Src.High32��ӦRm+1��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SHF_SStar(const DSP_BIT64 p_SACC, DSP_BIT64 p_Src,
		DSPU32 polynomial, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	

	DSPU32 u32SrcLow = p_Src.u32Low;
	DSPU32 u32SrcHgh = p_Src.u32High;
	DSPU32 u32SaccLow = p_SACC.u32Low;

	DSPU32 u32Temp1, u32Temp2, u32Temp3, u32Temp4;
	DSPU32 u32Dest7_0, u32Dest15_8, u32Dest23_16, u32Dest31_24, u32Dest;

	//u32Dest7_0
	u32Temp1 = JLH_Q8((u32SrcLow >> 8) & 0xff, u32SaccLow & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8((u32SrcLow >> 16) & 0xff, (u32SaccLow >> 8) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp3 = JLH_Q8((u32SrcLow >> 24) & 0xff, (u32SaccLow >> 16) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp4 = JLH_Q8(u32SrcHgh & 0xff, (u32SaccLow >> 24) & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);

	u32Dest7_0 = u32Temp1 ^ u32Temp2 ^ u32Temp3 ^ u32Temp4;

	////u32Dest15_8
	u32Temp1 = JLH_Q8((u32SrcLow >> 16) & 0xff, u32SaccLow & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8((u32SrcLow >> 24) & 0xff, (u32SaccLow >> 8) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp3 = JLH_Q8(u32SrcHgh & 0xff, (u32SaccLow >> 16) & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp4 = JLH_Q8((u32SrcHgh >> 8) & 0xff, (u32SaccLow >> 24) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);

	u32Dest15_8 = u32Temp1 ^ u32Temp2 ^ u32Temp3 ^ u32Temp4;

	//u32Dest23_16
	u32Temp1 = JLH_Q8((u32SrcLow >> 24) & 0xff, u32SaccLow & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8(u32SrcHgh & 0xff & 0xff, (u32SaccLow >> 8) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp3 = JLH_Q8((u32SrcHgh >> 8) & 0xff, (u32SaccLow >> 16) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp4 = JLH_Q8((u32SrcHgh >> 16) & 0xff, (u32SaccLow >> 24) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);

	u32Dest23_16 = u32Temp1 ^ u32Temp2 ^ u32Temp3 ^ u32Temp4;

	//u32Dest31_24
	u32Temp1 = JLH_Q8(u32SrcHgh & 0xff, u32SaccLow & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8((u32SrcHgh >> 8) & 0xff, (u32SaccLow >> 8) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp3 = JLH_Q8((u32SrcHgh >> 16) & 0xff, (u32SaccLow >> 16) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp4 = JLH_Q8((u32SrcHgh >> 24) & 0xff, (u32SaccLow >> 24) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);

	u32Dest31_24 = u32Temp1 ^ u32Temp2 ^ u32Temp3 ^ u32Temp4;

	u32Dest = (u32Dest7_0 & 0xff) | ((u32Dest15_8 & 0xff) << 8)
			| ((u32Dest23_16 & 0xff) << 16) | ((u32Dest31_24 & 0xff) << 24);

	return u32Dest;
}

/*found*****************************************************************
 ��������		SHF_SAt
 
 ��Ӧָ����ʽ:  ORs= ORm S@. OSACCk

 ����:	   Rs[7:0]=Rm[7:0]@*SACC[31:24];
 Rs[15..8]=(Rm[7..0]@*SACC[23..16]) XOR(Rm[15..8]@*SACC[31..24]);
 Rs[23..16]=(Rm[7..0]@*SACC[15..8]) XOR (Rm[15..8]@*SACC[23..16]) XOR (Rm[23..16]@*SACC[31..24]);
 Rs[31..24]=(Rm[7..0]@*SACC[7..0]) XOR (Rm[15..8]@*SACC[15..8]) XOR (Rm[23..16]@*SACC[23..16] XOR (Rm[31..24]@*SACC[31..24])��

 ����:		p_SACC -- 64λSACC�Ĵ�����
 p_u32Rm -- ����λ����������ӦRm��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SHF_SAt(const DSP_BIT64 p_SACC, DSPU32 p_u32Rm,
		DSPU32 polynomial, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	

	DSPU32 u32SrcRm = p_u32Rm;
	DSPU32 u32SaccLow = p_SACC.u32Low;

	DSPU32 u32Temp1, u32Temp2, u32Temp3, u32Temp4;
	DSPU32 u32Dest7_0, u32Dest15_8, u32Dest23_16, u32Dest31_24, u32Dest;

	//u32Dest7_0
	u32Dest7_0 = JLH_Q8(u32SrcRm & 0xff, (u32SaccLow >> 24) & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);

	//u32Dest15_8
	u32Temp1 = JLH_Q8(u32SrcRm & 0xff, (u32SaccLow >> 16) & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8((u32SrcRm >> 8) & 0xff, (u32SaccLow >> 24) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);

	u32Dest15_8 = u32Temp1 ^ u32Temp2;

	//u32Dest23_16
	u32Temp1 = JLH_Q8(u32SrcRm & 0xff, (u32SaccLow >> 8) & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8((u32SrcRm >> 8) & 0xff & 0xff, (u32SaccLow >> 16) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp3 = JLH_Q8((u32SrcRm >> 16) & 0xff, (u32SaccLow >> 24) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);

	u32Dest23_16 = u32Temp1 ^ u32Temp2 ^ u32Temp3;

	//u32Dest31_24
	u32Temp1 = JLH_Q8(u32SrcRm & 0xff, u32SaccLow & 0xff, polynomial,
			p_pStatReg, p_u32SHFCR);
	u32Temp2 = JLH_Q8((u32SrcRm >> 8) & 0xff, (u32SaccLow >> 8) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp3 = JLH_Q8((u32SrcRm >> 16) & 0xff, (u32SaccLow >> 16) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);
	u32Temp4 = JLH_Q8((u32SrcRm >> 24) & 0xff, (u32SaccLow >> 24) & 0xff,
			polynomial, p_pStatReg, p_u32SHFCR);

	u32Dest31_24 = u32Temp1 ^ u32Temp2 ^ u32Temp3 ^ u32Temp4;

	u32Dest = (u32Dest7_0 & 0xff) | ((u32Dest15_8 & 0xff) << 8)
			| ((u32Dest23_16 & 0xff) << 16) | ((u32Dest31_24 & 0xff) << 24);

	return u32Dest;

}

/******************************************************************
 ��������		CountZero32
 ָ�Rs= Rm cnt0 Rn

 ����:			ȷ��p_u32Src�дӵ͵��ߵ�p_u32Lenλ������0�ĸ�����

 ����:			p_u32Src -- Դ��������
 p_u32Len -- λ�����ȣ����ӵ͵��߹�p_u32Lenλ����ͳ�ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		0�ĸ�����

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 CountZero32(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
 
	p_u32Len = p_u32Len & 0x1f;

	DSPU32 u32Result = 0;

	for (DSPU32 i = 0; i < p_u32Len + 1; i ++) {
		if (!TestBit(p_u32Src, i)) {
			u32Result ++;
		}
	}

	return u32Result;
}

DSPU16 CountZero16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
		 
	p_u32Len = p_u32Len & 0xf;

	DSPU16 u16Result = 0;

	for (DSPU32 i = 0; i < p_u32Len + 1; i ++) {
		if (!TestBit(p_u32Src, i)) {
			u16Result ++;
		}
	}

	return u16Result;
}

/******************************************************************
 ��������		CountZeroD16

 ����:			ȷ��p_u32Src�иߵ�16λ�ӵ͵��ߵ�p_u32Lenλ������0�ĸ�����

 ����:			p_u32Src -- Դ������������ߵ�16λ���ݡ�
 p_u32Len -- λ�����ȣ����ӵ͵��߹�p_u32Lenλ����ͳ�ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		0�ĸ�������16λ��ͳ�ƽ������ڽ����ĵ�16λ�У���16λ��ͳ�ƽ���
 ���ڽ����ĸ�16λ�С�

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 CountZeroD16(DSPU32 p_u32Src, DSPU32 p_u32Len,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Len);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Len);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = CountZero16(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = CountZero16(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		CountOne32

 ����:			ȷ��p_u32Src�дӵ͵��ߵ�p_u32Lenλ������1�ĸ�����

 ����:			p_u32Src -- Դ��������
 p_u32Len -- λ�����ȡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		1�ĸ�����

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 CountOne32(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	p_u32Len = p_u32Len & 0x1f;

	DSPU32 u32Result = 0;

	for (DSPU32 i = 0; i < p_u32Len + 1; i ++) {
		if (TestBit(p_u32Src, i)) {
			u32Result ++;
		}
	}

	return u32Result;
}

DSPU16 CountOne16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	p_u32Len = p_u32Len & 0xf;

	DSPU16 u16Result = 0;

	for (DSPU32 i = 0; i < p_u32Len + 1; i ++) {
		if (TestBit(p_u32Src, i)) {
			u16Result ++;
		}
	}

	return u16Result;
}

/******************************************************************
 ��������		CountOneD16

 ����:			ȷ��p_u32Src�иߵ�16λ�ӵ͵��ߵ�p_u32Lenλ������1�ĸ�����

 ����:			p_u32Src -- Դ������������ߵ�16λ���ݡ�
 p_u32Len -- λ�����ȡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ;		1�ĸ�������16λ��ͳ�ƽ������ڽ����ĵ�16λ�У���16λ��ͳ�ƽ���
 ���ڽ����ĸ�16λ�С�

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 CountOneD16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Len);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Len);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = CountOne16(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = CountOne16(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		OnePosi32

 ����:			ȷ��p_u32Src�дӵ͵��ߵ�p_u32Lenλ������Ϊ1������λ��

 ����:			p_u32Src -- Դ��������
 p_u32Len -- λ�����ȣ����ӵ͵��߹�p_u32Lenλ����ͳ�ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		Ϊ1������λ��

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 OnePosi32(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	 
	p_u32Len = p_u32Len & 0x1f;

	DSPU32 u32Result = p_u32Len;
	DSPI32 i32Result = u32Result;
	//�Ӹ�λ��ʼ Ϊ0���Ҳ�������λʱ���� 
	while (!TestBit(p_u32Src, i32Result) && (i32Result >= 0)) {
		i32Result --;
	}

	return i32Result;
}

DSPU16 OnePosi16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	

	
	p_u32Len = p_u32Len & 0xf;

	DSPU16 u16Result = (DSPU16)p_u32Len;
	DSPI16 i16Result = (DSPI16)u16Result;
	
	while (!TestBit(p_u32Src, i16Result) && (i16Result >= 0)) {
		i16Result --;
	}

	return i16Result;
}

/******************************************************************
 ��������		OnePosiD16

 ����:			ȷ��p_u32Src�иߵ�16λ�ӵ͵��ߵ�p_u32Lenλ������Ϊ1������λ��

 ����:			p_u32Src -- Դ������������ߵ�16λ���ݡ�
 p_u32Len -- λ�����ȣ����ӵ͵��߹�p_u32Lenλ����ͳ�ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		Ϊ1������λ����16λ��ͳ�ƽ������ڽ����ĵ�16λ�У���16λ��ͳ�ƽ���
 ���ڽ����ĸ�16λ�С�

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 OnePosiD16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Len);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Len);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = OnePosi16(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = OnePosi16(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		Not32

 ����:			��32λ���ݵķǡ�

 ����:			p_u32Src -- 32λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Not32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	

	DSPU32 uDest = ~p_u32Src;

	return uDest;
}

/******************************************************************
 ��������		Xor32

 ����:			�����32λ���ݵ�������

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Xor32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	

	DSPU32 uDest = p_u32Src1 ^ p_u32Src2;

	return uDest;
}

/******************************************************************
 ��������		NOr32

 ����:			�����32λ���ݵĻ��ǡ�

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 NOr32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	

	DSPU32 uDest = ~(p_u32Src1 | p_u32Src2);

	return uDest;
}

/******************************************************************
 ��������		NAnd32

 ����:			�����32λ���ݵ����ǡ�

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 NAnd32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	

	DSPU32 uDest = ~(p_u32Src1 & p_u32Src2);

	return uDest;
}

/******************************************************************
 ��������		Or32

 ����:			�����32λ���ݵĻ���

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Or32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	

	DSPU32 uDest = p_u32Src1 | p_u32Src2;

	return uDest;
}

/******************************************************************
 ��������		And32

 ����:			�����32λ���ݵ��롣

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 And32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	

	DSPU32 uDest = p_u32Src1 & p_u32Src2;

	return uDest;
}

/******************************************************************
 ��������		Float16

 ����:			��16λ��������ת��Ϊ32λ�������ݡ�

 ����:			p_u16Src -- 16λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		32λ����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Float16(DSPU16 p_u16Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) { 

	DSPU16 u16Scr1 = p_u16Src;
	DSPU32 u32Scr1 = 0;
	DSPU32 f32Dest = 0;
	DSPU32 pStatReg = *p_pStatReg;
	bool Sign16Temp = false;
	if ((u16Scr1 & 0x8000) !=0) {
		Sign16Temp = true;
	}

	if (!Sign16Temp) {
		u32Scr1 = (DSPU32)u16Scr1;
	}

	if (Sign16Temp) {		
		u32Scr1 = 0xffff0000|(DSPU32)u16Scr1;
	}

	f32Dest = Float32(u32Scr1, 0, &pStatReg, p_u32SHFCR);
	*p_pStatReg = pStatReg;

	return f32Dest;

}

extern void FloatC16(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	
	
	DSPU16 u16SrcHigh = p_u32Src >> 16;
	DSPU16 u16SrcLow = p_u32Src&0xffff;

	DSPU32 StatRegHigh=*p_pStatReg, StatRegLow =*p_pStatReg;

	p_Rm_n.u32High = Float16(u16SrcHigh, &StatRegHigh, p_u32SHFCR);
	p_Rm_n.u32Low = Float16(u16SrcLow, &StatRegLow, p_u32SHFCR);

	*p_pStatReg = (StatRegHigh) | (StatRegLow);

}

/******************************************************************
 ��������		Abs32

 ����:			��32λ�������ľ���ֵ��

 ����:			p_u32Src -- Դ��������32λ�з���������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����				

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 2. Դ����������Ϊ���з�����, ����ʼ�����ʹ��� 

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Abs32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	

	      
	bool bolSrcSign= TestBit(p_u32Src, 31);
	bool u1Saturation = false;
	u1Saturation = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation); //

	DSPU32 uDest;
	if (bolSrcSign) {
		if (p_u32Src != 0x80000000) {
			uDest = -(DSPI32)p_u32Src;
		} else {
			if(u1Saturation){
				uDest = 0x7fffffff;
			}
			else{
				uDest = -(DSPI32)p_u32Src;
			}
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
		}

	} else {
		uDest = p_u32Src;
	}

	

	return uDest;
}

/******************************************************************
 ������:		    Abs16

 ����:			��16λ�������ľ���ֵ��

 ����:			p_u16Src -- Դ������(16λ�з�����).
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0.	
 p_u32SHFCR -- SHF���ƼĴ���, ����ʼ�����ʹ���				

 ����ֵ:		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 2. Դ����������Ϊ���з�������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU16 Abs16(DSPU16 p_u16Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	

	      
	bool bolSrcSign= TestBit(p_u16Src, 15);
	bool u1Saturation = false;//���Ϳ���λ 
	u1Saturation = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation); //

	DSPU16 uDest;
	if (bolSrcSign) {
		if (p_u16Src != 0x8000) {
			uDest = -p_u16Src;
		} else {
			if(u1Saturation){
				uDest = 0x7fff;
			}
			else{
				uDest = -(DSPI16)p_u16Src;
			}
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);

		}

	} else {
		uDest = p_u16Src;
	}
	return uDest;
}

/******************************************************************
 ��������		AbsD16

 ����:			�������ݵĸߵ�16λ�ֱ�������ֵ��

 ����:			p_u32Src -- Դ������������ߵ�16λ������з���������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����				

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 2. Դ����������Ϊ���з�������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 AbsD16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
	DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Abs16(u16UpperSrc, &UpperReg, p_u32SHFCR);
	DSPU16 u16LowerResult = Abs16(u16LowerSrc, &LowerReg, p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	if (TestBit(UpperReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);

		//[5]��λ
	}

	if (TestBit(LowerReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);

	}

	return u32Result;
}

/******************************************************************
 ��������		AbsFlo32

 ����:			��32λ�������ľ���ֵ��

 ����:			p_u32Src -- Դ��������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����				

 ����ֵ��		����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 AbsFlo32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	Cfloat32 cf32Src(p_u32Src);

	if (cf32Src.IsNAN()) {
		SetFlag(*p_pStatReg, SHF_FInvalid);
		SetFlag(*p_pStatReg, SHF_SFIS);
		return N_A_N;
	}

	if (cf32Src.IsINF()) {
		

		SetFlag(*p_pStatReg, SHF_FOverFlow);
		SetFlag(*p_pStatReg, SHF_SFVS);
		return MAX_NORM;
	}

	if (cf32Src.IsDNORM()) {
		cf32Src.SetZero();
	}

	return cf32Src.GetU32() & 0x7fffffff;
}
/******************************************************************
 ��������		PermuteCFix16

 ����:			16λ���㸴��ʵ���鲿������

 ����:			p_u32Src -- 16λ���㸴������16λ�鲿����16λʵ������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	
 p_bolNeg -- ��ʵ���鲿�����Ļ������Ƿ���Ҫ�󸺡�			

 ����ֵ��		16λ���㸴������16λ�鲿����16λʵ������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 PermuteCFix16(DSPU32 p_u32Src, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR, bool p_bolNeg) {
	
	
	DSP_CFix16 p_CFix16Src;

	p_CFix16Src.u32Value = p_u32Src;

	DSPU32 u32StatRegReal = 0, u32StatRegImag = 0;

	DSPU32 u32StatReg = 0;
	DSP_CFix16 cf16Result;

	if (p_bolNeg) {
		cf16Result.split.u16Real = Neg16(p_CFix16Src.split.u16Imag,
				&u32StatRegReal,p_u32SHFCR);
		cf16Result.split.u16Imag = Neg16(p_CFix16Src.split.u16Real,
				&u32StatRegImag,p_u32SHFCR);
	} else {
		cf16Result.split.u16Real = p_CFix16Src.split.u16Imag;
		cf16Result.split.u16Imag = p_CFix16Src.split.u16Real;
	}

	bool bolRealOverflow= TestBit(u32StatRegReal, SHF_OverFlow);
	bool bolImagOverflow= TestBit(u32StatRegImag, SHF_OverFlow);

	bool bolDestOverflow = bolRealOverflow || bolImagOverflow;

	u32StatReg = u32StatRegReal | u32StatRegImag;

	*p_pStatReg |= u32StatReg;

	if (bolDestOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
	}

	return cf16Result.u32Value;
}

/******************************************************************
 ��������		ConjCFix16

 ����:			��16λ���㸴���Ĺ��

 ����:			p_u32Src -- 16λ���㸴������16λ�鲿����16λʵ������
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	
 p_bolNeg -- ���������Ļ������Ƿ���Ҫ�󸺡�			

 ����ֵ��		16λ���㸴������16λ�鲿����16λʵ������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 ConjCFix16(DSPU32 p_u32Src, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR, bool p_bolNeg) {
	
	DSP_CFix16 p_CFix16Src;
	p_CFix16Src.u32Value = p_u32Src;

	DSPU32 u32StatRegReal = 0, u32StatRegImag = 0;

	DSPU32 u32StatReg;
	DSP_CFix16 cf16Result;

	if (p_bolNeg) {
		cf16Result.split.u16Real = Neg16(p_CFix16Src.split.u16Real,
				&u32StatRegReal,p_u32SHFCR);
		cf16Result.split.u16Imag = p_CFix16Src.split.u16Imag;
	} else {
		cf16Result.split.u16Real = p_CFix16Src.split.u16Real;
		cf16Result.split.u16Imag = Neg16(p_CFix16Src.split.u16Imag,
				&u32StatRegImag,p_u32SHFCR);
	}

	u32StatReg = u32StatRegReal |u32StatRegImag;

	*p_pStatReg |= u32StatReg;

	return cf16Result.u32Value;
}

/******************************************************************
 ��������		Float32

 ����:			��32λ��������ת��Ϊ32λ�������ݡ�

 ����:			p_u32Src -- 32λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		32λ����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
DSPU32 Float32(DSPU32 p_u32Src, DSPU32 p_u32Adjust, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR)

{
	DSPU32 u32Src = (DSPU32)p_u32Src;
	DSPU32 u32Exp = 0;
	DSPI32 i32ExpSum = 0;
	DSPU32 u32ExpInterval = 0;	
	DSPU32 u32ExpAmend = 0;
	DSPU32 u32BitOneLoc = 0;
	DSPU32 u8ShiftCnt = 0;
	DSPU32 f32Dest = 0;
	DSPU32 u32Frac = 0, u32Frac23 = 0, u32Frac24 = 0,u32TempFrac24 = 0;	

	bool u1Saturation= TestFlag(p_u32SHFCR ,SHF_Ctl_Saturation); 
	bool bolSignBit = false;
	bolSignBit = ((u32Src & 0x80000000) == 0x80000000) ? true : false;

	if (bolSignBit)
	{
		u32Src = ~u32Src+1;
	}

	for (int i = 31; i>-1; i--)
	{

		if (!(u32Src>>i)) {

			++u32ExpInterval; 
		}
		//1:stop 
		else {
			
			u32BitOneLoc = i;
			break; 
		}
	}

	u8ShiftCnt = u32ExpInterval+1;

	u32TempFrac24 = (u32Src<<u8ShiftCnt)>>8; 
	
	u32Frac24 = u32TempFrac24 + 1;
	u32Frac23 = u32Frac24 >> 1;
	

	if (u32TempFrac24==0xffffff) {
		u32ExpAmend += 1;
		u32Frac23 = 0;
		
	}
	
	if ((p_u32Adjust&0x80)==0) {
		i32ExpSum = 0x7f + u32BitOneLoc + (p_u32Adjust&0xff) + u32ExpAmend;
		

	}

	else if ((p_u32Adjust&0x80)==0x80) {
		i32ExpSum = 0x7f + u32BitOneLoc -((~p_u32Adjust+1)&0xff) + u32ExpAmend;//����2009.11.19 ����������0xff�ٱ��� 
	}

	
	if (u32Src == 0) {
		return 0;
	}
	
	else if (i32ExpSum <= 0) {
		
		SetFlag(*p_pStatReg, SHF_FUnderFlow);
		SetFlag(*p_pStatReg, SHF_SFUS);
		
		if (u1Saturation)
			return 0;//return imm
		
		if (!u1Saturation) {
			u32Exp = (DSPU8)(i32ExpSum & 0xff);
			u32Frac = u32Frac23; //��ȡʣ�µĸ�23λ
		}
	}

	//C��> = 255 
	else if (i32ExpSum >= 0xff) {
		
		SetFlag(*p_pStatReg, SHF_FOverFlow);
		SetFlag(*p_pStatReg, SHF_SFVS);
		
		if (u1Saturation) {
			u32Exp = 0xfe; 
			u32Frac = 0x7fffff;
		}		
		if (!u1Saturation) {
			u32Exp = (DSPU8)(i32ExpSum & 0xff);
			u32Frac = u32Frac23; 
		}
	}

	//((i32ExpSum > 0) &&(i32ExpSum < 0xff))
	else {
		u32Exp = (DSPU8)(i32ExpSum & 0xff);
		u32Frac = u32Frac23; //��ȡʣ�µĸ�23λ
	}

	f32Dest = (bolSignBit<<31)| (u32Exp << 23) |u32Frac;
	return f32Dest;
}

/******************************************************************
 ��������		Fix32

 ����:			��32λ��������ת��Ϊ32λ�������ݡ�

 ����:			p_u32Src -- 32λ�������ݡ�
 p_u32Exp -- ָ������������ָ��ֲᡣ
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- SHF���ƼĴ�����	

 ����ֵ��		32λ����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 ����4����������

 (1) ���� �� exp -sub >30
 (2) ���� �� exp -sub >31 
 (3) ���� �� exp -sub = 31 ,��ԭ24λ������800000
 (4) ��������������
 
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Fix32(DSPU32 p_u32Src, DSPU32 p_u32Adjust, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	bool u1Scr1Neg = false;
	bool u1Saturation = false;
	u1Saturation = TestFlag(p_u32SHFCR,SHF_Ctl_Saturation);
	Cfloat32 u32Src1(p_u32Src);

	DSPU32 u32Dest = 0;
	DSPU32 u32Src1Tmp = 0;
	
	DSPU64 u64Scr1TmpFrac = 0;

	u1Scr1Neg = false;
	if (u32Src1.GetNega()!=0) {
		u1Scr1Neg = true;
	}
	u32Src1Tmp = p_u32Src&0x7fffff; 
	u32Src1Tmp = u32Src1Tmp|0x800000; 
	u64Scr1TmpFrac = u32Src1Tmp;

	DSPI32 i32Exp = (DSPI32)(u32Src1.GetExp());
	DSPI32 i32ExpAjust = (DSPI8)(p_u32Adjust&0xff);


	DSPI32 i32DiffExp = i32Exp - i32ExpAjust -0x7f;


	if (u32Src1.IsDNORM() || u32Src1.IsZero()) {
		return 0;
	}

	if (u32Src1.IsNAN()) {
		SetFlag(*p_pStatReg, SHF_FInvalid);
		SetFlag(*p_pStatReg, SHF_SFIS);
		return N_A_N;
	}

	if ((p_u32Src == 0xff800000)||(p_u32Src == 0x7f800000)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
		
		if (p_u32Src == 0x7f800000) {
			
			if (u1Saturation)
				u32Dest = 0x7fffffff;

			
			if (!u1Saturation) {
				//2009.12.04
				if (i32DiffExp <=0) {
					u32Dest = 0;
				}

				else if (i32DiffExp <=54) {
					u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp) >>23;
					u32Dest = (DSPU32)u64Scr1TmpFrac;
				}

				else if (i32DiffExp >54) {
					u32Dest = 0;
				}
			}
		}
		
		if (p_u32Src == 0xff800000) {
			
			if (u1Saturation) {
				u32Dest = 0x80000000;
			}
			
			if (!u1Saturation) {
				//2009.12.04

				if (i32DiffExp <=0) {
					u32Dest = 0;
				}

				else if (i32DiffExp <=54) {
					u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
					u32Dest = (DSPU32)u64Scr1TmpFrac;
					u32Dest = ~u32Dest + 1;//LXM ������������ 
				}

				else if (i32DiffExp >54) {
					u32Dest = 0;
				}
			}
		}

		return u32Dest;
	}
	
	//1 
	if (i32Exp == 0) {
		u32Dest = 0;
	}

	//2
	if (i32DiffExp < 0) {
		return 0; //uDest = 0
	}
	//3 =0
	else if (i32DiffExp == 0) {
		//1 ����
		if (!u1Scr1Neg)
			return 0x1; //uDest = 1
		//2 ���� 
		if (u1Scr1Neg)
			return 0xffffffff;//-1 ,	//uDest = ~1+1; 
	}
	//4 <= 30
	else if (i32DiffExp <= 30) {
		//1 
		if (!u1Scr1Neg) {
			u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
			u32Dest = (DSPU32)u64Scr1TmpFrac;
		}
		//2  
		if (u1Scr1Neg) {
			u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
			u32Dest = (DSPU32)u64Scr1TmpFrac;
			u32Dest = ~u32Dest + 1;
		}
	}

	///5 >= 31
	else if ((i32DiffExp >= 31)&&(i32DiffExp <= 55 )) {
		
		if (!u1Scr1Neg) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);

			
			if (u1Saturation)
				u32Dest = 0x7fffffff;

			
			if (!u1Saturation) {
				u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
				u32Dest = (DSPU32)u64Scr1TmpFrac;
			}
		}

		if (u1Scr1Neg) {
	
			//A.
			if((u32Src1Tmp == 0x800000) && (i32DiffExp ==31)){
				
				if (u1Saturation){
					u32Dest = 0x80000000;
				}
				if (!u1Saturation){
					u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
					u32Dest = (DSPU32)u64Scr1TmpFrac;
					u32Dest = ~u32Dest + 1;
				}

			}
			//B:
			else if (u1Saturation) {
				u32Dest = 0x80000000;
				
				SetFlag(*p_pStatReg, SHF_OverFlow);
				SetFlag(*p_pStatReg, SHF_SOVS);
				SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
				SetFlag(*p_pStatReg, SHF_OV32BitS);
				

			}
			//C:
			else if (!u1Saturation) {

				u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
				u32Dest = (DSPU32)u64Scr1TmpFrac;
				u32Dest = ~u32Dest + 1;
				SetFlag(*p_pStatReg, SHF_OverFlow);
				SetFlag(*p_pStatReg, SHF_SOVS);
				SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
				SetFlag(*p_pStatReg, SHF_OV32BitS);
			}
		}
	}

	else if (i32DiffExp >= 55) {
		//1 
		if (!u1Scr1Neg) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);

			//A:
			if (u1Saturation)
				return 0x7fffffff;

			//B:
			if (!u1Saturation)
				return 0;
		}

		
		if (u1Scr1Neg) {

			//B 
			if (u1Saturation) {

				SetFlag(*p_pStatReg, SHF_OverFlow);
				SetFlag(*p_pStatReg, SHF_SOVS);
				SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
				SetFlag(*p_pStatReg, SHF_OV32BitS);
				return 0x80000000;
			}
			//C:
			if (!u1Saturation) {

				SetFlag(*p_pStatReg, SHF_OverFlow);
				SetFlag(*p_pStatReg, SHF_SOVS);
				SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
				SetFlag(*p_pStatReg, SHF_OV32BitS);
				return 0;
			}
		}

	}

	return u32Dest;
}




/******************************************************************
 ��������		Add16

 ����:			16λ�����������ӡ�

 ����:			p_u16Src1 -- Դ������1��
 p_u16Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ������λ���㡣


 �޸ļ�¼:   2007-8-6 : ɾ���˺���,��Ϊ�������add ��adc  

 --------------------------------------
 ����			����			�޸Ĵ�
 *******************************************************************/
extern DSPU16 Add16SHF(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	int OpBits = sizeof(p_u16Src1) * 8;

	
	bool bolSrc1Sign= TestBit(p_u16Src1, OpBits - 1);
	bool bolSrc2Sign= TestBit(p_u16Src2, OpBits - 1);
	
	DSPU16 uDest;
	uDest = p_u16Src1 + p_u16Src2;	
	

	bool bolDestSign= TestBit(uDest, OpBits - 1);
	
	bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
	bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

	
	bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	bool bolUnsignedOverflow = bolCarryFlag;

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed );
	if (bolSigned && (bolOverflow || bolUnderflow) || !bolSigned
			&& bolUnsignedOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);

	}

	unsigned int u2SatuMode = p_u32SHFCR & ( BIT(SHF_Ctl_Signed) | BIT(SHF_Ctl_Saturation) );
	
	switch (u2SatuMode) {
	case BaoHe_none:
	case BaoHe_none_unsigned:
		break;

	case BaoHe_signed:

		 
		if (bolOverflow) {
			uDest = MAX_SN(OpBits);
		}
		if (bolUnderflow) {
			uDest = MIN_SN(OpBits);
		}
		break;

	case BaoHe_unsigned:

		 
		if (bolUnsignedOverflow) {
			uDest = MAX_UN(OpBits);
		}
		break;

	}

	return uDest;
}

/******************************************************************
 ��������		Sub16

 ����:			16λ��������������

 ����:			p_u16Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����ָ�롣
 p_i32SMode -- ����ģʽ��
 BaoHe_none������ģʽ�رգ�
 BaoHe_signed���з������ı���ģʽ��
 BaoHe_unsigned���޷������ı���ģʽ��

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ������λ���㡣

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU16 Sub16SHF(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	int OpBits = 16;

	  

	
	p_u16Src2 = ~p_u16Src2;

	
	bool bolSrc1Sign= TestBit(p_u16Src1 , (OpBits - 1));
	bool bolSrc2Sign= TestBit(p_u16Src2 , (OpBits - 1));

	
	DSPU16 uDest;
	uDest = p_u16Src1 + p_u16Src2 + 1;

	

	bool bolDestSign= TestBit(uDest , (OpBits - 1));
	
	bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
	bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;
	bool bolOvfFlag = bolOverflow || bolUnderflow;

	
	bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	bool bolUnsingedOverflow = !bolCarryFlag;
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
	}

	unsigned int u2SatuMode = p_u32SHFCR & ( BIT(SHF_Ctl_Signed) | BIT(SHF_Ctl_Saturation) );
	
	switch (u2SatuMode) {
	case BaoHe_none:
	case BaoHe_none_unsigned:
		break;

	case BaoHe_signed:
		if (TestBit(*p_pStatReg, SHF_OverFlow)) {
			
			if (bolOverflow || ( !bolSrc1Sign && (p_u16Src2
					== (unsigned int)MIN_SN(OpBits)))) {
				uDest = MAX_SN(OpBits);
			} else {
				if (bolUnderflow) {
					uDest = MIN_SN(OpBits);
				}
			}
		}
		break;

	case BaoHe_unsigned:
		
		if (bolUnsingedOverflow) {
			uDest = 0;
		}
		break;

	}

	return uDest;
}

/******************************************************************
 ��������		AddD16SHF

 ����:			�������ݵĸߵ�16λ�ֱ������������ӡ�

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ�������ݡ�
 p_u32Src2 -- Դ������2�������ߵ����16λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AddD16SHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Add16SHF(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Add16SHF(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	if (TestBit(UpperReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
		
	}

	if (TestBit(LowerReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
		//[4]��λ
	}

	return u32Result;
}

/******************************************************************
 ��������		SubD16SHF

 ����:			�������ݵĸߵ�16λ�ֱ���������������

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ�������ݡ�
 p_u32Src2 -- Դ������2�������ߵ����16λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SubD16SHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Sub16SHF(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Sub16SHF(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	
	if (TestBit(UpperReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
		
	}

	if (TestBit(LowerReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
		SetFlag(*p_pStatReg, SHF_OV16BitS);
		
	}

	return u32Result;
}

DSPU8 Add8(DSPU8 p_u8Src1, DSPU8 p_u8Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	int OpBits = 8;


	bool bolSrc1Sign= TestBit(p_u8Src1, OpBits - 1);
	bool bolSrc2Sign= TestBit(p_u8Src2, OpBits - 1);
	
	DSPU8 uDest;
	uDest = p_u8Src1 + p_u8Src2;

	bool bolDestSign= TestBit(uDest, OpBits - 1);
	
	bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
	bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

	
	bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	bool bolUnsignedOverflow = bolCarryFlag;

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed );
	if (bolSigned && (bolOverflow || bolUnderflow) || !bolSigned
			&& bolUnsignedOverflow) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

	}

	unsigned int u2SatuMode = p_u32SHFCR & ( BIT(SHF_Ctl_Signed) | BIT(SHF_Ctl_Saturation) );
	
	switch (u2SatuMode) {
	case BaoHe_none:
	case BaoHe_none_unsigned:
		break;

	case BaoHe_signed:

		 
		if (bolOverflow) {
			uDest = MAX_SN(OpBits);
		}
		if (bolUnderflow) {
			uDest = MIN_SN(OpBits);
		}
		break;

	case BaoHe_unsigned:

		 
		if (bolUnsignedOverflow) {
			uDest = MAX_UN(OpBits);
		}
		break;

	}

	return uDest;
}

extern DSPU32 AddQ8SHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU8 u8UpperHighSrc1 = (DSPU8)(p_u32Src1 >> 24);
	DSPU8 u8UpperHighSrc2 = (DSPU8)(p_u32Src2 >> 24);
	
	DSPU8 u8UpperLowSrc1 = (DSPU8)(p_u32Src1 >> 16);
	DSPU8 u8UpperLowSrc2 = (DSPU8)(p_u32Src2 >> 16);
	
	DSPU8 u8LowerHighSrc1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU8 u8LowerHighSrc2 = (DSPU8)(p_u32Src2 >> 8);
	
	DSPU8 u8LowerLowSrc1 = (DSPU8)(p_u32Src1 );
	DSPU8 u8LowerLowSrc2 = (DSPU8)(p_u32Src2 );
	


	DSPU32 UpperHighReg = *p_pStatReg;
	DSPU32 UpperLowReg = *p_pStatReg;
	DSPU32 LowerHighReg = *p_pStatReg;
	DSPU32 LowerLowReg = *p_pStatReg;

	DSPU8 u8UpperHighResult = Add8(u8UpperHighSrc1, u8UpperHighSrc2, &UpperHighReg,p_u32SHFCR);
	DSPU8 u8UpperLowResult = Add8(u8UpperLowSrc1, u8UpperLowSrc2, &UpperLowReg,p_u32SHFCR);
	DSPU8 u8LowerHighResult = Add8(u8LowerHighSrc1, u8LowerHighSrc2, &LowerHighReg,p_u32SHFCR);
	DSPU8 u8LowerLowResult = Add8(u8LowerLowSrc1, u8LowerLowSrc2, &LowerLowReg,p_u32SHFCR);


	*p_pStatReg = UpperHighReg | UpperLowReg|LowerHighReg|LowerLowReg;

	DSPU32 u32Result = (((DSPU32)u8UpperHighResult) << 24)| (((DSPU32)u8UpperLowResult)<<16)|(((DSPU32)u8LowerHighResult)<<8)|((DSPU32)u8LowerLowResult);

	if (TestBit(UpperHighReg,0)|TestBit(UpperLowReg,0)|TestBit(LowerHighReg,0)||TestBit(LowerLowReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);
	}

	return u32Result;
}

DSPU8 Sub8(DSPU8 p_u8Src1, DSPU8 p_u8Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
		
	int OpBits = 8;
	DSPU8 u8Src1 = p_u8Src1;
	DSPU8 u8Src2 = ~p_u8Src2;
	
	bool bolSrc1Sign= TestBit(u8Src1 , (OpBits - 1));
	bool bolSrc2Sign= TestBit(u8Src2 , (OpBits - 1));

	
	DSPU8 uDest;
	uDest = p_u8Src1 + u8Src2 + 1;
	

	bool bolDestSign= TestBit(uDest , (OpBits - 1));
	
	bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
	bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;
	bool bolOvfFlag = bolOverflow || bolUnderflow;

	
	bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	bool bolUnsingedOverflow = !bolCarryFlag;
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);
	}

	unsigned int u2SatuMode = p_u32SHFCR & ( BIT(SHF_Ctl_Signed) | BIT(SHF_Ctl_Saturation) );
	
	switch (u2SatuMode) {
	case BaoHe_none:
	case BaoHe_none_unsigned:
		break;

	case BaoHe_signed:
		if (TestBit(*p_pStatReg, SHF_OverFlow)) {
			 
			if (bolOverflow || ( !bolSrc1Sign && (u8Src2
					== (unsigned int)MIN_SN(OpBits)))) {
				uDest = MAX_SN(OpBits);
			} else {
				if (bolUnderflow) {
					uDest = MIN_SN(OpBits);
				}
			}
		}
		break;

	case BaoHe_unsigned:
		 
		if (bolUnsingedOverflow) {
			uDest = 0;
		}
		break;

	}

	return uDest;
}

extern DSPU32 SubQ8SHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	DSPU8 u8UpperHighSrc1 = (DSPU8)(p_u32Src1 >> 24);
	DSPU8 u8UpperHighSrc2 = (DSPU8)(p_u32Src2 >> 24);
	
	DSPU8 u8UpperLowSrc1 = (DSPU8)(p_u32Src1 >> 16);
	DSPU8 u8UpperLowSrc2 = (DSPU8)(p_u32Src2 >> 16);
	
	DSPU8 u8LowerHighSrc1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU8 u8LowerHighSrc2 = (DSPU8)(p_u32Src2 >> 8);
	
	DSPU8 u8LowerLowSrc1 = (DSPU8)(p_u32Src1 );
	DSPU8 u8LowerLowSrc2 = (DSPU8)(p_u32Src2 );

	DSPU32 UpperHighReg = *p_pStatReg;
	DSPU32 UpperLowReg = *p_pStatReg;
	DSPU32 LowerHighReg = *p_pStatReg;
	DSPU32 LowerLowReg = *p_pStatReg;

	DSPU8 u8UpperHighResult = Sub8(u8UpperHighSrc1, u8UpperHighSrc2, &UpperHighReg,p_u32SHFCR);
	DSPU8 u8UpperLowResult = Sub8(u8UpperLowSrc1, u8UpperLowSrc2, &UpperLowReg,p_u32SHFCR);
	DSPU8 u8LowerHighResult = Sub8(u8LowerHighSrc1, u8LowerHighSrc2, &LowerHighReg,p_u32SHFCR);
	DSPU8 u8LowerLowResult = Sub8(u8LowerLowSrc1, u8LowerLowSrc2, &LowerLowReg,p_u32SHFCR);


	*p_pStatReg = UpperHighReg | UpperLowReg|LowerHighReg|LowerLowReg;

	DSPU32 u32Result = (((DSPU32)u8UpperHighResult) << 24)| (((DSPU32)u8UpperLowResult)<<16)|(((DSPU32)u8LowerHighResult)<<8)|((DSPU32)u8LowerLowResult);

	if (TestBit(UpperHighReg,0)|TestBit(UpperLowReg,0)|TestBit(LowerHighReg,0)||TestBit(LowerLowReg,0)) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);
	}
	
	return u32Result;
}

/******************************************************************
 ��������		AddD16CJSHF

 ����:			ʵ��16λ���㸴�����㣺(a + bi) + j(c + di)

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ��������(a + bi)����16λ�����鲿��
 p_u32Src2 -- Դ������2�������ߵ����16λ��������(c + di)����16λ�����鲿��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AddD16CJSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Sub16SHF(u16UpperSrc1, u16LowerSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Add16SHF(u16LowerSrc1, u16UpperSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		SubD16CJSHF

 ����:			ʵ��16λ���㸴�����㣺(a + bi) - j(c + di)

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ��������(a + bi)����16λ�����鲿��
 p_u32Src2 -- Դ������2�������ߵ����16λ��������(c + di)����16λ�����鲿��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SubD16CJSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Add16SHF(u16UpperSrc1, u16LowerSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Sub16SHF(u16LowerSrc1, u16UpperSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		Add16Half

 ����:			16λ�����������ӣ�����ƽ����

 ����:			p_u16Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����ָ�롣
 p_bolSigned -- �Ƿ�Ϊ�з�������
 true: �з�������
 false���޷�������
 p_i32TMode -- ���뷽ʽ��
 md_to_zero���������룬���ضϣ�
 md_to_nearest���������롣

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ������λ���㡣

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU16 Add16HalfSHF(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	bool bolSrc1LSB = p_u16Src1 & 0x1;
	bool bolSrc2LSB = p_u16Src2 & 0x1;

	DSPU16 uDest;
	uDest = (p_u16Src1 >> 1) + (p_u16Src2 >> 1);

	DSPU16 iDest;
	DSPI16 i16Src1Tmp = p_u16Src1;
	DSPI16 i16Src2Tmp = p_u16Src2;
	iDest = (i16Src1Tmp >> 1) + (i16Src2Tmp >> 1);

	if (bolSrc1LSB && bolSrc2LSB) {
		uDest += 1;
		iDest += 1;
	}

	
	DSPU32 u1TruncateMode= md_to_zero;
	
	if ( (u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB)
			&& (uDest & 0x1)) {
		uDest += 1;
		iDest += 1;
	}

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	if (bolSigned) {
		uDest = iDest;
	}	

	return uDest;
}

/******************************************************************
 ��������		Sub16Half

 ����:			16λ������������������ƽ����

 ����:			p_u16Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����ָ�롣
 p_bolSigned -- �Ƿ�Ϊ�з�������
 true: �з�������
 false���޷�������
 p_i32TMode -- ���뷽ʽ��
 md_to_zero���������룬���ضϣ�
 md_to_nearest���������롣

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ������λ���㡣

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU16 Sub16HalfSHF(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	int OpBits = 16;

	DSPU16 uOrignSrc2 = p_u16Src2;
	p_u16Src2 = ~p_u16Src2 + 1;

	bool bolSrc1LSB = p_u16Src1 & 0x1;
	bool bolSrc2LSB = p_u16Src2 & 0x1;

	DSPU16 uDest;
	uDest = (p_u16Src1 >> 1) + (p_u16Src2 >> 1);

	DSPU16 iDest;
	DSPI16 i16Src1Tmp = p_u16Src1;
	DSPI16 i16Src2Tmp = p_u16Src2;
	iDest = (i16Src1Tmp >> 1) + (i16Src2Tmp >> 1);

	if (bolSrc1LSB && bolSrc2LSB) {
		uDest += 1;
		iDest += 1;
	}

	
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolOvctr=  TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);

	
	DSPU32 u1TruncateMode= md_to_zero;

	if (bolSigned) {
		if (p_u16Src2 == 0x8000) {
			ClearBit(iDest,OpBits - 1);
		}
		if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB)
				&& (iDest & 0x1)) {
			iDest += 1;
		}
	} else {
		if (p_u16Src1 >= uOrignSrc2) {
			ClearFlag(uDest, OpBits - 1);
			if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB)
					&& (uDest & 0x1)) {
				uDest += 1;
			}
		} else {
			if (bolOvctr) 

			{
				uDest = 0;

			} 
			else {
				
				SetFlag(uDest, OpBits - 1);
				
			}
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
		}
	}

	if (bolSigned) {
		uDest = iDest;
	}

	//-----------д�ؼ�(WB��)����-----------------------        
	//һ������ �򱥺������¸��ݱ��ͽ���  ��������״̬�Ĵ���AZ��AN            

	return uDest;
}

/******************************************************************
 ��������		AddD16HalfSHF

 ����:			�������ݵĸߵ�16λ�ֱ������������ӣ�����ƽ����

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ�������ݡ�
 p_u32Src2 -- Դ������2�������ߵ����16λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AddD16HalfSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Add16HalfSHF(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Add16HalfSHF(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		SubD16HalfSHF

 ����:			�������ݵĸߵ�16λ�ֱ�������������������ƽ����

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ�������ݡ�
 p_u32Src2 -- Դ������2�������ߵ����16λ�������ݡ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SubD16HalfSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Sub16HalfSHF(u16UpperSrc1, u16UpperSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Sub16HalfSHF(u16LowerSrc1, u16LowerSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;

}

/******************************************************************
 ��������		AddD16HalfCJSHF

 ����:			ʵ��16λ���㸴�����㣺[(a + bi) + j(c + di)] / 2

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ��������(a + bi)����16λ�����鲿��
 p_u32Src2 -- Դ������2�������ߵ����16λ��������(c + di)����16λ�����鲿��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AddD16HalfCJSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Sub16HalfSHF(u16UpperSrc1, u16LowerSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Add16HalfSHF(u16LowerSrc1, u16UpperSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		SubD16HalfCJSHF

 ����:			ʵ��16λ���㸴�����㣺[(a + bi) - j(c + di)] / 2

 ����:			p_u32Src1 -- Դ������1�������ߵ����16λ��������(a + bi)����16λ�����鲿��
 p_u32Src2 -- Դ������2�������ߵ����16λ��������(c + di)����16λ�����鲿��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��
 ������������16λ������־�Ĵ�������Ϊ��ν�����������

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 SubD16HalfCJSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
	DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
	DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
	DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;

	DSPU16 u16UpperResult = Add16HalfSHF(u16UpperSrc1, u16LowerSrc2, &UpperReg,
			p_u32SHFCR);
	DSPU16 u16LowerResult = Sub16HalfSHF(u16LowerSrc1, u16UpperSrc2, &LowerReg,
			p_u32SHFCR);

	*p_pStatReg = UpperReg | LowerReg;

	DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16)
			| ((DSPU32)u16LowerResult);

	return u32Result;
}

/******************************************************************
 ��������		Add32SHF

 ����:			32λ�����������ӡ�

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Add32SHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	
	unsigned int OpBits = sizeof(p_u32Src1) * 8;

	
	bool bolSrc1Sign= TestBit(p_u32Src1, OpBits - 1);
	bool bolSrc2Sign= TestBit(p_u32Src2, OpBits - 1);


	DSPU32 uDest;
	uDest = p_u32Src1 + p_u32Src2;

	bool bolDestSign= TestBit(uDest, OpBits - 1);
	
	bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
	bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;
	bool bolOvfFlag = bolOverflow || bolUnderflow;

	
	bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	bool bolUnsingedOverflow = bolCarryFlag;

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow)) 
	{
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
	}

	unsigned int u2SatuMode = p_u32SHFCR & ( BIT(SHF_Ctl_Signed) | BIT(SHF_Ctl_Saturation) );
	
	switch (u2SatuMode) {
	case BaoHe_none:
	case BaoHe_none_unsigned:
		break;

	case BaoHe_signed:

		 
		if (bolOverflow) {
			uDest = MAX_SN(OpBits);
		}
		if (bolUnderflow) {
			uDest = MIN_SN(OpBits);
		}
		break;

	case BaoHe_unsigned:

		 
		if (bolUnsingedOverflow) {
			uDest = 0xffffffff; 
		}
		break;

	}

	return uDest;
}

/******************************************************************
 ��������		Sub32SHF

 ����:			32λ��������������

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Sub32SHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	
	
	int OpBits = sizeof(p_u32Src1) * 8;
	
	DSPU32 u32Src1 = p_u32Src1, u32Src2 = ~p_u32Src2;
	
	bool bolSrc1Sign= TestBit(u32Src1 , (OpBits - 1));
	bool bolSrc2Sign= TestBit(u32Src2 , (OpBits - 1));
	
	DSPU32 uDest;
	uDest =u32Src1 + u32Src2 + 1;

	bool bolDestSign= TestBit(uDest , (OpBits - 1));
	
	bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
	bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;
	bool bolOvfFlag = bolOverflow || bolUnderflow;

	
	bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);

	bool bolUnsingedOverflow = !bolCarryFlag;
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow)) //26-10-07 08:54

	{
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
	}

	unsigned int u2SatuMode = p_u32SHFCR & ( BIT(SHF_Ctl_Signed) | BIT(SHF_Ctl_Saturation) );
	
	switch (u2SatuMode) {
	case BaoHe_none:
	case BaoHe_none_unsigned:
		break;

	case BaoHe_signed:
		if (TestBit(*p_pStatReg, SHF_OverFlow)) {
			 
			if (bolOverflow || ( !bolSrc1Sign && (u32Src2
					== (unsigned int)MIN_SN(OpBits)))) {
				uDest = MAX_SN(OpBits);
			} else {
				if (bolUnderflow) {
					uDest = MIN_SN(OpBits);
				}
			}
		}
		break;

	case BaoHe_unsigned:
		 
		if (bolUnsingedOverflow) {
			uDest = 0;
		}
		break;

	}

	return uDest;
}

/******************************************************************
 ��������		Add32HalfSHF

 ����:			32λ�����������ӣ�����ƽ����

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Add32HalfSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	

	bool bolSrc1LSB = p_u32Src1 & 0x1;
	bool bolSrc2LSB = p_u32Src2 & 0x1;

	DSPU32 uDest;
	uDest = (p_u32Src1 >> 1) + (p_u32Src2 >> 1);

	DSPU32 iDest;
	DSPI32 i32Src1Tmp = p_u32Src1;
	DSPI32 i32Src2Tmp = p_u32Src2;
	iDest = (i32Src1Tmp >> 1) + (i32Src2Tmp >> 1);

	if (bolSrc1LSB && bolSrc2LSB) {
		uDest += 1;
		iDest += 1;
	}

	
	DSPU32 u1TruncateMode= md_to_zero;
	
	if ( (u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB)
			&& (uDest & 0x1)) {
		uDest += 1;
		iDest += 1;
	}

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	if (bolSigned) {
		uDest = iDest;
	}

	return uDest;
}

/******************************************************************
 ��������		Sub32HalfSHF

 ����:			32λ������������������ƽ����

 ����:			p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- SHF���ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern DSPU32 Sub32HalfSHF(DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	

	int OpBits = sizeof(p_u32Src1) * 8;

	DSPU32 uOrignSrc2 = p_u32Src2;
	p_u32Src2 = ~p_u32Src2 + 1;

	bool bolSrc1LSB = p_u32Src1 & 0x1;
	bool bolSrc2LSB = p_u32Src2 & 0x1;

	DSPU32 uDest;
	uDest = (p_u32Src1 >> 1) + (p_u32Src2 >> 1);

	DSPU32 iDest;
	DSPI32 i32Src1Tmp = p_u32Src1;
	DSPI32 i32Src2Tmp = p_u32Src2;
	iDest = (i32Src1Tmp >> 1) + (i32Src2Tmp >> 1);

	if (bolSrc1LSB && bolSrc2LSB) {
		uDest += 1;
		iDest += 1;
	}

	
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolOvctr=  TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);

	
	DSPU32 u1TruncateMode= md_to_zero;

	if (bolSigned) {
		if (p_u32Src2 == 0x80000000) {
			ClearBit(iDest,OpBits - 1);
		}
		if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB)
				&& (iDest & 0x1)) {
			iDest += 1;
		}
	} else {
		if (p_u32Src1 >= uOrignSrc2) {
			ClearFlag(uDest, OpBits - 1);
			if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB)
					&& (uDest & 0x1)) {
				uDest += 1;
			}
		} else {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			if (bolOvctr) {
				uDest = 0; 
			} else 
			{
				SetFlag(uDest, OpBits - 1);
				 

			}
		}
	}

	if (bolSigned) {
		uDest = iDest;
	}

	return uDest;
}

/******************************************************************
 ��������		SHF_Add_Sub32
 
 ��Ӧָ����ʽ:  Rm_n=Rm+/-Rn (U,sft)
 Rm_n=Rm+/-Rn (sft)
 Rm_n=(Rm+/-Rn)/2 (U,sft)
 Rm_n=(Rm+/-Rn)2/ (sft)

 ����:	  Rm��Rn�Ĵ����ϵ�32λ�������͵�����ͬʱ��������/���������ӵĽ�������Rm�Ĵ������Ľ�������Rn�Ĵ�����
 ��ϸ˵����ָ�20130402��

 ����:		p_Rm_n -- 64λ�����Ĵ�����32λ��Rm����32λ��Rn��
 p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ���,��0λ���㷨���չ���ڱ�ʾԴ�������Ƿ�Ϊ�з�������
 p_u32SHFCR[0] == 1�� Դ������Ϊ�з�����
 p_u32SHFCR[0] == 0�� Դ������Ϊ�޷�����
 p_bolHalf -- �����Ƿ�����2��
 p_bolHalf == 0: ������2
 p_bolHalf == 1: ����2��

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SHF_Add_Sub32(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1,
		DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR, bool p_bolHalf) {
	
	
	DSPU32 AddReg = *p_pStatReg;
	DSPU32 SubReg = *p_pStatReg;
	
	if (p_bolHalf) {
		p_Rm_n.u32High
				= Add32HalfSHF(p_u32Src1, p_u32Src2, &AddReg, p_u32SHFCR);
		p_Rm_n.u32Low = Sub32HalfSHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;

	}

	else {
		p_Rm_n.u32High = Add32SHF(p_u32Src1, p_u32Src2, &AddReg, p_u32SHFCR);
		p_Rm_n.u32Low = Sub32SHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;

	}

}

/******************************************************************
 ��������		SHF_Add_SubD16
 
 ��Ӧָ����ʽ:  HRm_n=HRm+/-HRn (U,sft)
 HRm_n=(HRm+/-HRn)/2(U,sft)
 HRm_n=HRm+/-HRn(sft)
 HRm_n=(HRm+/-HRn)/2(sft)
 
 ����:	  Rm��Rn�Ĵ����ϵ�˫16λ�������͵�����ͬʱ��������/����������16λ����16λ����/����16λ����16λ����/����
 �ӵĽ�������Rm�Ĵ������Ľ�������Rn�Ĵ�����
 ˫16λ�Ĳ�����־�Ĵ����������������־�Ļ���
 ��ϸ˵����ָ�20130402��

 ����:		p_Rm_n -- 64λ�����Ĵ�����32λ��Rm����32λ��Rn��
 p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ���,��0λ���㷨���չ���ڱ�ʾԴ�������Ƿ�Ϊ�з�������
 p_u32SHFCR[0] == 1�� Դ������Ϊ�з�����
 p_u32SHFCR[0] == 0�� Դ������Ϊ�޷�����
 p_bolHalf -- �����Ƿ�����2��
 p_bolHalf == 0: ������2
 p_bolHalf == 1: ����2��

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SHF_Add_SubD16(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1,
		DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR, bool p_bolHalf) {
	
	
	DSPU32 AddReg = *p_pStatReg;
	DSPU32 SubReg = *p_pStatReg;


	if (p_bolHalf) {
		p_Rm_n.u32High = AddD16HalfSHF(p_u32Src1, p_u32Src2, &AddReg,
				p_u32SHFCR);
		p_Rm_n.u32Low
				= SubD16HalfSHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;

	}

	else {
		p_Rm_n.u32High = AddD16SHF(p_u32Src1, p_u32Src2, &AddReg, p_u32SHFCR);
		p_Rm_n.u32Low = SubD16SHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;

	}

}
/******************************************************************
 ��������		SHF_Add_SubC32
 
 ��Ӧָ����ʽ:  CHRm_n=CHRm+/-CHRn(sft)
 CHRm_n=(CHRm+/-CHRn)/2(sft)

 ����:	  16λ���㸴��ͬʱ��/�����㡢16λ���㸴��ͬʱ��/������2���㡣�ӵĽ�������Rm�����Ľ�������Rn��
 ��ϸ˵����ָ�20130402��
 
 ����:		p_Rm_n -- 64λ�����Ĵ�����32λ��Rm����32λ��Rn��
 p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ���.
 p_bolHalf -- �����Ƿ�����2��
 p_bolHalf == 0: ������2
 p_bolHalf == 1: ����2��

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SHF_Add_SubC32(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1,
		DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR, bool p_bolHalf) {

	
	
	DSPU32 AddReg = *p_pStatReg;
	DSPU32 SubReg = *p_pStatReg;

	if (p_bolHalf) {
		p_Rm_n.u32High = AddD16HalfSHF(p_u32Src1, p_u32Src2, &AddReg,
				p_u32SHFCR);
		p_Rm_n.u32Low
				= SubD16HalfSHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;
	}

	else {
		p_Rm_n.u32High = AddD16SHF(p_u32Src1, p_u32Src2, &AddReg, p_u32SHFCR);
		p_Rm_n.u32Low = SubD16SHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;
	}

}
/******************************************************************
 ��������		SHF_Add_SubConjC32
 
 ��Ӧָ����ʽ:  CHRm_n=CHRm+/-jCHRn(sft)
 CHRm_n=(CHRm+/-jCHRn)/2(sft)

 ����:	  16λ���㸴��CHRmͬʱ��/��16λ���㸴��j*CHRn��16λ���㸴��CHRmͬʱ��/��16λ���㸴��j*CHRn���ҳ���2���ӵĽ�������Rm�����Ľ�������Rn��
 ��ϸ˵����ָ�20130402��
 
 ����:		p_Rm_n -- 64λ�����Ĵ�����32λ��Rm����32λ��Rn��
 p_u32Src1 -- Դ������1��
 p_u32Src2 -- Դ������2��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����
 p_bolHalf -- �����Ƿ�����2��
 p_bolHalf == 0: ������2
 p_bolHalf == 1: ����2��

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SHF_Add_SubConjC32(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1,
		DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR, bool p_bolHalf) {
	
	
	DSPU32 AddReg = *p_pStatReg;
	DSPU32 SubReg = *p_pStatReg;

	if (p_bolHalf) {
		p_Rm_n.u32High = AddD16HalfCJSHF(p_u32Src1, p_u32Src2, &AddReg,
				p_u32SHFCR);
		p_Rm_n.u32Low = SubD16HalfCJSHF(p_u32Src1, p_u32Src2, &SubReg,
				p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;

	}

	else {
		p_Rm_n.u32High = AddD16CJSHF(p_u32Src1, p_u32Src2, &AddReg, p_u32SHFCR);
		p_Rm_n.u32Low = SubD16CJSHF(p_u32Src1, p_u32Src2, &SubReg, p_u32SHFCR);
		*p_pStatReg = AddReg | SubReg;

	}

}

/******************************************************************
 ��������		ExpandC16

 ����:			16λ���㸴���չΪ32λ���㸴������ϸ˵����ָ�20130402����

 ����:		p_Rm_n -- 64λ�����Ĵ�����32λ��Rs+1����32λ��Rs��	
 p_u32Src -- ���չ16λ���㸴����
 p_u32Pos -- ��ʾ���չ��16λ������32λĿ�ļĴ���Rs��������λ�ã�
 ���ݴ���16������16����
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		

 ע������:		���ݼ��������������ر�־λ��
 �Ƿ�������λ�չ��p_u32SHFCR����

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void ExpandC16(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src, DSPU32 p_u32Pos,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	
	
	DSPU16 u16SrcHigh = p_u32Src >> 16;
	DSPU16 u16SrcLow = p_u32Src&0xffff;

	DSPU32 StatRegHigh=*p_pStatReg, StatRegLow =*p_pStatReg;

	p_Rm_n.u32High = Expand16(u16SrcHigh, p_u32Pos, &StatRegHigh, p_u32SHFCR);
	p_Rm_n.u32Low = Expand16(u16SrcLow, p_u32Pos, &StatRegLow, p_u32SHFCR);

	*p_pStatReg = (StatRegHigh) | (StatRegLow);
}


/*found*****************************************************************
 ��������		FixC32

 CRs+1:s=FIX CFRs+1:s
 CRs+1:s=FIX(CFRs+1:s,C)

 ����:			��32λ���㸴��ת��Ϊ32λ���㸴������ϸ˵����ָ�20130402��

 ����:		p_Rm_n -- 64λ�����Ĵ�����32λ��Rs+1����32λ��Rs��	
 p_u32Src1 -- Դ������1����ӦRs��
 p_u32Src2 -- Դ������2����ӦRs+1��
 p_u32Adjust -- ָ������������ָ��ֲᡣ
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern void FixC32(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 p_u32Adjust, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	

	p_Rm_n.u32High = Fix32(p_u32Src2, p_u32Adjust, p_pStatReg, p_u32SHFCR);
	p_Rm_n.u32Low = Fix32(p_u32Src1, p_u32Adjust, p_pStatReg, p_u32SHFCR);

}

/*found*****************************************************************
 ��������		FloatC32

 ָ����ʽ��CFRs+1:s=Float CRs+1:s 
 CFRs+1:s=Float(CRs+1:s��C)

 ����:			��32λ���㸴��ת��Ϊ32λ���㸴������ϸ˵����ָ�20130402��

 ����:			p_Rm_n -- 64λ�����Ĵ�����32λ��Rs+1����32λ��Rs��	
 p_u32Src1 -- Դ������1����ӦRs��
 p_u32Src2 -- Դ������2����ӦRs+1��
 p_u32Adjust -- ָ������������ָ��ֲᡣ
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern void FloatC32(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 p_u32Adjust, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
	p_Rm_n.u32High = Float32(p_u32Src2, p_u32Adjust, p_pStatReg, p_u32SHFCR);
	p_Rm_n.u32Low = Float32(p_u32Src1, p_u32Adjust, p_pStatReg, p_u32SHFCR);
}

/******************************************************************
 ��������		AShiftC32

 ��Ӧָ����ʽ:  CRs+1:s=CRm+1:m ashift a
 
 ����:			32λ������λ����ϸ˵����ָ�20130402��

 ����:			p_Rm_n -- 64λ�����Ĵ�����32λ��Rs+1����32λ��Rs��
 p_u32Src1 -- Դ������1����ӦRm��
 p_u32Src2 -- Դ������2����ӦRm+1��
 p_u32BitToShift -- �ƶ�λ���� ����ʾ���ƣ�����ʾ���ơ�
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 AShiftC32(DSP_BIT64 &p_Rm_n, DSPU32 p_u32Src1, DSPU32 p_u32Src2,
		DSPU32 p_u32BitToShift, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU32 UpperReg = *p_pStatReg;
	DSPU32 LowerReg = *p_pStatReg;
	p_Rm_n.u32Low= AShift32(p_u32Src1, p_u32BitToShift, &LowerReg, p_u32SHFCR);
	p_Rm_n.u32High = AShift32(p_u32Src2, p_u32BitToShift, &UpperReg,p_u32SHFCR);	
	*p_pStatReg = UpperReg | LowerReg;

	return 0;
}

/******************************************************************
 ��������		Compact16To8
 
 ��Ӧָ����ʽ:			
 LORm=COMPACT(HRm,a)(U)
 HORm=COMPACT(HRm,a)(U)
 LORm=COMPACT(HRm,a)
 HORm=COMPACT(HRm,a)

 ����:			16λ������ת��Ϊ8λ������,����ָ�20130502��λ��180ָ�

 ����:		p_u32Src -- ��ѹ�������ݡ�
 p_u32Pos -- ��Ӧָ���е������a����ʾѹ������8λ�������16λ�������е��ĸ�λ����
 p_u32IsHigh -- ��/��ѡ�񣬿���ת������8λ��������λ�á�
 Ϊ0ʱ��λ��Rm[15:8]��Rm[7:0]��
 Ϊ1ʱ��λ��Rm[31:24]��Rm[23:16]��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 ��������ֻ�޸���Rm��16λ��ʣ��16λ�Ա���ԭֵ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Compact16To8(DSPU32 p_u32Src, DSPU32 p_u32Pos, bool p_IsHigh,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	
		
	bool bolSrcSignHigh= TestBit (p_u32Src, 31);
	bool bolSrcSignLow= TestBit (p_u32Src, 15);

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);
	bool bolSignedOverflow, bolUnsignedOverflow;

	DSPU32 u8DestHigh, u8DestLow,u32Dest, u32Cnt;
	
	DSPI16 i16SrcHigh, i16SrcLow;	
	DSPU16 u16SrcHigh, u16SrcLow;		

	i16SrcHigh = (DSPI16)(p_u32Src >> 16);
	i16SrcLow =  (DSPI16)(p_u32Src & 0xffff);
	
	u16SrcHigh = (DSPU16)(p_u32Src >> 16);
	u16SrcLow =  (DSPU16)(p_u32Src & 0xffff);
	
	u32Cnt = p_u32Pos;
	if (p_u32Pos > 8) {
		u32Cnt = 8;
	}
	
	u8DestHigh = (DSPU8)(i16SrcHigh >> u32Cnt);
	
	DSPI16 i16SrcHighShf = i16SrcHigh >> u32Cnt;
	
	bolSignedOverflow = (((i16SrcHighShf >> 7) &0xffff)!= 0x0)&& (((i16SrcHighShf >> 7)&0xffff) != 0xffff);

	DSPU16 u16SrcHighShf = u16SrcHigh >> u32Cnt;
	bolUnsignedOverflow = (u16SrcHighShf >> 8) != 0x0;


	if (bolSigned) {
		if (bolSignedOverflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				if (bolSrcSignHigh) {
					u8DestHigh = 0x80;
				} else {
					u8DestHigh = 0x7f;
				}			}			
		}

	} else {
		if (bolUnsignedOverflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				u8DestHigh = 0xff;
			}
		}
	}

	
	u8DestLow = (DSPU8)(i16SrcLow >> u32Cnt);
	DSPI16 i16SrcLowShf = i16SrcLow >> u32Cnt;

	bolSignedOverflow = (((i16SrcLowShf >> 7) &0xffff)!= 0x0)&& (((i16SrcLowShf >> 7)&0xffff) != 0xffff);
	

	
	DSPU16 u16SrcLowShf = u16SrcLow >> u32Cnt;
	bolUnsignedOverflow = (u16SrcLowShf >> 8) != 0x0;

	if (bolSigned) {
		if (bolSignedOverflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				if (bolSrcSignLow) {
					u8DestLow = 0x80;
				} else {
					u8DestLow = 0x7f;
				}
			}

		}
	} else {
		if (bolUnsignedOverflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				u8DestLow = 0xff;
			}
		}
	}

	switch (p_IsHigh) {
	
	case 0:
		u32Dest = (u16SrcHigh<<16)|(u8DestHigh<<8)|u8DestLow;
		
		break;
		
	case 1:
		u32Dest = (((u8DestHigh<<8)|u8DestLow)<<16)|u16SrcLow;

		break;
	}

	return u32Dest;
}

/******************************************************************
 ��������		Expand8To16
 
 ��Ӧָ����ʽ:			CHRm=EXPAND(CLORM,a)
 CHRm=EXPAND(CHORM,a)

 ����:			8λ������ת��Ϊ16λ������,����ָ�20130502��λ��180ָ�

 ����:		p_u16Src -- ���չ16λ��������
 p_u32Pos -- ��Ӧָ���е������a������ѹ��ǰ��8λ���ݷ���16λ�������е��ĸ�λ����
 p_u32IsHigh -- ��/��ѡ�񣬿���ת��ǰ��8λ��������λ�á�
 Ϊ0ʱ��λ��Rm[15:8]��Rm[7:0]��
 Ϊ1ʱ��λ��Rm[31:24]��Rm[23:16]��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��
 �Ƿ�������λ�չ��p_u32SHFCR����

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 Expand8To16(DSPU32 p_u16Src, DSPU32 p_u32Pos, bool p_IsHigh,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	
	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolHighNum= p_IsHigh;
	
	DSPU32 u4Pos = p_u32Pos;
	DSPU16 u16Src = 0,u16SrcHigh = 0, u16SrcLow = 0;	
	DSPU16 u16DestHigh = 0, u16DestLow = 0,u16Mask = 0xff00;

	if(!bolHighNum){
		u16Src = (p_u16Src & 0xffff);
	}
	
	if(bolHighNum){
		u16Src = ((p_u16Src >> 16) & 0xffff);
	}	

	u16SrcHigh = u16Src>>8;
	u16SrcLow = u16Src&0xff;

	
		
	if (u4Pos > 8) {
		u4Pos = 8;
	}

	if (bolSigned) {
		if(TestBit(u16SrcHigh,7)){
			u16DestHigh = (u16SrcHigh | u16Mask) << u4Pos;
		}

		else{
			u16DestHigh = u16SrcHigh << u4Pos;
		}

		if(TestBit(u16SrcLow,7)){
			u16DestLow = (u16SrcLow | u16Mask) << u4Pos;
		}

		else{
			u16DestLow = u16SrcLow << u4Pos;
		}		
		
	} else {
		u16DestHigh= (u16SrcHigh<< u4Pos);
		u16DestLow = (u16SrcLow<< u4Pos);
	}
	
	return (((u16DestHigh<<16)|u16DestLow));
}

/******************************************************************
 add by baohua 
 ��������		RegStabToSACC

 ��Ӧָ����ʽ:  

 SACCs = Sigma_b1(Rn��STABn(LLORm))
 SACCs += Sigma_b1(Rn��STABn (LLORm))

 ����:
 SACCs = Sigma_b1(Rn��STABn(LLRm))��ʾ��Rn�е�32λ������λ��TAB���ж����32λ���ݷֱ�����-1����ָ������֮�����ӣ����������Ĵ���SACCs��
 SACCs=SACCs + Rn[0]���-1��^TAB[0] +  Rn[1]���-1��^TAB[1]+ �� + Rn[31]���-1��^TAB[31]��

 SACCs += Sigma_b1(Rn��STABn (LLRm))��ʾ��Rn�е�32λ������λ��TAB���ж����32λ���ݷֱ�����-1����ָ������֮�����ӣ�����������SACCs��ԭ���ֵ�ۼӺ󣬽��������Ĵ���SACCs��
 SACCs+=SACCs + Rn[0]���-1��^TAB[0] +  Rn[1]���-1��^TAB[1]+ �� + Rn[31]���-1��^TAB[31]��
 
 ����Rm�ĵ�[7:0]λΪ��λ�����ұ�STAB��λ��
 
 ��ָ��Ӱ��������־λ����SACCs�ۼӽ�������ʱ������λ����־�Ĵ���SHFFR�ĵ�1λ�͵�0λ��1��������0��

 ����:		p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- SACCs = Sigma_b1(Rn��STABn(LLORm))
 1 -- SACCs += Sigma_b1(Rn��STABn (LLORm))
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void RegStabToSACC(DSP_BIT64 &p_SACC, DSPU32 p_u32Rm, DSPU32 p_u32Rn,
		SHF_RAM *p_pRAM, DSPU32 p_u32N, DSPU32 p_u32Mode, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	//״̬�Ĵ����ı���
	

	int OpBits = 24;

	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest = 0;

	bool bolSrc1Sign = false;
	bool bolSrc2Sign = false;
	bool bolDestSign = false;
	bool bolOverflow = false;
	bool bolUnderflow = false;	
	bool bolSigned = false;
	
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;
	u32ArrRow = (p_u32N>>14)&0x3;
	u32ArrColumn = p_u32Rm & 0xff;
	u32Stab = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];

	
	for (int i = 0; i < 32; i++) {
		
		if (TestBit(p_u32Rn,i)&&TestBit(u32Stab,i)) {
			u32Dest -= 1;
		}
		
		else if (TestBit(p_u32Rn,i)&&(!TestBit(u32Stab,i))) {
			u32Dest += 1;
		}
	}

	switch (p_u32Mode) {
	//SACCs = Sigma_b1(Rn��STABn(LLRm))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;
		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);

		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);


		bolDestSign= TestBit(u32AddDest, OpBits - 1);

		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		
		bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed );

		if (bolOverflow || bolUnderflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
		}

		if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)){

			if (bolOverflow) {
				u32AddDest = 0x7fffff;
			}
			if (bolUnderflow) {
				u32AddDest = 0x800000;
			}
		}

		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;

		break;

	}
}

/******************************************************************
 add by baohua 
 ��������		SCStabB1ToSACC

 ��Ӧָ����ʽ:  

 SACCs = Sigma_b1(Rm��STABn(SC))
 SACCs += Sigma_b1(Rm��STABn(SC))

 ����:

 ģʽΪ00ʱ��SACCs = Sigma_b1(Rm��STABn(d))��ʾ��Rm�е�32λ������λ��TAB���ж����32λ���ݷֱ�����-1����ָ������֮�����ӣ����������Ĵ���SACCs��
 SACCs=Rm[0]���-1��^TAB[0] +  Rm[1]���-1��^TAB[1]+ �� + Rm[31]���-1��^TAB[31]��
 
 ģʽΪ5ʱ��SACCs += Sigma_b1(Rm��STABn(d))��ʾ��Rm�е�32λ������λ��TAB���ж����32λ���ݷֱ�����-1����ָ������֮�����ӣ����������Ĵ���SACCs��
 SACCs+=Rm[0]���-1��^TAB[0] +  Rm[1]���-1��^TAB[1]+ �� + Rm[31]���-1��^TAB[31]��
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- SACCs = Sigma_b1(Rm��STABn(SC))
 1 -- SACCs += Sigma_b1(Rm��STABn(SC))
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SCStabB1ToSACC(DSP_BIT64 &p_SACC, DSPU32 p_u32SC, DSPU32 p_u32Rm,
		DSPU32 p_u32Rn, SHF_RAM *p_pRAM, DSPU32 p_u32N, DSPU32 p_u32Mode,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	

	int OpBits = 24;

	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest = 0;
	bool bolSrc1Sign = false;
	bool bolSrc2Sign = false;
	bool bolDestSign = false;		
	bool bolOverflow = false;
	bool bolUnderflow = false;		
	bool bolSigned = true;

	
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;

	u32ArrRow = (p_u32N>>14)&0x3;//ȡSRAM�е�ֵ
	u32ArrColumn = p_u32SC >> 24;

	u32Stab = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];

	for (int i = 0; i < 32; i++) {

		if (TestBit(p_u32Rn,i)&&TestBit(u32Stab,i)) {
			u32Dest -= 1;
		}

		else if (TestBit(p_u32Rn,i)&&(!TestBit(u32Stab,i))) {
			u32Dest += 1;
		}
	}


	switch (p_u32Mode) {
	//SACCs = Sigma_b1(Rn��STABn(LLRm))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;
		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);
		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);

		bolDestSign= TestBit(u32AddDest, OpBits - 1);

		//�з��Ž�λ��־��������״̬�Ĵ���
		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		//������־
		if (bolOverflow || bolUnderflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
		}
		//�����ʹ���
		//�з��ű��ʹ��� 
		if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)){

			if (bolOverflow) {
				u32AddDest = 0x7fffff;
			}

			if (bolUnderflow) {
				u32AddDest = 0x800000;
			}
		}
		

		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;
		break;

	}

}

/******************************************************************
 add by baohua 
 ��������		SCStabB2ToSACC

 ��Ӧָ����ʽ:  

 SACCs = Sigma_b2(Rm+1:m��STABn(SC))
 SACCs += Sigma_b2(Rm+1:m��STABn(SC))

 ����:

 ģʽΪ00ʱ��SACCs = Sigma_b1(Rm��STABn(d))��ʾ��Rm�е�32λ������λ��TAB���ж����32λ���ݷֱ�����-1����ָ������֮�����ӣ����������Ĵ���SACCs��
 SACCs=Rm[1:0] ���-1��^TAB[0]+ Rm[3:2] ���-1��^TAB[1]+ �� + Rm[31:30] ���-1��^TAB[15]+Rm+1[1:0] ���-1��^TAB[16]+ Rm+1[3:2] ���-1��^TAB[17]+ �� + Rm+1[31:30] ���-1��^TAB[31]��
 
 ģʽΪ5ʱ��SACCs+=Rm[1:0] ���-1��^TAB[0]+ Rm[3:2] ���-1��^TAB[1]+ �� + Rm[31:30] ���-1��^TAB[15]+Rm+1[1:0] ���-1��^TAB[16]+ Rm+1[3:2] ���-1��^TAB[17]+ �� + Rm+1[31:30] ���-1��^TAB[31]��
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- SACCs = Sigma_b1(Rm��STABn(SC))
 1 -- SACCs += Sigma_b1(Rm��STABn(SC))
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void SCStabB2ToSACC(DSP_BIT64 &p_SACC, DSPU32 p_u32SC, DSPU32 p_u32Rm,
		DSPU32 p_u32Rn, SHF_RAM *p_pRAM, DSPU32 p_u32N, DSPU32 p_u32Mode,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	
	int OpBits = 24;

	DSPU32 u2Scr = 0, j = 0;
	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest=0;
	bool bolSrc1Sign = false;
	bool bolSrc2Sign= false;		
	bool bolDestSign= false;
	bool bolOverflow = false;
	bool bolUnderflow = false;	
	bool bolSigned= false;

	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;
	u32ArrRow = (p_u32N>>14)&0x3;//ȡSRAM�е�ֵ
	u32ArrColumn = (p_u32SC >> 24) & 0xff;//SC[31:24]λ����λ���Ĳ��ұ�STAB����Ѱַ
	u32Stab = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];


	for (int i = 0; i < 32; i++) {

		if (i<16) {

			u2Scr = (p_u32Rm >> (2*i)) & 0x3;

		}

		else {
			j = i-16;
			u2Scr = (p_u32Rn >> (2*j)) & 0x3;

		}
		//TAB[i]��ӦλΪ1,����Ϊ-1��ʵ�ʲ����Ǽ���
		if (TestBit(u32Stab,i)) {
			u32Dest -= u2Scr;
		}
		//TAB[i]��ӦλΪ0,����Ϊ1��ʵ�ʲ����Ǽӷ�
		else if (!TestBit(u32Stab,i)) {
			u32Dest += u2Scr;
		}
	}


	switch (p_u32Mode) {
	//SACCs = Sigma_b1(Rm��STABn(SC))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);

		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);
		bolDestSign= TestBit(u32AddDest, OpBits - 1);
		
		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		
		bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed );
		
		if (bolOverflow || bolUnderflow)  {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
		}
		
		if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)){
			
			if (bolOverflow) {
				u32AddDest = 0x7fffff;
			}
			if (bolUnderflow) {
				u32AddDest = 0x800000;
			}
		}

		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;
		break;

	}

}

/******************************************************************
 add by baohua 
 ��������		HHSCStabB4ToSACC

 ��Ӧָ����ʽ:  
 SACCs = Sigma_b4(Rm+1:m��HHSTABn(SC))
 SACCs += Sigma_b4(Rm+1:m��HHSTABn(SC))

 ����:

 ģʽΪ10ʱ��SACCs=Rm[3:0] ���-1��^TAB[16]+ Rm[7:4] ���-1��^TAB[17] + �� + Rm[31:28] ���-1��^TAB[23]+Rm+1[3:0] ���-1��^TAB[24]+ Rm+1[7:4] ���-1��^TAB[25] + �� + Rm+1[31:28] ���-1��^TAB[31]��
 
 ģʽΪ6ʱ��SACCs+=Rm[3:0] ���-1��^TAB[16]+ Rm[7:4] ���-1��^TAB[17] + �� + Rm[31:28] ���-1��^TAB[23]+Rm+1[3:0] ���-1��^TAB[24]+ Rm+1[7:4] ���-1��^TAB[25] + �� + Rm+1[31:28] ���-1��^TAB[31]��
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- SACCs = Sigma_b1(Rm��STABn(SC))
 1 -- SACCs += Sigma_b1(Rm��STABn(SC))
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void HHSCStabB4ToSACC(DSP_BIT64 &p_SACC, DSPU32 p_u32SC, DSPU32 p_u32Rm,
		DSPU32 p_u32Rn, SHF_RAM *p_pRAM, DSPU32 p_u32N, DSPU32 p_u32Mode,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	
	int OpBits = 24;

	DSPU32 u2Scr = 0, j = 0, k=0;
	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest=0;
		
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;
	u32ArrRow = (p_u32N>>14)&0x3;
	u32ArrColumn = (p_u32SC >> 24) & 0xff;
	u32Stab = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];

	bool bolSrc1Sign = false;
	bool bolSrc2Sign = false;		
	bool bolDestSign = false;
	bool bolOverflow = false;
	bool bolUnderflow = false;
	bool bolCarryFlag = false;
	bool bolUnsignedOverflow  = false;
	bool bolSigned = true;

	
	for (int i = 0; i < 16; i++) {

		if (i<8) {
			u2Scr = (p_u32Rm >> (4*i)) & 0xf;
		} else {
			j = i-8;
			u2Scr = (p_u32Rn >> (4*j)) & 0xf;

		}
		
		k = i+16;
		if (TestBit(u32Stab,k)) {
			u32Dest -= u2Scr;
		}
		
		else if (!TestBit(u32Stab,k)) {
			u32Dest += u2Scr;
		}
	}

	switch (p_u32Mode) {
	//SACCs = Sigma_b1(Rm��STABn(SC))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);

		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);
		bolDestSign= TestBit(u32AddDest, OpBits - 1);
		
		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;

		
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		bolUnsignedOverflow = bolCarryFlag;

		
		if (bolOverflow || bolUnderflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
		}
		
		if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)){
			
			if (bolOverflow) {
				u32AddDest = 0x7fffff;
			}
			if (bolUnderflow) {
				u32AddDest = 0x800000;
			}
		}

		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;
		break;
	
	}

}

/******************************************************************
 add by baohua 
 ��������		LHSCStabB4ToSACC

 ��Ӧָ����ʽ:  
 SACCs = Sigma_b4(Rm+1:m��HHSTABn(SC))
 SACCs += Sigma_b4(Rm+1:m��HHSTABn(SC))

 ����:

 ģʽΪ11ʱ��SACCs=Rm[3:0] ���-1��^TAB[0]+ Rm[7:4] ���-1��^TAB[1] + �� + Rm[31:28] ���-1��^TAB[7]+Rm+1[3:0] ���-1��^TAB[8]+ Rm+1[7:4] ���-1��^TAB[9] + �� + Rm+1[31:28] ���-1��^TAB[15]��
 
 ģʽΪ7ʱ��SACCs+=Rm[3:0] ���-1��^TAB[0]+ Rm[7:4] ���-1��^TAB[1] + �� + Rm[31:28] ���-1��^TAB[7]+Rm+1[3:0] ���-1��^TAB[8]+ Rm+1[7:4] ���-1��^TAB[9] + �� + Rm+1[31:28] ���-1��^TAB[15]��
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��
 p_pRAM -- ָ����λ���ڲ�RAM��ָ�롣
 p_u32N -- ��ӦTAB����n��
 p_u32Mode -- ģʽ���ơ�
 0 -- SACCs = Sigma_b1(Rm��STABn(SC))
 1 -- SACCs += Sigma_b1(Rm��STABn(SC))
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void LHSCStabB4ToSACC(DSP_BIT64 &p_SACC, DSPU32 p_u32SC, DSPU32 p_u32Rm,
		DSPU32 p_u32Rn, SHF_RAM *p_pRAM, DSPU32 p_u32N, DSPU32 p_u32Mode,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	int OpBits = 24;

	DSPU32 u2Scr = 0, j = 0;
	DSPU32 u32Stab = 0;
	DSPU32 u32Dest = 0, u32AddDest=0;
	
	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;
	u32ArrRow = (p_u32N>>14)&0x3;
	u32ArrColumn = (p_u32SC >> 24) & 0xff;
	u32Stab = p_pRAM->arrElem[u32ArrRow][u32ArrColumn];

	bool bolSrc1Sign = false ;
	bool bolSrc2Sign = false ;		
	bool bolDestSign = false ;	
	bool bolOverflow = false ;
	bool bolUnderflow = false ;		
	bool bolCarryFlag = false ;
	bool bolUnsignedOverflow = false ;
	bool bolSigned = true ;


	for (int i = 0; i < 16; i++) {

		if (i<8) {
			u2Scr = (p_u32Rm >> (4*i)) & 0xf;
		} else {
			j = i-8;
			u2Scr = (p_u32Rn >> (4*j)) & 0xf;

		}
	
		if (TestBit(u32Stab,i)) {
			u32Dest -= u2Scr;
		}

		else if (!TestBit(u32Stab,i)) {
			u32Dest += u2Scr;
		}
	}

	switch (p_u32Mode) {
	//SACCs = Sigma_b1(Rm��STABn(SC))
	case 0:
		p_SACC.u32Low = u32Dest&0xffffff;
		p_SACC.u32High = 0;

		break;
		//SACCs += Sigma_b1(Rn��STABn (LLRm)
	case 1:
		bolSrc1Sign= TestBit(p_SACC.u32Low, OpBits - 1);
		bolSrc2Sign= TestBit(u32Dest, OpBits - 1);

		u32AddDest = (p_SACC.u32Low&0xffffff) + (u32Dest&0xffffff);
		bolDestSign= TestBit(u32AddDest, OpBits - 1);

		bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
		bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;


		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);

		bolUnsignedOverflow = bolCarryFlag;


		if (bolOverflow || bolUnderflow) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
		}

		if (TestBit(p_u32SHFCR,SHF_Ctl_Saturation)) {

			if (bolOverflow) {
				u32AddDest = 0x7fffff;
			}
			if (bolUnderflow) {
				u32AddDest = 0x800000;
			}
		}

		p_SACC.u32Low = u32AddDest&0xffffff;
		p_SACC.u32High = 0;
		break;
	
	}
}

/******************************************************************
 add by baohua 
 ��������		exchange

 ��Ӧָ����ʽ:  
 Rs1Rs2=exchange(Rm,Rn,a)

 ����:

 �Ȱ�Rm��Rn����һ��λ����Rmλ�ڵ�32λ��Rnλ�ڸ�32λ���ٽ������´���
 ��Rm�ĸ�aλ��Rn�ĵ�aλ��������������Rs1Rs2�С�Rs1�ŵ�32λ��Rs2�Ÿ�32λ��
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��	 
 p_u32N -- ��Ӧ����A��	 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����
 p_u64Dest--64λ��������

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void Exchang(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 p_u32A, DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR)

 {


	DSPU32 u32SrcRm = p_u32SrcM;
	DSPU32 u32SrcRn = p_u32SrcN;
	DSPU32 u32a = p_u32A ;
	DSPU32 u32DestLow = 0;
	DSPU32 u32DestHigh = 0;

	DSPU32 u32Shifter = u32a;

	DSPU32 u32MaskLow = 0xffffffff >> u32Shifter;
	DSPU32 u32MaskHigh = 0xffffffff << u32Shifter;

	DSPU32 u32ExchangeLow = 0;
	DSPU32 u32ExchangeHigh = 0;

	if (u32a > 32) {
		u32a = 31;
	}

	u32ExchangeLow = (u32SrcRm & (~u32MaskLow)) >> (32 - u32Shifter);
	u32ExchangeHigh = (u32SrcRn & (~u32MaskHigh)) << (32 - u32Shifter);

	u32DestLow = u32ExchangeHigh | (u32SrcRm & u32MaskLow);
	u32DestHigh = u32ExchangeLow |(u32SrcRn & u32MaskHigh);

	p_Dest.u32High = u32DestHigh;
	p_Dest.u32Low = u32DestLow;
}

/******************************************************************
 add by baohua 
 ��������		sexchange

 ��Ӧָ����ʽ:  
 Rs1Rs2=s_exchange(Rm,Rn,a)

 ����:

 �Ȱ�Rm��Rn����һ��λ����Rmλ�ڵ�32λ��Rnλ�ڸ�32λ���ٽ������´���
 a������0��1���������ܱ���ͨ����
 ��Rn������λ����0λ���ŵ�Rm�ĵ�32-aλ��Rn�ĵ�1��a-1λ����λ��1λ��ͬʱ����Rm������λ����31λ���ŵ�Rn��a-1λ��Rm�ĵ�32-a��30λ����λ��һλ��
 ��������Rs1Rs2�С�Rs1�ŵ�32λ��Rs2�Ÿ�32λ����
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��	 
 p_u32N -- ��Ӧ����A��	 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����
 p_u64Dest--64λ��������

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/

extern void SExchang(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 p_u32A, DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){


	DSPU32 u32SrcRm = p_u32SrcM;
	DSPU32 u32SrcRn = p_u32SrcN;
	DSPU32 u32a = p_u32A ;
	

	DSPU32 u32Shifter = 32 - u32a;

	DSPU32 u32SrcRnbottom = u32SrcRn &0x1;

	
	DSPU32 u32SrcRnHigher = (u32SrcRn >> u32a)<<u32a;
	DSPU32 u32SrcRnLower = (u32SrcRn <<u32Shifter)>>(u32Shifter+1);

	DSPU32 u32SrcRmTop = u32SrcRm >> 31;


	DSPU32 u32SrcRmHigher = (u32SrcRm >> u32Shifter)<<(u32Shifter+1);
	DSPU32 u32SrcRmLower = (u32SrcRm <<u32a)>>u32a;
	

	if ((u32a == 0)||(u32a == 1)) {
		p_Dest.u32Low = 0;
		p_Dest.u32High = 0;
	}
	else {
		p_Dest.u32Low = u32SrcRmHigher | (u32SrcRnbottom<< u32Shifter )
				| u32SrcRmLower;
		p_Dest.u32High = u32SrcRnHigher | (u32SrcRmTop << (u32a-1) )
				| u32SrcRnLower;
	}
}
/******************************************************************
 add by baohua 
 ��������		Ext

 ��Ӧָ����ʽ:  
 Rs1Rs2=Rm Ext Rn (f:g)

 ����:

 �Ȱ�Rm��Rn����һ��λ����Rmλ�ڵ�32λ��Rnλ�ڸ�32λ���ٽ������´���
 g����ȡ0��f��������g���ܱ�g������gֻ��Ϊ2��ָ��������1��2��4��8�����������ܱ���ͨ����
 ������λ��ÿ��fλ�������gλ����ƴ����һ�������磺��fΪ4��gΪ1������0��4��8��12��16��56��60λ���ڽ����ĵ�0��1��2��3��14��15λ����1��5��9��13��17��57��61λ���ڽ����ĵ�16��17��18��19��30��31λ����2��6��10��14��58��62λ���ڽ����ĵ�32��33��34��35��46��47λ����3��7��11��15��19��59��63λ���ڽ����ĵ�48��49��50��51��62��63λ��
 ��fΪ4��gΪ2������0��1��4��5��8��9������56��57��60��61λ���ڽ����ĵ�0��1��2��3������30��31λ����2��3��6��7��10��11������58��59��62��63λ���ڽ����ĵ�32��33��34������62��63λ��
 ��ƴ�ӵ�������һ��������fλ�޷�ƴ�꣬��ƴ��������ƴ��һλΪֹ��
 ��������Rs1Rs2�С�Rs1�ŵ�32λ��Rs2�Ÿ�32λ��
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��	 
 p_u32F -- ��Ӧ����f��
 p_u32G -- ��Ӧ����g��	 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����
 p_u64Dest--64λ��������

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void ExtReg(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 p_u32F, DSPU32 p_u32G, DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR)

{

	//״̬�Ĵ����ı���
	

	bitset<32> u32HighBit;
	bitset<32> u32LowBit;
	bitset<64> u64SrcBit;
	bitset<64> u64DestBit;
		u32HighBit.reset();
	u32LowBit.reset();
	u64SrcBit.reset();
	u64DestBit.reset();
	
	
	int a = 63;
	DSPU32 remainder,divQuot; 

	DSPU32 f = p_u32F ;
	DSPU32 g = p_u32G;	
	
	
	
	remainder = fmod((float)f,g);
	
	
	div_t div_result;

	if(f > 0){
		div_result = div(a,(int)f);
		divQuot = div_result.quot;
	}
	
	//g==0, or f==0 is prohbitable	
	if(f == 0){
		divQuot = 0;
	}	
	bool bolCondition = false;
	

	if ((g > 0)&&(f > g)&&(remainder==0) &&(f <=16)&&(g <=8)) {
		//g ��2��ָ��
		if ((g == 1)||(g == 2)||(g == 4)||(g == 8)) {
			bolCondition = true;
		} else {
			bolCondition = false;
		}
	}

	else {
		bolCondition = false;
	}
	

	//condition is not appropriate,return zero.
	if (bolCondition == false) {
		p_Dest.u32Low = 0;
		p_Dest.u32High = 0;
		
	}

	//condition is not appropriate,computer ,
	else if (bolCondition == true) {

		//merge Rn,Rm,Rn put in high,Rm put in low
		for (unsigned int i = 0; i < 64; i++) {
			if (i < 32) {
				if (TestBit(p_u32SrcM,i)) {
					u64SrcBit.set(i);
				}
			}
			else {
				if (TestBit(p_u32SrcN,i-32)) {
					u64SrcBit.set(i);
				}
			}
		}//end  merge 
				
		//spell
		for (unsigned int i = 0, num = 0, bitSrcPos = 0, bitDesPos = 0; i<f; i++) {
			for (unsigned int j = 0; j<=divQuot; j++) {
				num = j*f+i*g;//the start bit of the merge bitset				
				for (unsigned int k = 0; k < g; k++) {
					bitSrcPos = num + k;//each bit of the merge bitset should be output					
					if ((bitSrcPos < 64)&&(bitDesPos < 64) ){
						u64DestBit[bitDesPos] = u64SrcBit[bitSrcPos];		
						
						bitDesPos++;
					}
				}
				
			}
			
		}//end spell

		//output
		for (unsigned int i = 0; i < 64; i++) {
			if (i < 32) {
				u32LowBit[i] = u64DestBit[i];

			} else {
				u32HighBit[i-32] = u64DestBit[i];
			}
		}

		p_Dest.u32Low = u32LowBit.to_ulong();
		p_Dest.u32High = u32HighBit.to_ulong();
	
		

	}//end else if

	u32HighBit.reset();
	u32LowBit.reset();
	u64SrcBit.reset();
	u64DestBit.reset();
}

/******************************************************************
 add by baohua 
 ��������		InsertPqfg

 ��Ӧָ����ʽ:  
 Rs1Rs2=Rm Insert Rn (p:q, f:g)

 ����:

 �Ȱ�Rm��Rn����һ��λ����Rmλ�ڵ�32λ��Rnλ�ڸ�32λ���ٽ������´���
 a������0��1���������ܱ���ͨ����
 ��Rn������λ����0λ���ŵ�Rm�ĵ�32-aλ��Rn�ĵ�1��a-1λ����λ��1λ��ͬʱ����Rm������λ����31λ���ŵ�Rn��a-1λ��Rm�ĵ�32-a��30λ����λ��һλ��
 ��������Rs1Rs2�С�Rs1�ŵ�32λ��Rs2�Ÿ�32λ����
 

 ����:p_u32Rm -- ��Ӧ�Ĵ���Rm��
 p_u32Rn -- ��Ӧ�Ĵ���Rn��	 
 p_u32P -- ��Ӧ����p��
 p_u32Q -- ��Ӧ����q��
 p_u32F -- ��Ӧ����f��
 p_u32G -- ��Ӧ����g��	 
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����
 p_u64Dest--64λ��������

 ����ֵ��	

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void InsertReg(DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 p_u32F, DSPU32 p_u32G, DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){

	DSPU32 f = p_u32F ;
	DSPU32 g = p_u32G ;

	DSPU32 iRmLength = 32;
	DSPU32 iRnLength = 32 ;
	DSPU32 iRmBegain = 0;
	DSPU32 iRnBegain = 0;
	DSPU32 iDestBeg = 0;

	bitset<32> u32RnBit;
	bitset<32> u32RmBit;
	bitset<32> u32HighBit;
	bitset<32> u32LowBit;
	bitset<64> u64DestBit;

	u32RnBit.reset();
	u32RmBit.reset();
	u32HighBit.reset();
	u32LowBit.reset();
	u64DestBit.reset();

	bool bolDoRm = true;
	bool bolCondition = false; 

	if ((f == 0) || (g == 0) ||(g > f)||(f>8)||(g>8)) {
		bolCondition = false;
	}

	else {
		bolCondition = true;
	}

	if (bolCondition == false) {
		p_Dest.u32Low = 0;
		p_Dest.u32High = 0;
	}

	if (bolCondition == true) {

		for (unsigned int i = 0; i < 32; i++) {
			if (TestBit(p_u32SrcN,i)) {
				u32RnBit.set(i);
			}
		}

		for (unsigned int i = 0; i < 32; i++) {
			if (TestBit(p_u32SrcM,i)) {
				u32RmBit.set(i);
			}
		}

		//f,g;f,g...
		while ((iRmLength>=0)&&(iRnLength>=0)){
			if((iRmLength==0)&&(iRnLength==0)){
				break;
			}
			
			else{

			while ((iRmLength>=f)&&(iRnLength>=g)) {

				if ((iRmLength>=f)&&(bolDoRm == true)) {

					for (unsigned int i = iDestBeg; i< iDestBeg + f; i++) {
						u64DestBit[i]=u32RmBit[iRmBegain];
						iRmBegain++;
					}
					iDestBeg +=f;					
					iRmLength -=f;
					bolDoRm = false;
					
				}
				if ((iRnLength>=g) &&(bolDoRm == false)) {
					for (unsigned int i = iDestBeg; i< iDestBeg + g; i++) {
						u64DestBit[i]=u32RnBit[iRnBegain];
						iRnBegain++;	
					}
					iDestBeg +=g;					
					iRnLength -=g;
					bolDoRm = true;
				
				}				
			}	
		
			while ((iRmLength>=0)&&(iRmLength<f)&&(iRnLength>=0)) {

				if((iRmLength == 0)&&(iRnLength == 0)){
					break;
				}

				else if (iRmLength>=0) {

					if(iRmLength>0){
						for (unsigned int i = iDestBeg; i< iDestBeg + iRmLength; i++) {
							u64DestBit[i]=u32RmBit[iRmBegain];
							iRmBegain++;

						}
						iDestBeg +=iRmLength;

						iRmLength =0;
						

						for (unsigned int i = iDestBeg; i< iDestBeg + iRnLength; i++) {
							u64DestBit[i]=u32RnBit[iRnBegain];
							iRnBegain++;
						}
						iDestBeg +=iRnLength;
						iRnLength =0;

					}
					else if(iRmLength == 0){
						//bolDoRm = false;

						if(iRnLength>0){
						for (unsigned int i = iDestBeg; i< iDestBeg + iRnLength; i++) {
						u64DestBit[i]=u32RnBit[iRnBegain];

							iRnBegain++;
						}
						iDestBeg +=iRnLength;
						iRnLength =0;
						//bolDoRm = true;
						}
					}
				}
			}

		
			while ((iRmLength>=f)&&(iRnLength>=0)&&(iRnLength<g)) {
				
				if ((iRmLength>=f)&&(bolDoRm == true)) {

					if(iRnLength>0){
						for (unsigned int i = iDestBeg; i< iDestBeg + f; i++) {
							u64DestBit[i]=u32RmBit[iRmBegain];
							iRmBegain++;
						}
						iDestBeg +=f;
						bolDoRm = false;
						iRmLength -=f;

					}


					
					if(iRnLength==0){
						for (unsigned int i = iDestBeg; i< iDestBeg + iRmLength; i++) {
						u64DestBit[i]=u32RmBit[iRmBegain];
						iRmBegain++;
						}
						iDestBeg +=iRmLength;
						iRmLength =0;
						bolDoRm = false;//question
						break;
					}
				
				}



				else if ((iRnLength>=0) &&(bolDoRm == false)) {
					if(iRnLength>0){
						for (unsigned int i = iDestBeg; i< iDestBeg + iRnLength; i++) {
							u64DestBit[i]=u32RnBit[iRnBegain];
							iRnBegain++;
						}
						iDestBeg +=iRnLength;
						iRnLength = 0;
						bolDoRm = true;					
					}
					else if(iRnLength==0){
						bolDoRm = true;	
					}
					
				}

			}


			while ((iRmLength>=0)&&(iRmLength<f)&&(iRnLength>=0)&&(iRnLength<g)) {
				
				if((iRmLength==0)&&(iRnLength==0)) {
					
					break;
				}
				else if ((iRmLength>=0)&&(bolDoRm == true)) {
					
					if(iRmLength>0){
						for (unsigned int i = iDestBeg; i< iDestBeg + iRmLength; i++) {
							u64DestBit[i]=u32RmBit[iRmBegain];
							iRmBegain++;
							
						}
						iDestBeg +=iRmLength;
						iRmLength =0;
						bolDoRm = false;
						

					}
					else if(iRmLength==0){
						bolDoRm = false;
										}
				}
				else if ((iRnLength>=0) &&(bolDoRm == false)) {
					
					if(iRnLength>0){
						
						for (unsigned int i = iDestBeg; i< iDestBeg + iRnLength; i++) {
							u64DestBit[i]=u32RnBit[iRnBegain];
							
							iRnBegain++;
						}
						iDestBeg +=iRnLength;
						iRnLength = 0;
						bolDoRm = true;	
						
					}
					else if(iRnLength==0){
						bolDoRm = true;	
					}
				}
			}
			}//endl else
			
		}

		for (unsigned int i = 0; i< 64; i++) {
			if (i < 32) {

				u32LowBit[i] = u64DestBit[i];
			} else {
				u32HighBit[i-32] = u64DestBit[i];
			}
		}

		p_Dest.u32Low = u32LowBit.to_ulong();
		p_Dest.u32High = u32HighBit.to_ulong();

		u32RnBit.reset();
		u32RmBit.reset();
		u32HighBit.reset();
		u32LowBit.reset();
		u64DestBit.reset();

	}

}


/******************************************************************
 ��������		ExpandDW8To16
 
 ��Ӧָ����ʽ:			HRs1HRs2=EXPAND(ORm,a)(U)
 HRs1HRs2=EXPAND(ORm,Rn)(U)
 HRs1HRs2=EXPAND(ORm,a)
 HRs1HRs2=EXPAND(ORm,Rn)

 ����:			˫��ָ���4��8λ������ת��Ϊ4��16λ������,����ָ�20130507˫��5ָ�

 ����:		p_Res -- 64λ�����Ĵ�����32λ��ӦRs1, ��32λ��ӦRs2��
 p_u32Src -- ���չ8λ����������ӦRm��
 p_u32Pos -- ��Ӧָ���е������a��Rn��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����0λ��ʾ���޷�������0--�޷�������1--�з�������

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern void ExpandDW8To16(DSP_BIT64 &p_Res, DSPU32 p_u32Src, DSPU32 p_u32Pos,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {


	DSPU32 u32Src = p_u32Src ;
	DSPU32 u32Pos = p_u32Pos & 0xf;

	if (u32Pos > 8) {
		u32Pos = 8;
	} 

	DSPU16 u16Mask = 0xff00;
	DSPU16 u8ScrOne, u8ScrTwo, u8ScrThr, u8ScrFour;
	DSPU16 u16DestOne, u16DestTwo, u16DestThr, u16DestFour;

	//initialize
	u8ScrOne = u32Src & 0xff;
	u8ScrTwo = (u32Src >> 8) & 0xff;
	u8ScrThr = (u32Src >> 16) & 0xff;
	u8ScrFour = (u32Src >> 24) & 0xff;

	//computer 
	//unsigned
	if (TestBit(p_u32SHFCR,0) == 0) {
		//computer u16Dest respectively
		u16DestOne = u8ScrOne << u32Pos;
		u16DestTwo = u8ScrTwo << u32Pos;
		u16DestThr = u8ScrThr << u32Pos;
		u16DestFour = u8ScrFour << u32Pos;

	} else {//signed
		//computer mask underly signed 
		if (TestBit(u8ScrOne,7)) {
			u16DestOne = (u8ScrOne | u16Mask)<< u32Pos ;
		}

		else {
			u16DestOne = u8ScrOne << u32Pos;
		}

		if (TestBit(u8ScrTwo,7)) {
			u16DestTwo = (u8ScrTwo |u16Mask)<< u32Pos;
		}

		else {
			u16DestTwo = u8ScrTwo << u32Pos;
		}

		if (TestBit(u8ScrThr,7)) {
			u16DestThr = (u8ScrThr|u16Mask) << u32Pos ;
		}

		else {
			u16DestThr = u8ScrThr << u32Pos;
		}

		if (TestBit(u8ScrFour,7)) {
			u16DestFour = ((u8ScrFour|u16Mask) << u32Pos) ;
		}

		else {
			u16DestFour = u8ScrFour << u32Pos;
		}
	}
	p_Res.u32High = (u16DestFour << 16) | u16DestThr;
	p_Res.u32Low = (u16DestTwo << 16) | u16DestOne;
}

/******************************************************************
 ��������		CompactDW16to8
 
 ��Ӧָ����ʽ:			ORs=COMPACT(HRmHRn,a)(U)
 ORs=COMPACT(HRmHRn,a)

 ����:			˫��ָ���4��16λ������ת��Ϊ4��8λ������,����ָ�20130507˫��5ָ�

 ����:		p_u32Rm -- ��ѹ��λ����������ӦRm��
 p_u32Rn -- ��ѹ��λ����������ӦRn��
 p_u32Pos -- ��Ӧָ���е������a��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��
 p_u32SHFCR -- ��λ�����ƼĴ�����0λ��ʾ���޷�������0--�޷�������1--�з�������

 ����ֵ��		����������

 ע������:		���ݼ��������������ر�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�
 
 *******************************************************************/
extern DSPU32 CompactDW16to8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32Pos,
		DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {

	DSPU32 u32Pos;

	if (p_u32Pos > 8) {
		u32Pos = 8;
	} else {
		u32Pos = p_u32Pos;
	}

	DSPU16 u16SrcOne, u16SrcTwo, u16SrcThr, u16SrcFour;
	DSPI16 i16SrcOne, i16SrcTwo, i16SrcThr, i16SrcFour;

	u16SrcOne = p_u32Rn & 0xffff;
	u16SrcTwo = (p_u32Rn >> 16) & 0xffff;
	u16SrcThr = p_u32Rm & 0xffff;
	u16SrcFour = (p_u32Rm >> 16) & 0xffff;

	i16SrcOne = (DSPI16)(p_u32Rn & 0xffff);
	i16SrcTwo = (DSPI16)((p_u32Rn >> 16) & 0xffff);
	i16SrcThr = (DSPI16)(p_u32Rm & 0xffff);
	i16SrcFour = (DSPI16)((p_u32Rm >> 16) & 0xffff);

	DSPU8 u8DestOne, u8DestTwo, u8DestThr, u8DestFour;
	
	u8DestOne = (u16SrcOne >> u32Pos) & 0xff;
	u8DestTwo = (u16SrcTwo >> u32Pos) & 0xff;
	u8DestThr = (u16SrcThr >> u32Pos) & 0xff;
	u8DestFour = (u16SrcFour >> u32Pos) & 0xff;
	
	DSPU32 u32Dest = 0;

	bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);
	bool bolSrcSignOne=false,bolSrcSignTwo=false,bolSrcSignThr=false,bolSrcSignFour=false;
	bool bolSignedOverflowOne = false,bolSignedOverflowTwo = false,bolSignedOverflowThr = false,bolSignedOverflowFour = false;
	bool bolUnsignedOverflowOne = false,bolUnsignedOverflowTwo = false,bolUnsignedOverflowThr = false,bolUnsignedOverflowFour= false;	

	DSPI16 i16SrcShfOne,i16SrcShfTwo,i16SrcShfThr,i16SrcShfFour;
	DSPU16 u16SrcShfOne,u16SrcShfTwo,u16SrcShfThr,u16SrcShfFour;

	////
	i16SrcShfOne = i16SrcOne >> u32Pos;	
	bolSignedOverflowOne = (((i16SrcShfOne >> 7) &0xffff)!= 0x0)&& (((i16SrcShfOne >> 7)&0xffff) != 0xffff);
	bolSrcSignOne= TestBit (u16SrcOne, 15);

	u16SrcShfOne= u16SrcOne >> u32Pos;
	bolUnsignedOverflowOne = (u16SrcShfOne >> 8) != 0x0;
	////
	i16SrcShfTwo = i16SrcTwo >> u32Pos;	
	bolSignedOverflowTwo = (((i16SrcShfTwo >> 7) &0xffff)!= 0x0)&& (((i16SrcShfTwo >> 7)&0xffff) != 0xffff);
	bolSrcSignTwo= TestBit (u16SrcTwo, 15);

	u16SrcShfTwo= u16SrcTwo >> u32Pos;
	bolUnsignedOverflowTwo = (u16SrcShfTwo >> 8) != 0x0;
	////
	i16SrcShfThr = i16SrcThr >> u32Pos;	
	bolSignedOverflowThr = (((i16SrcShfThr >> 7) &0xffff)!= 0x0)&& (((i16SrcShfThr >> 7)&0xffff) != 0xffff);
	bolSrcSignThr= TestBit (u16SrcThr, 15);

	u16SrcShfThr= u16SrcThr >> u32Pos;
	bolUnsignedOverflowThr = (u16SrcShfThr >> 8) != 0x0;
	////
	i16SrcShfFour = i16SrcFour >> u32Pos;	
	bolSignedOverflowFour = (((i16SrcShfFour >> 7) &0xffff)!= 0x0)&& (((i16SrcShfFour >> 7)&0xffff) != 0xffff);


	bolSrcSignFour= TestBit (u16SrcFour, 15);

	u16SrcShfFour= u16SrcFour >> u32Pos;
	bolUnsignedOverflowFour = (u16SrcShfFour >> 8) != 0x0;


	if (bolSigned) {
		if (bolSignedOverflowOne) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);

			if (bolSatu) {
				if (bolSrcSignOne) {
					u8DestOne = 0x80;
				} else {
					u8DestOne = 0x7f;
				}			}			
		}

	
		if (bolSignedOverflowTwo) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				if (bolSrcSignTwo) {
					u8DestTwo = 0x80;
				} else {
					u8DestTwo = 0x7f;
				}			}			
		}

		if (bolSignedOverflowThr) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				if (bolSrcSignThr) {
					u8DestThr = 0x80;
				} else {
					u8DestThr = 0x7f;
				}			}			
		}

		
		if (bolSignedOverflowFour) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				if (bolSrcSignFour) {
					u8DestFour = 0x80;
					
				} else {
					u8DestFour = 0x7f;
				}			}			
		}

	}

	else{

		if (bolUnsignedOverflowOne) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				u8DestOne = 0xff;
			}
		}
		
		if (bolUnsignedOverflowTwo) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				u8DestTwo = 0xff;
			}
		}
		
		if (bolUnsignedOverflowThr) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				u8DestThr = 0xff;
			}
		}

		if (bolUnsignedOverflowFour) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
			if (bolSatu) {
				u8DestFour = 0xff;
			}
		}
	
	}

	u32Dest = (u8DestFour << 24)|(u8DestThr << 16)|(u8DestTwo <<8)|u8DestOne;

	return u32Dest;

}

//----------------------------------------------------------------------------------------------
/*found*****************************************************************
 ��������		Flo64ToFix32

 Rs=DFRm_Rn

 ����:			��64λ��������ת��Ϊ32λ�������ݡ�

 ����:			p_u32SrcLow -- 64λ�������ĵ�32λ����ӦRn��
 p_u32SrcHigh -- 64λ�������ĸ�32λ����ӦRm��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		32λ����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����:2013.3.4  ����:baohua		�޸Ĵ�

 *******************************************************************/
extern DSPU32 Flo64ToFix32(DSPU32 p_u32SrcLow, DSPU32 p_u32SrcHigh,
		DSPU32 p_u32Adjust, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
bool u1Saturation= TestFlag(p_u32SHFCR,SHF_Ctl_Saturation); 
	bool u1Scr1Neg = ((p_u32SrcHigh & 0x80000000) == 0x80000000) ? true : false;

	DSPU32 u32Dest = 0;
	DSPU32 u32Src1TmpLow = 0,u32Src1TmpHgh = 0;
	DSPU32 u32FracLow = 0,u32FracHgh = 0;
	DSPI32  i32Exp = 0, i32DiffExp = 0;

	u32Src1TmpLow = p_u32SrcLow;
	u32Src1TmpHgh = (p_u32SrcHigh&0xfffff)|0x100000; 

	
	u32FracLow = p_u32SrcLow;
	u32FracHgh = p_u32SrcHigh&0xfffff; 

	bitset<32> bitvec32;
	bitvec32.reset();
	bitset<150> bitvec150, bitvecTmp150One, bitvecTmp150Two;
	bitvec150.reset();
	bitvecTmp150One.reset();
	bitvecTmp150Two.reset();

	for (int i = 0; i<64; i++) {
		if (i<32) {
			if (TestBit(u32Src1TmpLow, i))
				bitvec150.set(i);
		} else {
			if (TestBit(u32Src1TmpHgh, i-32))
				bitvec150.set(i);
		}
	}

	
        i32Exp = (DSPU32)((p_u32SrcHigh>>20)&0x7ff);	
	if ((p_u32Adjust&0x400)==0) { 		
		i32DiffExp = i32Exp - (p_u32Adjust&0x7ff) - 0x3ff;
	}
	
	else if((p_u32Adjust&0x400)==0x400) { 		
		i32DiffExp = i32Exp + ((~p_u32Adjust+1)&0x7ff)- 0x3ff;			
	}	
	
	if (i32Exp == 0) {		
		return 0;
	}


	else if (i32Exp == 0x7ff) {
		//NAN
		if ((u32FracHgh !=0)||(u32FracLow!=0)) {
			SetFlag(*p_pStatReg, SHF_FInvalid);
			SetFlag(*p_pStatReg, SHF_SFIS);
			return N_A_N;
		}

		else if ((u32FracHgh ==0)&&(u32FracLow==0)) {

			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			//A �������� 
			if (!u1Scr1Neg) {
				//A:�������� 
				if (u1Saturation){
					u32Dest = 0x7fffffff;
					}

				//B:���������� 
				if (!u1Saturation) {
					//����i32DiffExpλ
					for (int i =0; i<64; i++) {
						if((i+i32DiffExp)<150){
							bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
						}
					}
					//����λ52λ
					for (int i =0; i<76; i++) {
						bitvecTmp150Two[i] = bitvecTmp150One[i+52];
					}
					//ȡ������32λ��
					for (int i =0; i<32; i++) {
						bitvec32[i] = bitvecTmp150Two[i];
					}
					u32Dest = (DSPU32)bitvec32.to_ulong();
				}
				return u32Dest;
			}
			//B �������� 
			else if (u1Scr1Neg) {
				//A:�������� 
				if (u1Saturation) {
					u32Dest = 0x80000000;
				}
				//B:���������� 
				if (!u1Saturation) {
					//����i32DiffExpλ
					for (int i =0; i<64; i++) {
						if((i+i32DiffExp)<150){
							bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
						}
					}
					//����λ52λ
					for (int i =0; i<76; i++) {
						bitvecTmp150Two[i] = bitvecTmp150One[i+52];
					}
					//ȡ������32λ��
					for (int i =0; i<32; i++) {
						bitvec32[i] = bitvecTmp150Two[i];
					}
					u32Dest = (DSPU32)bitvec32.to_ulong();
					u32Dest = ~u32Dest + 1;
				}
				return u32Dest;
			}			
		}
	}

	//(5)������
	else if (i32DiffExp == 0) {

		if (!u1Scr1Neg){
			return 0x1; //uDest = 1
		}

		if (u1Scr1Neg){	
					
			return 0xffffffff;//-1  
		}
	}

	//(6)
	else if (i32DiffExp < 0) {
		
		return 0;
	}
	//(7) <= 30
	else if (i32DiffExp <= 30) {
		//1 ����
		if (!u1Scr1Neg) {

			for (int i =0; i<64; i++) {
				bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
			}

			for (int i =0; i<76; i++) {
				bitvecTmp150Two[i] = bitvecTmp150One[i+52];
			}
	
			for (int i =0; i<32; i++) {
				bitvec32[i] = bitvecTmp150Two[i];
			}
			u32Dest = (DSPU32)bitvec32.to_ulong();
	
			return u32Dest;

		}

		//2 ���� 
		if (u1Scr1Neg) {
		
			for (int i =0; i<64; i++) {
				bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
			}

			for (int i =0; i<76; i++) {
				bitvecTmp150Two[i] = bitvecTmp150One[i+52];
			}

			for (int i =0; i<32; i++) {
				bitvec32[i] = bitvecTmp150Two[i];
			}

			u32Dest = (DSPU32)bitvec32.to_ulong();
			
			u32Dest = ~u32Dest + 1;

			return u32Dest;
		}
	}

	//5 >= 31
	//else if ((i32DiffExp >= 30)&&(i32DiffExp <= 77 )) {
	else if ((i32DiffExp >= 31)&&(i32DiffExp <= 83 )) {
		//1 ���� ������
		if (u1Scr1Neg == false) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);

			if (u1Saturation) {
				u32Dest = 0x7fffffff;
				return u32Dest;
			}


			if (!u1Saturation) {

				for (int i =0; i<64; i++) {
					bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
				}

				for (int i =0; i<76; i++) {
					bitvecTmp150Two[i] = bitvecTmp150One[i+52];
				}

				for (int i =0; i<32; i++) {
					bitvec32[i] = bitvecTmp150Two[i];
				}				
				u32Dest = (DSPU32)bitvec32.to_ulong();
				return u32Dest;
			}
		}

		//2 ���� ����diffexp��31������
		if (u1Scr1Neg==true) {

			if((u32Src1TmpHgh == 0x100000)&&(u32Src1TmpLow==0)&&(i32DiffExp==31)){

				if (u1Saturation) {
					u32Dest = 0x80000000;
					return u32Dest;
	
				}
				//C:�������������� 
				else if (!u1Saturation) {
	
					//����i32DiffExpλ
					for (int i =0; i<64; i++) {
						bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
					}
					//����λ52λ
					for (int i =0; i<76; i++) {
						bitvecTmp150Two[i] = bitvecTmp150One[i+52];
					}
					//ȡ������32λ��
					for (int i =0; i<32; i++) {
						bitvec32[i] = bitvecTmp150Two[i];
					}
					u32Dest = (DSPU32)bitvec32.to_ulong();
					u32Dest = ~u32Dest + 1;
	
					return u32Dest;
				}

			}
			else{
				SetFlag(*p_pStatReg, SHF_OverFlow);
				SetFlag(*p_pStatReg, SHF_SOVS);
				SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
				SetFlag(*p_pStatReg, SHF_OV32BitS);
				//B:������������ 
				if (u1Saturation) {
					u32Dest = 0x80000000;
					return u32Dest;
	
				}
				//C:�������������� 
				else if (!u1Saturation) {
	
					//����i32DiffExpλ
					for (int i =0; i<64; i++) {
						bitvecTmp150One[i+i32DiffExp] = bitvec150[i];
					}
					//����λ52λ
					for (int i =0; i<76; i++) {
						bitvecTmp150Two[i] = bitvecTmp150One[i+52];
					}
					//ȡ������32λ��
					for (int i =0; i<32; i++) {
						bitvec32[i] = bitvecTmp150Two[i];
					}
					u32Dest = (DSPU32)bitvec32.to_ulong();
					u32Dest = ~u32Dest + 1;
	
					return u32Dest;
				}
			}
		}
	}

	else if (i32DiffExp >= 84) {
	
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);
				//1 ���� ������
		if (!u1Scr1Neg) {

			//A:�������� 
			if (u1Saturation){				
				return 0x7fffffff;
			}				

			//B:������
			if (!u1Saturation){
				return 0;
			}
		}

		//2 ���� ����diffexp��31������
		if (u1Scr1Neg) {
			//A:Դ��������0x800000 -1 ���������� 

			//B:������������ 		
			
			if (u1Saturation) {
				
				return 0x80000000;
			}
			//C:�������������� 
			if (!u1Saturation) {
				
				return 0;
			}
		}
	}

	bitvec32.reset();
	bitvec150.reset();
	bitvecTmp150One.reset();
	bitvecTmp150Two.reset();
}

/*found*****************************************************************
 ��������		Fix32ToFlo64

 ָ����ʽ��DFRs1_Rs2=Rn

 ����:			��32λ��������ת��Ϊ64λ�������ݡ�

 ����:		p_u32Src -- 32λ����Դ����������ӦRn��
 p_u32DestLow -- 64λ�������ĵ�32λ����ӦRs2��(��Ӧ��Rs1,baohua)
 p_u32DestHigh -- 64λ�������ĸ�32λ����ӦRs1��(��Ӧ��Rs2,baohua)
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		�ޡ�

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern void Fix32ToFlo64(DSPU32 p_u32Src, DSPU32 &p_u32DestHigh,
		DSPU32 &p_u32DestLow, DSPU32 p_u32Adjust, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	bool u1Saturation= TestFlag(p_u32SHFCR ,SHF_Ctl_Saturation); 
	bool bolSignTemp = false;

	DSPU32 u32Src = (DSPU32)p_u32Src;
	DSPU32 u32ExpOffset = 0;
	DSPU32 u32ExpTemp = 0;
	DSPU32 u32Count = 0;
	DSPU8 u32ExpAmend = 0;
	DSPU32 u32FracHigh = 0, u32FracLow = 0;
	DSPU32 u32BitOneLoc = 0;
	DSPI32 i32ExpSum = 0;
	
	DSPU32 u32FracTemp = 0;
	DSPU64 u64Frac = 0,u64FracTemp = 0;

	//A 
	if (p_u32Src == 0) {
		p_u32DestLow = 0;
		p_u32DestHigh = 0;
	}

	//B 
	else {
		if ((u32Src & 0x80000000) !=0) {
			bolSignTemp = true;
			u32Src = ~u32Src+1; 
		}

		for (int i = 31; i>-1; i--)
		{

			if (!(u32Src>>i)) {
				++u32ExpTemp; 
			}
			//stop 
			else {
				
				u32BitOneLoc = i;
				break; //break ������ 
			}
		}

		u32Count = u32ExpTemp+1;

		if ((p_u32Adjust&0x400)==0) {
			i32ExpSum = 0x3ff + u32BitOneLoc + (p_u32Adjust&0x7ff);
		}//ָ����
		
		
		else if ((p_u32Adjust&0x400)==0x400) {
			i32ExpSum = 0x3ff + u32BitOneLoc -((~p_u32Adjust+1)&0x7ff);//����2009.11.19 ����������0xff�ٱ��� 
		}

		if (i32ExpSum <= 0) {
			SetFlag(*p_pStatReg, SHF_FUnderFlow);
			SetFlag(*p_pStatReg, SHF_SFUS);
			
			if (u1Saturation) {
				p_u32DestHigh = 0;
				p_u32DestLow = 0;
			}
			if (!u1Saturation) {
				u32ExpOffset = i32ExpSum & 0x7ff;
				
				u32FracTemp = u32Src<<u32Count;
				if(u32Count == 0x20){
					u32FracTemp = 0;
				}
				u64FracTemp = ((DSPU64)u32FracTemp)<<32;
				u64Frac = u64FracTemp >> 12;
				u32FracHigh = (DSPU32)(u64Frac>>32); 
				u32FracLow = (DSPU32)u64Frac;

				p_u32DestLow = u32FracLow;
				p_u32DestHigh = (bolSignTemp<<31)| u32ExpOffset<<20|u32FracHigh;
			}
		}

		//B��> = 2047 
		else if (i32ExpSum >= 0x7ff) {

			SetFlag(*p_pStatReg, SHF_FOverFlow);
			SetFlag(*p_pStatReg, SHF_SFVS);

			if (u1Saturation) {
				u32ExpOffset = 0x7fe;  
				u32FracHigh = 0xfffff;
				u32FracLow = 0xffffffff;
			}

			if (!u1Saturation) {
				u32ExpOffset = i32ExpSum & 0x7ff;
				
				u32FracTemp = u32Src<<u32Count;
				if(u32Count == 0x20){
					u32FracTemp = 0;
				}
				u64FracTemp = ((DSPU64)u32FracTemp)<<32;
				u64Frac = u64FracTemp >> 12;
				u32FracHigh = (DSPU32)(u64Frac>>32); 
				u32FracLow = (DSPU32)u64Frac;
			}
			p_u32DestLow = u32FracLow;
			p_u32DestHigh = (bolSignTemp<<31)| u32ExpOffset<<20|u32FracHigh;
		}

		//((i32ExpSum > 0) &&(i32ExpSum < 0x7ff)) 
		else {
			u32ExpOffset =i32ExpSum & 0x7ff;
			
			u32FracTemp = (u32Src<<u32Count);
			if(u32Count ==0x20){
				u32FracTemp = 0;
			}
			
			u64FracTemp = ((DSPU64)u32FracTemp)<<32;
			u64Frac = u64FracTemp >> 12;
			u32FracHigh = (DSPU32)(u64Frac>>32); 
			u32FracLow = (DSPU32)u64Frac;
			
			p_u32DestLow = u32FracLow;
			p_u32DestHigh = (bolSignTemp<<31)| u32ExpOffset<<20|u32FracHigh;
		}		
	}
}

/*found*****************************************************************
 ��������		Flo64ToFix64

 ָ����ʽ��Rs1s2=FIX DFRm+1:m
 Rs1s2=FIX(DFRm+1:m,C)

 ����:			��64λ��������ת��Ϊ64λ�������ݡ�

 ����:		 p_u32SrcLow -- 64λ�������ĵ�32λ����ӦRm��
 p_u32SrcHigh -- 64λ�������ĸ�32λ����ӦRm+1��
 p_u32Adjust -- �з�����,��Ӧָ���е�C��
 p_Dest -- 64λ������32λ��ӦRs1����ת����64λ�������ĵ�32λ, ��32λ��ӦRs2����ת����64λ�������ĸ�32λ��
 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
 p_u32SHFCR -- ��λ�����ƼĴ�����

 ����ֵ��		64λ����������

 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

 �޸ļ�¼
 --------------------------------------
 ����			����			�޸Ĵ�

 *******************************************************************/
extern void Flo64ToFix64(DSPU32 p_u32SrcLow, DSPU32 p_u32SrcHigh,
		DSPU32 p_u32Adjust, DSP_BIT64 &p_Dest, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {
	*p_pStatReg &= 0x7f00;
	DSPU32 u32FloSrcLow = (DSPU32)p_u32SrcLow;
	DSPU32 u32FloSrcHgh = (DSPU32)p_u32SrcHigh;

	DSPI32 i32ExpAjust = 0, i32DiffExp = 0;
	DSPI32 i32ExpSrc = (DSPU32)((u32FloSrcHgh >> 20) & 0x7ff);

	DSPU64 u64Frag = 0, u64FragTemp = 0;
	
	bool bolSignBit= TestBit(u32FloSrcHgh,31);
	bool u1Saturation= TestFlag(p_u32SHFCR ,SHF_Ctl_Saturation); 

	bool bolSignAdjust = ((p_u32Adjust & 0x400) == 0x400) ? true : false;

	bitset<32> u32FragBit;
	bitset<32> u32FragHighBit;
	bitset<32> u32FragLowBit;
	bitset<64> u64FragBit;
	bitset<64> u64FragTempBit;
	bitset<200> u200FragTempBit;
	u32FragBit.reset();
	u32FragHighBit.reset();
	u32FragLowBit.reset();
	u64FragBit.reset();
	u64FragTempBit.reset();
	u200FragTempBit.reset();
	

	DSPU32 u32FloFracLow = u32FloSrcLow;
	DSPU32 u32FloFracHgh = (u32FloSrcHgh & 0xfffff) | 0x100000;	
	
	DSPU32 u32FracLow = u32FloSrcLow;
	DSPU32 u32FracHgh = u32FloSrcHgh & 0xfffff;
	

	for (int i = 0, j = 0; i < 64; i++) {
		if (i < 32){
			if(TestBit(u32FloFracLow,i)) {
			u64FragTempBit.set(i);}
		}
		else {
			j = i - 32;
			if (TestBit(u32FloFracHgh,j)) {
				u64FragTempBit.set(i);
			}
		}
	}
	
	//B.
	if(!bolSignAdjust){
		i32ExpAjust = p_u32Adjust&0x7ff;
		i32DiffExp = i32ExpSrc - i32ExpAjust -0x3ff;
		//cout<<"i32DiffExp:"<<i32DiffExp<<endl;
	}
	
	if(bolSignAdjust){
		i32ExpAjust = (~(p_u32Adjust&0x7ff)+1)&0x7ff;
		i32DiffExp = i32ExpSrc + i32ExpAjust -0x3ff;
	}
	

	
	//C �ж�		
	//C.1 �DNorm and Zero�����
	if (i32ExpSrc == 0) {
		p_Dest.u32Low = 0;
		p_Dest.u32High = 0;		
	}	
		
	//c.2 ��NAN
	else if ((i32ExpSrc == 0x7ff) &&((u32FracLow != 0)||(u32FracHgh != 0))) {
		SetFlag(*p_pStatReg, SHF_FInvalid);
		SetFlag(*p_pStatReg, SHF_SFIS);
		p_Dest.u32Low = 0xffffffff;
		p_Dest.u32High = 0xffffffff;
	}

	//C.3 infinite
	else if (i32ExpSrc == 0x7ff) {		
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
		SetFlag(*p_pStatReg, SHF_OV32BitS);


		//C.3.1
		if (!bolSignBit) {

			//A
			if (u1Saturation) {
				p_Dest.u32Low = 0xffffffff;
				p_Dest.u32High = 0x7fffffff;
			}
			//B:
			else {
				if (i32DiffExp <=0) {
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0;	
				}
				
				else if (i32DiffExp <=115) {
					for (int i = 0; i < 64; i++) {
						u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
					}
				
					for (int i = 0, j = 0; i < 64; i++) {
						j = i + 52;
						u64FragBit[i] = u200FragTempBit[j];
					}
					//u64Frag = u64FragBit.to_ulong();					
					
					for (int i = 0; i < 64; i++) {
						if(i < 32){
							u32FragLowBit[i]=u64FragBit[i];						
						}
						else{
							u32FragHighBit[i-32]=u64FragBit[i];
						}					
					}
					p_Dest.u32High = u32FragHighBit.to_ulong();
					p_Dest.u32Low = u32FragLowBit.to_ulong();
				}
				//i32DiffExp >115
				else {
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0;						
				}
			}
		}
		//C.3.2 ��������
		else if (bolSignBit) {
			//A:
			if (u1Saturation) {
				p_Dest.u32Low = 0;
				p_Dest.u32High = 0x80000000;
			}
			//B:
			else {
				if (i32DiffExp <=0) {
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0;					
				}
				
				else if (i32DiffExp <=115) {
							
					for (int i = 0; i < 64; i++) {
						u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
					}
					//ʵ
					for (int i = 0, j = 0; i < 64; i++) {
						j = i + 52;
						u64FragBit[i] = u200FragTempBit[j];
					}
					//u64FragTemp = u64FragBit.to_ulong();
					//u64Frag = ~u64FragTemp + 1;
					//p_Dest.u32High = (DSPU32)(u64Frag >> 32);
					//p_Dest.u32Low = (DSPU32)(u64Frag);
					for (int i = 0; i < 64; i++) {
						if(i < 32){
							u32FragLowBit[i]=u64FragBit[i];						
						}
						else{
							u32FragHighBit[i-32]=u64FragBit[i];
						}					
					}
					
					p_Dest.u32Low = ~u32FragLowBit.to_ulong() + 1;
					
					if(u32FragLowBit.to_ulong() == 0){
						p_Dest.u32High = ~u32FragHighBit.to_ulong() +1;
					
					}
					
					else{
						p_Dest.u32High = ~u32FragHighBit.to_ulong();
					}
					
						
				}
				//i32DiffExp >115
				else {
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0;						
				}
			}
		}
	}//end c.3

	//C.4 ������
	else {		
		if (i32DiffExp <0) {
			p_Dest.u32Low = 0;
			p_Dest.u32High = 0;	
	
		}
		//c.4.2 ָ����Ϊ0
		else if (i32DiffExp == 0) {
			//����:1
			if (!bolSignBit) {
				p_Dest.u32Low = 1;
				p_Dest.u32High = 0;
			}
			//���� :-1			
			else if (bolSignBit) {
				p_Dest.u32Low = 0xffffffff;
				p_Dest.u32High = 0xffffffff;
			}
		}
		//c.4.3 
		else if (i32DiffExp < 63) {
			
			if (!bolSignBit) {
				//ʵ��������λ					
					for (int i = 0; i < 64; i++) {
						u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
					}
					//ʵ��������λ52λ�����ҽ�ȡ64λβ��
					for (int i = 0, j = 0; i < 64; i++) {
						j = i + 52;
						u64FragBit[i] = u200FragTempBit[j];
					}
										
					for (int i = 0; i < 64; i++) {
						if(i < 32){
							u32FragLowBit[i]=u64FragBit[i];						
						}
						else{
							u32FragHighBit[i-32]=u64FragBit[i];
						}					
					}
					p_Dest.u32High = u32FragHighBit.to_ulong();
					p_Dest.u32Low = u32FragLowBit.to_ulong();				
			}
			//���� :-1			
			else if (bolSignBit) {
					for (int i = 0; i < 64; i++) {
						u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
					}
					for (int i = 0, j = 0; i < 64; i++) {
						j = i + 52;
						u64FragBit[i] = u200FragTempBit[j];
					}
						for (int i = 0; i < 32; i++) {
						u32FragBit[i] = u64FragBit[i];
					}
					for (int i = 0; i < 64; i++) {
						if(i < 32){
							u32FragLowBit[i]=u64FragBit[i];						
						}
						else{
							u32FragHighBit[i-32]=u64FragBit[i];
						}					
					}
					
					p_Dest.u32Low = ~u32FragLowBit.to_ulong() + 1;
					
					if(u32FragLowBit.to_ulong() == 0){
						p_Dest.u32High = ~u32FragHighBit.to_ulong() +1;
					
					}
					
					else{
						p_Dest.u32High = ~u32FragHighBit.to_ulong();
					}
			}
		}

		//c.4.4 ָ����:[63,115]
		else if ((i32DiffExp >= 63)&&(i32DiffExp <= 115)) {			
			if (!bolSignBit) {			
				
				if (u1Saturation) {
					p_Dest.u32Low = 0xffffffff;
					p_Dest.u32High = 0x7fffffff;
						
				}
				//B ������
				else {					
					for (int i = 0; i < 64; i++) {
						u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
					}
					for (int i = 0, j = 0; i < 64; i++) {
						j = i + 52;
						u64FragBit[i] = u200FragTempBit[j];
					}
					for (int i = 0; i < 32; i++) {
						u32FragBit[i] = u64FragBit[i];
					}
					
					for (int i = 0; i < 64; i++) {
						if(i < 32){
							u32FragLowBit[i]=u64FragBit[i];						
						}
						else{
							u32FragHighBit[i-32]=u64FragBit[i];
						}					
					}
					p_Dest.u32High = u32FragHighBit.to_ulong();
					p_Dest.u32Low = u32FragLowBit.to_ulong();					
				}
				
				SetFlag(*p_pStatReg, SHF_OverFlow);
				SetFlag(*p_pStatReg, SHF_SOVS);
				SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
				SetFlag(*p_pStatReg, SHF_OV32BitS);	
			}
		
			if (bolSignBit) {
				
				//A ����
				if(( u32FloFracHgh == 0x100000)&&(u32FloFracLow == 0) && (i32DiffExp ==63)){
					if (u1Saturation) {
						p_Dest.u32Low = 0;
						p_Dest.u32High = 0x80000000;
					}
					
					if (!u1Saturation){					
						for (int i = 0; i < 64; i++) {
							u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
						}
	
						for (int i = 0, j = 0; i < 64; i++) {
							j = i + 52;
							u64FragBit[i] = u200FragTempBit[j];
						}		
						for (int i = 0; i < 64; i++) {
							if(i < 32){
								u32FragLowBit[i]=u64FragBit[i];
							}
							else{
								u32FragHighBit[i-32]=u64FragBit[i];
							}					
						}
					
						p_Dest.u32Low = ~u32FragLowBit.to_ulong() + 1;
					
						if(u32FragLowBit.to_ulong() == 0){
							p_Dest.u32High = ~u32FragHighBit.to_ulong() +1;
					
						}
					
						else{
							p_Dest.u32High = ~u32FragHighBit.to_ulong();
						}					
					}					
				}
				//B
				else if (u1Saturation) {
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0x80000000;
					
					SetFlag(*p_pStatReg, SHF_OverFlow);
					SetFlag(*p_pStatReg, SHF_SOVS);
					SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
					SetFlag(*p_pStatReg, SHF_OV32BitS);	
				}
				//c
				else if (!u1Saturation){					
					for (int i = 0; i < 64; i++) {
						u200FragTempBit[i+i32DiffExp] = u64FragTempBit[i];
					}

					for (int i = 0, j = 0; i < 64; i++) {
						j = i + 52;
						u64FragBit[i] = u200FragTempBit[j];
					}
							
					for (int i = 0; i < 64; i++) {
						if(i < 32){
							u32FragLowBit[i]=u64FragBit[i];						
						}
						else{
							u32FragHighBit[i-32]=u64FragBit[i];
						}					
					}
					
					p_Dest.u32Low = ~u32FragLowBit.to_ulong() + 1;
					
					if(u32FragLowBit.to_ulong() == 0){
						p_Dest.u32High = ~u32FragHighBit.to_ulong() +1;
					
					}
					
					else{
						p_Dest.u32High = ~u32FragHighBit.to_ulong();
					}

					SetFlag(*p_pStatReg, SHF_OverFlow);
					SetFlag(*p_pStatReg, SHF_SOVS);
					SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
					SetFlag(*p_pStatReg, SHF_OV32BitS);						
				}
			}//end 

		}//end c.4.4 

		//c.4.5 
		else if ((i32DiffExp > 115)) {

			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow32Bit);
			SetFlag(*p_pStatReg, SHF_OV32BitS);
			//A 
			if (!bolSignBit) {
			
				if(u1Saturation){
					p_Dest.u32Low = 0xffffffff;
					p_Dest.u32High = 0x7fffffff;
				}
				
				if(!u1Saturation){
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0;				
				}
			}
			//B 
			else {
				if(u1Saturation){
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0x80000000;
				}
				
				if(!u1Saturation){
					p_Dest.u32Low = 0;
					p_Dest.u32High = 0;					
				}
			}
		}

	}//end C.4 ������

	u32FragBit.reset();
	u32FragHighBit.reset();
	u32FragLowBit.reset();
	u64FragBit.reset();
	u64FragTempBit.reset();
	u200FragTempBit.reset();
}

	/*found*****************************************************************
	 ��������		Fix64ToFlo64

	 ָ����ʽ��DFRs+1:s=Double RmRn
	 DFRs+1:s=Double(RmRn,C)

	 ����:			��64λ��������ת��Ϊ64λ�������ݡ�

	 ����:		p_u32Rm -- ��ӦRm, ��64λ�������ĵ�32λ��
	 p_u32Rn -- ��ӦRn, ��64λ�������ĸ�32λ��
	 p_u32DestLow -- 64λ�������ĵ�32λ����ӦRs��
	 p_u32DestHigh -- 64λ�������ĸ�32λ����ӦRs+1��
	 p_u32Adjust -- �з�����,��Ӧָ���е�C��
	 p_pStatReg -- ָ����־�Ĵ�����������ָ�룬��ָ�ڴ�������ʼΪ0��	
	 p_u32SHFCR -- ��λ�����ƼĴ�����

	 ����ֵ��		�ޡ�

	 ע������:		1. ���ݼ����������ñ�־�Ĵ���������SHF�ı�־λ��

	 �޸ļ�¼
	 --------------------------------------
	 ����			����			�޸Ĵ�

	 *******************************************************************/
extern void Fix64ToFlo64(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 &p_u32DestHigh,
		DSPU32 &p_u32DestLow, DSPU32 p_u32Adjust, DSPU32 *p_pStatReg,
		DSPU32 p_u32SHFCR) {

	bool u1Saturation= TestFlag(p_u32SHFCR ,SHF_Ctl_Saturation); //���Ϳ���λ 
	bool bolSignBit = false;

	DSPU32 u32RmSrc = (DSPU32)p_u32Rm;
	DSPU32 u32RnSrc = (DSPU32)p_u32Rn;

	DSPU32 u32ExpOffset = 0;
	DSPU32 u32ExpTotalCount = 0;
	DSPU32 u32ExpAmend = 0;
	DSPU32 u32FracHighRes = 0, u32FracLowRes = 0;
	DSPU32 u32BitOneLoc = 0;
	DSPU64 u64Src, u64ComSrc, u53TempFragment, u53Fragment, u52Fragment;
	u64ComSrc = (((DSPU64)u32RnSrc)<<32) | (DSPU64)u32RmSrc;
	DSPI32 i32ExpSum = 0;

	bitset<64> u64SrcBit;
	u64SrcBit.reset();

	//A 
	if ((u32RmSrc == 0)&& (u32RnSrc == 0)) {
		p_u32DestLow = 0;
		p_u32DestHigh = 0;
	}

	//B �ж����벻Ϊ0
	else {//�����ж��Ƿ�Ϊ����

		//judge the input is negative?
		bolSignBit = ((u32RnSrc & 0x80000000) == 0x80000000) ? true : false;


		if (bolSignBit) {
			u64Src = ~u64ComSrc+1;
		} else {
			u64Src = u64ComSrc;
		}

		for (int i = 63; i>-1; i--) {

			if (!(u64Src>>i)) {

				++u32ExpTotalCount; 
			}
			//stop 
			else {

				u32BitOneLoc = i;
				break;
			}
		}

		u32ExpTotalCount += 1;

		u53TempFragment = (u64Src<<u32ExpTotalCount)>>11; 
		u53Fragment = u53TempFragment + 1;
		u52Fragment = u53Fragment >> 1;
		
		DSPU64 u53AdjNum = ((DSPU64)0x1fffff << 32)|0xffffffff;

		
		if (u53TempFragment == u53AdjNum) {
			u32ExpAmend += 1;
			u52Fragment = 0;
		}

		u32FracHighRes = (DSPU32)(u52Fragment >> 32), u32FracLowRes
				= (DSPU32)u52Fragment ;


		if ((p_u32Adjust&0x400)==0) {
			i32ExpSum = 0x3ff + u32BitOneLoc + (p_u32Adjust&0x7ff)
					+ u32ExpAmend;
		}

		
		else if ((p_u32Adjust&0x400)==0x400) {
			i32ExpSum = 0x3ff + u32BitOneLoc -((~p_u32Adjust+1)&0x7ff)
					+ u32ExpAmend;
		}



		if (i32ExpSum <= 0) {
			
			SetFlag(*p_pStatReg, SHF_FUnderFlow);
			SetFlag(*p_pStatReg, SHF_SFUS);
			
			if (u1Saturation) {
				p_u32DestHigh = 0;
				p_u32DestLow = 0;
			}
			
			else if (!u1Saturation) {
				u32ExpOffset = i32ExpSum & 0x7ff;
				
				p_u32DestHigh = (bolSignBit<<31)| u32ExpOffset<<20
						|u32FracHighRes;
				
				p_u32DestLow = u32FracLowRes;
			}
		}

		//B��> = 2047 
		else if (i32ExpSum >= 0x7ff) {
			
			SetFlag(*p_pStatReg, SHF_FOverFlow);
			SetFlag(*p_pStatReg, SHF_SFVS);
			//���ͣ�
			if (u1Saturation) {
				u32ExpOffset = 0x7fe; 
				u32FracHighRes = 0xfffff;
				u32FracLowRes = 0xffffffff;
				p_u32DestHigh = (bolSignBit<<31)| u32ExpOffset<<20
						|u32FracHighRes;
				//64λ�������ĵ�32λֻ�Ǳ���β��
				p_u32DestLow = u32FracLowRes;
			}

			
			else if (!u1Saturation) {
				u32ExpOffset = i32ExpSum & 0x7ff;
				
				p_u32DestHigh = (bolSignBit<<31)| u32ExpOffset<<20
						|u32FracHighRes;
				
				p_u32DestLow = u32FracLowRes;
			}

		}
		//((i32ExpSum > 0) &&(i32ExpSum < 0x7ff)) 
		else {
			u32ExpOffset =i32ExpSum & 0x7ff;
			p_u32DestHigh = (bolSignBit<<31)| u32ExpOffset<<20|u32FracHighRes;
			
			p_u32DestLow = u32FracLowRes;
		}
	}
}

extern DSPU32 UnsignFix32ToFlo32(DSPU32 p_u32Rm, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	DSPU32 u32Src = p_u32Rm;
	DSPU32 u32Exp = 0;
	DSPI32 i32ExpSum = 0;
	DSPU32 u32ExpInterval = 0;	
	DSPU32 u32ExpAmend = 0;
	DSPU32 u32BitOneLoc = 0;
	DSPU32 u8ShiftCnt = 0;
	DSPU32 f32Dest = 0;
	DSPU32 u32Frac = 0, u32Frac23 = 0, u32Frac24 = 0,u32TempFrac24 = 0;
	bool u1Saturation= TestFlag(p_u32SHFCR ,SHF_Ctl_Saturation); 

	for (int i = 31; i>-1; i--)
	{
		if (!(u32Src>>i)) {
			++u32ExpInterval; 
		}
		//1:stop 
		else {

			u32BitOneLoc = i;
			break; 
		}
	}

	u8ShiftCnt = u32ExpInterval+1;	

	
	u32TempFrac24 = (u32Src<<u8ShiftCnt)>>8; //
	
	u32Frac24 = u32TempFrac24 + 1;
	u32Frac23 = u32Frac24 >> 1;
	
	
	if (u32TempFrac24==0xffffff) {
		u32ExpAmend += 1;
		u32Frac23 = 0;		
	}

	i32ExpSum = 0x7f + u32BitOneLoc  + u32ExpAmend;


	//A: ����Ϊ0 ,����Ϊ0 
	if (u32Src == 0) {
		return 0;
	}
	//B��<= 0
	else if (i32ExpSum <= 0) {
		//����������־Ϊ1��
		SetFlag(*p_pStatReg, SHF_FUnderFlow);
		SetFlag(*p_pStatReg, SHF_SFUS);
		//���ͣ�
		if (u1Saturation)
			return 0;
		//�����ͣ�
		if (!u1Saturation) {
			u32Exp = (DSPU8)(i32ExpSum & 0xff);
			u32Frac = u32Frac23; //��ȡʣ�µĸ�23λ
		}
	}

	//C��> = 255 
	else if (i32ExpSum >= 0xff) {
		//����������־Ϊ1��
		SetFlag(*p_pStatReg, SHF_FOverFlow);
		SetFlag(*p_pStatReg, SHF_SFVS);
		//���ͣ�
		if (u1Saturation) {
			u32Exp = 0xfe; //��������ֵ 
			u32Frac = 0x7fffff;
		}

		//�����ͣ�
		if (!u1Saturation) {
			u32Exp = (DSPU8)(i32ExpSum & 0xff);
			u32Frac = u32Frac23; //��ȡʣ�µĸ�23λ
		}
	}

	//((i32ExpSum > 0) &&(i32ExpSum < 0xff))
	else {
		u32Exp = (DSPU8)(i32ExpSum & 0xff);
		u32Frac = u32Frac23; //��ȡʣ�µĸ�23λ
	}

	f32Dest = (u32Exp << 23) |u32Frac;
	return f32Dest;
}

extern void OTABAccConstBefore(DSPU32 p_u32C, DSPU32 p_u32Rs, SHF_RAM *p_pRAM,
		DSPU32 p_u32N, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR) {
	//״̬�Ĵ����ı���
	
	unsigned int OpBits = 8;

	DSPU32 u32ArrRow;
	DSPU32 u32ArrColumn;
	u32ArrRow = (p_u32N>>14)&0x3;

	DSPU8 u8Src0, u8Src1, u8Src2, u8Src3;
	DSPU8 u8Ram0, u8Ram1, u8Ram2, u8Ram3;
	DSPU8 u8Des0, u8Des1, u8Des2, u8Des3;

	bool bolSrc1Sign;
	bool bolSrc2Sign;
	bool bolDestSign;

	//����״̬�Ĵ���
	bool bolSatu;//����λ

	bool bolCarryFlag;//����λ��λ��־
	bolSatu = TestBit(p_u32SHFCR,1);

	u32ArrColumn = p_u32Rs & 0xff;
	u8Src0 = p_u32C&0xff;
	u8Ram0 = (p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>24;//TAB0
	
	
	u8Des0 = u8Src0 + u8Ram0;	

	bolSrc1Sign = TestBit(u8Src0, OpBits - 1);
	bolSrc2Sign = TestBit(u8Ram0, OpBits - 1);
	bolDestSign = TestBit(u8Des0, OpBits - 1);//�������Ӻ�������λ	


	//�����޷��ţ�������λ�ͻᷢ������
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);
	
	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);

		if (bolSatu)
			u8Des0 = 0xff;
	}

	
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn] = u8Des0<<24;


	//��1��RAMȡ����8λ����Rm[15:8]������
	//��ַȡRs[15:8]

	u32ArrColumn = (p_u32Rs >> 8) & 0xff;
	u8Src1 =p_u32C&0xff;
	u8Ram1 = (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>16)&0xff);
	u8Des1 = u8Src1 + u8Ram1;
	


	//���ñ�־λ
	bolSrc1Sign = TestBit(u8Src1, OpBits - 1);
	bolSrc2Sign = TestBit(u8Ram1, OpBits - 1);
	bolDestSign = TestBit(u8Des1, OpBits - 1);//�������Ӻ�������λ


	//�����޷��ţ�������λ�ͻᷢ������
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);
	

	//�޷��������ұ���������,��������ֵ
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);
		if (bolSatu)
			u8Des1 = 0xff;
	}

	
	
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn]&=0xff00ffff;
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u8Des1<<16;
	
	
	//��2��RAMȡ����8λ����Rm[23:16]������	
	//��ַȡRs[23:16]
	u32ArrColumn = (p_u32Rs >> 16) & 0xff;
	u8Src2 = p_u32C&0xff;
	u8Ram2 = (((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])>>8)&0xff);

	u8Des2 = u8Src2 + u8Ram2;


	//���ñ�־λ
	bolSrc1Sign = TestBit(u8Src2, OpBits - 1);
	bolSrc2Sign = TestBit(u8Ram2, OpBits - 1);
	bolDestSign = TestBit(u8Des2, OpBits - 1);//�������Ӻ�������λ


	
	
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);
			

	
	//�޷��������ұ���������,��������ֵ
	if (bolCarryFlag) {

		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);
		if (bolSatu)
			u8Des2 = 0xff;
	}
	//���ɽ
	
	
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn]&=0xffff00ff;
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u8Des2<<8;
	
	//��3��RAMȡ����8λ����Rm[31:24]�����㡣
	//��ַȡRs[31:24]
	
	u32ArrColumn = (p_u32Rs >> 24) & 0xff;	
	u8Src3 = p_u32C&0xff;
	u8Ram3 = ((p_pRAM->arrElem[u32ArrRow][u32ArrColumn])&0xff);

	u8Des3 = u8Src3 + u8Ram3;


	//���ñ�־λ
	bolSrc1Sign = TestBit(u8Src3, OpBits - 1);
	bolSrc2Sign = TestBit(u8Ram3, OpBits - 1);
	bolDestSign = TestBit(u8Des3, OpBits - 1);//�������Ӻ�������λ


	
	bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
			|| (bolSrc1Sign && bolSrc2Sign);
	
	if (bolCarryFlag) {
		SetFlag(*p_pStatReg, SHF_OverFlow);
		SetFlag(*p_pStatReg, SHF_SOVS);
		SetFlag(*p_pStatReg, SHF_OverFlow8Bit);
		SetFlag(*p_pStatReg, SHF_OV8BitS);
		if (bolSatu)
			u8Des3 = 0xff;
	}
	
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn]&=0xffffff00;
	p_pRAM->arrElem[u32ArrRow][u32ArrColumn] |= u8Des3;
	
}
///////////////////////////////////////////////////////////////////
/******************************************************************

	Expand16To32
	Rs+1:s= EXPAND(HRm,Rn)(U)
*******************************************************************/

extern void Expand16To32(DSP_BIT64 &p_Res, DSPU32 p_u32Src, DSPU32 p_u32Pos, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){

	DSPU16 u16UpSrc = p_u32Src >> 16;
	DSPU16 u16LowSrc = p_u32Src & 0xffff;
	DSPU32 *p_pStatRegUp,*p_pStatRegLow;
	p_pStatRegUp = p_pStatReg; p_pStatRegLow = p_pStatReg;	

	p_Res.u32High = Expand16(u16UpSrc,  p_u32Pos, p_pStatRegUp, p_u32SHFCR); 
	p_Res.u32Low = Expand16(u16LowSrc,  p_u32Pos, p_pStatRegLow, p_u32SHFCR);
	*p_pStatReg = *p_pStatRegUp | *p_pStatRegLow;
}
/*****************************************************************
	SACCAddReg32
	SACCs+=Rm(Rn)
	unsigned 
*******************************************************************/
extern void SACCAddReg32(DSP_BIT64 &p_SACC, DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){

	DSPU32 pos = p_u32SrcN & 0x1f;
	DSPU32 Value = (p_u32SrcM >> (pos))& 0x1;
	DSPU32 u32Low = p_SACC.u32Low;
	DSPU32 u32High = p_SACC.u32High;
	DSPU32 *p_pStatRegUp,*p_pStatRegLow;
	
	DSPU32 u32LowRes;
	DSPU32 u32HighRes;	
	u32LowRes = u32Low + Value;

	if ((u32Low == 0xffffffff)&&(Value == 1)){
		u32HighRes = u32High + 1;
	}
	else {
		u32HighRes = u32High ;
	}
	p_SACC.u32Low = u32LowRes;
	p_SACC.u32High = u32HighRes;

	bool bolOverFlow = false;
	//bool bolSigned= TestFlag(p_u32SHFCR, SHF_Ctl_Signed);
	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);
	if((Value == 1)&&(u32Low == 0xffffffff)&&(u32High == 0xffffffff)){
		bolOverFlow = true;
	}

	if(bolOverFlow){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			p_SACC.u32Low = 0xffffffff;
			p_SACC.u32High = 0xffffffff;
		}
		else{
			p_SACC.u32Low &= 0xffffffff;
			p_SACC.u32High &= 0xffffffff;
		}
	}	
}

/*found*****************************************************************
	SACCAddReg16
	HSACCs+=HRm(Rn)
	unsigned 
***********************************************************************/
extern void SACCAddReg16(DSP_BIT64 &p_SACC, DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	DSPU32 pos = p_u32SrcN & 0xf;
	DSPU32 u32Low = p_SACC.u32Low;
	DSPU32 u32High = p_SACC.u32High;

	DSPU32 u32LowRes, u32HighRes;

	DSPU32 u32ValLow = (p_u32SrcM >> (pos))& 0x1;
	u32LowRes = u32Low + u32ValLow;

	DSPU32 u32ValHigh = (p_u32SrcM >> (pos+16))& 0x1;
	u32HighRes = u32High + u32ValHigh;

	p_SACC.u32Low = u32LowRes;
	p_SACC.u32High = u32HighRes;

	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);

	if((u32ValLow == 1)&&(u32Low == 0xffffffff)){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);	
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			p_SACC.u32Low = 0xffffffff;
		}
		else{
			p_SACC.u32Low &= 0xffffffff;
		}
	}
	if((u32ValHigh == 1)&&(u32High == 0xffffffff)){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			p_SACC.u32High = 0xffffffff;
		}
		else{
			p_SACC.u32High &= 0xffffffff;
		}
	}
}

/*found*****************************************************************
	SACCAddReg8
	OSACCs+=ORm(Rn)
************************************************************************/
extern void SACCAddReg8(DSP_BIT64 &p_SACC, DSPU32 p_u32SrcM, DSPU32 p_u32SrcN, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR){
	DSPU32 pos = p_u32SrcN & 0x7;	
	DSPU32 u32ResLowest,u32ResLower, u32ResHgher,u32ResHghest;

	DSPU32 u32Val_Low_Low = (p_u32SrcM >> (pos))& 0x1;
	DSPU16 u32Res_Low_Low = p_SACC.u32Low & 0xffff;
	u32ResLowest = u32Res_Low_Low + u32Val_Low_Low;
	
	DSPU32 u32Val_Low_High = (p_u32SrcM >> (pos+8))& 0x1;
	DSPU16 u32Res_Low_High = (p_SACC.u32Low >> 16)& 0xffff;
	u32ResLower = u32Res_Low_High + u32Val_Low_High;

	DSPU32 u32Val_High_Low = (p_u32SrcM >> (pos+16))& 0x1;
	DSPU16 u32Res_High_Low = p_SACC.u32High & 0xffff;
	u32ResHgher = u32Res_High_Low + u32Val_High_Low;

	DSPU32 u32Val_High_High = (p_u32SrcM >> (pos+24))& 0x1;
	DSPU16 u32Res_High_High = (p_SACC.u32High >> 16) & 0xffff;;
	u32ResHghest = u32Res_High_High + u32Val_High_High;

	bool bolSatu= TestFlag(p_u32SHFCR, SHF_Ctl_Saturation);

	if((u32Val_Low_Low == 1)&&(u32Res_Low_Low == 0xffff)){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);	
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			u32ResLowest = 0xffff;
		}
		else{
			u32ResLowest &= 0xffff;
		}
	}

	if((u32Val_Low_High == 1)&&(u32Res_Low_High == 0xffff)){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);	
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			u32ResLower = 0xffff;
		}
		else{
			u32ResLower &= 0xffff;
		}
	}

	if((u32Val_High_Low == 1)&&(u32Res_High_Low == 0xffff)){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			u32ResHgher = 0xffff;
		}
		else{
			u32ResHgher &= 0xffff;
		}
	}

	if((u32Val_High_High == 1)&&(u32Res_High_High == 0xffff)){
		SetFlag(*p_pStatReg,SHF_OverFlow);
		SetFlag(*p_pStatReg,SHF_FOverFlow);	
		SetFlag(*p_pStatReg,SHF_SOVS);
		SetFlag(*p_pStatReg,SHF_SFVS);	
		if(bolSatu){
			u32ResHghest = 0xffff;
		}
		else{
			u32ResHghest &= 0xffff;
		}
	}
	p_SACC.u32Low = u32ResLower << 16 | u32ResLowest;
	p_SACC.u32High = u32ResHghest << 16 | u32ResHgher;
}
/************************************************************
unsigned add 
*************************************************************/
extern DSPU32 STabAddReg(DSPU32 u32TabValue, DSPU32 p_u32SrcM, DSPU32 p_u32Imm, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR, DSPU32 p_u32Mode){

	DSPU32 u32Dest = 0;
	DSPU32 mode = p_u32Mode;

	DSPU16 u16Res0, u16Res1;
	DSPU16 u16Ram0, u16Ram1;
	DSPU16 u16Des0, u16Des1;

	bool bolSrc1Sign;
	bool bolSrc2Sign;
	bool bolDestSign;

	bool bolSatu;
	bool bolCarryFlag;
	bolSatu = TestBit(p_u32SHFCR,1);
	switch(p_u32Mode){
	case 0:
		u16Res0 = p_u32SrcM&0xf;
		u16Ram0 = u32TabValue&0xffff;	
		u16Des0 = u16Res0 + u16Ram0;

		bolSrc1Sign = TestBit(u16Res0, 15);
		bolSrc2Sign = TestBit(u16Ram0, 15);
		bolDestSign = TestBit(u16Des0, 15);	
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);	
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);	
			if (bolSatu)
				u16Des0 = 0xffff;
		}
	
		u16Res1 = (p_u32SrcM>>16)&0xf;;
		u16Ram1 = (u32TabValue>>16)&0xffff;
		u16Des1 = u16Res1 + u16Ram1;

		bolSrc1Sign = TestBit(u16Res1, 15);
		bolSrc2Sign = TestBit(u16Ram1, 15);
		bolDestSign = TestBit(u16Des1, 15);
	
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);
	
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);	
			if (bolSatu)
				u16Des1 = 0xffff;
		}		
		break;

	case 1:
		u16Res0 = p_u32Imm&0xf;
		u16Ram0 = u32TabValue&0xffff;	
		u16Des0 = u16Res0 + u16Ram0;	

		bolSrc1Sign = TestBit(u16Res0, 15);
		bolSrc2Sign = TestBit(u16Ram0, 15);
		bolDestSign = TestBit(u16Des0, 15);	
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);	
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
	
			if (bolSatu)
				u16Des0 = 0xffff;
		}
	
		u16Res1 = p_u32Imm&0xf;;
		u16Ram1 = (u32TabValue>>16)&0xffff;
		u16Des1 = u16Res1 + u16Ram1;	

		bolSrc1Sign = TestBit(u16Res1, 15);
		bolSrc2Sign = TestBit(u16Ram1, 15);
		bolDestSign = TestBit(u16Des1, 15);
	
		bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign)
				|| (bolSrc1Sign && bolSrc2Sign);
	
		if (bolCarryFlag) {
			SetFlag(*p_pStatReg, SHF_OverFlow);
			SetFlag(*p_pStatReg, SHF_SOVS);
			SetFlag(*p_pStatReg, SHF_OverFlow16Bit);
			SetFlag(*p_pStatReg, SHF_OV16BitS);
	
			if (bolSatu)
				u16Des1 = 0xffff;
		}		
		break;
	default:
		break;
	}

	u32Dest = (u16Des0)|(u16Des1<<16);
	return u32Dest;
}

extern DSPU32 STabRdAddrSet(DSPU32 p_u32SrcM, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR)
{	
	DSPU8 src1  = p_u32SrcM & 0xff;
	DSPU8 src2  = (p_u32SrcM >> 8)& 0xff;
	DSPU8 src3  = (p_u32SrcM >> 16)& 0xff;
	DSPU8 src4  = (p_u32SrcM >> 24)& 0xff;
	DSPU8 u8Res ;
	DSPU8 add1,add3;	
	//1)
	if ((src3 & 0x80) == 0x0)
	{		
		add1 = src1;
		add3 = src3;
		u8Res = Add8(add1,add3, p_pStatReg,p_u32SHFCR & 0x2);		
	}
	//2)	
	if ((src3 & 0x80) == 0x80)
	{		
		add1 = src1;
		add3 = (~src3+1) & 0xff;
		u8Res = Sub8(add1,add3, p_pStatReg,p_u32SHFCR & 0x2);	
	}		
	DSPU32 u32Res = (src4 << 24) |(src3 << 16)|(src2 << 8)|u8Res;
	return u32Res;
}
extern DSPU32 STabRdWtAddrSet(DSPU32 p_u32SrcN, DSPU32 *p_pStatReg, DSPU32 p_u32SHFCR)
{

	DSPU8 src1  = p_u32SrcN & 0xff;
	DSPU8 src2  = (p_u32SrcN >> 8)& 0xff;
	DSPU8 src3  = (p_u32SrcN >> 16)& 0xff;
	DSPU8 src4  = (p_u32SrcN >> 24)& 0xff;
		

	DSPU8 u8Res1, u8Res2;
	DSPU32 u32Reg1 = *p_pStatReg;
	DSPU32 u32Reg2 = *p_pStatReg;
	DSPU8 add1,add2,add3,add4;

	//1)
	if ((src3 & 0x80) == 0x0)
	{
		add1 = src1;
		add3 = src3;
		u8Res1 = Add8(add1,add3, &u32Reg1,p_u32SHFCR & 0x2);
	}
	//2)
	if ((src3 & 0x80) == 0x80)
	{		
		add1 = src1;
		add3 = (~src3+1)&0xff;
		u8Res1 = Sub8(add1,add3, &u32Reg1,p_u32SHFCR & 0x2);	
	}
	//1)
	if ((src4 & 0x80) == 0x0)
	{
		add2 = src2;
		add4 = src4;
		u8Res2 = Add8(add2,add4, &u32Reg2,p_u32SHFCR & 0x2);	

	}
	//2)
	if ((src4 & 0x80) == 0x80)
	{
		add2 = src2;
		add4 = (~src4+1)&0xff;
		u8Res2 = Sub8(add2,add4, &u32Reg2,p_u32SHFCR & 0x2);	
	}
	*p_pStatReg = u32Reg1 | u32Reg2;		

	DSPU32 u32Res = (src4 << 24) |(src3 << 16)|(u8Res2 << 8)|u8Res1;
	return u32Res;

}




