
#include "sc_iss.h"
//-----------------------------------------------------------------------------------
inline DSPU32 BitRev(DSPU32 p_u32Addr, DSPU32 p_u32BRC)
{
	DSPU32 i, j, u32BRAddr;

	if (p_u32BRC > 17)
	{
		return  p_u32Addr;
	}

	if (p_u32BRC < 5)
	{
		return  p_u32Addr;
	}

	u32BRAddr = p_u32Addr;
	for (i = 0, j = p_u32BRC; i <= p_u32BRC; i++, j--)
	{
		if (GIsBitSet(p_u32Addr, i))
		{
			u32BRAddr = GSetBit(u32BRAddr, j);
		}
		else
		{
			u32BRAddr = GClrBit(u32BRAddr, j);
		}
		
	}

	return u32BRAddr;
}


/*---------------------------------------------------Double words Operations---------------------------------------------------*/
bool sc_iss::ext_like_rd_sw_m8_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_like_rd_sw_m8_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_like_rd_sw_m8_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 arrDestIdx[4];
		DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u6A: 6;
				DSPU32      u6B: 6;
				DSPU32      u6C: 6;
				DSPU32      u6D: 6;
				DSPU32      u1Rev0: 1;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u4K: 4;
				DSPU32      u4M: 4;
				DSPU32      u4N: 4;
				DSPU32      u1Rev1: 1;
				DSPU32      u2Mode: 2;
				DSPU32      u3Rev2: 3;
				DSPU32      u2UVW: 2;
				DSPU32      u1Read: 1;            
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6A;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6B;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6C;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6D;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4K;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4M;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4N;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u2Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 10; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			arrDestIdx[i] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i];
		}
		u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

		// 资源使用: 一条内部数据读总线
		m_arrDCResNeeded[p_u32Slot].bolInnerRdBus = true;


		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = true;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = true;	    
		if (u32Mode == 0)  // 模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
		}
		else if (u32Mode == 1) // 双模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = true;
		}

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = arrDestIdx[i];
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = 0;
		}

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(arrDestIdx[i], m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		switch (u32UVWIdx)
		{
		case 0:
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
			break;
		case 1:
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
			break;
		case 2:
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
			break;        
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

	}
	else if (p_u32Phase == PHASE_DC2_POST)
	{
		DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32AddrRegN, u32AddrRegM, u32AddrRegK;
		DSPU32 u32Addr, u32NextAddr, u32Mode;

		u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

		u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
		u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
		u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

		// generate address for memory access
		u32Addr = u32AddrRegN;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32Addr;
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);

				u32NextAddr = u32Addr + u32AddrRegK;
				if (u32Mode == 0)  // 模8
				{
					if ( (u32NextAddr & 0x7)  < (u32Addr & 0x7) )
					{
						u32Addr = u32NextAddr - 8;
					}
					else
					{
						u32Addr = u32NextAddr;
					}
				}
				else if (u32Mode == 1) // 双模8
				{
					if ( (u32NextAddr & 0x1F)  < (u32Addr & 0x1F) )
					{
						u32Addr = u32NextAddr - 32;
					}
					else
					{
						u32Addr = u32NextAddr;
					}
				}
			} // if ( GIsBitSet(u32Units, i) )
		}    
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32AddrRegN + u32AddrRegM;
	} // else if (p_u32Phase == PHASE_DC2_POST)
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32N, u32UVWIdx, u32AddrResult;
		DSPU32 u32AddrRegN, u32AddrRegM, u32Units, u32Result;

		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

		if (!m_bolMemExcp_AC)
		{
			u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
			u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

			u32AddrResult = u32AddrRegN + u32AddrRegM;
			wr_u32r_UVW(u32UVWIdx, u32N, u32AddrResult);
		}

	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 arrDestIdx[4];
		DSPU32 u32Units, u32GenResultIdx, u32Result;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			arrDestIdx[i] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i];
		}

		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];
				wr_u32r_R_new(i, arrDestIdx[i], u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, arrDestIdx[i], u32Result);
				u32GenResultIdx++;
			}
		}

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_wr_sw_m8_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_like_wr_sw_m8_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_like_wr_sw_m8_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 arrSrcIdx[4];
		DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u6A: 6;
				DSPU32      u6B: 6;
				DSPU32      u6C: 6;
				DSPU32      u6D: 6;
				DSPU32      u1Rev0: 1;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u4K: 4;
				DSPU32      u4M: 4;
				DSPU32      u4N: 4;
				DSPU32      u1Rev1: 1;
				DSPU32      u2Mode: 2;
				DSPU32      u3Rev2: 3;
				DSPU32      u2UVW: 2;
				DSPU32      u1Read: 1;            
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6A;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6B;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6C;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6D;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4K;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4M;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4N;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u2Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 10; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			arrSrcIdx[i] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i];
		}
		u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

		// 资源使用: 一条内部数据写总线
		m_arrDCResNeeded[p_u32Slot].bolInnerWrBus = true;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = false;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = true;	    
		if (u32Mode == 0)  // 模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
		}
		else if (u32Mode == 1) // 双模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = true;
		}

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = 0;
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = arrSrcIdx[i];
		}


		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(arrSrcIdx[i], m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		switch (u32UVWIdx)
		{
			case 0:
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );            
				break;
			case 1:
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N ); 
				break;
			case 2:
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
				break;        
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
	}
	else if (p_u32Phase == PHASE_DC2_POST)
	{
		DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32AddrRegN, u32AddrRegM, u32AddrRegK;
		DSPU32 u32Addr, u32NextAddr, u32Mode;

		u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

		u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
		u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
		u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

		// generate address for memory access
		u32Addr = u32AddrRegN;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32Addr;
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);

				u32NextAddr = u32Addr + u32AddrRegK;
				if (u32Mode == 0)  // 模8
				{
					if ( (u32NextAddr & 0x7)  < (u32Addr & 0x7) )
					{
						u32Addr = u32NextAddr - 8;
					}
					else
					{
						u32Addr = u32NextAddr;
					}
				}
				else if (u32Mode == 1) // 双模8
				{
					if ( (u32NextAddr & 0x1F)  < (u32Addr & 0x1F) )
					{
						u32Addr = u32NextAddr - 32;
					}
					else
					{
						u32Addr = u32NextAddr;
					}
				}
			} // if ( GIsBitSet(u32Units, i) )
		}	
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32AddrRegN + u32AddrRegM;
	} // else if (p_u32Phase == PHASE_DC2_POST)

	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32N, u32UVWIdx, u32AddrResult;
		DSPU32 u32AddrRegN, u32AddrRegM;

		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];

		if (!m_bolMemExcp_AC)
		{
			u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
			u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

			u32AddrResult = u32AddrRegN + u32AddrRegM;
			wr_u32r_UVW(u32UVWIdx, u32N, u32AddrResult);

		}
	}   
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_rd_dw_m8_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_like_rd_dw_m8_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_like_rd_dw_m8_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 arrDestIdx[4];
		DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u6A: 6;
				DSPU32      u6B: 6;
				DSPU32      u6C: 6;
				DSPU32      u6D: 6;
				DSPU32      u1Rev0: 1;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u4K: 4;
				DSPU32      u4M: 4;
				DSPU32      u4N: 4;
				DSPU32      u1Rev1: 1;
				DSPU32      u2Mode: 2;
				DSPU32      u3Rev2: 3;
				DSPU32      u2UVW: 2;
				DSPU32      u1Read: 1;            
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6A;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6B;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6C;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6D;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4K;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4M;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4N;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u2Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 10; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			arrDestIdx[i] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i];
		}
		u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

		// 资源使用: 一条内部数据读总线
		m_arrDCResNeeded[p_u32Slot].bolInnerRdBus = true;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = true;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = false;	    
		if (u32Mode == 2)  // 模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
		}
		else if (u32Mode == 3) // 双模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = true;
		}

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = arrDestIdx[i];
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = 0;
		}


		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(arrDestIdx[i], m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(arrDestIdx[i] + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);            
			}
		}

		switch (u32UVWIdx)
		{
			case 0:
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
				break;
			case 1:
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
				break;
			case 2:
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
				break;        
		}
		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
	}
	else if (p_u32Phase == PHASE_DC2_POST)
	{
		DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32AddrRegN, u32AddrRegM, u32AddrRegK;
		DSPU32 u32Addr, u32NextAddr, u32Mode;

		u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

		u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
		u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
		u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
		m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

		// generate address for memory access
		u32Addr = u32AddrRegN;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32Addr;
				m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32Addr + 1;
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);

				u32NextAddr = u32Addr + 2 * u32AddrRegK;               
				if (u32Mode == 2)  // 模8
				{
					if ( (u32NextAddr & 0x7)  < (u32Addr & 0x7) )
					{
						u32Addr = u32NextAddr - 8;
					}
					else
					{
						u32Addr = u32NextAddr;
					}
				}
				else if (u32Mode == 3) // 双模8
				{
					if ( (u32NextAddr & 0x1F)  < (u32Addr & 0x1F) )
					{
						u32Addr = u32NextAddr - 32;
					}
					else
					{
						u32Addr = u32NextAddr;
					}
				}
			} // if ( GIsBitSet(u32Units, i) )
		}	
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32AddrRegN + u32AddrRegM;
	} // else if (p_u32Phase == PHASE_DC2_POST)
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32N, u32UVWIdx, u32AddrResult;
		DSPU32 u32AddrRegN, u32AddrRegM, u32Units, u32Result;

		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

		if (!m_bolMemExcp_AC)
		{
			u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
			u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

			u32AddrResult = u32AddrRegN + u32AddrRegM;
			wr_u32r_UVW(u32UVWIdx, u32N, u32AddrResult);
		}    
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 arrDestIdx[4];
		DSPU32 u32Units, u32GenResultIdx, u32Result;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			arrDestIdx[i] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i];
		}

		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];
				wr_u32r_R_new(i, arrDestIdx[i], u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, arrDestIdx[i], u32Result);
				u32GenResultIdx++;

				u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][1];
				wr_u32r_R_new(i, arrDestIdx[i] + 1, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, arrDestIdx[i] + 1, u32Result);
				u32GenResultIdx++;
			}
		}

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_wr_dw_m8_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_like_wr_dw_m8_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_like_wr_dw_m8_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 arrSrcIdx[4];
        DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u6A: 6;
                DSPU32      u6B: 6;
                DSPU32      u6C: 6;
                DSPU32      u6D: 6;
                DSPU32      u1Rev0: 1;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u1Rev1: 1;
                DSPU32      u2Mode: 2;
                DSPU32      u3Rev2: 3;
                DSPU32      u2UVW: 2;
                DSPU32      u1Read: 1;            
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6A;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6B;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6C;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6D;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u2Mode;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 10; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            arrSrcIdx[i] = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i];
        }
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

        // 资源使用: 一条内部数据写总线
		m_arrDCResNeeded[p_u32Slot].bolInnerWrBus = true;
        
                
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = false;

        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = false;	    
	    if (u32Mode == 2)  // 模8
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
		}
        else if (u32Mode == 3) // 双模8
        {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = true;
        }
        
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = 0;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = arrSrcIdx[i];
	    }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(arrSrcIdx[i], m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(arrSrcIdx[i] + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
            }
        }

        switch (u32UVWIdx)
        {
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N ); 
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                break;        
        }

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
           
    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32K, u32M, u32N, u32UVWIdx, u32Units, u32AddrRegN, u32AddrRegM, u32AddrRegK;
        DSPU32 u32Addr, u32NextAddr, u32Mode;
    
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
    
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access
        u32Addr = u32AddrRegN;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32Addr;
                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32Addr + 1;
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);

                u32NextAddr = u32Addr + 2 * u32AddrRegK;
                if (u32Mode == 2)  // 模8
				{
					if ( (u32NextAddr & 0x7)  < (u32Addr & 0x7) )
	                {
    	                u32Addr = u32NextAddr - 8;
        	        }
            	    else
                	{
                    	u32Addr = u32NextAddr;
	                }
				}
                else if (u32Mode == 3) // 双模8
                {
					if ( (u32NextAddr & 0x1F)  < (u32Addr & 0x1F) )
	                {
    	                u32Addr = u32NextAddr - 32;
        	        }
            	    else
                	{
                    	u32Addr = u32NextAddr;
	                }
                }

            } // if ( GIsBitSet(u32Units, i) )
        }   
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32AddrRegN + u32AddrRegM;
    } // else if (p_u32Phase == PHASE_DC2_POST)
        
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32N, u32UVWIdx, u32AddrResult;
        DSPU32 u32AddrRegN, u32AddrRegM;
    
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];   
	if (!m_bolMemExcp_AC)
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32AddrResult = u32AddrRegN + u32AddrRegM;
            wr_u32r_UVW(u32UVWIdx, u32N, u32AddrResult);
			
        }
    }   

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_rd_br_dw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_rd_br_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_rd_br_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
		DSPU32 u32C_Q, u32K, u32M, u32N, u32DestIdx, u32UVWIdx, u32Units, u32Mode;

        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u5C_Q: 5;              //GRQ: 4 bits or 5 bits?
                DSPU32      u20Rev0: 20;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u2Rev1: 2;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u1Rev2: 1;
                DSPU32      u1Mode: 1;
                DSPU32      u1IsRead: 1;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5C_Q;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u1Mode;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 8; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable     
        u32C_Q = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];

        // 资源使用: 一条内部数据读总线
		m_arrDCResNeeded[p_u32Slot].bolInnerRdBus = true;
        
    
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = true;

        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = u32DestIdx;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = 0;
	    }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        switch (u32UVWIdx)
        {
            case 0:
            	if (u32Mode == 1)
            	{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32C_Q );
            	}
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                break;
            case 1:
            	if (u32Mode == 1)
            	{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32C_Q );
            	}
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                break;
            case 2:
            	if (u32Mode == 1)
            	{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32C_Q );
            	}
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                break;
        }        

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
        
    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32C_Q, u32K, u32M, u32N, u32Units, u32AddrRegN, u32AddrRegM, u32AddrRegK, u32BRAddr;
        DSPU32 u32UVWIdx, u32Mode;
    
        u32C_Q = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
    
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);
        if (u32Mode == 1)
        {
			u32C_Q =  rd_u32r_UVW(u32UVWIdx, u32C_Q);
        }

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access
        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                // attention: rd_u32r_UVW
                u32BRAddr = BitRev(u32AddrRegN, u32C_Q);
                u32BRAddr = u32BRAddr + 2 * j * u32AddrRegK;

                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32BRAddr;
                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32BRAddr + 1;
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);

                j++;
            }
        } // for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
       	// added by liuyu
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32AddrRegN + u32AddrRegM;
    }
        
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32N, u32Units, u32UVWIdx;
		DSPU32 u32AddrResult, u32AddrRegN, u32AddrRegM, u32Result;
    
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
    
	if (!m_bolMemExcp_AC)
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32AddrResult = u32AddrRegN + u32AddrRegM;
            wr_u32r_UVW(u32UVWIdx, u32N, u32AddrResult);
			
        }

    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Units, u32GenResultIdx, u32Result;
    
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
    
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;

                u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][1];
				wr_u32r_R_new(i, u32DestIdx + 1, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx + 1, u32Result);
                u32GenResultIdx++;

            }
        } // for (i = 0; i < 4; i++)

    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_wr_br_dw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_wr_br_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_wr_br_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
		DSPU32 u32C_Q, u32K, u32M, u32N, u32SrcIdx, u32UVWIdx, u32Units, u32Mode;

        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u5C_Q: 5;
                DSPU32      u20Rev0: 20;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u2Rev1: 2;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u1Rev2: 1;
                DSPU32      u1Mode: 1;
                DSPU32      u1IsRead: 1;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5C_Q;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u1Mode;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 8; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable   
        u32C_Q = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32SrcIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];

        // 资源使用: 一条内部数据写总线
		m_arrDCResNeeded[p_u32Slot].bolInnerWrBus = true;
        
    
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = false;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = 0;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = u32SrcIdx;
	    }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
            }
        }

        switch (u32UVWIdx)
        {
            case 0:
            	if (u32Mode == 1)
            	{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32C_Q );
            	}
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                break;
            case 1:
            	if (u32Mode == 1)
            	{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32C_Q );
            	}
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                break;
            case 2:
            	if (u32Mode == 1)
            	{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32C_Q );
            	}
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                break;
        }        

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
        
    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32C_Q, u32K, u32M, u32N, u32Units, u32AddrRegN, u32AddrRegM, u32AddrRegK;
        DSPU32 u32UVWIdx, u32BRAddr, u32Mode;
    
        u32C_Q = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
    
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);
        if (u32Mode == 1)
        {
			u32C_Q =  rd_u32r_UVW(u32UVWIdx, u32C_Q);
        }

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;        

        // generate address for memory access
        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                // attention: rd_u32r_UVW
                u32BRAddr = BitRev(u32AddrRegN, u32C_Q);
                u32BRAddr = u32BRAddr + 2 * j * u32AddrRegK;

                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32BRAddr;
                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32BRAddr + 1;
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);

                j++;
            }
        } // for (i = 0; i < 4; i++)     
       	// added by liuyu
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32AddrRegN + u32AddrRegM;
    }
        
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32N, u32Units, u32UVWIdx;
		DSPU32 u32AddrResult, u32AddrRegN, u32AddrRegM;
    
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
    
	if (!m_bolMemExcp_AC)
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32AddrResult = u32AddrRegN + u32AddrRegM;
            wr_u32r_UVW(u32UVWIdx, u32N, u32AddrResult);
}

    }    

    return true;
}

//-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_rd_sw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_rd_sw_u_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_rd_sw_u_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Mode, u32K, u32M, u32N, u32DestIdx, u32UVWIdx, u32ChgBase, u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u16C0: 16;
                DSPU32      u7C1: 7;
                DSPU32      u2Flag: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u1ChgBase: 1;
                DSPU32      u1Rev0: 1;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u16C0;
		g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0], 16);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u7C1;
		g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1], 7);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u1ChgBase;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 10; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

        // 资源使用: 一条内部数据读总线
		m_arrDCResNeeded[p_u32Slot].bolInnerRdBus = true;
        
                            
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = true;

        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = true;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = u32DestIdx;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = 0;
	    }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        //-----------------------------------------------------------------------------
        switch (u32UVWIdx)
        {
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                }
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                }
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                }
                break;
                
        } // switch (u32UVWIdx)                

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32C0, u32C1, u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrRegK, u32_A, u32_B, u32_C;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32C1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
		u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
            
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access        
        u32_A = u32AddrRegN;
        u32_C = u32C1;
        u32_B = u32C0;
        if (u32Mode == 0)
        {
            u32_C = u32AddrRegK;
        }

        if (u32Mode == 1)
        {
            u32_B = u32AddrRegM;
        }

        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + u32_B + j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                }

                j++;
            }
        }        
	// added by liuyu
	if(u32ChgBase == 1) {
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32_A + u32_B;
	}
    } // else if (p_u32Phase == PHASE_DC2_POST)
        
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32C0, u32Mode, u32UVWIdx, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32_A, u32_B, u32N;
        DSPU32 u32Units, u32Result;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9]; 
	if ( (u32ChgBase == 1) && (!m_bolMemExcp_AC) )
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32_A = u32AddrRegN;
            u32_B = u32C0;

            if (u32Mode == 1)
            {
                u32_B = u32AddrRegM;
            }

            wr_u32r_UVW(u32UVWIdx, u32N, u32_A + u32_B);

        }

    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Units, u32Result, u32GenResultIdx;
    
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
    
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;
            }

        } // for (i = 0; i < 4; i++)
    }

    return true;
}

//-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_rd_dw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_rd_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_rd_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Mode, u32K, u32M, u32N, u32DestIdx, u32UVWIdx, u32ChgBase, u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
				DSPU32      u16C0: 16;
                DSPU32      u7C1: 7;
                DSPU32      u2Flag: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u1ChgBase: 1;
                DSPU32      u1Rev0: 1;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
			            
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u16C0;
		g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0], 16);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u7C1;
		g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1], 7);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u1ChgBase;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 10; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

        // 资源使用: 一条内部数据读总线
		m_arrDCResNeeded[p_u32Slot].bolInnerRdBus = true;
        
                            
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = true;

        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = u32DestIdx;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = 0;
	    }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        //-----------------------------------------------------------------------------
        switch (u32UVWIdx)
        {                
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                }
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                }
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                }
                break;
                
        } // switch (u32UVWIdx)                

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32C0, u32C1, u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrRegK, u32_A, u32_B, u32_C;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32C1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
            
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access        
        u32_A = u32AddrRegN;
        u32_C = u32C1;
        u32_B = u32C0;
        if (u32Mode == 0)
        {
            u32_C = u32AddrRegK;
        }

        if (u32Mode == 1)
        {
            u32_B = u32AddrRegM;
        }

        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + 2 * j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32_A + 2 * j * u32_C + 1;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + u32_B + 2 * j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32_A + u32_B + 2 * j * u32_C + 1;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);
                }

                j++;
            }
            
        } // for (i = 0, j = 0; i < NUM_OF_UNITS; i++)        
	if(u32ChgBase == 1) {
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32_A + u32_B;
	}
    } // else if (p_u32Phase == PHASE_DC2_POST)
    
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32C0, u32Mode, u32UVWIdx, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32_A, u32_B, u32N;
        DSPU32 u32Units, u32Result;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
    
	if ( (u32ChgBase == 1) && (!m_bolMemExcp_AC) )
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32_A = u32AddrRegN;
            u32_B = u32C0;

            if (u32Mode == 1)
            {
                u32_B = u32AddrRegM;
            }

            wr_u32r_UVW(u32UVWIdx, u32N, u32_A + u32_B);
        }

    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Units, u32Result, u32GenResultIdx;
    
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
    
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;

                u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][1];
				wr_u32r_R_new(i, u32DestIdx + 1, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx + 1, u32Result);
                u32GenResultIdx++;
            }

        } // for (i = 0; i < 4; i++)

    }

    return true;
}

//-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_wr_sw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_wr_sw_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_wr_sw_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Mode, u32K, u32M, u32N, u32SrcIdx, u32UVWIdx, u32ChgBase, u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
				DSPU32      u16C0: 16;
                DSPU32      u7C1: 7;
                DSPU32      u2Flag: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u1ChgBase: 1;
                DSPU32      u1Rev0: 1;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;

            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u16C0;
		g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0], 16);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u7C1;
		g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1], 7);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u1ChgBase;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 10; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32SrcIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

        // 资源使用: 一条内部数据写总线
		m_arrDCResNeeded[p_u32Slot].bolInnerWrBus = true;
        
                            
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = false;

        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = true;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = 0;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = u32SrcIdx;
	    }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
            }
        }

        //-----------------------------------------------------------------------------
        switch (u32UVWIdx)
        {
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                }
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                }
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                }
                break;
                
        } // switch (u32UVWIdx)                

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32C0, u32C1, u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrRegK, u32_A, u32_B, u32_C;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32C1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
            
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access
        u32_A = u32AddrRegN;
        u32_B = u32C0;
        u32_C = u32C1;
        if (u32Mode == 0)
        {
            u32_C = u32AddrRegK;
        }

        if (u32Mode == 1)
        {
            u32_B = u32AddrRegM;
        }

        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + u32_B + j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                }

                j++;
            }
            
        } // for (i = 0, j = 0; i < NUM_OF_UNITS; i++)
        if(u32ChgBase == 1) {
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32_A + u32_B;
	}
    } // else if (p_u32Phase == PHASE_DC2_POST)
        
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32C0, u32Mode, u32UVWIdx, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32_A, u32_B, u32N;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
    
	if ( (u32ChgBase == 1) && (!m_bolMemExcp_AC) )
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32_A = u32AddrRegN;
            u32_B = u32C0;

            if (u32Mode == 1)
            {
                u32_B = u32AddrRegM;
            }

            wr_u32r_UVW(u32UVWIdx, u32N, u32_A + u32_B);
			
        }
    }
    
    return true;
}
//-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_wr_dw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_wr_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_wr_dw_u_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Mode, u32K, u32M, u32N, u32SrcIdx, u32UVWIdx, u32ChgBase, u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
				DSPU32      u16C0: 16;
                DSPU32      u7C1: 7;
                DSPU32      u2Flag: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u1ChgBase: 1;
                DSPU32      u1Rev0: 1;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;

            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u16C0;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0], 16); //GRQ
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u7C1;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = GSignExtend(g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1], 7);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u1ChgBase;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[9] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 10; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32SrcIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];

        // 资源使用: 一条内部数据写总线
		m_arrDCResNeeded[p_u32Slot].bolInnerWrBus = true;
        
                            
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = false;

        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = false;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = 0;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = u32SrcIdx;
	    }


        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
            }
        }

        //-----------------------------------------------------------------------------
        switch (u32UVWIdx)
        {
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                }
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                }
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                if (u32Mode == 0)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                }

                if (u32Mode == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                }

                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                }
                break;
                
        } // switch (u32UVWIdx)                

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32C0, u32C1, u32K, u32M, u32N, u32UVWIdx, u32Units, u32Mode, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrRegK, u32_A, u32_B, u32_C;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32C1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[9];
            
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access
        u32_A = u32AddrRegN;
        u32_B = u32C0;
        u32_C = u32C1;
        if (u32Mode == 0)
        {
            u32_C = u32AddrRegK;
        }

        if (u32Mode == 1)
        {
            u32_B = u32AddrRegM;
        }

        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                if (u32ChgBase == 1)
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + 2 * j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32_A + 2 * j * u32_C + 1;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32_A + u32_B + 2 * j * u32_C;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][1] = u32_A + u32_B + 2 * j * u32_C + 1;
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                    m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 1);
                }

                j++;
            }
        }
	if(u32ChgBase == 1) {
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVWIdx][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVWIdx][u32N] = u32_A + u32_B;
	}
    } // else if (p_u32Phase == PHASE_DC2_POST)
    
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32C0, u32Mode, u32UVWIdx, u32ChgBase;
        DSPU32 u32AddrRegN, u32AddrRegM, u32_A, u32_B, u32N;
    
        u32C0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
        u32ChgBase = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

	if ( (u32ChgBase == 1) && (!m_bolMemExcp_AC) )
        {
            u32AddrRegN = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN;
            u32AddrRegM = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM;

            u32_A = u32AddrRegN;
            u32_B = u32C0;

            if (u32Mode == 1)
            {
                u32_B = u32AddrRegM;
            }

            wr_u32r_UVW(u32UVWIdx, u32N, u32_A + u32_B);
			
        }
    }
    
    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_fext_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_fext_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_fext_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32DestIdx, u32Mode, u32Units;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u15ImmPQF: 15;
                DSPU32      u2Mode: 2;
                DSPU32      u8Rev0: 8;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u6Rev1: 6;
                DSPU32      u6RegM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u15ImmPQF;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);              
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                if ( u32Mode == 1 )
                {
                    SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                }
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcMIdx, u32DestIdx, u32Mode, u32Units, u32Result, u32SHFIdx;
    
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                if ( u32Mode == 1 )
                {
                    if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                    }
                    else
                    {
                        m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                    }
                }               

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Mode, u32Units, u32SHFIdx;
        DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32ImmPQF;
		DSPU32 u32Result;
    
		u32ImmPQF = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                switch (u32Mode)
                {
                    case 0:
                        u32Result = Fextz(u32SrcA, u32ImmPQF, &u32Status, u32SHFCR);
                        break;
                    case 1:
                        u32Result = Fext(u32SrcA, u32SrcB, u32ImmPQF, &u32Status, u32SHFCR);
                        break;
                    case 2:
                        u32Result = Fexts(u32SrcA, u32ImmPQF, &u32Status, u32SHFCR);
                        break;
                    default:
                        PrintToCerr("ext_fext_cores: Invalid work mode\n");
                }

                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    return true;
}

//-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_reg_is_fix_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_reg_is_fix_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_reg_is_fix_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Complex, u32DestIdx, u32Mode1, u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u24CLow: 24;
                DSPU32      u1Rev0: 1;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2Mode1: 2;
				DSPU32      u2Rev1: 2;
                DSPU32      u1LineL: 1;

                DSPU32      u8CHigh: 8;
                DSPU32      u3Rev2: 3;
                DSPU32      u1Complex: 1;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode0: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = ((p_u32IWordLow & 0xFFFFFF) | (p_u32IWordHigh << 24));
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode0;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Complex;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u2Mode1;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
        u32Complex = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        if ( u32Complex == 0 )
        {
            if ( (u32Mode1 == 1) || (u32Mode1 == 2) )
            {
                m_arrResSLK[p_u32SLKIdx].slot_res_used.bolDestHL = true;
            }
        }

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Const, u32Complex, u32DestIdx, u32Mode1, u32Units;
        DSPU32 u32GenResultIdx, u32Result;
    
        u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Complex = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        u32GenResultIdx = 0;
		u32Result = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                if (u32Complex == 1)
                {
                    u32Result = u32Const;
                }
                else
                {
                    switch (u32Mode1)
                    {
                        case 0:
                            u32Result = u32Const;
                            break;
                        case 1:
							u32Result = ReadGPR_Page(i, u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
                            u32Result = (u32Result & 0xFFFF) | ((u32Const & 0xFFFF) << 16);
                            break;
                        case 2:
							u32Result = ReadGPR_Page(i, u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
                            u32Result = (u32Result & 0xFFFF0000) | (u32Const & 0xFFFF);
                            break;
                        case 3:
                            u32Result = u32Const;
                            break;
                        default :
                            PrintToCerr("ext_reg_is_fix_cores: mode is invalid\n");
                    }
                } //if (bolComplex)

                wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;

            } //if ( GIsBitSet(u32Units, i) )
        } //for (i = 0; i < NUM_OF_UNITS; i++)
    }
    return true;
}
//-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_reg_is_flo32_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_reg_is_flo32_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_reg_is_flo32_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
		DSPU32 u32DestIdx, u32Units;
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u23CLow: 23;
                DSPU32      u2Rev0: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4Rev0: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u9CHigh: 9;
                DSPU32      u3Rev1: 3;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode0: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = ((p_u32IWordLow & 0x7FFFFF) | (p_u32IWordHigh << 23));
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode0;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Const, u32DestIdx, u32Units, u32GenResultIdx;
    
        u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				wr_u32r_R_new(i, u32DestIdx, u32Const, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Const);
                u32GenResultIdx++;

            } //if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_uvw_is_imm_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_uvw_is_imm_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_uvw_is_imm_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32N, u32UVW;
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u24CLow: 24;
                DSPU32      u1Rev0: 1;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4Mode0: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u8CHigh: 8;
                DSPU32      u4N: 4;
				DSPU32      u2UVW: 2;
                DSPU32      u4Rev1: 4;                
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = ((p_u32IWordLow & 0xFFFFFF) | (p_u32IWordHigh << 24));
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Mode0;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2UVW;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32UVW = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
                        
        switch (u32UVW)
        {
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestU, u32N );
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestV, u32N );
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestW, u32N );
                break;

            default :
                PrintToCerr("ext_uvw_is_imm_cores: parameter is invalid\n");
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
        // add by zx 资源使用: 使用一条UVW立即数通道
		m_arrDCResNeeded[p_u32Slot].bolUVWImmBus = true;
    }
	else if(p_u32Phase == PHASE_DC2_POST)
	{
		DSPU32 u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32UVW = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		PIPE_EX.DC2_DC3.m_left.arrBPValid[u32UVW][u32N] = true;
		PIPE_EX.DC2_DC3.m_left.arrBPValue[u32UVW][u32N] = u32Const;
	}
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Const, u32N, u32UVW;
    
        u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32UVW = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
    
	if (!m_bolMemExcp_AC)
        {
            switch (u32UVW)
            {
                case 0:
                    wr_u32r_UVW(0, u32N, u32Const);
                    break;
                case 1:
                    wr_u32r_UVW(1, u32N, u32Const);
                    break;
                case 2:
                    wr_u32r_UVW(2, u32N, u32Const);
                    break;

                default :
                    PrintToCerr("ext_uvw_is_imm_cores: parameter is invalid\n");
            }
			
        }
    }
    
    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_cond_to_cpred_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_cond_to_cpred_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_cond_to_cpred_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32ALUIdx, u32Units, u32SrcM, u32SrcN;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32    u8Rev0: 8;
				//DSPU32    u5D: 5;
				DSPU32    u2DP: 2;
				DSPU32    u1Signed: 1;
				DSPU32    u14Rev1: 14;
 			   	DSPU32    u1MWSL: 1;
				DSPU32    u1MWL: 1;
				DSPU32    u4UnitsL: 4;
				DSPU32    u1LineL: 1;

				DSPU32    u6SrcN: 6;
				DSPU32    u6SrcM: 6;
				DSPU32    u2CMode: 2;
				DSPU32    u1Rev2: 1;
				DSPU32    u3K: 3;
				DSPU32    u3Flag: 3;
				DSPU32    u4Opcode: 4;
				DSPU32    u1MWSH: 1;
				DSPU32    u1MWH: 1;
				DSPU32    u4UnitsH: 4;
 			   	DSPU32    u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			//g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5D;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2DP;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Signed;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u2CMode;            
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3K;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;
		}
		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 8; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{				
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				// used for CPred hazard detection
				// m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestCPred |= (1U << i);
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestCPred |= ( (1U<<u32ALUIdx) << (i * 8) );
			}
		}
		
		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcM, u32SrcN, u32Result;
		DSPU32 u32D, u32DP, u32CMode;
		DSPU32 u32ALUIdx, u32ALUCR, u32Status;
		DSPU16 u16SrcM, u16SrcN;
		bool bolSigned, bolCond, bolIsMacroInstr;

		//u32D = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DP = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		bolSigned = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];		
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32CMode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		bolCond = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcM) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcM] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcM, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcN) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcN, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcM = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcN = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				if(bolSigned)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
				}

				u32Status = 0;
				switch (u32DP)
				{
					case 0:  // fix 32
						switch (u32CMode)
						{
							case 0:  // HT
								bolCond = BIsHT32(u32SrcM, u32SrcN, u32ALUCR);
								break;
							case 1:  // HE
								bolCond = BIsHE32(u32SrcM, u32SrcN, u32ALUCR);
								break;
							case 2:  // EQ
								bolCond = (u32SrcN == u32SrcM)? true:false;
								break;
							case 3:  // NEQ
								bolCond = (u32SrcN != u32SrcM)? true:false;
								break;
							default : 
								PrintToCerr("ext_b_cmp_cores: invalid option\n");
						}
						break;
					case 1:  // low fix 16
						u16SrcM = u32SrcM;
						u16SrcN = u32SrcN;
						switch (u32CMode)
						{
							case 0:  // HT
								bolCond = BIsHT16(u16SrcM, u16SrcN, u32ALUCR);
								break;
							case 1:  // HE
								bolCond = BIsHE16(u16SrcM, u16SrcN, u32ALUCR);
								break;
							case 2:  // EQ
								bolCond = (u16SrcN == u16SrcM)? true:false;
								break;
							case 3:  // NEQ
								bolCond = (u16SrcN != u16SrcM)? true:false;
								break;
							default : 
								PrintToCerr("ext_b_cmp_cores: invalid option\n");
						}
						break;
					case 2:  // high fix 16
						u16SrcM = u32SrcM >> 16;
						u16SrcN = u32SrcN >> 16;
						switch (u32CMode)
						{
							case 0:  // HT
								bolCond = BIsHT16(u16SrcM, u16SrcN, u32ALUCR);
								break;
							case 1:  // HE
								bolCond = BIsHE16(u16SrcM, u16SrcN, u32ALUCR);
								break;
							case 2:  // EQ
								bolCond = (u16SrcN == u16SrcM)? true:false;
								break;
							case 3:  // NEQ
								bolCond = (u16SrcN != u16SrcM)? true:false;
								break;
							default : 
								PrintToCerr("ext_b_cmp_cores: invalid option\n");
						}
						break;
					case 3:  // float 32
						switch (u32CMode)
						{
							case 0:  // HT
								bolCond = BIsHTF32(u32SrcM, u32SrcN, &u32Status, u32ALUCR);
								break;
							case 1:  // HE
								bolCond = BIsHEF32(u32SrcM, u32SrcN, &u32Status, u32ALUCR);
								break;
							case 2:  // EQ
								bolCond = BIsEQF32(u32SrcM, u32SrcN, &u32Status, u32ALUCR);
								break;
							case 3:  // NEQ
								bolCond = !BIsEQF32(u32SrcM, u32SrcN, &u32Status, u32ALUCR);
								break;
							default : 
								PrintToCerr("ext_b_cmp_cores: invalid option\n");
						}
						break;
				} // switch (instr_word.details.u2DP)

				u32D = u32ALUIdx;
				if(bolCond) 
				{
					u32ri_CPredReg[i] = GSetBit(u32ri_CPredReg[i], u32D);
				}
				else
				{
					u32ri_CPredReg[i] = GClrBit(u32ri_CPredReg[i], u32D);
				}
				//m_arrResSLK[p_u32SLKIdx].arrFlag[i][0] = 0;//u32Status;
				m_arrResSLK[p_u32SLKIdx].arrFlag[i][0] = u32Status;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (int i = 0; i < 4; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32ALUIdx, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

				// if necessory
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], m_arrResSLK[p_u32SLKIdx].arrFlag[i][0]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				//break;
			}
		}
	}
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_maxmin_hlacc_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_maxmin_hlacc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_maxmin_hlacc_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32ALUIdx, u32Units, u32Dest;

		union INSTR_WORD
		{
			struct  INST_WORD
    		{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

    		struct  SPLIT_VALUE
    		{
				DSPU32    u3C: 3;
				DSPU32    u4Mode: 4;
				DSPU32    u1Signed: 1;
				DSPU32    u17Rev0: 17;
 			   	DSPU32    u1MWSL: 1;
                DSPU32    u1MWL: 1;
                DSPU32    u4UnitsL: 4;
                DSPU32    u1LineL: 1;

    			DSPU32    u3K: 3;
		    	DSPU32    u9Rev1: 9;
				DSPU32    u6Dest: 6;
				DSPU32    u3Flag: 3;
				DSPU32    u4Opcode: 4;
				DSPU32    u1MWSH: 1;
				DSPU32    u1MWH: 1;
				DSPU32    u4UnitsH: 4;
 			   	DSPU32    u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3C;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Signed;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 7; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];		
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units ;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
			}
		}
	}
	else if(p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32Units;
		DSPU32 u32ALUIdx, u32Status, u32ALUCR, u32Result;
		DSP_BIT48 b48Temp;

		u32Result = 0;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Status = 0;

				if(u32Sign)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
				}
				
				ReadACC_48(i, u32ALUIdx, b48Temp);

				if(u32Mode == 0 || u32Mode ==1)
				{
					//HHRs=max(LACCk,HACCk)(U,cut=C),HHRs=max(LACCk,HACCk)(cut=C)
					//LHRs= max(LACCk,HACCk)(U,cut=C),LHRs= max(LACCk,HACCk)(cut=C)
					u32Result = MaxACC(b48Temp, u32Imm, u32Mode, &u32Status, u32ALUCR);
				}
				else if(u32Mode == 2 || u32Mode == 3)
				{
					//HHRs=min(LACCk,HACCk)(U,cut=C),HHRs=min(LACCk,HACCk)(cut=C)
					//LHRs=min(LACCk,HACCk)(U,cut=C),LHRs=min(LACCk,HACCk)(cut=C)
					u32Result = MinACC(b48Temp, u32Imm, u32Mode, &u32Status, u32ALUCR);
				}
				else 
				{
					PrintToCerr("ext_maxmin_hlacc_cores: Invalid parameter\n");
				}
				
				m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Status;
				m_arrResSLK[p_u32SLKIdx].arrDestL[i][1] = u32Result;

			}
		}
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units;
		DSPU32 u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32ALUIdx, u32Flag, DestValue, u32Result;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

				DestValue = ReadGPR_Page(i, u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
				u32Result = m_arrResSLK[p_u32SLKIdx].arrDestL[i][1];
				if(u32Mode == 0 || u32Mode ==2)  //结果放在高16位
				{
					u32Result = (u32Result & 0xFFFF0000) | (DestValue & 0x0000FFFF);
				}
				else  //结果放在低16位
				{
					u32Result = (u32Result & 0x0000FFFF) | (DestValue & 0xFFFF0000);
				}
				
				//write ALUFR
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], m_arrResSLK[p_u32SLKIdx].arrDestL[i][0]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

				//write Rs
				wr_u32r_R_new(i, u32Dest, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
			}
		}
	}
	
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_fix16_is_on_cmp_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_fix16_is_on_cmp_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_fix16_is_on_cmp_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcM, u32SrcN, u32Dest;
		union INSTR_WORD
		{
			struct  INST_WORD
    		{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

    		struct  SPLIT_VALUE
    		{
				DSPU32    u3Rev0: 3;
				DSPU32    u4Mode: 4;
				DSPU32    u1Signed: 1;
				DSPU32    u17Rev1: 17;
				DSPU32    u1MWSL: 1;
				DSPU32    u1MWL: 1;
				DSPU32    u4AddrPart1: 4;
 			   	DSPU32    u1LineL: 1;

    			DSPU32    u6SrcN: 6;
		    	DSPU32    u6SrcM: 6;
				DSPU32    u6Dest: 6;
				DSPU32    u3Flag: 3;
				DSPU32    u4Opcode: 4;
				DSPU32    u1MWSH: 1;
				DSPU32    u1MWH: 1;
				DSPU32    u4UnitsH: 4;
 			   	DSPU32    u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Signed;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 7; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data hazard detection of general purpose register.
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}

		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32Units;
		DSPU32 u32Result;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcM) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcM, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcN) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcN, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			}
		}
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32Flag, u32Status, u32Rm, u32Rn, u32ALUIdx, u32Result, u32ALUCR, u32ACF, DestValue;

		u32Result = 0;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32Status = 0;
				//read ACF
				u32ACF = u32r_ALU_ACF[i][u32ALUIdx];	
				DestValue = ReadGPR_Page(i, u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);

				if(u32Sign)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
				}			

				u32Result = ConditionalAssignD16(u32Rm, u32Rn, u32Mode, &u32Status, &u32ACF, u32ALUCR);

				if(u32Mode==0 || u32Mode==2 || u32Mode==4 || u32Mode==6)
				{
					u32Result = (u32Result & 0x0000FFFF) | (DestValue & 0xFFFF0000);
				}
				else
				{
					u32Result = (u32Result & 0xFFFF0000) | (DestValue & 0x0000FFFF);
				}
				//write ACF
				u32r_ALU_ACF[i][u32ALUIdx] = u32ACF;
				//write Rs
				wr_u32r_R_new(i, u32Dest, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				//write ALUFR
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;	
			}
		}
	}
	
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_shf_c_add_32_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_shf_c_add_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_shf_c_add_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32SrcNIdx, u32DestIdx, u32Units;

		union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u25Rev0: 25;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

				DSPU32      u6SrcN: 6;
				DSPU32      u6SrcM: 6;
				DSPU32      u6Dest: 6;
				DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
        }		

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;
		DSPU32 u32SrcMIdxSel, u32SrcNIdxSel, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32SrcMIdxSel = 0;
		u32SrcNIdxSel = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
                {
					// read SHFCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);

					switch (u32Mode)
	        		{
						case 0: // CRs+1:s = CRm+1:m + CRn+1:n (shf)
						case 1: // CRs+1:s = CRm+1:m - CRn+1:n (shf)
						case 4: // CRs+1:s = (CRm+1:m + CRn+1:n) / 2 (shf)
						case 5: // CRs+1:s = (CRm+1:m - CRn+1:n) / 2 (shf)
							u32SrcMIdxSel = u32SrcMIdx + k;
							u32SrcNIdxSel = u32SrcNIdx + k;
							break;
						case 2: // CRs+1:s = CRm+1:m + jCRn+1:n (shf)
						case 3: // CRs+1:s = CRm+1:m - jCRn+1:n (shf)
						case 6: // CRs+1:s = (CRm+1:m + jCRn+1:n) / 2 (shf)
						case 7: // CRs+1:s = (CRm+1:m - jCRn+1:n) / 2 (shf)
							if (k == 0)
							{
								u32SrcMIdxSel = u32SrcMIdx;
								u32SrcNIdxSel = u32SrcNIdx + 1;
							}
							else
							{
								u32SrcMIdxSel = u32SrcMIdx + 1;
								u32SrcNIdxSel = u32SrcNIdx;									
							}
							break;

					} // switch (p_u32Opcode)

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
					
                } // for (k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32SHFIdx, u32Result, u32SHFCR, u32Mode;
		
		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], (k + 1));
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					switch (u32Mode)
	        		{
						case 0: // CRs+1:s = CRm+1:m + CRn+1:n (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
     		               	u32Result = Add32SHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
       	            		break;
						case 1: // CRs+1:s = CRm+1:m - CRn+1:n (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
     		               	u32Result = Sub32SHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
       	            		break;
						case 2: // CRs+1:s = CRm+1:m + jCRn+1:n (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
							if (k == 0)
							{
								u32Result = Add32SHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
							else
							{
								u32Result = Sub32SHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
       	            		break;
						case 3: // CRs+1:s = CRm+1:m - jCRn+1:n (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
							if (k == 0)
							{
								u32Result = Sub32SHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
							else
							{
								u32Result = Add32SHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
       	            		break;

						case 4: // CRs+1:s = (CRm+1:m + CRn+1:n) / 2 (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
							u32Result = Add32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
       	            		break;
						case 5: // CRs+1:s = (CRm+1:m - CRn+1:n) / 2 (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);     		               	
							u32Result = Sub32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
       	            		break;
						case 6: // CRs+1:s = (CRm+1:m + jCRn+1:n) / 2 (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
     		               	if (k == 0)
							{
								u32Result = Add32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
							else
							{
								u32Result = Sub32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
       	            		break;
						case 7: // CRs+1:s = (CRm+1:m - jCRn+1:n) / 2 (shf)
							// set bit[0] of SHFCR indicate this is signed operation
							u32SHFCR = GSetBit(u32SHFCR, 0);
     		               	if (k == 0)
							{
								u32Result = Sub32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
							else
							{
								u32Result = Add32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32SHFCR);
							}
       	            		break;
						
						
						default:
							PrintToCerr("ext_shf_c_add_32_cores: opcode not found\n");
					}
										
					wr_u32r_R_new(i, u32DestIdx + k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				} // for (int k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_shf_64_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_shf_64_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_shf_64_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcM, u32DestS1, u32DestS2, u32Mode, u32Units, u32SHFIdx;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u10Rev0: 10;
                DSPU32      u6DestS2: 6;
                DSPU32      u9Rev1: 9;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u2SHFIdx: 2;
                DSPU32      u3Mode: 3;
				DSPU32      u1Rev2: 1;
				DSPU32      u6SrcM: 6;
                DSPU32      u6DestS1: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6DestS2;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2SHFIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u3Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6DestS1;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
		u32DestS2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SHFIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestS1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];        
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        SetCalcResIdx(u32SHFIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				switch (u32Mode)
				{
					case 0:
					case 1:
					case 2:
						SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32SrcM + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
						SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						break;
					case 3:
						SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					case 4:
					case 5:
						SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
						break;					
				}

				//设置SACC数据相关
				//设置SACC读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
				
            }

        } // for (int i = 0; i < NUM_OF_UNITS; i++)

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Result,u32SACCIdx;
		DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				
				//get Rm : m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = Rm
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				
				//get Rm+1 : m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = Rm+1
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				//if((u32Mode == 0) || (u32Mode == 1) || (u32Mode == 2))
				//{
					//zx need data forward of SACC
					u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u64ro_SHF_SACC[i][u32SACCIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u64ro_SHF_SACC[i][u32SACCIdx].u32High;
				//}
			}
		}
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32SACCIdx, u32Status, u32SHFCR, u32Flag;
		DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32DestS1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		DSPU32 u32DestS2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSP_BIT64 u64Src, u64Res;
		DSP_BIT64 u64SACC;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				u32SACCIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SHFCR = GSetBit(u32SHFCR, 0);
				u32Status = 0;
				u64Res.u32Low = 0;
				u64Res.u32High = 0;

				u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
				switch (u32Mode)
				{
				case 0: //Rs1Rs2=Rm+1:m aShift HSACCs
					u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
					AShift64SACC(u64Src, u64SACC, u64Res, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 1: //Rs1Rs2=Rm+1:m lShift HSACCs
					u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
					LShift64SACC(u64Src, u64SACC, u64Res, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 2: //Rs1Rs2=Rm+1:m rot HSACCs
					u64Src.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					u64Src.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
					Rot64SACC(u64Src, u64SACC, u64Res, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 3: //Rs1Rs2=SACCs
					wr_u32r_R_new(i, u32DestS1, u64SACC.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64SACC.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 4: //Rs=LHSACCs
					wr_u32r_R_new(i, u32DestS1, u64SACC.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 5: //Rs=HHSACCs
					wr_u32r_R_new(i, u32DestS1, u64SACC.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SACCIdx], u32Status);
                u32ri_SHFFR[i][u32SACCIdx] = u32Flag;
			}
		}
	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_sacc_insert_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_sacc_insert_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_sacc_insert_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcN, u32SrcM, u32SHFIdx, u32Mode, u32Units;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
				DSPU32      u5P: 5;
				DSPU32      u5Q: 5;
                DSPU32      u7Rev0: 7;
				DSPU32      u6F: 6;
				DSPU32      u2Rev1: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

				DSPU32      u6SrcN: 6;
				DSPU32      u6SrcM: 6;
                DSPU32      u2SHFIdx: 2;
                DSPU32      u2Mode: 2;
				DSPU32      u2Rev2: 2;
				DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5P;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u5Q;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6F;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2SHFIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u2Mode;            
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;

			if(instr_word.details.u2Mode == 0)
			{
				g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6F & 0x1F;
			}
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 8; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32SHFIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];        
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        SetCalcResIdx(u32SHFIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				
				if (u32Mode == 0)
				{
					SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);		

				//设置SACC数据相关				
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
				if(u32Mode == 1)
				{
					//设置SACC读相关
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
				}
            }

        } // for (int i = 0; i < NUM_OF_UNITS; i++)

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Result, u32SHFIdx;
        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        DSPU32 u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6]; 
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcN) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcN, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
				
				if(u32Mode == 0)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcM) )
					{
						// data forward to get the value of R[u32SrcMIdx] of current macro
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
					}
					else
					{
						// read the value of R[u32SrcMIdx] from register heap directly
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcM, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}                
				
				if(u32Mode == 1)
				{
					//zx need SACC data forward
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u64ro_SHF_SACC[i][u32SHFIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u64ro_SHF_SACC[i][u32SHFIdx].u32High;
				}				

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32SHFIdx, u32SHFCR, u32Status, u32Flag, u32Rm, u32Rn;
		DSP_BIT64 u64SACC;
        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        DSPU32 u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6]; 
		DSPU32 p = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 q = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 f = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
				// get the index of the first SHF allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Status = 0;
				u64SACC.u32Low = 0;
				u64SACC.u32High = 0;
				
				u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				
				if(u32Mode == 0) //SACCs=Rm Insert Rn (p:q,f)
				{
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];
					InsGPRToSACC(u32Rm, u32Rn, u64SACC, p, q, f, &u32Status, u32SHFCR);
				}
				else if(u32Mode == 1) //SACCs=SACCs Insert Rn (p:q,f)
				{
					u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
					InsSACCToSACC(u32Rn, u64SACC, p, q, f, &u32Status, u32SHFCR);
				}
				
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SHFIdx].u32Low = u64SACC.u32Low;
				u64ri_SHF_SACC[i][u32SHFIdx].u32High = u64SACC.u32High;
			}
		}
	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_sigma_b1_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_sigma_b1_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_sigma_b1_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcN, u32SrcM, u32SHFIdx, u32IsAcc, u32Units, n;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u25Rev0: 25;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

				DSPU32      u6SrcN: 6;
				DSPU32      u6SrcM: 6;
                DSPU32      u2SHFIdx: 2;
                DSPU32      u2N: 2;
				DSPU32      u1Rev1: 1;
				DSPU32      u1IsAcc: 1;
				DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2SHFIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2N;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u1IsAcc;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SHFIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32IsAcc = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];        
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        SetCalcResIdx(u32SHFIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);		

				//设置SACC数据相关
				//设置SACC读相关
				if(u32IsAcc)
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSACC = true;
				}
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;

				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				// 根据所访问的STAB中块的序号设置掩码
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<n);
            }

        } // for (int i = 0; i < NUM_OF_UNITS; i++)

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Result, u32SHFIdx, u32TabAddr, u32Rm;
        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        DSPU32 u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 n = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32IsAcc = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];        
        DSPU32 u32Units;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcM) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    u32Rm = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    u32Rm = rd_u32r_R_new(i, u32SrcM, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

				u32TabAddr = u32Rm & 0xff;
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_SHF_Tab(i, u32SHFIdx, n, u32TabAddr);


                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcN) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcN, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
				
				if(u32IsAcc)
				{
					//zx need SACC data forward
					
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u64ro_SHF_SACC[i][u32SHFIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u64ro_SHF_SACC[i][u32SHFIdx].u32High;
				}
				

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32SHFIdx, u32SHFCR, u32Status, u32Flag, u32TabValue, u32Rn;
		DSP_BIT64 u64SACC;
        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		DSPU32 u32IsAcc = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];   
        DSPU32 u32Units;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
				// get the index of the first SHF allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32Status = 0;
				u64SACC.u32Low = 0;
				u64SACC.u32High = 0;
				u32TabValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];

				if(u32IsAcc == 1)
				{
					u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
				}
				//SACCs = Sigma_b1(Rn，STABn(LLORm)), SACCs += Sigma_b1(Rn，STABn (LLORm))
				SigmaSR(u64SACC, u32Rn, u32TabValue, u32IsAcc, &u32Status, u32SHFCR);				
				
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SHFIdx].u32Low = u64SACC.u32Low;
				u64ri_SHF_SACC[i][u32SHFIdx].u32High = u64SACC.u32High;
			}
		}
	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_fext_reg_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_fext_reg_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_fext_reg_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcN, u32SrcM, u32SHFIdx, u32Mode, u32Units;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u25Rev0: 25;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

				DSPU32      u6SrcN: 6;
				DSPU32      u6SrcM: 6;
                DSPU32      u2SHFIdx: 2;
                DSPU32      u2Mode: 2;
				DSPU32      u2Rev2: 2;
				DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2SHFIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2Mode;            
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 5; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SHFIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];        
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        SetCalcResIdx(u32SHFIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);	

				//设置SACC数据相关
				//设置SACC写相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSACC = true;
            }

        } // for (int i = 0; i < NUM_OF_UNITS; i++)

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Result, u32SHFIdx;
        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        DSPU32 u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3]; 
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcM) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcM, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcN) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcN, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
				
				if(u32Mode == 1)
				{
					//zx need SACC data forward
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u64ro_SHF_SACC[i][u32SHFIdx].u32Low;
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1] = u64ro_SHF_SACC[i][u32SHFIdx].u32High;
				}
				

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32SHFIdx, u32SHFCR, u32Status, u32Flag, u32Rm, u32Rn;
		DSP_BIT64 u64SACC;
        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        DSPU32 u32Units;
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];  
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
				// get the index of the first SHF allocated for this instruction in current macro
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SHFCR = GSetBit(u32SHFCR, 0);
				u32Status = 0;
				u64SACC.u32Low = 0;
				u64SACC.u32High = 0;
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];

				if(u32Mode == 1)
				{
					u64SACC.u32Low = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					u64SACC.u32High = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][1];
				}

				//SACCs=Rm fext Rn, SACCs=Rm fext Rn(z), SACCs=Rm fext Rn(s)
				Fext32ToReg(u32Rm, u32Rn, u64SACC, u32Mode, &u32Status, u32SHFCR);
				
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

				u64ri_SHF_SACC[i][u32SHFIdx].u32Low = u64SACC.u32Low;
				u64ri_SHF_SACC[i][u32SHFIdx].u32High = u64SACC.u32High;
			}
		}
	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_append_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_like_append_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_like_append_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u15Rev0: 15;
                DSPU32      u2Mode: 2;
                DSPU32      u8Rev1: 8;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u6RegN: 6;
                DSPU32      u6RegM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6RegN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units, u32Result, u32SHFIdx;
    
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
                
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Mode, u32Units, u32GenResultIdx, u32SHFIdx;
        DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag;
        DSPU32 u32Result;

        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                u32Result = Append(u32SrcA, u32SrcB, &u32Status, u32SHFCR, u32Mode);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_compact_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_compact_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_compact_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units;
    
        union INSTR_WORD
       {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u5Imm: 5;
				DSPU32      u10Rev0: 10;
                DSPU32      u2Mode: 2;
                DSPU32      u8Rev1: 8;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u6RegN: 6;
                DSPU32      u6RegM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 7; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
                    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result;
    
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
                
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Units, u32SHFIdx;
        DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32Imm;
        DSPU32 u32Result;

        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;
                u32Result = CompactMN(u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_reg_mask_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_reg_mask_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_reg_mask_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32DestIdx, u32Units;
		DSPU32 u32ImmLow, u32ImmMid, u32ImmHigh, u32Mode;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u25CLow: 25;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
				DSPU32      u4CMid: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u3CHigh: 3;
                DSPU32      u3Mode: 3;
                DSPU32      u6RegM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			u32ImmLow = instr_word.details.u25CLow;
			u32ImmMid = instr_word.details.u4CMid;
			u32ImmHigh = instr_word.details.u3CHigh;

            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = u32ImmLow | (u32ImmMid << 25) | (u32ImmHigh << 29);
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Flag;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Mode;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
        u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
        u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
        u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5];
    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if(u32Mode==0)
				{
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Result;
    
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }   
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Const, u32DestIdx, u32Units, u32SHFCR, u32Mode, u32SrcA, u32SrcB;
        DSPU32 u32Result, u32Flag, u32GenResultIdx, u32Status, u32SHFIdx;
    
        u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
                
                u32Status = 0; 
                if(u32Mode==0)
                {
                	//Rs=Rm mask C
                	u32Result = Mask(u32SrcA, u32SrcB, u32Const, &u32Status, u32SHFCR);
                }
                else if(u32Mode==1)
                {
                	//Rs=Rm & C
                	u32Result = And32(u32SrcA, u32Const, &u32Status, u32SHFCR);
                }
                else if(u32Mode==2)
                {
                	//Rs=Rm | C
                	u32Result = Or32(u32SrcA, u32Const, &u32Status, u32SHFCR);
                }
                else if(u32Mode==3)
                {
                	//Rs=Rm ^ C
                	u32Result = Xor32(u32SrcA, u32Const, &u32Status, u32SHFCR);
                }
                
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    
    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_fix_reg_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_fix_reg_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_fix_reg_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Sel32or64, u32DestIdx2;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u11ImmC: 11;
                DSPU32      u14Rev0: 14;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u2HRev0: 2;
                DSPU32      u1Sel32or64: 1;
                DSPU32      u2HRev1: 2;
                DSPU32      u1IsImm: 1;
                DSPU32      u6RegM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u11ImmC;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Sel32or64;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1IsImm;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        u32Sel32or64 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
        u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
        u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
        u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

                if(u32Sel32or64==1)
                {
                	SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                }
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcMIdx, u32Units, u32Result;
    
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
                
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1] = u32r_SHFCUTR[i] & 0x7FF;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Units, u32SHFIdx, u32IsImm;;
        DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32Imm, u32Sel32or64;
        DSPU32 u32Result;
        DSP_BIT64 u64Res;
    
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sel32or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32IsImm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		u32Result = 0;
		u64Res.u32High = 0;  //对应Rs2
		u64Res.u32Low = 0;  //对应Rs1
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SHFCR = GSetBit(u32SHFCR, 0);
                //Rm
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                //Rm+1
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

                u32Status = 0;

                if(u32IsImm==1)
                {
                	u32Imm = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1];
                }

                if(u32Sel32or64==0)
                {
                	//Rs=FIX DFRm+1:m, Rs=FIX(DFRm+1:m,C)
                	u32Result = Flo64ToFix32(u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
                	wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                }
				else
				{
					//Rs+1:s=FIX DFRm+1:m, Rs+1:s=FIX(DFRm+1:m,C)
					Flo64ToFix64(u32SrcA, u32SrcB, u32Imm, u64Res, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
				
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    
    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_double_reg_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_double_reg_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_double_reg_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcM, u32Dest, u32Units, u32Sel32Or64;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u11ImmC: 11;
                DSPU32      u1Sel32Or64: 1;
                DSPU32      u13Rev0: 13;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u5Rev1: 5;
                DSPU32      u1IsImm: 1;
                DSPU32      u6RegM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u11ImmC;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u1Sel32Or64;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1IsImm;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
        u32SrcM = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
        u32Dest = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
        u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
        u32Sel32Or64 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
            	if(u32Sel32Or64 == 1)
            		{
            			SetGenRegIdx(u32SrcM+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
            		}
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
                SetGenRegIdx(u32Dest+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcMIdx, u32Sel32Or64, u32Units, u32Result;
    
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    	u32Sel32Or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
    		
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                                
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                if(u32Sel32Or64 == 1)
                {
                	if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
	                {
	                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
	                }
	                else
	                {
	                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
	                }
                }

				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1] = u32r_SHFCUTR[i] & 0x7FF;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Dest, u32Units, u32SHFIdx, u32Sel32Or64, u32IsImm;
        DSPU32 u32SHFCR, u32Status, u32Flag, u32Imm, u32SrcA, u32SrcB;
        DSPU32 u32Rs1 = 0, u32Rs2 = 0;
  
        u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sel32Or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32IsImm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SHFCR = GSetBit(u32SHFCR, 0);
                //Rm
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

                u32Status = 0;

                if(u32IsImm==1)
                {
                	u32Imm = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1];
                }

                if(u32Sel32Or64 == 0)
                {
                	//DFRs+1:s=Double Rm, DFRs+1:s=Double(Rm,C)
                	Fix32ToFlo64(u32SrcA, u32Rs1, u32Rs2, u32Imm, &u32Status, u32SHFCR);
                }
                else
                {
                	//Rm+1
                	u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
                	//DFRs+1:s=Double Rm+1:m, DFRs+1:s=Double(Rm+1:m,C)
                	Fix64ToFlo64(u32SrcA, u32SrcB, u32Rs1, u32Rs2, u32Imm, &u32Status, u32SHFCR);
                }
				
                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32Dest+1, u32Rs1, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				wr_u32r_R_new(i, u32Dest, u32Rs2, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    
    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_fix_float_reg_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_fix_float_reg_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_fix_float_reg_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcMIdx,u32DestIdx,u32Mode,u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u8ImmC: 8;
                DSPU32      u2Rev0: 2;
				DSPU32      u6DestIdx: 6;
				DSPU32      u9Rev1: 9;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
				DSPU32      u4Rev2: 4;
                DSPU32      u1LineL: 1;

				DSPU32      u2Mode: 2;
				DSPU32		u3Rev3: 3;
				DSPU32      u1IsImm: 1;
                DSPU32      u6SrcMIdx: 6;
				DSPU32      u5Rev4: 5;
				DSPU32      u1SHFNum: 1;                
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u8ImmC;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcMIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6DestIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1IsImm;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
        u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
        u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
        u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if(u32Mode == 2 || u32Mode == 3)
				{
					SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
				//
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        DSPU32 u32Units;
		DSPU32 u32Result;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				// read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1] = u32r_SHFCUTR[i] & 0x7ff;

				//get Rm
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

				if(u32Mode == 2 || u32Mode == 3)
				{
					//get Rm+1
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
					{
						// data forward to get the value of R[u32SrcMIdx] of current macro
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = u32Result;
					}
					else
					{
						// read the value of R[u32SrcMIdx] from register heap directly
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}
			}
		}

	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32Units;
		DSPU32 u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32IsImm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		DSPU32 u32SHFIdx, u32SHFCR, u32SrcA, u32SrcB, u32Status,u32Result, u32Flag;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				 u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				 u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				 u32SHFCR = GSetBit(u32SHFCR, 0);
				 //Rm
				 u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
			
				 u32Status = 0;

				 if(u32IsImm==1)
				 {
				 	u32Imm = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1];
				 }

				 switch (u32Mode)
				 {
				 case 0:
					 //Rs=FIX(FRm,C)
					 u32Result =  Fix32(u32SrcA, u32Imm, &u32Status, u32SHFCR);
					 wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					 break;
				 case 1:
					 //FRs=Float(Rm,C)
					 u32Result =  Float32(u32SrcA, u32Imm, &u32Status, u32SHFCR);
					 wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					 break;
				 case 2:
					 //Rm+1
					 u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];

					 //CRs+1:s=FIX(CFRm+1:m,C)
					 FixC32(u64Res, u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
					 wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					 wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					 break;
				 case 3:
					 //Rm+1
					 u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][1];

					 //CFRs+1:s=Float(CRm+1:m，C)
					 FloatC32(u64Res, u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
					 wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					 wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					 break;
				 }

				 u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                 u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			}
		}
	}
    
    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_compact_expand_cors(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_compact_expand_cors: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_compact_expand_cors: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcN, u32SrcM, u32DestS1, u32DestS2, u32Units,u32Mode;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u4ImmA: 4;
                DSPU32      u6Rev0: 6;
				DSPU32		u6DestS2: 6;
				DSPU32		u6Rev1: 6;
				DSPU32		u1Sign: 1;
				DSPU32		u2Mode: 2;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
                DSPU32      u1LineL: 1;

                DSPU32      u6RegN: 6;
                DSPU32      u6RegM: 6;
                DSPU32      u6DestS1: 6;
                DSPU32      u3Flag: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4ImmA;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Sign;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6RegM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6DestS2;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6DestS1;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 8; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
		u32SrcN = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32SrcM = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
        u32DestS2 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5];
        u32DestS1 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6];
        u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7];
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
    
        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);

				if(u32Mode==0)
				{
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
				if(u32Mode==1)
				{
					SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
				if(u32Mode==2)
				{
					SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
            }
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result, u32Mode;
    
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
                     
				if(u32Mode == 1 || u32Mode ==2)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestS1,u32DestS2, u32Mode, u32Units, u32SHFIdx, u32Sign;
        DSPU32 u32SHFCR, u32Status, u32Flag, u32Imm, u32Rn, u32Rm;
        DSPU32 u32Result = 0;
		DSP_BIT64 u64res;
    
        u32DestS2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32DestS1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
                u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];                
                
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
                u32Status = 0;
				u64res.u32Low = 0; //对应Rs1
				u64res.u32High = 0;//对应Rs2
				if(u32Sign==1)
				{
					u32SHFCR = GSetBit(u32SHFCR, 0);
				}

				switch (u32Mode)
				{
				case 0:
					//HRs1HRs2=EXPAND(ORm,a)(U)，HRs1HRs2=EXPAND(ORm,a)
					ExpandDW8To16(u64res, u32Rm, u32Imm, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 1:
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					//HRs1HRs2=EXPAND(ORm,Rn)(U)，HRs1HRs2=EXPAND(ORm,Rn)
					ExpandDW8To16(u64res, u32Rm, u32Rn, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 2:
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					//ORs=COMPACT(HRmHRn,a)(U)，ORs=COMPACT(HRmHRn,a)
					u32Result = CompactDW16to8(u32Rm, u32Rn, u32Imm, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				default:
					PrintToCerr("ext_compact_expand_cors: opcode not found\n");
				}

                u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    }
    
    return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::ext_exchange_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_exchange_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_exchange_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx1, u32DestIdx2,  u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u5La: 5;
                DSPU32      u5LRev0: 5;
                DSPU32      u6LDestIdx2: 6;
                DSPU32      u9LRev1: 9;
				DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32		u6HSrcN: 6;
				DSPU32		u6HSrcM: 6;
				DSPU32		u6HDestIdx1: 6;
				DSPU32		u1HRev0: 1;
				DSPU32		u2HMode: 2;
				DSPU32		u4HOpcode: 4; 
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5La;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6LDestIdx2;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6HSrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6HSrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6HDestIdx1;            
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2HMode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4HOpcode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 8; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            	SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units;
		DSPU32 u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		
		DSPU32 u32Result;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				// read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				//get Rm
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                // get the value of R[u32SrcNIdx](Rn) of current macro
                // data forward or directly
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
			}
		}
	}
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Units;
		DSPU32 u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        DSPU32 u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		DSPU32 u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		DSPU32 u32SHFIdx, u32SHFCR, u32Flag, u32Status;
		DSPU32 u32Rm, u32Rn;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				 u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				 u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				 u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				 u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				
				 u32Status = 0;

				 if(u32Mode == 0)
				 {
					 Exchang(u32Rm, u32Rn, u32Imm, u64Res, &u32Status, u32SHFCR);
				 }
				 else if(u32Mode == 1)
				 {
					 SExchang(u32Rm, u32Rn, u32Imm, u64Res, &u32Status, u32SHFCR);
				 }

				 wr_u32r_R_new(i, u32DestIdx2, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				 wr_u32r_R_new(i, u32DestIdx1, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				 u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                 u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			}
		}
    }
    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_insert_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_insert_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_insert_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx1, u32DestIdx2,  u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u4Lg: 4;
                DSPU32      u4Lf: 4;
                DSPU32      u2LRev0: 2;
                DSPU32      u6LDestIdx2: 6;
				DSPU32      u4Lq: 4;
				DSPU32      u4Lp: 4;
				DSPU32      u1LRev1: 1;
				DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32		u6HSrcN: 6;
				DSPU32		u6HSrcM: 6;
				DSPU32		u6HDestIdx1: 6;
				DSPU32		u1HRev0: 1;
				DSPU32		u2HMode: 2;
				DSPU32		u4HOpcode: 4; 
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Lg;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Lf;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6LDestIdx2;
			
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6HSrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6HSrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6HDestIdx1;            
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u2HMode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4HOpcode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 9; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            	SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units;
		DSPU32 u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		
		DSPU32 u32Result;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				// read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				//get Rm
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                // get the value of R[u32SrcNIdx](Rn) of current macro
                // data forward or directly
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
			}
		}
	}
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Units;
		DSPU32 u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        DSPU32 u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32F = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32G = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		DSPU32 u32SHFIdx, u32SHFCR, u32Flag, u32Status;
		DSPU32 u32Rm, u32Rn;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				 u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				 u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				 u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				 u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				
				 u32Status = 0;

				 InsertReg(u32Rm, u32Rn, u32F, u32G, u64Res, &u32Status, u32SHFCR);

				 wr_u32r_R_new(i, u32DestIdx2, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				 wr_u32r_R_new(i, u32DestIdx1, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				 u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                 u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			}
		}
    }
    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_ext_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_ext_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_ext_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx1, u32DestIdx2,  u32Units;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u4Lg: 4;
                DSPU32      u5Lf: 5;
                DSPU32      u1LRev0: 1;
                DSPU32      u6LDestIdx2: 6;
				DSPU32      u9LRev1: 9;
				DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u4UnitsL: 4;
                DSPU32      u1LineL: 1;

                DSPU32		u6HSrcN: 6;
				DSPU32		u6HSrcM: 6;
				DSPU32		u6HDestIdx1: 6;
				DSPU32		u1HRev0: 1;
				DSPU32		u2HMode: 2;
				DSPU32		u4HOpcode: 4; 
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Lg;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u5Lf;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6LDestIdx2;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6HSrcN;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6HSrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6HDestIdx1;            
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u2HMode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4HOpcode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 9; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }
        
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            	SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
        }

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units;
		DSPU32 u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		
		DSPU32 u32Result;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				// read SHFCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				//get Rm
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                // get the value of R[u32SrcNIdx](Rn) of current macro
                // data forward or directly
                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
                }
                else
                {
                    m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }
			}
		}
	}
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32Units;
		DSPU32 u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
        DSPU32 u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32F = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32G = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		DSPU32 u32SHFIdx, u32SHFCR, u32Flag, u32Status;
		DSPU32 u32Rm, u32Rn;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				 u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				 u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				 u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				 u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				
				 u32Status = 0;

				 ExtReg(u32Rm, u32Rn, u32F, u32G, u64Res, &u32Status, u32SHFCR);

				 wr_u32r_R_new(i, u32DestIdx2, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				 wr_u32r_R_new(i, u32DestIdx1, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				 u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
                 u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			}
		}
    }
    return true;
}

 //-----------------------------------------------------------------------------------
bool sc_iss::ext_Float32_Add_C_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_Float32_Add_C_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_Float32_Add_C_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Mode;
		DSPU32 u32ImmLow, u32ImmMid, u32ImmHigh;
		DSPU32 u32ALUNum;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32	u25CLow: 25;
				DSPU32	u1MWSL: 1;
				DSPU32	u1MWL: 1;
				DSPU32	u4CMid: 4;
				DSPU32	u1LineL: 1;

				DSPU32	u3CHigh: 3;
				DSPU32	u2Mode: 2;
				DSPU32	u1Rev0: 1;
				DSPU32	u6RegM: 6;
				DSPU32	u6Dest: 6;
				DSPU32	u3Flag: 3;
				DSPU32	u4Opcode: 4;
				DSPU32	u1MWSH: 1;
				DSPU32	u1MWH: 1;
				DSPU32	u4UnitsH: 4;
				DSPU32	u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			u32ImmLow = instr_word.details.u25CLow;
			u32ImmMid = instr_word.details.u4CMid;
			u32ImmHigh = instr_word.details.u3CHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = u32ImmLow | (u32ImmMid << 25) | (u32ImmHigh << 29);
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;
		
		ISS_ASSERT(u32Mode < 3);
		u32ALUNum = (1 << u32Mode);
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = u32ALUNum;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int j = 0; j < u32ALUNum; j++)
				{
					SetGenRegIdx(u32SrcMIdx + j, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx + j, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Result;
		DSPU32 u32ALUNum;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32ALUNum = (1 << m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5]);
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int j = 0; j < u32ALUNum; j++)
				{				
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][j] = ReadALUCR(i);
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][j] = ReadGPR_Page(i, u32SrcMIdx + j, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}   
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Const, u32DestIdx, u32Units, u32ALUCR, u32SrcA, u32SrcB;
		DSPU32 u32Result, u32Flag, u32GenResultIdx, u32Status, u32ALUIdx;
		DSPU32 u32ALUNum;

		u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32ALUNum =  (1 << m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5]);
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int j = 0; j < u32ALUNum; j++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], j+1);				
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][j];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][j];
					u32Status = 0; 
					u32ALUCR = GSetBit(u32ALUCR, 0);
					u32Result = AddF32(u32SrcA, u32Const, &u32Status, u32ALUCR);
					u32Flag = SetSHFFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
					WriteGPR_Page(i, u32DestIdx+j, u32Result, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
				}
				
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}
 //-----------------------------------------------------------------------------------
// sync done
bool sc_iss::ext_set_spec_reg_imm_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_set_spec_reg_imm_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_set_spec_reg_imm_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
		DSPU32 u32RegIdxLow, u32RegIdxHigh;

        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
                DSPU32      u24ImmL: 24;
                DSPU32      u1Rev0: 1;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
				DSPU32      u2SpecRegIdxHigh: 2;
                DSPU32      u2Rev1: 2;
                DSPU32      u1LineL: 1;

                DSPU32      u8ImmH: 8;
                DSPU32      u10SpecRegIdxLow: 10;
				DSPU32      u3Mode0: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = ((p_u32IWordLow & 0xFFFFFF) | (p_u32IWordHigh << 24));
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode0;
			u32RegIdxLow = instr_word.details.u10SpecRegIdxLow;
			u32RegIdxHigh = instr_word.details.u2SpecRegIdxHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = (u32RegIdxHigh << 10) | u32RegIdxLow;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4UnitsH;

        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 4; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }      

		// ---------------------------------------------------
		// for cpred hazard detection (liuyu)
		DSPU32 u32SpecRegIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		if(u32SpecRegIdx == 0x130)
		{
			for(int i = 0; i < NUM_OF_UNITS; i++)
			{
				if(GIsBitSet(u32Units, i))
				{
					m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestCPred |= (0xffU << (i*8));
				}
			}
		}


		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;
    
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Imm, u32SpecRegIdx, u32Units;
    
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SpecRegIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		
		if(u32Units!=0)
		{
			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				if ( GIsBitSet(u32Units, i) )
				{
					WrSpecificReg(u32SpecRegIdx,i, u32Imm);
				}
			}
		}
		else
		{
			WrSpecificReg(u32SpecRegIdx,0, u32Imm);
		}		

        if ( (u32SpecRegIdx == 0x3cd) && GIsBitSet(u32Imm, 12) )
        {
            m_bolSetCGCRBit12 = true;
        }
    }

    return true;
}

bool sc_iss::rd_wrt_onestab_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("rd_wrt_onestab_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("rd_wrt_onestab_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcN, u32SrcM, u32Dest, u32SHFIdx, u32Units, d;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				//DSPU32      u2SHFIdx: 2;
				DSPU32		u2D: 2;
				DSPU32      u8Rev0: 8;
				DSPU32      u6Dest: 6;
				DSPU32      u9Rev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev2: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6SrcN: 6;
				DSPU32      u6SrcM: 6;
				//DSPU32      u6Dest: 6;
				DSPU32      u4Rev3: 4;
				DSPU32      u2SHFIdx: 2;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2SHFIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u2D;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SHFIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		d = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];        
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32SHFIdx, m_arrDCResNeeded[p_u32Slot].u8SHFs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);	
				SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);		
				SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);	

				
				//设置Tab表数据相关
				//设置Tab表读相关
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRdSTAB = true;
				m_arrResSLK[p_u32SLKIdx].slot_res_used.bolWrSTAB_AC = true;
				// 根据所访问的STAB中块的序号设置掩码
				m_arrResSLK[p_u32SLKIdx].slot_res_used.u32STABMask |= (1<<d);
			}

		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Result, u32SHFIdx, u32RdAddr, u32TabWrAddr, u32Rn, u32Rm;
		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		DSPU32 u32SrcN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 d = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		DSPU32 u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;        

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read SHFCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcM) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					u32Rm = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					u32Rm = rd_u32r_R_new(i, u32SrcM, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcN) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					u32Rn = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					u32Rn = rd_u32r_R_new(i, u32SrcN, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Rn;
			
				u32RdAddr = u32Rn & 0xffU;
				u32TabWrAddr = (u32Rn >> 8) & 0xFFU;

				if (u32RdAddr == u32TabWrAddr)  //读写地址一致产生异常
				{
					//PIPE_EX.AC_EX.m_left.u32_ExcpMask |= 4;
					//用高16位表示，19~16表示x宏的3~0号移位器异常码
					//23~20表示y宏的3~0号移位器异常码
					//27~24表示z宏的3~0号移位器异常码
					//31~28表示t宏的3~0号移位器异常码
					PIPE_EX.AC_EX.m_left.u32_ExcpMask = GSetBit(PIPE_EX.AC_EX.m_left.u32_ExcpMask, (i*4+u32SHFIdx+16));  
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][2] = rd_SHF_Tab(i, u32SHFIdx, d, u32RdAddr);				
					wr_SHF_Tab(i, u32SHFIdx, d, u32TabWrAddr, 0xf, u32Rm);	
				}		
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32SHFIdx,u32Status,u32SHFCR,u32Rn, u32Result;
		DSPU32 u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				// whether current macro(unit) is used.
				if ( GIsBitSet(u32Units, i) )
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					if(!GIsBitSet(PIPE_EX.AC_EX.m_right.u32_ExcpMask, (i*4+u32SHFIdx+16)))   //检测是否发生读写地址异常
					{					
						u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
						u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
						u32Status = 0;

						u32SHFCR = GSetBit(u32SHFCR, 0);

						u32Result = STabRdWtAddrSet(u32Rn, &u32Status, u32SHFCR);

						m_arrResSLK[p_u32SLKIdx].arrDestL[i][0] = u32Result;
						m_arrResSLK[p_u32SLKIdx].arrDestL[i][1] = u32Status;
					}
				}
			}
		

	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32SHFIdx, u32Status, u32Flag, u32TabRDValue, u32TabWrAddr,u32Rn,u32RnIdx;

		DSPU32 u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 d = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.  
		DSPU32 u32Units;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32RnIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		

			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				// whether current macro(unit) is used.
				if ( GIsBitSet(u32Units, i) )
				{
					// get the index of the first SHF allocated for this instruction in current macro
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
					if(!GIsBitSet(PIPE_EX.EX_WB.m_right.u32_ExcpMask, (i*4+u32SHFIdx+16)))  //检测是否发生读写地址异常
					{										
						//将读表的结果写入通用寄存器
						u32TabRDValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][2];
						wr_u32r_R_new(i, u32DestIdx, u32TabRDValue, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

						u32Rn = m_arrResSLK[p_u32SLKIdx].arrDestL[i][0];
						wr_u32r_R_new(i, u32RnIdx, u32Rn, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

						u32Status = m_arrResSLK[p_u32SLKIdx].arrDestL[i][1];
						u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
						u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
					}
					else
					{
						//将读表的结果写入通用寄存器
						u32TabRDValue = 0;
						wr_u32r_R_new(i, u32DestIdx, u32TabRDValue, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

						u32Rn = 0;
						wr_u32r_R_new(i, u32RnIdx, u32Rn, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

						u32Status = 0;
						u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
						u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

					}

				}
			}
		
	}

	return true;
}

 #if 0
 //-----------------------------------------------------------------------------------
bool sc_iss::ext_atom_rd_sw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_atom_rd_sw_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_atom_rd_sw_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32K, u32M, u32N, u32DestIdx, u32Units, u32UVWIdx;
    
        union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
				DSPU32      u25Rev0: 25;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u1Rev1: 2;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Dest: 6;
                DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
			            
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
		u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];        
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];          

		// 资源使用: 一条内部数据读总线
		m_arrDCResNeeded[p_u32Slot].bolInnerRdBus = true;
		
        
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = true;

	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = true;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = true;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = u32DestIdx;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = 0;
	    }

		// 为通用寄存器的相关性检测提供信息
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

		// 为地址寄存器的相关性检测提供信息
        switch (u32UVWIdx)
        {
            case 0:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );
                break;
            case 1:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );            
                break;
            case 2:
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                break;                
        }        

        // 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

    }
    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32K, u32M, u32N, u32Units, u32Addr;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrRegK, u32UVWIdx;
    
        // use decode info carried accross pipeline
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];        
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];     
    
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access
        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
            	// 计算访存地址
                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32AddrRegN + u32AddrRegM + j * u32AddrRegK;
                // 设置访存地址序号掩码
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);       
                
                j++;
            }

        } // for (i = 0, j = 0; i < NUM_OF_UNITS; i++)		

    } // else if (p_u32Phase == PHASE_DC2_POST)
       
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32N, u32Units, u32Result;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrResult, u32UVWIdx;
    
        // use decode info carried accross pipeline
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32DestIdx, u32Units, u32Result, u32GenResultIdx;
    
        // use decode info carried accross pipeline
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
    
        u32GenResultIdx = 0;
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                u32Result = m_arrResSLK[p_u32SLKIdx].slot_res_used.arrValues[i][0];
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
                u32GenResultIdx++;

            }
        } // for (i = 0; i < 4; i++)

    } // else if (p_u32Phase == PHASE_WB)

    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_atom_wr_sw_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("ext_atom_wr_sw_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("ext_atom_wr_sw_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32K, u32M, u32N, u32SrcIdx, u32Units, u32UVWIdx, u32IsBaseOff;
    
		union INSTR_WORD
        {
            struct  INST_WORD
            {
                DSPU32 u32Low;
                DSPU32 u32High;
            } ext_words;

            struct  SPLIT_VALUE
            {
				DSPU32      u25Rev0: 25;
                DSPU32      u1MWSL: 1;
                DSPU32      u1MWL: 1;
                DSPU32      u2UVW: 2;
                DSPU32      u1Rev1: 2;
                DSPU32      u1LineL: 1;

                DSPU32      u4K: 4;
                DSPU32      u4M: 4;
                DSPU32      u4N: 4;
                DSPU32      u6Src: 6;
                DSPU32      u3Mode: 3;
                DSPU32      u4Opcode: 4;
                DSPU32      u1MWSH: 1;
                DSPU32      u1MWH: 1;
                DSPU32      u4UnitsH: 4;
                DSPU32      u1LineH: 1;
			            
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.ext_words.u32Low = p_u32IWordLow;
            instr_word.ext_words.u32High = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
            g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u2UVW;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4K;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4M;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4N;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Src;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32SrcIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		// 资源使用: 一条内部数据写总线
		m_arrDCResNeeded[p_u32Slot].bolInnerWrBus = true;

        
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolMemAcs = true;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.bolRead = false;

	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolAtom = true;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolSingleWord = true;
	    m_arrResSLK[p_u32SLKIdx].slot_res_used.bolIsDM8 = false;
	    for (int i = 0; i < NUM_OF_UNITS; i++)
	    {
			m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemDestReg[i] = 0;
		    m_arrResSLK[p_u32SLKIdx].slot_res_used.arrMemSrcReg[i] = u32SrcIdx;
	    }

		// 为通用寄存器相关性检测提供信息
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
				// log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
            }
        }

		// 为地址寄存器相关性检测提供信息
		// UVW regs are read in DC2 and written in AC
        switch (u32UVWIdx)
        {
            case 0: // U
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcU, u32K );           
                break;
            case 1: // V
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcV, u32K );
                break;
            case 2: // W
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32N );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32M );
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW = GSetBit( m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcW, u32K );
                break;         
       
        } // switch (u32UVWIdx)

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = false;

    } // if (p_u32Phase == PHASE_DC2)

    else if (p_u32Phase == PHASE_DC2_POST)
    {
        DSPU32 u32K, u32M, u32N, u32Units, u32Addr;
        DSPU32 u32AddrRegN, u32AddrRegM, u32AddrRegK, u32UVWIdx;        
    
        // use decode info carried accross pipeline
        u32UVWIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32K = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32M = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32N = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
    
		// read UVW regs
        u32AddrRegN = rd_u32r_UVW(u32UVWIdx, u32N);
        u32AddrRegM =  rd_u32r_UVW(u32UVWIdx, u32M);
        u32AddrRegK =  rd_u32r_UVW(u32UVWIdx, u32K);

		// these value will be used in AC
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegN =  u32AddrRegN;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegM =  u32AddrRegM;
        m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrRegK =  u32AddrRegK;

        // generate address for memory access
        for (int i = 0, j = 0; i < NUM_OF_UNITS; i++)
        {
			// whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
            	// 计算访存地址
                m_arrResSLK[p_u32SLKIdx].slot_res_used.arrAddrs[i][0] = u32AddrRegN + u32AddrRegM + j * u32AddrRegK;
                 
				// 设置访存地址序号掩码
                m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask = SetAddrMaskBit(m_arrResSLK[p_u32SLKIdx].slot_res_used.u32AddrMask, i, 0);
                
                j++;
            }

        } // for (i = 0, j = 0; i < NUM_OF_UNITS; i++)	

    } // else if (p_u32Phase == PHASE_DC2_POST)
       

    return true;
}

 #endif


bool sc_iss::ext_cmp_acf_reg_cores(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_cmp_acf_reg_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_cmp_acf_reg_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32ALUIdx, u32Units, u32Dest,u32SrcNIdx,u32SrcMIdx;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32    u10Rev0: 10;
				DSPU32    u6Dest: 6;
				DSPU32    u9Rev1: 9;
				DSPU32    u1MWSL: 1;
				DSPU32    u1MWL: 1;
				DSPU32    u4UnitsL: 4;
				DSPU32    u1LineL: 1;

				DSPU32	  u6SrcN: 6;
				DSPU32    u6SrcM: 6;
				DSPU32    u1Rev2: 1;
				DSPU32    u2Mode: 2;
				DSPU32    u3K: 3;
				DSPU32    u3Flag: 3;
				DSPU32    u4Opcode: 4;
				DSPU32    u1MWSH: 1;
				DSPU32    u1MWH: 1;
				DSPU32    u4UnitsH: 4;
				DSPU32    u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3K;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 7; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];		
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units,u32Result,u32SrcMIdx,u32SrcNIdx;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			}
		}
	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units,u32ACF,u32Rm,u32Rn;
		DSPU32 u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32ALUIdx, u32Flag, u32Result,u32Status;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32ACF = u32r_ALU_ACF[i][u32ALUIdx];
				u32Status = 0;
				u32Result = 0;

				if (u32Mode==0) //Rs =ACFk?Rm:Rn
				{
					u32Result = (u32ACF>>31)?u32Rm:u32Rn;
				} 
				else if(u32Mode==1) //HRs=HACFk?HRm:HRn
				{
					if(u32ACF & 0x8000)
					{	u32Result = u32Rm & 0xFFFF;}
					else
					{	u32Result = u32Rn & 0xFFFF;}
					if(u32ACF>>31)
					{	u32Result |= u32Rm & 0xFFFF0000;}
					else
					{	u32Result |= u32Rn & 0xFFFF0000;}
				}
				else  //ORs=OACFk?ORm:ORn
				{
					if(u32ACF & 0x80)
					{	u32Result = u32Rm & 0xFF;}
					else
					{	u32Result = u32Rn & 0xFF;}
					if(u32ACF & 0x8000)
					{	u32Result |= u32Rm & 0xFF00;}
					else
					{	u32Result |= u32Rn & 0xFF00;}
					if(u32ACF & 0x800000)
					{	u32Result |= u32Rm & 0xFF0000;}
					else
					{	u32Result |= u32Rn & 0xFF0000;}
					if(u32ACF>>31)
					{	u32Result |= u32Rm & 0xFF000000;}
					else
					{	u32Result |= u32Rn & 0xFF000000;}
				}

				//write ALUFR
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], 0);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

				//write Rs
				wr_u32r_R_new(i, u32Dest, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
			}
		}
	}

	return true;
}
bool sc_iss::ext_exchange_cores_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_exchange_cores_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_exchange_cores_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx1, u32DestIdx2,  u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u5La: 5;
				DSPU32      u5LRev0: 5;
				DSPU32      u6LDestIdx2: 6;
				DSPU32      u9LRev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32		u6HSrcN: 6;
				DSPU32		u6HSrcM: 6;
				DSPU32		u6HDestIdx1: 6;
				DSPU32		u1HRev0: 1;
				DSPU32		u2HMode: 2;
				DSPU32		u4HOpcode: 4; 
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5La;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6LDestIdx2;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6HSrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6HSrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6HDestIdx1;            
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2HMode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4HOpcode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 8; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[7];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx1+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units;
		DSPU32 u32SrcNIdxSel, u32SrcMIdxSel;
		DSPU32 u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		DSPU32 u32Result;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);

					u32SrcMIdxSel = u32SrcMIdx + k;
					u32SrcNIdxSel = u32SrcNIdx + k;

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (k = 0; k < 2; k++)
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units;
		DSPU32 u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		DSPU32 u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		DSPU32 u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		DSPU32 u32SHFIdx, u32SHFCR, u32Flag, u32Status;
		DSPU32 u32Rm, u32Rn;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k + 1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];
					u32Status = 0;

					if(u32Mode == 0)
					{
						Exchang(u32Rm, u32Rn, u32Imm, u64Res, &u32Status, u32SHFCR);
					}
					else if(u32Mode == 1)
					{
						SExchang(u32Rm, u32Rn, u32Imm, u64Res, &u32Status, u32SHFCR);
					}

					wr_u32r_R_new(i, u32DestIdx2+k, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx1+k, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				}//end for		

			}//end if
		}//end for
	}//end if(WB)
	return true;
}
bool sc_iss::ext_insert_cores_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_insert_cores_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_insert_cores_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx1, u32DestIdx2,  u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u4Lg: 4;
				DSPU32      u4Lf: 4;
				DSPU32      u2LRev0: 2;
				DSPU32      u6LDestIdx2: 6;
				DSPU32      u4Lq: 4;
				DSPU32      u4Lp: 4;
				DSPU32      u1LRev1: 1;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32		u6HSrcN: 6;
				DSPU32		u6HSrcM: 6;
				DSPU32		u6HDestIdx1: 6;
				DSPU32		u1HRev0: 1;
				DSPU32		u2HMode: 2;
				DSPU32		u4HOpcode: 4; 
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Lg;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Lf;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6LDestIdx2;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6HSrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6HSrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6HDestIdx1;            
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u2HMode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4HOpcode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 9; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx1+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units,u32SrcMIdxSel,u32SrcNIdxSel;
		DSPU32 u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		DSPU32 u32Result;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);

					u32SrcMIdxSel = u32SrcMIdx + k;
					u32SrcNIdxSel = u32SrcNIdx + k;

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (k = 0; k < 2; k++)
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units;
		DSPU32 u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		DSPU32 u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32F = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32G = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		DSPU32 u32SHFIdx, u32SHFCR, u32Flag, u32Status;
		DSPU32 u32Rm, u32Rn;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;

					InsertReg(u32Rm, u32Rn, u32F, u32G, u64Res, &u32Status, u32SHFCR);

					wr_u32r_R_new(i, u32DestIdx2+k, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx1+k, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				}//end for

			}
		}
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_ext_cores_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_ext_cores_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_ext_cores_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx1, u32DestIdx2,  u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u4Lg: 4;
				DSPU32      u5Lf: 5;
				DSPU32      u1LRev0: 1;
				DSPU32      u6LDestIdx2: 6;
				DSPU32      u9LRev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32		u6HSrcN: 6;
				DSPU32		u6HSrcM: 6;
				DSPU32		u6HDestIdx1: 6;
				DSPU32		u1HRev0: 1;
				DSPU32		u2HMode: 2;
				DSPU32		u4HOpcode: 4; 
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Lg;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u5Lf;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6LDestIdx2;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6HSrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6HSrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6HDestIdx1;            
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u2HMode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4HOpcode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[8] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 9; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[8];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx1+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx2+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units,u32SrcMIdxSel,u32SrcNIdxSel;
		DSPU32 u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		DSPU32 u32Result;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);

					u32SrcMIdxSel = u32SrcMIdx + k;
					u32SrcNIdxSel = u32SrcNIdx + k;

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (k = 0; k < 2; k++)
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units;
		DSPU32 u32DestIdx1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		DSPU32 u32DestIdx2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32F = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32G = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		DSPU32 u32SHFIdx, u32SHFCR, u32Flag, u32Status;
		DSPU32 u32Rm, u32Rn;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;

					ExtReg(u32Rm, u32Rn, u32F, u32G, u64Res, &u32Status, u32SHFCR);

					wr_u32r_R_new(i, u32DestIdx2+k, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx1+k, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				}//end for

			}//end if
		}//end for
	}
	return true;
}
bool sc_iss::ext_fext_cores_new(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_fext_cores_new: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_fext_cores_new: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Mode, u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u15ImmPQF: 15;	
				DSPU32      u6Dest: 6;
				DSPU32      u4Rev0: 4;				
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6Rev1: 6;				
				DSPU32      u6RegM: 6;
				DSPU32      u3Rev2: 3;				
				DSPU32      u3Mode: 3;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u15ImmPQF;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);              
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if ( u32Mode == 1 )
				{
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Mode, u32Units, u32Result, u32SHFIdx;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( u32Mode == 1 )
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}               

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Mode, u32Units, u32SHFIdx;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32ImmPQF;
		DSPU32 u32Result;

		u32ImmPQF = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				switch (u32Mode)
				{
				case 0:
					u32Result = Fextz(u32SrcA, u32ImmPQF, &u32Status, u32SHFCR);
					break;
				case 1:
					u32Result = Fext(u32SrcA, u32SrcB, u32ImmPQF, &u32Status, u32SHFCR);
					break;
				case 2:
					u32Result = Fexts(u32SrcA, u32ImmPQF, &u32Status, u32SHFCR);
					break;
				default:
					PrintToCerr("ext_fext_cores_new: Invalid work mode\n");
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_append_cores_new(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_like_append_cores_new: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_like_append_cores_new: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u10Rev0: 10;
				DSPU32      u6Dest: 6;				
				DSPU32      u9Rev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6RegN: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u3Rev2: 3;
				DSPU32      u3Mode: 3;				
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units, u32Result, u32SHFIdx;

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Mode, u32Units, u32GenResultIdx, u32SHFIdx;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag;
		DSPU32 u32Result;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				u32Result = Append(u32SrcA, u32SrcB, &u32Status, u32SHFCR, u32Mode);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
				u32GenResultIdx++;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_compact_cores_new(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_compact_cores_new: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_compact_cores_new: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u5Imm: 5;
				DSPU32      u5Rev0: 5;
				DSPU32      u6Dest: 6;
				DSPU32      u9Rev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6RegN: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u5Rev2: 5;
				DSPU32      u1Mode: 1;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5Imm;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 7; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result;

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Units, u32SHFIdx;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32Imm;
		DSPU32 u32Result;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				u32Result = CompactMN(u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::ext_fix_reg_cores_new(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_fix_reg_cores_new: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_fix_reg_cores_new: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Sel32or64, u32DestIdx2;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u11ImmC: 11;
				DSPU32      u6Dest: 6;
				DSPU32      u8Rev0: 8;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6HRev0: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u3HRev1: 3;
				DSPU32      u3Mode: 3;				
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u11ImmC;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		//u3Mode的第0位用于决定是64位/32位
		//u3Mode的第1位用于决定是用立即数还是cut
		//u3Mode的第2位用于决定是用1个shf/2个shf
		u32Sel32or64 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] & 0x1;
		u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				if(u32Sel32or64==1)
				{
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32Units, u32Result;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1] = u32r_SHFCUTR[i] & 0x7FF;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Units, u32SHFIdx, u32IsImm;;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32Imm, u32Sel32or64;
		DSPU32 u32Result;
		DSP_BIT64 u64Res;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sel32or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] & 0x1;
		u32IsImm = (m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] & 0x2)>>1;

		u32Result = 0;
		u64Res.u32High = 0;  //对应Rs2
		u64Res.u32Low = 0;  //对应Rs1

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SHFCR = GSetBit(u32SHFCR, 0);
				//Rm
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				//Rm+1
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;

				if(u32IsImm==1)
				{
					u32Imm = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1];
				}

				if(u32Sel32or64==0)
				{
					//Rs=FIX DFRm+1:m, Rs=FIX(DFRm+1:m,C)
					u32Result = Flo64ToFix32(u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
				else
				{
					//Rs+1:s=FIX DFRm+1:m, Rs+1:s=FIX(DFRm+1:m,C)
					Flo64ToFix64(u32SrcA, u32SrcB, u32Imm, u64Res, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestIdx, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestIdx+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;


			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}

bool sc_iss::ext_double_reg_cores_new(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_double_reg_cores_new: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_double_reg_cores_new: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcM, u32Dest, u32Units, u32Sel32Or64;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u11ImmC: 11;
				DSPU32      u6Dest: 6;		
				DSPU32      u8Rev0: 8;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6Rev1: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u3Rev2: 3;
				DSPU32      u3Mode: 3;				
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u11ImmC;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcM = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
		u32Dest = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Sel32Or64 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] & 0x1;

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				if(u32Sel32Or64 == 1)
				{
					SetGenRegIdx(u32SrcM+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32Dest+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32Sel32Or64, u32Units, u32Result;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Sel32Or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4] & 0x1;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if(u32Sel32Or64 == 1)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx+1) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1] = u32r_SHFCUTR[i] & 0x7FF;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Dest, u32Units, u32SHFIdx, u32Sel32Or64, u32IsImm;
		DSPU32 u32SHFCR, u32Status, u32Flag, u32Imm, u32SrcA, u32SrcB;
		DSPU32 u32Rs1 = 0, u32Rs2 = 0;

		u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sel32Or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4] & 0x1;
		u32IsImm = ((m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4] & 0x2) >> 1);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SHFCR = GSetBit(u32SHFCR, 0);
				//Rm
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				u32Status = 0;

				if(u32IsImm==1)
				{
					u32Imm = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][1];
				}

				if(u32Sel32Or64 == 0)
				{
					//DFRs+1:s=Double Rm, DFRs+1:s=Double(Rm,C)
					Fix32ToFlo64(u32SrcA, u32Rs1, u32Rs2, u32Imm, &u32Status, u32SHFCR);
				}
				else
				{
					//Rm+1
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
					//DFRs+1:s=Double Rm+1:m, DFRs+1:s=Double(Rm+1:m,C)
					Fix64ToFlo64(u32SrcA, u32SrcB, u32Rs1, u32Rs2, u32Imm, &u32Status, u32SHFCR);
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				wr_u32r_R_new(i, u32Dest+1, u32Rs1, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				wr_u32r_R_new(i, u32Dest, u32Rs2, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::ext_compact_expand_cors_new(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_compact_expand_cors_new: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_compact_expand_cors_new: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcN, u32SrcM, u32DestS1, u32DestS2, u32Units,u32Mode;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u4ImmA: 4;
				DSPU32      u6Rev0: 6;
				DSPU32		u6DestS2: 6;
				DSPU32      u6DestS1: 6;
				DSPU32		u3Rev1: 3;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6RegN: 6;
				DSPU32      u6RegM: 6;
				DSPU32		u2Rev3: 2;
				DSPU32      u2Mode: 2;
				DSPU32		u1Sign: 1;
				DSPU32      u1SHFNum: 1;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4ImmA;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Sign;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6DestS2;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6DestS1;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 8; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcN = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32SrcM = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
		u32DestS2 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5];
		u32DestS1 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7];
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);

				if(u32Mode==0)
				{
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
				if(u32Mode==1)
				{
					SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
				if(u32Mode==2)
				{
					SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result, u32Mode;

		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);

				if(u32Mode == 1 || u32Mode ==2)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestS1,u32DestS2, u32Mode, u32Units, u32SHFIdx, u32Sign;
		DSPU32 u32SHFCR, u32Status, u32Flag, u32Imm, u32Rn, u32Rm;
		DSPU32 u32Result = 0;
		DSP_BIT64 u64res;

		u32DestS2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32DestS1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];                

				u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
				u32Status = 0;
				u64res.u32Low = 0; //对应Rs1
				u64res.u32High = 0;//对应Rs2
				if(u32Sign==1)
				{
					u32SHFCR = GSetBit(u32SHFCR, 0);
				}

				switch (u32Mode)
				{
				case 0:
					//HRs1HRs2=EXPAND(ORm,a)(U)，HRs1HRs2=EXPAND(ORm,a)
					ExpandDW8To16(u64res, u32Rm, u32Imm, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 1:
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					//HRs1HRs2=EXPAND(ORm,Rn)(U)，HRs1HRs2=EXPAND(ORm,Rn)
					ExpandDW8To16(u64res, u32Rm, u32Rn, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32DestS2, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				case 2:
					u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
					//ORs=COMPACT(HRmHRn,a)(U)，ORs=COMPACT(HRmHRn,a)
					u32Result = CompactDW16to8(u32Rm, u32Rn, u32Imm, &u32Status, u32SHFCR);
					wr_u32r_R_new(i, u32DestS1, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					break;
				default:
					PrintToCerr("ext_compact_expand_cors: opcode not found\n");
				}

				u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
				u32ri_SHFFR[i][u32SHFIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}


bool sc_iss::ext_fext_cores_new_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_fext_cores_new_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_fext_cores_new_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Mode, u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u15ImmPQF: 15;	
				DSPU32      u6Dest: 6;
				DSPU32      u4Rev0: 4;				
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6Rev1: 6;				
				DSPU32      u6RegM: 6;
				DSPU32      u3Rev2: 3;				
				DSPU32      u3Mode: 3;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u15ImmPQF;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);              
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);              
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				if ( u32Mode == 5 )
				{
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Mode, u32Units, u32Result,u32SrcMIdxSel,u32DestIdxSel;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )         
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
					u32SrcMIdxSel = u32SrcMIdx + k;
					u32DestIdxSel = u32DestIdx + k;
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( u32Mode == 5 )
					{
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdxSel) )
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
						}
						else
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32DestIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
						}
					}      
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Mode, u32Units, u32SHFIdx;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32ImmPQF;
		DSPU32 u32Result;

		u32ImmPQF = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					switch (u32Mode)
					{
					case 4:
						u32Result = Fextz(u32SrcA, u32ImmPQF, &u32Status, u32SHFCR);
						break;
					case 5:
						u32Result = Fext(u32SrcA, u32SrcB, u32ImmPQF, &u32Status, u32SHFCR);
						break;
					case 6:
						u32Result = Fexts(u32SrcA, u32ImmPQF, &u32Status, u32SHFCR);
						break;
					default:
						PrintToCerr("ext_fext_cores_new_2: Invalid work mode\n");
					}

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_like_append_cores_new_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_like_append_cores_new_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_like_append_cores_new_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u10Rev0: 10;
				DSPU32      u6Dest: 6;				
				DSPU32      u9Rev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6RegN: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u3Rev2: 3;
				DSPU32      u3Mode: 3;				
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units, u32Result,u32SrcMIdxSel,u32SrcNIdxSel;

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
					u32SrcMIdxSel = u32SrcMIdx + k;
					u32SrcNIdxSel = u32SrcNIdx + k;
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Mode, u32Units, u32GenResultIdx, u32SHFIdx;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag;
		DSPU32 u32Result;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					u32Result = Append(u32SrcA, u32SrcB, &u32Status, u32SHFCR, u32Mode&0x3);
					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
					u32GenResultIdx++;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}


//-----------------------------------------------------------------------------------
bool sc_iss::ext_compact_cores_new_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_compact_cores_new_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_compact_cores_new_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32DestIdx, u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u5Imm: 5;
				DSPU32      u5Rev0: 5;
				DSPU32      u6Dest: 6;
				DSPU32      u9Rev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4UnitsL: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6RegN: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u5Rev2: 5;
				DSPU32      u1Mode: 1;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u5Imm;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 7; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result,u32SrcMIdxSel,u32SrcNIdxSel;

		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
					u32SrcMIdxSel = u32SrcMIdx + k;
					u32SrcNIdxSel = u32SrcNIdx + k;
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Units, u32SHFIdx;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32Imm;
		DSPU32 u32Result;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					u32Result = CompactMN(u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::ext_compact_expand_cors_new_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_compact_expand_cors_new_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_compact_expand_cors_new_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcN, u32SrcM, u32DestS1, u32DestS2, u32Units,u32Mode;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u4ImmA: 4;
				DSPU32      u6Rev0: 6;
				DSPU32		u6DestS2: 6;
				DSPU32      u6DestS1: 6;
				DSPU32		u3Rev1: 3;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6RegN: 6;
				DSPU32      u6RegM: 6;
				DSPU32		u2Rev3: 2;
				DSPU32      u2Mode: 2;
				DSPU32		u1Sign: 1;
				DSPU32      u1SHFNum: 1;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4ImmA;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Sign;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6RegN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u6DestS2;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u6DestS1;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 8; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcN = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32SrcM = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
		u32DestS2 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5];
		u32DestS1 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[7];
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcM+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);

				if(u32Mode==0)
				{
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS1+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
				if(u32Mode==1)
				{
					SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

					SetGenRegIdx(u32SrcN+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestS2+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				}
				if(u32Mode==2)
				{
					SetGenRegIdx(u32SrcN, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

					SetGenRegIdx(u32SrcN+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestS1+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units, u32Result, u32Mode,u32SrcNIdxSel,u32SrcMIdxSel;

		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int k=0;k<2;k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);

					u32SrcNIdxSel = u32SrcNIdx+k;
					u32SrcMIdxSel = u32SrcMIdx+k;
					if(u32Mode == 1 || u32Mode ==2)
					{
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
						}
						else
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
						}
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}


			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestS1,u32DestS2, u32Mode, u32Units, u32SHFIdx, u32Sign;
		DSPU32 u32SHFCR, u32Status, u32Flag, u32Imm, u32Rn, u32Rm;
		DSPU32 u32Result = 0;
		DSP_BIT64 u64res;

		u32DestS2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32DestS1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int k=0;k<2;k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];                

					u32Rm = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];
					u32Status = 0;
					u64res.u32Low = 0; //对应Rs1
					u64res.u32High = 0;//对应Rs2
					if(u32Sign==1)
					{
						u32SHFCR = GSetBit(u32SHFCR, 0);
					}

					switch (u32Mode)
					{
					case 0:
						//HRs1HRs2=EXPAND(ORm,a)(U)，HRs1HRs2=EXPAND(ORm,a)
						ExpandDW8To16(u64res, u32Rm, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestS1+k, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						wr_u32r_R_new(i, u32DestS2+k, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					case 1:
						u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
						//HRs1HRs2=EXPAND(ORm,Rn)(U)，HRs1HRs2=EXPAND(ORm,Rn)
						ExpandDW8To16(u64res, u32Rm, u32Rn, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestS1+k, u64res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						wr_u32r_R_new(i, u32DestS2+k, u64res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					case 2:
						u32Rn = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
						//ORs=COMPACT(HRmHRn,a)(U)，ORs=COMPACT(HRmHRn,a)
						u32Result = CompactDW16to8(u32Rm, u32Rn, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestS1+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					default:
						PrintToCerr("ext_compact_expand_cors_new_2: opcode not found\n");
					}

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				}			

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}

bool sc_iss::ext_reg_mask_cores_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_reg_mask_cores_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_reg_mask_cores_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units;
		DSPU32 u32ImmLow, u32ImmMid, u32ImmHigh, u32Mode;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u25CLow: 25;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4CMid: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u3CHigh: 3;
				DSPU32      u3Mode: 3;
				DSPU32      u6RegM: 6;
				DSPU32      u6Dest: 6;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			u32ImmLow = instr_word.details.u25CLow;
			u32ImmMid = instr_word.details.u4CMid;
			u32ImmHigh = instr_word.details.u3CHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = u32ImmLow | (u32ImmMid << 25) | (u32ImmHigh << 29);
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u3Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];
		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				if(u32Mode==4)
				{
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Result,u32SrcMIdxSel,u32DestIdxSel;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
					u32SrcMIdxSel = u32SrcMIdx + k;
					u32DestIdxSel = u32DestIdx + k;
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32DestIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}   
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Const, u32DestIdx, u32Units, u32SHFCR, u32Mode, u32SrcA, u32SrcB;
		DSPU32 u32Result, u32Flag, u32GenResultIdx, u32Status, u32SHFIdx;

		u32Const = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);

					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0; 
					if(u32Mode==4)
					{
						//Rs=Rm mask C
						u32Result = Mask(u32SrcA, u32SrcB, u32Const, &u32Status, u32SHFCR);
					}
					else if(u32Mode==5)
					{
						//Rs=Rm & C
						u32Result = And32(u32SrcA, u32Const, &u32Status, u32SHFCR);
					}
					else if(u32Mode==6)
					{
						//Rs=Rm | C
						u32Result = Or32(u32SrcA, u32Const, &u32Status, u32SHFCR);
					}
					else if(u32Mode==7)
					{
						//Rs=Rm ^ C
						u32Result = Xor32(u32SrcA, u32Const, &u32Status, u32SHFCR);
					}

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx+k, u32Result);
					u32GenResultIdx++;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}

#if 0

//-----------------------------------------------------------------------------------
bool sc_iss::ext_fix_reg_cores_new_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_fix_reg_cores_new_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_fix_reg_cores_new_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Sel32or64, u32DestIdx2;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u11ImmC: 11;
				DSPU32      u6Dest: 6;
				DSPU32      u8Rev0: 8;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6HRev0: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u3HRev1: 3;
				DSPU32      u3Mode: 3;				
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u11ImmC;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		//u3Mode的第0位用于决定是64位/32位
		//u3Mode的第1位用于决定是用立即数还是cut
		//u3Mode的第2位用于决定是用1个shf/2个shf
		u32Sel32or64 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] & 0x1;
		u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				SetGenRegIdx(u32SrcMIdx+2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+3, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				if(u32Sel32or64==1)
				{
					SetGenRegIdx(u32DestIdx+2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32DestIdx+3, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				}
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32Units, u32Result,u32SrcMIdxSel;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int k=0;k<2;k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
					u32SrcMIdxSel = u32SrcMIdx + k*2;
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel+1) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					m_arrResSLK[p_u32SLKIdx].arrDestL[i][k] = u32r_SHFCUTR[i] & 0x7FF;
				}				

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx, u32Units, u32SHFIdx, u32IsImm;;
		DSPU32 u32SHFCR, u32SrcA, u32SrcB, u32Status, u32Flag, u32Imm, u32Sel32or64;
		DSPU32 u32Result;
		DSP_BIT64 u64Res;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sel32or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] & 0x1;
		u32IsImm = (m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] & 0x2)>>1;

		u32Result = 0;
		u64Res.u32High = 0;  //对应Rs2
		u64Res.u32Low = 0;  //对应Rs1

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int k=0;k<2;k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SHFCR = GSetBit(u32SHFCR, 0);
					//Rm
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					//Rm+1
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;

					if(u32IsImm==1)
					{
						u32Imm = m_arrResSLK[p_u32SLKIdx].arrDestL[i][k];
					}

					if(u32Sel32or64==0)
					{
						//Rs=FIX DFRm+1:m, Rs=FIX(DFRm+1:m,C)
						u32Result = Flo64ToFix32(u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					}
					else
					{
						//Rs+1:s=FIX DFRm+1:m, Rs+1:s=FIX(DFRm+1:m,C)
						Flo64ToFix64(u32SrcA, u32SrcB, u32Imm, u64Res, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestIdx+k*2, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						wr_u32r_R_new(i, u32DestIdx+k*2+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					}

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				}		

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}
bool sc_iss::ext_double_reg_cores_new_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_double_reg_cores_new_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_double_reg_cores_new_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcM, u32Dest, u32Units, u32Sel32Or64;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u11ImmC: 11;
				DSPU32      u6Dest: 6;		
				DSPU32      u8Rev0: 8;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u6Rev1: 6;
				DSPU32      u6RegM: 6;
				DSPU32      u3Rev2: 3;
				DSPU32      u3Mode: 3;				
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u11ImmC;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6RegM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32SrcM = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
		u32Dest = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Sel32Or64 = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] & 0x1;

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				if(u32Sel32Or64 == 1)
				{
					SetGenRegIdx(u32SrcM+2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32SrcM+3, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32Dest, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32Dest+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcM+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32Dest+2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32Dest+3, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32Sel32Or64, u32Units, u32Result,u32SrcMIdxSel;

		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Sel32Or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4] & 0x1;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int k=0;k<2;k++)
				{
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);

					u32SrcMIdxSel = u32SrcMIdx + k*2;

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if(u32Sel32Or64 == 1)
					{
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel+1) )
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
						}
						else
						{
							m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
						}
					}

					m_arrResSLK[p_u32SLKIdx].arrDestL[i][k] = u32r_SHFCUTR[i] & 0x7FF;
				}


			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Dest, u32Units, u32SHFIdx, u32Sel32Or64, u32IsImm;
		DSPU32 u32SHFCR, u32Status, u32Flag, u32Imm, u32SrcA, u32SrcB;
		DSPU32 u32Rs1 = 0, u32Rs2 = 0;

		u32Dest = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sel32Or64 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4] & 0x1;
		u32IsImm = ((m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4] & 0x2) >> 1);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for(int k=0;k<2;k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SHFCR = GSetBit(u32SHFCR, 0);
					//Rm
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];

					u32Status = 0;

					if(u32IsImm==1)
					{
						u32Imm = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					}

					if(u32Sel32Or64 == 0)
					{
						//DFRs+1:s=Double Rm, DFRs+1:s=Double(Rm,C)
						Fix32ToFlo64(u32SrcA, u32Rs1, u32Rs2, u32Imm, &u32Status, u32SHFCR);
					}
					else
					{
						//Rm+1
						u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];
						//DFRs+1:s=Double Rm+1:m, DFRs+1:s=Double(Rm+1:m,C)
						Fix64ToFlo64(u32SrcA, u32SrcB, u32Rs1, u32Rs2, u32Imm, &u32Status, u32SHFCR);
					}

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
					wr_u32r_R_new(i, u32Dest+k*2+1, u32Rs1, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					wr_u32r_R_new(i, u32Dest+k*2, u32Rs2, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::ext_fix_float_reg_cores_2(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("ext_fix_float_reg_cores_2: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("ext_fix_float_reg_cores_2: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx,u32DestIdx,u32Mode,u32Units;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u8ImmC: 8;
				DSPU32      u2Rev0: 2;
				DSPU32      u6DestIdx: 6;
				DSPU32      u9Rev1: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev2: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u2Mode: 2;
				DSPU32		u3Rev3: 3;
				DSPU32      u1IsImm: 1;
				DSPU32      u6SrcMIdx: 6;
				DSPU32      u5Rev4: 5;
				DSPU32      u1SHFNum: 1;                
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u8ImmC;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcMIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6DestIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1IsImm;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32Mode = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1];
		u32SrcMIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2];
		u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32SHFNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				if(u32Mode == 2 || u32Mode == 3)
				{
					SetGenRegIdx(u32SrcMIdx+2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx+2, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
					SetGenRegIdx(u32SrcMIdx+3, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					SetGenRegIdx(u32DestIdx+3, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				}
				//
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if(p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		DSPU32 u32Units,u32SrcMIdxSel;
		DSPU32 u32Result;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for(int k=0;k<2;k++)
				{
					// read SHFCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadSHFCR(i);
					m_arrResSLK[p_u32SLKIdx].arrDestL[i][k] = u32r_SHFCUTR[i] & 0x7ff;

					u32SrcMIdxSel = u32SrcMIdx + k*2;
					//get Rm
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						// data forward to get the value of R[u32SrcMIdx] of current macro
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						// read the value of R[u32SrcMIdx] from register heap directly
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if(u32Mode == 2 || u32Mode == 3)
					{
						//get Rm+1
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel+1) )
						{
							// data forward to get the value of R[u32SrcMIdx] of current macro
							m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
						}
						else
						{
							// read the value of R[u32SrcMIdx] from register heap directly
							m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel+1, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
						}
					}
				}

			}
		}

	}
	else if(p_u32Phase == PHASE_WB)
	{
		DSPU32 u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		DSPU32 u32Units;
		DSPU32 u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		DSPU32 u32IsImm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		DSPU32 u32SHFIdx, u32SHFCR, u32SrcA, u32SrcB, u32Status,u32Result, u32Flag;
		DSP_BIT64 u64Res;
		u64Res.u32Low = 0;
		u64Res.u32High = 0;
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for(int i = 0; i<NUM_OF_UNITS; i++)
		{
			if( GIsBitSet(u32Units, i))
			{
				for(int k=0;k<2;k++)
				{
					u32SHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], k+1);
					u32SHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SHFCR = GSetBit(u32SHFCR, 0);
					//Rm
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];

					u32Status = 0;

					if(u32IsImm==1)
					{
						u32Imm = m_arrResSLK[p_u32SLKIdx].arrDestL[i][k];
					}

					switch (u32Mode)
					{
					case 0:
						//Rs=FIX(FRm,C)
						u32Result =  Fix32(u32SrcA, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					case 1:
						//FRs=Float(Rm,C)
						u32Result =  Float32(u32SrcA, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					case 2:
						//Rm+1
						u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

						//CRs+1:s=FIX(CFRm+1:m,C)
						FixC32(u64Res, u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestIdx+k*2, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						wr_u32r_R_new(i, u32DestIdx+k*2+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					case 3:
						//Rm+1
						u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

						//CFRs+1:s=Float(CRm+1:m，C)
						FloatC32(u64Res, u32SrcA, u32SrcB, u32Imm, &u32Status, u32SHFCR);
						wr_u32r_R_new(i, u32DestIdx+k*2, u64Res.u32Low, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						wr_u32r_R_new(i, u32DestIdx+k*2+1, u64Res.u32High, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						break;
					}

					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32SHFIdx], u32Status);
					u32ri_SHFFR[i][u32SHFIdx] = u32Flag;
				}


			}
		}
	}

	return true;
}

#endif
