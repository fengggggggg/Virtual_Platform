
#include "sc_iss.h"

//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::EMIT_ACTION()
{
#define isEmitBegPos(I) ((I) != 0U)
#define isEmitEndPos(I) ((I) & 0x80000000U)
	DSPU32 u32EndPos = 2*MAX_INUM_LINE;
	DSPU32 u32EmitPos = 2*MAX_INUM_LINE;
	DSPU32 arrIAB[2*MAX_INUM_LINE];
	DSPU32 u32IWords0, u32IWords1;
	
	m_bolEMITDone = true;
	if ( !m_bolStall_EMITDC1 )
	{
		for(int i = 0; i < MAX_INUM_LINE; i++)
		{
			arrIAB[i] = m_arrIABP0Out[i];
			arrIAB[i + MAX_INUM_LINE] = m_arrIABP1Out[i];
		}
		for(int i = 0; i < 2*MAX_INUM_LINE; i++)
		{
			if((i < u32EmitPos) && isEmitBegPos(arrIAB[i]) )
			{
				u32EmitPos = i;
			}
			if((i < u32EndPos) && isEmitEndPos(arrIAB[i]) )
			{
				u32EndPos = i;
				break;
			}
		}
		ISS_ASSERT(u32EmitPos <= u32EndPos);

		// CASE 1: 没有找到执行行结束标识
		if( u32EndPos == 2*MAX_INUM_LINE )
		{
			return;
		}
		// CASE 2: 执行行跨IAB0和IAB1，并且IAB0和IAB1不属于同一中断级别
		if( (u32EmitPos < MAX_INUM_LINE) && (u32EndPos >= MAX_INUM_LINE) \
			&& (m_arrIABP1Out[17] & 0xffU) != (m_arrIABP0Out[17] & 0xffU) )
		{
			printf("EMIT: IAB0 and IAB1 belong to different nest level\n");
			return;
		}
		// CASE 3: 找到有效执行行, 将有效执行行信息记录下来，准备发射
		for(int i = u32EmitPos, j = 0; i <= u32EndPos; i++, j++)
		{			
			m_u32slot_EMIT[j] = arrIAB[i];
			PIPE_EX.EMIT_DC1.m_left.uint32r_slot[j] = arrIAB[i];
			arrIAB[i] = 0U;
		}
		m_u32SlotNum_EMIT = u32EndPos - u32EmitPos + 1;
		PIPE_EX.EMIT_DC1.m_left.u32r_SlotNum = m_u32SlotNum_EMIT;

		// CASE 3.1: 如果行首标识在IAB0，那么程序流相关信息取自IAB0
		if(u32EmitPos < MAX_INUM_LINE)
		{
			PIPE_EX.EMIT_DC1.m_left.uint32r_pc = u32EmitPos + m_arrIABP0Out[16];
			PIPE_EX.EMIT_DC1.m_left.u32_NestLvl = m_arrIABP0Out[17] & 0xffU;

			if (GIsBitSet(m_arrIABP0Out[17], 8))
			{
				PIPE_EX.EMIT_DC1.m_left.bol_ISRFirstLn = true;
				m_arrIABP0Out[17] = GClrBit(m_arrIABP0Out[17], 8);
			}
			if (u32EmitPos % 4 == 0)
			{
				// 若执行行的起始位置是取指行的slot0、slot4、slot8、slot12
				// 传递分支预测相关信息到前级流水线
				DSPU32 u32Index = u32EmitPos / 4;
				if (GIsBitSet(m_arrIABP0Out[19 + u32Index * 2], 0))
				{
					// 当发射的执行行在FE2已被处理过
					PIPE_EX.EMIT_DC1.m_left.bol_Processed = true;
					PIPE_EX.EMIT_DC1.m_left.u32r_RetBPC = m_arrIABP0Out[18 + u32Index * 2];
					if (GIsBitSet(m_arrIABP0Out[19 + u32Index * 2], 1))
					{
						PIPE_EX.EMIT_DC1.m_left.bolr_BPT = true;
					}
				}				
			}	
		}
		// CASE 3.2: 如果行首标识在IAB1，那么程序流相关信息取自IAB1
		else
		{
			PIPE_EX.EMIT_DC1.m_left.uint32r_pc = u32EmitPos - MAX_INUM_LINE + m_arrIABP1Out[16];
			PIPE_EX.EMIT_DC1.m_left.u32_NestLvl = m_arrIABP1Out[17] & 0xffU;

			if (GIsBitSet(m_arrIABP1Out[17], 8))
			{
				PIPE_EX.EMIT_DC1.m_left.bol_ISRFirstLn = true;
				m_arrIABP1Out[17] = GClrBit(m_arrIABP1Out[17], 8);
			}
			if (u32EmitPos % 4 == 0)
			{
				DSPU32 u32Index = (u32EmitPos -MAX_INUM_LINE) / 4;
				if (GIsBitSet(m_arrIABP1Out[19 + u32Index * 2], 0))
				{
					PIPE_EX.EMIT_DC1.m_left.bol_Processed = true;
					PIPE_EX.EMIT_DC1.m_left.u32r_RetBPC = m_arrIABP1Out[18 + u32Index * 2];
					if (GIsBitSet(m_arrIABP1Out[19 + u32Index * 2], 1))
					{
						PIPE_EX.EMIT_DC1.m_left.bolr_BPT = true;
					}
				}				
			}			
		}

		DSPU32 u32SeqCounter = IncSeqCounter(u32r_SeqCounter_EMIT);  // inc seqcounter
		u32r_SeqCounter_EMIT = u32SeqCounter;
		PIPE_EX.EMIT_DC1.m_left.u32_SeqCounter = u32SeqCounter;
		PIPE_EX.EMIT_DC1.m_left.bol_InstValid = true; // 是有效执行行

		u32IWords0 = 0;
		u32IWords1 = 0;
		for (int i = 0; i < MAX_INUM_LINE; i++)
		{
			m_arrIABP0In[i] = arrIAB[i];
			m_arrIABP0Out[i] = arrIAB[i];
			m_arrIABP1In[i] = arrIAB[i + MAX_INUM_LINE];
			m_arrIABP1Out[i] = arrIAB[i + MAX_INUM_LINE];

			u32IWords0 |= m_arrIABP0Out[i];
			u32IWords1 |= m_arrIABP1Out[i];
		}

		// IAB0中的指令被发射完毕
		if (u32EndPos >= MAX_INUM_LINE - 1 || u32IWords0 == 0)
		{
			m_arrIABP0In[16] = 0;
			m_arrIABP0Out[16] = 0;
		}
		// IAB1中的指令被发射完毕
		if (u32EndPos >= 2*MAX_INUM_LINE - 1 || u32IWords1 == 0)
		{
			m_arrIABP1In[16] = 0;
			m_arrIABP1Out[16] = 0;
		}
	}
}
//-------------------------------------------------------------------------------------------------------------------------------
// 以下处理IAB0, IAB1的内容更新
//
void sc_iss::UpdateIAB()
{

	if (!m_bolStallIABP0)
	{
		memcpy(m_arrIABP0In, m_arrIABP1Out, sizeof(m_arrIABP1Out));
	}

	if (!m_bolStallIABP1)
	{
		bool bolCacheHit;
		PIPE_FE_REG_CONTENT pipe_fe_reg_content;
		
		m_pICACHE->ReadCacheSlots(&bolCacheHit, &pipe_fe_reg_content);

		memset(m_arrIABP1In, 0, sizeof(m_arrIABP1In));
		
		for (int i = 0; i < MAX_INUM_LINE; i++) // forward instruction words
		{
			m_arrIABP1In[i] = pipe_fe_reg_content.u32_slot[i];
		}

		// forward other information
		m_arrIABP1In[16] = pipe_fe_reg_content.u32_LinePC;
		m_arrIABP1In[17] = pipe_fe_reg_content.u32_NestLvl & 0xff;
		if (pipe_fe_reg_content.bol_ISRFirstLn)
		{
			// 传递bol_ISRFirstLn标志
			m_arrIABP1In[17] = GSetBit(m_arrIABP1In[17], 8);
		}

		for (int i = 0; i < 4; i++)
		{
			m_arrIABP1In[18 + 2 * i] = pipe_fe_reg_content.arrFE2ActionInfo[i].u32_RetBPC;
			if (pipe_fe_reg_content.arrFE2ActionInfo[i].bol_SlotDone)
			{
				// 传递bol_SlotDone标志
				m_arrIABP1In[19 + 2 * i] = GSetBit(m_arrIABP1In[19 + 2 * i], 0);
			}
			
			if (pipe_fe_reg_content.arrFE2ActionInfo[i].bol_BPT)
			{
				// 传递bol_BPT标志
				m_arrIABP1In[19 + 2 * i] = GSetBit(m_arrIABP1In[19 + 2 * i], 1);
			}
		}

	} // if (!m_bolStallIABP1)
}

void sc_iss::GenIABHalt()
{		
	bool bolIABP0Invalid = false;
	bool bolIAB0AllZero = false;
	
	//-------------------------------------------------------------------------------------------------------
	// 判断IAB0 内容是否需要更新
	// 注: 不存在IAB0不需要更新而IAB1需要更新的情况，
	//
	DSPU32 u32LineWords = 0U;
	for(int i = 0; i < MAX_INUM_LINE; i++)
	{
		u32LineWords = u32LineWords | m_arrIABP0Out[i];
	}

	if( !isEmitEndPos(u32LineWords) && (m_arrIABP1Out[17] & 0xff) > (m_arrIABP0Out[17] & 0xff) )
	{
		bolIABP0Invalid = true;
	}
	if(u32LineWords == 0U)
	{
		bolIAB0AllZero = true;
	}

	// 若IAB0中全零，或IAB0中指令无效，则更新IAB
	if (bolIAB0AllZero || bolIABP0Invalid)
	{			
		// 如果IAB0中被废弃的指令是ISR_firstline, 则清PMASK中的相应位
		if ( GIsBitSet(m_arrIABP0Out[17], 8) )
		{
			ClrPMASKBit((m_arrIABP0Out[17] & 0xff) - 1);
		}

		if (bolIABP0Invalid)
		{
			for (int i = 0; i < MAX_INUM_LINE; i++)
			{
				m_arrIABP0In[i] = 0;
				m_arrIABP0Out[i] = 0;
			}
		}		
	}
	else
	{
		m_bolIABCanBeUpdate = false;
	}
}

//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::DC2_ACTION()
{
		DSPU32 *arrPipeSlots, *arrSLKIdx;
		DSPU32 u32SLKIdx;

		m_bolDC2Done = true;
		u32r_SeqCounter_DC2 = PIPE_EX.DC1_DC2.m_right.u32_SeqCounter;

		// clear m_arrDCResNeeded[MAX_INUM_LINE]
		RstDCResNeeded();
	
		for (int i = 0; i < PIPE_EX.DC1_DC2.m_right.u32r_SlotNum; i++)
		{
			//malloc space to hold resource info
			u32SLKIdx = MallocResSLK();
			if (u32SLKIdx != 0)
			{
				PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i] = u32SLKIdx;
				ClrSLKElem(u32SLKIdx);
			}
			else
			{
				PrintToCerr("DC2: Failed to malloc in SLK!\n");
			}
		}
		arrPipeSlots = PIPE_EX.DC1_DC2.m_right.uint32r_slot;
		arrSLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res;
		
		memset(PIPE_EX.DC2_DC3.m_left.arrBPValue, 0, sizeof(DSPU32)*REG_NUM_OF_ADDRUNIT*NUM_OF_ADDR_UNITS);
		memset(PIPE_EX.DC2_DC3.m_left.arrBPValid, 0, sizeof(bool)*REG_NUM_OF_ADDRUNIT*NUM_OF_ADDR_UNITS);
		
		do_slots(arrPipeSlots, arrSLKIdx, PIPE_EX.DC1_DC2.m_right.uint32r_pc, PIPE_EX.DC1_DC2.m_right.u32r_SlotNum, PHASE_DC2);

		malloc_res_needed(PIPE_EX.DC1_DC2.m_right.u32r_SlotNum, arrSLKIdx);
#ifdef DECODER_TESTING
		
		log_res_use_info_new(PIPE_EX.DC1_DC2.m_right.u32r_SlotNum, arrSLKIdx, arrPipeSlots);
		LogBusTest(PIPE_EX.DC1_DC2.m_right.u32r_SlotNum, arrSLKIdx, arrPipeSlots);
		
#endif
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::DC2_POST_ACT()
{
	DSPU32 *arrPipeSlots, *arrSLKIdx;

	arrPipeSlots = PIPE_EX.DC1_DC2.m_right.uint32r_slot;
	// u32SLKIdx is malloced at DC2 stage
	arrSLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res;

	do_slots(arrPipeSlots, arrSLKIdx, PIPE_EX.DC1_DC2.m_right.uint32r_pc, PIPE_EX.DC1_DC2.m_right.u32r_SlotNum, PHASE_DC2_POST);

	// 访存地址合法性检查
	ChkMemReqAddr_DC2_POST();

//#ifdef GPR_FWD
	//数据前推设置
	SetGenRegFwd(arrPipeSlots,arrSLKIdx,PIPE_EX.DC1_DC2.m_right.u32r_SlotNum);
//#endif
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::ChkMemReqAddr_DC2_POST()
{
	DSPU32 arrAddrType[2], arrAddrs[2][8], arrAddrMask[2], arrSLKIdx[2];
	DSPU32 u32SLKIdx, u32WrInsnNum, u32AddrNum, u32Attr;
	int i,j,k;
	SLOT_RES_USED *pSlotResUsed;

	u32WrInsnNum = 0;
	// 判定单条访存指令类型
	for (i = 0; i < PIPE_EX.DC1_DC2.m_right.u32r_SlotNum; i++)
	{
		u32SLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i];
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);

		if( !CondPermitted(u32SLKIdx) )
		{
			continue;
		}
		// 1. 原子访存
		if(pSlotResUsed->bolAtom)
		{
			// An exe-line could have one atom insn at most(exclude other mem-req)
			pSlotResUsed->u32AddrType = GetReqType(pSlotResUsed->u32AtomAddr);
			// 1.1 地址越界
			if(GIsBitSet(pSlotResUsed->u32AddrType, 8))
			{
				pSlotResUsed->u32AtomRdVal = 0U;
				if(pSlotResUsed->u32SrcU != 0)
				{
					PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 2;
				}
				else if(pSlotResUsed->u32SrcV != 0)
				{
					PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 4;
				}
				else if(pSlotResUsed->u32SrcW != 0)
				{
					PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 8;
				}
				else
				{
					PrintToCerr("%s: Unknown address registers\n");
				}
				memset(pSlotResUsed->arrSrcGenRegs, 0, sizeof(DSPU64)*NUM_OF_UNITS);
			}
			SetRWMask_DC2_POST(pSlotResUsed->u32AddrType, true);
			SetRWMask_DC2_POST(pSlotResUsed->u32AddrType, false);			
			// thus just return
			return;
		}
		// 2. 普通访存
		if ( pSlotResUsed->bolMemAcs)
		{
			pSlotResUsed->u32AddrType = GetAddrType(u32SLKIdx);

			// 2.1 地址越界/跨界
			if ( GIsBitSet(pSlotResUsed->u32AddrType, 8) )
			{
				if ( pSlotResUsed->bolRead ) 
				{
					SetRWMask_DC2_POST(pSlotResUsed->u32AddrType, true);					
					memset(pSlotResUsed->arrValues, 0, sizeof(DSPU32) * NUM_OF_UNITS * 2);
				}
				else
				{
					SetRWMask_DC2_POST(pSlotResUsed->u32AddrType, false);				
					if(pSlotResUsed->u32SrcU != 0)
					{
						PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 2;
					}
					else if(pSlotResUsed->u32SrcV != 0)
					{
						PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 4;
					}
					else if(pSlotResUsed->u32SrcW != 0)
					{
						PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 8;
					}
					else
					{
						PrintToCerr("%s: Unknown address registers\n");
					}
					memset(pSlotResUsed->arrSrcGenRegs, 0, sizeof(DSPU64)*NUM_OF_UNITS);

					continue;
				}
			}
			// 2.2 单条写指令(检查地址冲突)
			else if (!pSlotResUsed->bolRead)
			{
				ISS_ASSERT(u32WrInsnNum < 2);		// 指令行内部最多只能有两条写指令
				
				SetRWMask_DC2_POST(pSlotResUsed->u32AddrType, false);
				
				memcpy(arrAddrs[u32WrInsnNum], pSlotResUsed->arrAddrs, NUM_OF_UNITS*2*sizeof(DSPU32));
				if ( IsSameAddr_Insn(arrAddrs[u32WrInsnNum], pSlotResUsed->u32AddrMask) )
				{
					pSlotResUsed->u32AddrType = GSetBit(pSlotResUsed->u32AddrType, 9);
					if(pSlotResUsed->u32SrcU != 0)
					{
						PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 16;
					}
					else if(pSlotResUsed->u32SrcV != 0)
					{
						PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 32;
					}
					else if(pSlotResUsed->u32SrcW != 0)
					{
						PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 64;
					}
					else
					{
						PrintToCerr("%s: Unknown address registers\n");
					}
					memset(pSlotResUsed->arrSrcGenRegs, 0, sizeof(DSPU64)*NUM_OF_UNITS);
					
					u32WrInsnNum++;
					continue;
				}
				arrAddrMask[u32WrInsnNum] = pSlotResUsed->u32AddrMask;
				arrAddrType[u32WrInsnNum] = pSlotResUsed->u32AddrType;
				arrSLKIdx[u32WrInsnNum] = u32SLKIdx;
				u32WrInsnNum++;
				
			}
			// 2.3 单条读访存指令
			else
			{
				SetRWMask_DC2_POST(pSlotResUsed->u32AddrType, true);			
			}
		}
	}

	// 3. 若存在两条写访存指令且地址类型相同
	if ( (u32WrInsnNum == 2) && IsSameAddrType(arrAddrType[0], arrAddrType[1]) )
	{
		// 地址冲突(两条写指令之间)
		if ( IsSameAddr_Line(arrAddrs[0], arrAddrMask[0], arrAddrs[1], arrAddrMask[1]) )
		{		
			m_arrResSLK[arrSLKIdx[0]].slot_res_used.u32AddrType = GSetBit(m_arrResSLK[arrSLKIdx[0]].slot_res_used.u32AddrType, 10);
			m_arrResSLK[arrSLKIdx[1]].slot_res_used.u32AddrType = GSetBit(m_arrResSLK[arrSLKIdx[1]].slot_res_used.u32AddrType, 10);
			memset(m_arrResSLK[arrSLKIdx[0]].slot_res_used.arrSrcGenRegs, 0, sizeof(DSPU64)*NUM_OF_UNITS);
			memset(m_arrResSLK[arrSLKIdx[1]].slot_res_used.arrSrcGenRegs, 0, sizeof(DSPU64)*NUM_OF_UNITS);
			PIPE_EX.DC2_DC3.m_left.u32_ExcpMask |= 128;
		}
	}	
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::SetRWMask_DC2_POST(DSPU32 p_u32AddrType, bool p_bolIsRead)
{
	if(IS_LOCAL_REQ(p_u32AddrType))
	{
		if(p_bolIsRead)
		{
			PIPE_EX.DC2_DC3.m_left.u32RWMask = GSetBit(PIPE_EX.DC2_DC3.m_left.u32RWMask, 0);
		}
		else
		{
			PIPE_EX.DC2_DC3.m_left.u32RWMask = GSetBit(PIPE_EX.DC2_DC3.m_left.u32RWMask, 16);
		}
	}
	else if(IS_ICMA_REQ(p_u32AddrType))
	{
		if(p_bolIsRead)
		{
			PIPE_EX.DC2_DC3.m_left.u32RWMask = GSetBit(PIPE_EX.DC2_DC3.m_left.u32RWMask, 1);
		}
		else
		{
			PIPE_EX.DC2_DC3.m_left.u32RWMask = GSetBit(PIPE_EX.DC2_DC3.m_left.u32RWMask, 17);
		}
	}
	else if(IS_DMAC_REQ(p_u32AddrType))
	{
		if(p_bolIsRead)
		{
			PIPE_EX.DC2_DC3.m_left.u32RWMask = GSetBit(PIPE_EX.DC2_DC3.m_left.u32RWMask, 2);
		}
		else
		{
			PIPE_EX.DC2_DC3.m_left.u32RWMask = GSetBit(PIPE_EX.DC2_DC3.m_left.u32RWMask, 18);
		}
	}	
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::DC3_POST_ACT()
{
	DSPU32 u32InstrWord;

	// (Us = Um CB Un) located at the first exec slot
	u32InstrWord = PIPE_EX.DC2_DC3.m_right.uint32r_slot[0];
	if(IsInstNoCalc(u32InstrWord))
	{
		if(GetOpcodeNoCalc(u32InstrWord) == op_areg_cb_reg_c)
		{
			// Branch target addr has been modified at DC2_POST
			if(bolr_CBEn)
			{
				m_bolCondBraTaken = true;
				bolr_CBEn = false;
				PIPE_EX.DC3_DC4.m_left.u32CB_NPC = u32r_CBTgtAddr;
			}
			else
			{
				PIPE_EX.DC3_DC4.m_left.u32CB_NPC = PIPE_EX.DC3_DC4.m_left.uint32r_pc + PIPE_EX.DC3_DC4.m_left.u32r_SlotNum;
			}
#ifdef LIBTESTCODE
			if(m_CodeCovForLibTest)
			{
				if (m_bolCondBraTaken)
					m_cond_pc[PIPE_EX.DC3_DC4.m_right.uint32r_pc].cnttrue++;
				else
					m_cond_pc[PIPE_EX.DC3_DC4.m_right.uint32r_pc].cntfalse++;
				
				//PrintConditionPCToTmpFile(PIPE_EX.DC3_DC4.m_right.uint32r_pc,m_bolCondBraTaken);	
			}					
#endif
		}		
	}
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::DC4_ACTION()
{
	m_bolDC4Done = true;
	u32r_SeqCounter_DC4 = PIPE_EX.DC3_DC4.m_right.u32_SeqCounter;

	// 提交核内访存请求
	if (HAS_LOCAL_REQ(PIPE_EX.DC3_DC4.m_right.u32RWMask) )
	{
		RstMemReqs_DC4();	
		PutCoreMemReq_DC4();
	}
}
void sc_iss::PutCoreMemReq_DC4()
{
	DSPU32 u32SLKIdx, u32AddrMask, u32AddrType, u32BlkIdx, u32Value;
	bool bolAddrIllegal;
	DSPU32 u32SrcPageIdx;
	
	SLOT_RES_USED *pSlotResUsed = NULL;
	DSPU32 *p_arrSlotRes = PIPE_EX.DC3_DC4.m_right.u32r_slot_res;
	DSPU32 rdBusID = RD_BUS0;
	DSPU32 wrBusID = WR_BUS0;
	RD_BUS_T *pRdBus;
	WR_BUS_T *pWrBus;
	
	// 遍历每一个指令槽，根据需要提交核内访存请求
	for (int intSlot = 0; intSlot < PIPE_EX.DC3_DC4.m_right.u32r_SlotNum; intSlot++)
	{
		u32SLKIdx = p_arrSlotRes[intSlot];
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);

		if ( !CondPermitted(u32SLKIdx) )
		{
			continue;
		}

		u32AddrType	= pSlotResUsed->u32AddrType;
		u32AddrMask	= pSlotResUsed->u32AddrMask;
		
		if (!pSlotResUsed->bolMemAcs || !IS_LOCAL_REQ(u32AddrType) )
		{
			continue;
		}
		
		u32BlkIdx	= TYPE_BLK_IDX(u32AddrType);
		bolAddrIllegal	= (TYPE_FAULT_CODE(u32AddrType) == 0) ? false : true;

		u32SrcPageIdx = pSlotResUsed->u32SrcPageIdx;
		if( pSlotResUsed->bolAtom )
		{
			pRdBus = &(m_RdBus[rdBusID]);
			pWrBus = &(m_WrBus[wrBusID]);
			
			pRdBus->u32Block = u32BlkIdx;
			pRdBus->bolAtom = true;
			pRdBus->bolIllegal = bolAddrIllegal;
			pRdBus->bolInUse = true;

			pWrBus->u32Block = u32BlkIdx;
			pWrBus->bolIsSpecWr = false;
			pWrBus->bolAtom = true;
			pWrBus->bolIllegal = bolAddrIllegal;
			pWrBus->u32PageIdx = u32SrcPageIdx;
			pWrBus->bolInUse = true;

			for(int k = 0; k < NUM_OF_UNITS; k++)
			{
				if(GIsBitSet(pSlotResUsed->u32AtomUnit, k))
				{
					fill_rd_bus(pRdBus, pSlotResUsed->u32AtomAddr);
					fill_wr_bus(pWrBus, pSlotResUsed->u32AtomAddr, 0, k, pSlotResUsed->u32AtomSrcIdx);
					break;
				}
			}
			return;
		}

		if ( pSlotResUsed->bolRead )
		{
			pRdBus = &(m_RdBus[rdBusID]);
		
			pRdBus->u32Block = u32BlkIdx;
			pRdBus->bolAtom = false;
			pRdBus->bolIllegal = bolAddrIllegal;
			pRdBus->bolInUse = true;
	
			for (int k = 0; k < NUM_OF_UNITS; k++)
			{
				if ( GIsBitSet(u32AddrMask, k * 2) ) // 同GIsBitSet(u32Units, j)
				{          
					fill_rd_bus(pRdBus, pSlotResUsed->arrAddrs[k][0]);
					if ( GIsBitSet(u32AddrMask, k * 2 + 1) ) // 是否为双字访存请求
					{		
						fill_rd_bus(pRdBus, pSlotResUsed->arrAddrs[k][1]);
					}
				}
			}
			rdBusID++;
		}
		else
		{
			pWrBus = &(m_WrBus[wrBusID]);
		
			pWrBus->u32Block = u32BlkIdx;
			pWrBus->bolIsSpecWr = pSlotResUsed->bolSpecWr;
			pWrBus->bolAtom = false;
			pWrBus->bolIllegal = bolAddrIllegal;
			pWrBus->u32PageIdx = u32SrcPageIdx;
			pWrBus->bolInUse = true;

			for (int k = 0; k < NUM_OF_UNITS; k++)
			{
				if ( GIsBitSet(u32AddrMask, k * 2) ) // 同GIsBitSet(u32Units, j)
				{
					fill_wr_bus(pWrBus, pSlotResUsed->arrAddrs[k][0], pSlotResUsed->arrValues[k][0], k, pSlotResUsed->arrMemSrcReg[k]);
					if ( GIsBitSet(u32AddrMask, k * 2 + 1) ) // 是否为双字访存请求
					{
						fill_wr_bus(pWrBus, pSlotResUsed->arrAddrs[k][1], pSlotResUsed->arrValues[k][1], k, pSlotResUsed->arrMemSrcReg[k] + 1);
					}
				}
			}
			wrBusID++;
		}
	}

}
void sc_iss::fill_wr_bus(WR_BUS_T *p_wrBus, DSPU32 p_u32Addr, DSPU32 p_u32Value, DSPU32 p_u32RegUnit, DSPU32 p_u32RegIdx)
{
	WR_BUS_ELEM *pWrElem;
	DSPU32 u32Bank, u32ElemNum;

	u32Bank = p_u32Addr % 8;
	u32ElemNum = p_wrBus->arrBanks[u32Bank].u32ElemNum;
	for(int i = 0; i < u32ElemNum; i++)
	{
		if(p_wrBus->arrBanks[u32Bank].arrElems[i].u32MemAddr == p_u32Addr)
		{
			return;
		}
	}
	
	pWrElem = &(p_wrBus->arrBanks[u32Bank].arrElems[u32ElemNum]);
	
	pWrElem->bolInUse = true;
	pWrElem->u32MemAddr = p_u32Addr;
	pWrElem->u32Value = p_u32Value;		
	pWrElem->u32RegUnit = p_u32RegUnit;
	pWrElem->u32RegIdx = p_u32RegIdx;
	
	p_wrBus->u32ElemNum++;
	p_wrBus->arrBanks[u32Bank].u32ElemNum++;

}

void sc_iss::fill_rd_bus(RD_BUS_T *p_rdBus, DSPU32 p_u32Addr)
{
	DSPU32 u32Bank, u32ElemNum;

	u32Bank = p_u32Addr % 8;
	u32ElemNum = p_rdBus->arrBanks[u32Bank].u32ElemNum;
	for(int i = 0; i < u32ElemNum; i++)
	{
		if(p_rdBus->arrBanks[u32Bank].arrElems[i].u32MemAddr == p_u32Addr)
		{
			return;
		}
	}

	p_rdBus->arrBanks[u32Bank].arrElems[u32ElemNum].bolInUse = true;
	p_rdBus->arrBanks[u32Bank].arrElems[u32ElemNum].u32MemAddr = p_u32Addr;

	p_rdBus->u32ElemNum++;
	p_rdBus->arrBanks[u32Bank].u32ElemNum++;

}
#define HAS_MEM_REQ() (m_RdBus[RD_BUS0].bolInUse || m_RdBus[RD_BUS1].bolInUse || m_WrBus[WR_BUS0].bolInUse || m_WrBus[WR_BUS1].bolInUse)

void sc_iss::SrvMemReq_DC4()
{
	bool bolPermitPipe = false; // 流水线是否允许内核访存指令执行
	DSPU32 u32SlotNum;
	DSPU32 u32AtomMask = 0;

	if ( m_bolStall_ACEX || m_DC4_bolCPredStall_DC4AC || m_DC4_bolISRStall_DC4AC  || m_DC4_bolIRETStall_DC4AC || bolro_AtomO) 
	{
		// 若前方流水线已经确定DC4/AC将被stall, 则当前周期不执行内核访存指令
	}
	else
	{
		if(PIPE_EX.DC4_AC.m_left.u32r_SlotNum != 0 && HAS_MEM_REQ())
		{
			bolPermitPipe = true;
		}
	/*
		if ( PIPE_EX.DC4_AC.m_left.u32r_SlotNum != 0 )
		{
			if ( !m_bolFlush_DC4AC && HAS_MEM_REQ())
			{
				bolPermitPipe = true; // 流水线允许内核访存指令执行
			}			
		}		
	*/
	}
	//---------------------------------------------------------------
	// 来自核外的访存请求不受流水线状态的影响

	if ( bolPermitPipe && PermitRW_DC4() )
	{
		SrvCoreMem_DC4();		
	}	

	#ifdef ICMA_TESTING
	// 以block为单位禁止服务来自核外的原子访存请求
	if(PermitICMA())
	{
		SrvICMA_DC4();
	}
	if(m_icma_resp.bolInUse)
	{
		RespICMA();
	}
	#endif
	SrvDMAC_DC4();
}
//--------------------------------------------------------
bool sc_iss::PermitRW_DC4()
{
	DSPU32 u32RdMask_DC4 = 0;
	DSPU32 u32ConfBlks;

	if ( m_RdBus[RD_BUS0].bolInUse && !m_RdBus[RD_BUS0].bolIllegal )
	{			
		u32RdMask_DC4 = GSetBit(u32RdMask_DC4, m_RdBus[RD_BUS0].u32Block);
	}
	if ( m_RdBus[RD_BUS1].bolInUse &&  !m_RdBus[RD_BUS1].bolIllegal)
	{
		if ( !m_RdBus[RD_BUS0].bolInUse || m_RdBus[RD_BUS0].u32Block != m_RdBus[RD_BUS1].u32Block)
		{
			u32RdMask_DC4 = GSetBit(u32RdMask_DC4, m_RdBus[RD_BUS1].u32Block);
		}
	}

	u32ConfBlks = m_u32RdBlockMask & u32RdMask_DC4;
	if( u32ConfBlks == 0 )
	{
		return true;
	}
	#ifdef STALL_REASON_LOG
	LogBankConf(true, BLK_PORT_CLOSED, GetLSB_32(u32ConfBlks), 0);
	#endif
	return false;
}
//--------------------------------------------------------
void sc_iss::SrvCoreMem_DC4()
{
	DSPU32 u32Block;
	DSPU32 u32MPSLKIdx = 0;	
	
	// 以下按照优先级顺序执行
	// 对于同一执行行，本核原子读与本核非原子读不会同时出现。
	for(DSPU32 u32Bus = RD_BUS0; u32Bus < RD_BUS_MAX; u32Bus++)
	{
		if(m_RdBus[u32Bus].bolInUse)
		{
			u32Block = m_RdBus[u32Bus].u32Block;
			if(m_RdBus[u32Bus].bolIllegal)
			{
				if(IsVPortValid(u32Block))
				{
					SrvRdBus_DC4(u32Bus);
					CloseVPort(u32Block);
					CloseRdPort(u32Block);
					CloseWrPort(u32Block);
				}
			}
			else if(IsRdPortValid(u32Block))
			{
				SrvRdBus_DC4(u32Bus);
				CloseVPort(u32Block);
				CloseRdPort(u32Block);
				CloseWrPort(u32Block);
				CloseOutPort(u32Block);
			}
		}
	}
	for(DSPU32 u32Bus = WR_BUS0; u32Bus < WR_BUS_MAX; u32Bus++)
	{
		if(m_WrBus[u32Bus].bolInUse)
		{
			u32Block = m_WrBus[u32Bus].u32Block;
			if(IsWrPortValid(u32Block))
			{
				u32MPSLKIdx = (u32MPSLKIdx == 0) ? MallocMPSLK() : u32MPSLKIdx;
				SrvWrBus_DC4(u32Bus, u32MPSLKIdx);
				// WR_BUS0 > WR_BUS1
				CloseWrPort(u32Block);
				if( !m_WrBus[u32Bus].bolIllegal )
				{
					if(m_WrBus[u32Bus].bolAtom
				#ifdef ICMA_TESTING
						|| (m_icma_resp.icma_mem.bolAtom && ICMA_ARRIVED()) 
				#endif
					)
					{
						CloseOutPort(u32Block);
					}
				}
			}
		}
	}

}
//--------------------------------------------------------
void sc_iss::SrvRdBus_DC4(DSPU32 p_rdBusID)
{
	DSPU32 u32ElemNum, u32MemAddr, u32Value, u32Idx;
//	RD_BUS_ELEM *pRdBusElem = NULL;

	for(DSPU32 u32Bank = 0; u32Bank < BANK_NUM_PERBLK; u32Bank++)
	{
		u32ElemNum = m_RdBus[p_rdBusID].arrBanks[u32Bank].u32ElemNum;
		if(u32ElemNum != 0)
		{
			for(int i = 0; i < 8; i++)
			{
				if(m_RdBus[p_rdBusID].arrBanks[u32Bank].arrElems[i].bolInUse)
				{
					u32Idx = i;
					u32MemAddr = m_RdBus[p_rdBusID].arrBanks[u32Bank].arrElems[i].u32MemAddr;
					break;
				}
			}
			/*
			u32MemAddr = ~0U;
			u32Idx = BANK_DEPTH;
			pRdBusElem = &(m_RdBus[p_rdBusID].arrBanks[u32Bank].arrElems[0]);
			for(int i = 0; i < BANK_DEPTH; i++)
			{								
				if( pRdBusElem->bolInUse && pRdBusElem->u32MemAddr < u32MemAddr)
				{
					u32MemAddr = pRdBusElem->u32MemAddr;
					u32Idx = i;
				}
				pRdBusElem++;
			}
			ISS_ASSERT(u32Idx < BANK_DEPTH);
			*/
			
			// u32MemAddr = m_RdBus[p_rdBusID].arrBanks[u32Bank].arrElems[u32Idx].u32MemAddr;
			if ( !m_RdBus[p_rdBusID].bolIllegal )
			{
				if ( !RdDataFrmPipe(u32MemAddr, &u32Value, PIPE_EX.AC_EX.m_left.u32_MPSLKIdx) ) // try to forward from PIPE_EX.DC4_AC.m_right					
				{
					if ( !RdDataFrmPipe(u32MemAddr, &u32Value, PIPE_EX.EX_WB.m_left.u32_MPSLKIdx) ) // try to forward from PIPE_EX.AC_EX.m_right						
					{
						ReadCoreDataMem(u32MemAddr, &u32Value);
					}
				}
				CheckAddrValid_DC4(u32MemAddr, true);
				PutReqResult(u32MemAddr, u32Value, PIPE_EX.DC4_AC.m_left.INST_LINE_RD_RESULT);	
			}
			
			m_RdBus[p_rdBusID].arrBanks[u32Bank].arrElems[u32Idx].bolInUse = false;
			m_RdBus[p_rdBusID].arrBanks[u32Bank].u32ElemNum--;
			m_RdBus[p_rdBusID].u32ElemNum--;
			
			if(m_RdBus[p_rdBusID].u32ElemNum == 0)
			{
				m_RdBus[p_rdBusID].bolInUse = false;
				break;
			}
		}
	}
}
//--------------------------------------------------------
void sc_iss::SrvWrBus_DC4(DSPU32 p_wrBusID, DSPU32 &p_u32MPSLKIdx)
{
	DSPU32 u32ElemNum, u32MemAddr, u32Value, u32Block, u32PageIdx, u32Idx;
	DSPU32 u32NumToWr = m_arrMemPipeSLK[p_u32MPSLKIdx].u32WrElemNum;
	bool bolAtom, bolSpecWr;
//	WR_BUS_ELEM *pWrBusElem = NULL;

	u32Block = m_WrBus[p_wrBusID].u32Block;
	u32PageIdx = m_WrBus[p_wrBusID].u32PageIdx;
	bolAtom = m_WrBus[p_wrBusID].bolAtom;
	bolSpecWr = m_WrBus[p_wrBusID].bolIsSpecWr;
	
	for(DSPU32 u32Bank = 0; u32Bank < BANK_NUM_PERBLK; u32Bank++)
	{
		u32ElemNum = m_WrBus[p_wrBusID].arrBanks[u32Bank].u32ElemNum;
		if(u32ElemNum != 0)
		{
			for(int i = 0; i < 8; i++)
			{
				if(m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[i].bolInUse)
				{
					u32Idx = i;
					u32MemAddr = m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[i].u32MemAddr;
					break;
				}
			}
			/*
			u32MemAddr = ~0U;
			u32Idx = BANK_DEPTH;
			pWrBusElem = &(m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[0]);
			for(int i = 0; i < BANK_DEPTH; i++)
			{				
				if( pWrBusElem->bolInUse && pWrBusElem->u32MemAddr < u32MemAddr)
				{
					u32MemAddr = pWrBusElem->u32MemAddr;
					u32Idx = i;
				}
				pWrBusElem++;
			}
			ISS_ASSERT(u32Idx < BANK_DEPTH);
			*/
			if(!m_WrBus[p_wrBusID].bolIllegal)
			{
				// u32MemAddr = m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[u32Idx].u32MemAddr;
				u32Value = m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[u32Idx].u32Value;
				if ( bolSpecWr)
				{
					m_arrMemPipeSLK[p_u32MPSLKIdx].arrWrValue[u32NumToWr] = u32Value;
					m_arrMemPipeSLK[p_u32MPSLKIdx].u32SpecWrMask = GSetBit(m_arrMemPipeSLK[p_u32MPSLKIdx].u32SpecWrMask, u32NumToWr);
				}
				else
				{
					m_arrMemPipeSLK[p_u32MPSLKIdx].arrUnitIdx[u32NumToWr] = m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[u32Idx].u32RegUnit;
					m_arrMemPipeSLK[p_u32MPSLKIdx].arrRegIdx[u32NumToWr] = m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[u32Idx].u32RegIdx;
					m_arrMemPipeSLK[p_u32MPSLKIdx].arrSrcPageIdx[u32NumToWr] = u32PageIdx;
				}
				m_arrMemPipeSLK[p_u32MPSLKIdx].arrWrAddr[u32NumToWr] = u32MemAddr;
				m_arrMemPipeSLK[p_u32MPSLKIdx].arrBlkIdx[u32NumToWr] = u32Block;
				m_arrMemPipeSLK[p_u32MPSLKIdx].arrAtom[u32NumToWr] = bolAtom;
				m_arrMemPipeSLK[p_u32MPSLKIdx].u32WrElemNum++;
				CheckAddrValid_DC4(u32MemAddr, false);
				u32NumToWr++;	
			}
			
			m_WrBus[p_wrBusID].arrBanks[u32Bank].arrElems[u32Idx].bolInUse = false;
			m_WrBus[p_wrBusID].arrBanks[u32Bank].u32ElemNum--;
			m_WrBus[p_wrBusID].u32ElemNum--;

			if(m_WrBus[p_wrBusID].u32ElemNum == 0)
			{
				m_WrBus[p_wrBusID].bolInUse = false;
				break;
			}
		}
	}
	if (m_arrMemPipeSLK[p_u32MPSLKIdx].u32WrElemNum > 0)
	{		
		m_u32MPReqIdx = p_u32MPSLKIdx;
	}
	else
	{
		FreeMPSLK(p_u32MPSLKIdx);
		p_u32MPSLKIdx = 0;
	}	
}
//--------------------------------------------------------
void sc_iss::SrvDMAC_DC4()
{
	for(int i = 0; i < DMAC_MAX_CHANNELS; i++)
	{
		if ( m_dmac_resp[i].bolInUse && !m_dmac_resp[i].bolServed )
		{
			if( m_dmac_resp[i].u32ElemNum == 0 )
			{
				if(m_dmac_resp[i].dmac_mem.bolAllWrReq)
				{
					m_dmac_resp[i].bolInUse = false;
					m_dmac_resp[i].bolServed = true;
					continue;
				}
				if(m_dmac_resp[i].u32DelayResp == 0)
				{
					m_dmac_resp[i].bolInUse = false;
					m_dmac_resp[i].bolServed = true;
					send_resp_dmac(&(m_dmac_resp[i].dmac_mem));
				}
				else
				{
					m_dmac_resp[i].u32DelayResp--;
				}
			}
			else if ( IsOutPortValid(m_dmac_resp[i].u32Block) )
			{				
				SrvDMACH_DC4(&(m_dmac_resp[i]));
				CloseOutPort(m_dmac_resp[i].u32Block);
			}
		}
	}

}

//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::DC4_POST_ACT()  // grui todo
{
	DSPU32 *arrPipeSlots, *arrSLKIdx;

	arrPipeSlots = PIPE_EX.DC3_DC4.m_right.uint32r_slot;
	arrSLKIdx = PIPE_EX.DC4_AC.m_left.u32r_slot_res;

	do_slots(arrPipeSlots, arrSLKIdx, PIPE_EX.DC3_DC4.m_right.uint32r_pc, PIPE_EX.DC3_DC4.m_right.u32r_SlotNum, PHASE_DC4_POST);
}

//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::AC_ACTION()
{
	DSPU32 u32NestLvl;

	if (PIPE_EX.DC4_AC.m_right.u32r_slot_res[0] == 0)
	{
		printf("AC: Invalid SLK index\n");
	}
	
	m_bolACDone = true;
	u32r_SeqCounter_AC = PIPE_EX.DC4_AC.m_right.u32_SeqCounter;
	m_bolMemExcp_AC = false;
	
//	if (!m_bolAbandon_AC)
	{		
		// 提交核外访存请求
		// GRQ: 全局关中断标志检查每个节拍都进行，
		//      而这里核外访存请求在AC级的第一个节拍就提交。
		//      建议全局关中断标志应禁止JTAG写(待确认)
#ifdef ICMA_TESTING
		if ( HAS_ICMA_REQ(PIPE_EX.DC4_AC.m_right.u32RWMask) )
		{
			reset_icma_req();
			PutICMAReq_AC();	
			if(m_icma_req.icma_mem.u32ElemNum != 0)
			{
				m_icma_req.bolInUse = true;			
			}
		}
#endif		
#ifdef DMAC_TESTING
		if ( HAS_DMAC_REQ(PIPE_EX.DC4_AC.m_right.u32RWMask) )
		{
			reset_dmac_req();
			PutDMACReq_AC();	
			if(m_dmac_req.dmac_mem.u32ElemNum != 0)
			{
				m_dmac_req.bolInUse = true;			
			}
		}
#endif
		// 访存异常不影响地址寄存器更新
		// 地址寄存器前推
//		m_bolMemExcp_AC = IsMemExcp(PIPE_EX.DC4_AC.m_right.u32_ExcpMask);
	}

#ifdef LIBTEST
	//该段代码用于算法测试
	if(m_bolTestForLib)
	{
		DSPU32 u32SLKIdx,u32MemAddr;
		SLOT_RES_USED *pSlotResUsed;
		int i,j,k;
		for(i=0;i<PIPE_EX.DC4_AC.m_right.u32r_SlotNum;i++)
		{
			u32SLKIdx = PIPE_EX.DC4_AC.m_right.u32r_slot_res[i];
			pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);

			if( !CondPermitted(u32SLKIdx) )
			{
				continue;
			}
			if ( pSlotResUsed->bolMemAcs)
			{
				if(!pSlotResUsed->bolRead) //是写访存
				{
					for(j=0;j<NUM_OF_UNITS;j++)  //遍历四个宏
					{
						for(k=0;k<2;k++) //每个宏一次最多写2个地址
						{
							u32MemAddr = pSlotResUsed->arrAddrs[j][k];
							if(u32MemAddr)
							{
								//检测栈的大小
								GetAccessStackStatus();

								bool CheckDataPagFlag = false;  
								RWAddrError tmpWtError;
								//需要检测的data段是不可写		
								list<AreaAddr>::iterator Diter = m_TestLibInput.DataPagList.begin();
								list<AreaAddr>::iterator Diter_end = m_TestLibInput.DataPagList.end();
								for (; Diter!=Diter_end; ++Diter)
								{
									if(  (u32MemAddr >= Diter->StartAddr) && (u32MemAddr <= Diter->EndAddr) )
									{
										CheckDataPagFlag = true;  //发生了写操作
										break;
									}
								}
								if (CheckDataPagFlag)
								{
									tmpWtError.PC = u32r_EPC;
									tmpWtError.Addr = u32MemAddr;
									m_TestLibOutput.WriteIllegalDataPagAddr.push_back(tmpWtError);
								}
								else
								{
									bool ParaMemflag = false;

									//检测所写地址是否在栈空间内
									DSPU32 AddrU8 = u32ro_U[8];
									//DSPU32 AddrU9 = u32ro_U[9];
									if((u32MemAddr >= AddrU8) && (u32MemAddr <= 0x60ffffU))
									{
										//所写地址合法,在栈空间内
										ParaMemflag = true;
									}
									else
									{
										//所写地址不在栈空间内
										//检测写地址是否在所给内存空间内
										list<AreaAddr>::iterator iter = m_TestLibInput.InParaMemList.begin();
										list<AreaAddr>::iterator iter_end = m_TestLibInput.InParaMemList.end();
										for (; iter!=iter_end; ++iter)
										{
											if(  (u32MemAddr >= iter->StartAddr) && (u32MemAddr <= iter->EndAddr) )
											{
												//所写地址合法
												ParaMemflag = true;
												break;
											}
										}
									}
									if (!ParaMemflag)
									{	//所写地址不合法，即在所给内存区间之外发生了写操作
										WrtStackError tmpstack;
										//tmpstack.PC = PIPE_EX.AC_EX.m_right.uint32r_pc;
										tmpstack.PC = u32r_EPC;
										tmpstack.AddrU8 = AddrU8;
										tmpstack.AddrU9 = 0x60ffffU;
										tmpstack.WriteAddr = u32MemAddr;
										m_TestLibOutput.WriteIllegalAddr.push_back(tmpstack);
									}
								}
							}
						}
					}
				}
			}
		}
	}
#endif	
}

//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::AC_POST_ACT()
{
	unsigned int u32NestLvl, u32Temp;
	DSPU32 *arrPipeSlots, *arrSLKIdx;
	unsigned int u32InstrWord0, u32InstrWord1, u32OpCode, u32ExcpMask;
	bool bol_ISRFirstLn;
	DSPU64 u64PMASK, u32RWMask;

	u32NestLvl = PIPE_EX.AC_EX.m_left.u32_NestLvl;
	u32ExcpMask = PIPE_EX.AC_EX.m_left.u32_ExcpMask;
	bol_ISRFirstLn = PIPE_EX.AC_EX.m_left.bol_ISRFirstLn;

	arrPipeSlots = PIPE_EX.DC4_AC.m_right.uint32r_slot;
	arrSLKIdx = PIPE_EX.DC4_AC.m_right.u32r_slot_res;

	if ( !m_bolAbandon_AC )
	{
#ifdef INTERRUPT_TESTING
		m_bolACPostDone = true;
		m_u32ACPostPC = PIPE_EX.DC4_AC.m_right.uint32r_pc;
		m_u32ACPostNestLvl = PIPE_EX.DC4_AC.m_right.u32_NestLvl;
#endif
	
		do_slots(arrPipeSlots, arrSLKIdx, PIPE_EX.DC4_AC.m_right.uint32r_pc, PIPE_EX.DC4_AC.m_right.u32r_SlotNum, PHASE_AC_POST);

		u32RWMask = PIPE_EX.DC4_AC.m_right.u32RWMask;
		if ( HAS_ICMA_RD_REQ(u32RWMask) || HAS_DMAC_RD_REQ(u32RWMask) )
		{
			GetRdResult_INSN(PHASE_AC_POST);		
		}
		//---------------------------------------------------------------------------------
		u32InstrWord0 = PIPE_EX.DC4_AC.m_right.uint32r_slot[0];
		u32InstrWord1 = PIPE_EX.DC4_AC.m_right.uint32r_slot[1];
		if (IsExtFirstWord(u32InstrWord0))
		{
			u32OpCode = GetOpcodeExt(u32InstrWord1);
			if (u32OpCode == op_ext_b_lbl_etc_c)
		       {
				switch ( ExtractBinStr(u32InstrWord1, 19, 2) )
				{
					case 2:  // call label
						// store return PC into CJMP register,
						// the return PC is address of next execution line.
						u32Temp = PIPE_EX.DC4_AC.m_right.uint32r_pc + PIPE_EX.DC4_AC.m_right.u32r_SlotNum;
						WrCJMP(u32Temp, false);
						InitCurFunStatus();
						break;
				}
			} // if (u32OpCode == op_ext_b_lbl_etc_c)
		}
		else if ( IsInstNoCalc(u32InstrWord0) )
		{
			u32OpCode = GetOpcodeNoCalc(u32InstrWord0);
			switch (u32OpCode)
			{
				case  op_idle_c:
				{
					bolri_Idle = true;
					break;
				}
				case  op_iret_c:
				{					
					if (bol_ISRFirstLn)
					{
						u32ri_IRET_ADDR_ACEX = u32r_EX_NPC;
					}
					else
					{
						u32ri_IRET_ADDR_ACEX = ReadIRA(u32NestLvl - 1);
					}									
#ifdef ECS_LOG
					FILE *fp = NULL;

					sprintf(g_arrFileName, "%s/U8Log.txt", g_arrIOPath);
					if ((fp = fopen(g_arrFileName, "a+")) == NULL)
					{
						PrintToCerr("Error occured when open U8Log.txt\n");
						return ;
					}
					fprintf(fp, "IRET: %08x %08x %08x %016llx %016llx\n", 
						PIPE_EX.DC4_AC.m_right.uint32r_pc, u32NestLvl - 1, 
						u32ri_IRET_ADDR_ACEX, u64ro_ILAT, (DSPU64)u64r_PMASK);
					fclose(fp);
#endif
					u64PMASK = u64r_PMASK;
					u32r_NestLvlAftIRET_AC_EX = GetNestLvlAftIRET(u64PMASK, u32NestLvl - 1);
					ClrPMASKBit(u32NestLvl - 1);
					
					if (u32NestLvl == 62)
					{
						if ( m_bolLogOnStrap )
						{
							LogOnStrap(u32ro_R[0], u32ro_R[1]);
						}							
					}

					break;
				}
				case  op_call_reg_c:
				{
					// the return PC is address of next execution line
					u32Temp = PIPE_EX.DC4_AC.m_right.uint32r_pc + PIPE_EX.DC4_AC.m_right.u32r_SlotNum;
					WrCJMP(u32Temp, false);
					PIPE_EX.AC_EX.m_left.arrCondRegsValid[BREG_SRP] = true;
					PIPE_EX.AC_EX.m_left.arrCondRegsValue[BREG_SRP] = u32ro_SRP;
					InitCurFunStatus();
					break;
				}
				case op_b_reg_c:
				{
					PIPE_EX.AC_EX.m_left.arrCondRegsValid[BREG_BA] = true;
					PIPE_EX.AC_EX.m_left.arrCondRegsValue[BREG_BA] = u32ro_BAR;
					break;
				}
				
				case  op_strap_c:
				{
					if ( GetNestLvl(u64r_PMASK) != 0x3E )
					{
						// 若当前流水线中没有strap正在被服务
						// 即若有strap正在被服务，则忽略本次strap
						SetILAT(0x3d);
						u32r_SITR = u32InstrWord0 & 0x3F;
					}
										
					break;
				}	
				case op_swi_c:
				{					
					DSPU32 u32CoreID = ExtractBinStr(u32InstrWord0, 0, 8);
					if(u32CoreID == (DSPU32)u32r_CoreID)
					{
						SetILAT(0x26);
					}
					else
					{						
						send_swi_req();
					}
					break;
				}

			} // switch (u32OpCode)
		}

//		PIPE_EX.AC_EX.m_left.u32_ExcpMask = u32ExcpMask;
//		PIPE_EX.AC_EX.m_left.u32_ExcpMaskHigh = 0;
		
	} // if ( !m_bolAbandon_AC )

}
//
bool sc_iss::send_swi_req()
{
	tlm::tlm_generic_payload trans;
	tlm::tlm_phase phase;
	sc_time delay;
	bool bolOK = true;
#ifdef ICMA_TESTING
	trans.set_address(CMD_SWI_REQ);
	trans.set_data_ptr( NULL );
	trans.set_data_length(0);
	phase = tlm::BEGIN_REQ;
		
	m_iICMASocket->nb_transport_fw(trans, phase, delay);

	if (trans.get_response_status() != tlm::TLM_OK_RESPONSE)
	{
		PrintToCerr("%s: nb_transport_fw failed", __FUNCTION__);
		bolOK = false;
	}
#endif
	return bolOK;
}

//-------------------------------------------------------------------
void sc_iss::GetRdResult_INSN(DSPU32 u32Phase)
{
	DSPU32 u32SLKIdx, u32AddrMask, u32AddrType, u32SlotNum, u32Result;
	DSPU32 *p_arrSlotRes, *p_arrSlots;
	SLOT_RES_USED *pSlotResUsed;

	bool (sc_iss::*get_rd_result)(DSPU32, DSPU32 &) = NULL;

	ISS_ASSERT(u32Phase == PHASE_AC_POST || u32Phase == PHASE_EX);
	
	if(u32Phase == PHASE_AC_POST)
	{
		u32SlotNum = PIPE_EX.DC4_AC.m_right.u32r_SlotNum;
		p_arrSlotRes = PIPE_EX.DC4_AC.m_right.u32r_slot_res;
		p_arrSlots = PIPE_EX.DC4_AC.m_right.uint32r_slot;
	}
	else
	{
		u32SlotNum = PIPE_EX.AC_EX.m_right.u32r_SlotNum;
		p_arrSlotRes = PIPE_EX.AC_EX.m_right.u32r_slot_res;
		p_arrSlots = PIPE_EX.AC_EX.m_right.uint32r_slot;
	}
	

	for (int intSlot = 0; intSlot < u32SlotNum; intSlot++)
	{		
		u32SLKIdx = p_arrSlotRes[intSlot];
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);
		
		if ( !CondPermitted(u32SLKIdx) )
		{
			continue;
		}

		u32AddrType	= pSlotResUsed->u32AddrType;
		
		if ( !pSlotResUsed->bolRead || TYPE_FAULT_CODE(u32AddrType) != 0)
		{
			continue;
		}
		//如果不置为NULL，同一指令行里既有核内访存又有ICMA时，会导致混乱
		get_rd_result = NULL;
		if ( u32Phase == PHASE_AC_POST )
		{
			if ( IS_DMAC_REQ(u32AddrType) )
			{
				get_rd_result = &sc_iss::get_dmac_rd_result;
			}
			else if ( IS_ICMA_REQ(u32AddrType) )
			{
				get_rd_result = &sc_iss::get_icma_rd_result;
			}
		}
		else
		{
			if ( IS_LOCAL_REQ(u32AddrType) )
			{
				get_rd_result = &sc_iss::get_core_rd_result;
			}
		}
		if(get_rd_result == NULL)
		{
			continue;
		}
		if ( pSlotResUsed->bolAtom )
		{
			if ( (this->*get_rd_result)(pSlotResUsed->u32AtomAddr, u32Result) )
			{
				pSlotResUsed->u32AtomRdVal = u32Result;
			}
			else
			{
				PrintToCerr("%s: Atom Rd(%#x) cannot get result", __FUNCTION__, pSlotResUsed->u32AtomAddr);
			}
			return;
		}

		u32AddrMask	= pSlotResUsed->u32AddrMask;
		
		for (int k = 0; k < NUM_OF_UNITS; k++)
		{
			if ( GIsBitSet(u32AddrMask, k * 2) )
			{
				if ( (this->*get_rd_result)(pSlotResUsed->arrAddrs[k][0], u32Result) )
				{
					pSlotResUsed->arrValues[k][0] = u32Result;
				}
				else
				{
					PrintToCerr("%s: failed to get rd result(%#x)", __FUNCTION__, pSlotResUsed->arrAddrs[k][0]);
				}
				if ( GIsBitSet(u32AddrMask, k * 2 + 1) )
				{
					if ( (this->*get_rd_result)(pSlotResUsed->arrAddrs[k][1], u32Result) )
					{
						pSlotResUsed->arrValues[k][1] = u32Result;
					}
					else
					{
						PrintToCerr("%s: failed to get rd result(%#x)", __FUNCTION__, pSlotResUsed->arrAddrs[k][1]);
					}					
				}
			}
		}
	}
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::EX_ACTION()
{
		int *pintTemp;
		unsigned int u32InstrWord0, u32InstrWord1, u32OpCode;
		DSPU32 *arrPipeSlots, *arrSLKIdx;
		unsigned int u32NPC, u32NestLvl, u32_BPBValue,  u32ExcpMaskHigh, u32PC, u32Temp;
		bool bolIsExtBOnBit = false;
		bool bolIsExtBNOnAReg = false; // 根据地址寄存器的相对转移

		unsigned u32ExCond = 0;

		m_bolEXDone = true;
		u32r_SeqCounter_EX = PIPE_EX.AC_EX.m_right.u32_SeqCounter;
		m_bolStepInsn = true;

		u32InstrWord0 = PIPE_EX.AC_EX.m_right.uint32r_slot[0];
		u32InstrWord1 = PIPE_EX.AC_EX.m_right.uint32r_slot[1];
		u32NestLvl = PIPE_EX.AC_EX.m_right.u32_NestLvl;
		m_u32ExcpMask_EX = PIPE_EX.AC_EX.m_right.u32_ExcpMask;
		u32ExcpMaskHigh = PIPE_EX.AC_EX.m_right.u32_ExcpMaskHigh;
		u32PC = PIPE_EX.AC_EX.m_right.uint32r_pc;

		// 当前执行行之后的PC值
		u32NPC = PIPE_EX.AC_EX.m_right.uint32r_pc + PIPE_EX.AC_EX.m_right.u32r_SlotNum;
		arrPipeSlots = PIPE_EX.AC_EX.m_right.uint32r_slot;
		arrSLKIdx = PIPE_EX.AC_EX.m_right.u32r_slot_res;

		do_slots(arrPipeSlots, arrSLKIdx, PIPE_EX.AC_EX.m_right.uint32r_pc, PIPE_EX.AC_EX.m_right.u32r_SlotNum, PHASE_EX);
		if ( HAS_LOCAL_RD_REQ(PIPE_EX.AC_EX.m_right.u32RWMask) )
		{
			GetRdResult_INSN(PHASE_EX);		
		}
		
		if (IsExtFirstWord(u32InstrWord0))
		{
			// 如果是双字指令
			
			u32OpCode = GetOpcodeExt(u32InstrWord1);
			if (u32OpCode == op_ext_b_on_bit_etc_c)
			{
				// If {x,y,z,t}Rm[bit]==0 B <pro>
				// If {x,y,z,t}Rm[bit]==1 B <pro>

				// 因为op_ext_b_on_bit_etc_c中包含若干组指令
				// bolIsExtBOnBit为true表示为其中的分支指令
				bolIsExtBOnBit = (ExtractBinStr(u32InstrWord1, 18, 3) == 0)? true:false;
			}
			else if ((u32OpCode == op_ext_bn_on_u_cmp_c) || (u32OpCode == op_ext_bn_on_v_cmp_c) || (u32OpCode == op_ext_bn_on_w_cmp_c))
			{
				// If Um==C BN <pro>
				// If Um!=C BN <pro>
				bolIsExtBNOnAReg = true;
			}

			// 以上识别出双字分支指令的各种形式，便于
			// 以下根据双字分支指令的形式进一步处理
			
			if (u32OpCode == op_ext_b_lbl_etc_c)
			{
				switch ( ExtractBinStr(u32InstrWord1, 19, 2) )
				{
					case 0:  // zloop
						u32ExCond = 1;
						m_u32BRCnt++;
						if (m_bolEX_BCond)
						{
							// 若该指令的语义要求在EX级转移
							// 从指令字中提取出转移目标地址
							u32NPC = m_u32EX_BCondAddr;
							if ( !PIPE_EX.AC_EX.m_right.bolr_BPT)
							{
								// 若该指令已在FE2被预测为不发生分支，或者该指令在FE2未被处理过
								// 则进行纠错
								m_bolEXBraTaken = true;
								m_u32EXTgtAddr = u32NPC;
								m_u32MPCnt++;
							}							
						} // if (m_bolEX_BCond)
						else
						{
							// 若该指令的语义要求在EX级不进行转移
						
							if ( PIPE_EX.AC_EX.m_right.bolr_BPT )
							{
								// 若该指令已在FE2被预测为发生分支
								// 则进行纠错								
								m_bolEXBraTaken = true;

								// 计算顺序执行时在当前执行行之后的下一执行行的PC
								m_u32EXTgtAddr = PIPE_EX.AC_EX.m_right.uint32r_pc + PIPE_EX.AC_EX.m_right.u32r_SlotNum;
								m_u32MPCnt++;
							}							
						}										
						break;
					case 1:  // b label
						u32ExCond = 2;
						m_u32BRCnt++;
						// 从指令字中提取出转移目标地址
						u32NPC = (ExtractBinStr(u32InstrWord0, 0, 25) | (u32InstrWord1 << 25));

						if ( !PIPE_EX.AC_EX.m_right.bolr_BPT )
						{
							// 若该指令在FE2未被处理过
							m_bolEXBraTaken = true;
							m_u32EXTgtAddr = u32NPC;
							m_u32MPCnt++;
						}
#ifdef TEST_FUN_STATUS
						DSPU32 u32CylcleTemp = u32r_CyclesL;
						CurFunStatus.BeginCycle = u32CylcleTemp;
						CurFunStatus.JumpAddr = u32NPC;
						FunStatusBuf0.push(CurFunStatus);
#endif			
						break;
					case 2:  // call label
						u32ExCond = 3;
						m_u32BRCnt++;
						// 从指令字中提取出转移目标地址
						u32NPC = (ExtractBinStr(u32InstrWord0, 0, 25) | (u32InstrWord1 << 25));
						
						if ( !PIPE_EX.AC_EX.m_right.bolr_BPT )
						{
							// 若该指令在FE2未被处理过
							m_bolEXBraTaken = true;
							m_u32EXTgtAddr = u32NPC;
							m_u32MPCnt++;
						}
						if(m_bolABIChkEn)
						{
							if(m_u32ABIMask & CALLEE_SAVED_CHK)
							{
								SaveRegs();
							}						
						}
#ifdef TEST_FUN_STATUS
						DSPU32 u32CylcleTemp = u32r_CyclesL;
						CurFunStatus.BeginCycle = u32CylcleTemp;
						CurFunStatus.JumpAddr = u32NPC;
						FunStatusBuf0.push(CurFunStatus);
#endif					
						break;
				}
			}
			else if ( u32OpCode == op_ext_b_cmp_etc_c || bolIsExtBOnBit || bolIsExtBNOnAReg )
			{
				u32ExCond = 4;
				m_u32BRCnt++;
				// 从分支预测表中取历史信息
				u32_BPBValue = ReadBPB(PIPE_EX.AC_EX.m_right.uint32r_pc);
				
				if (m_bolEX_BCond)
				{
					// 若该指令的语义要求在EX级转移					
					u32NPC = m_u32EX_BCondAddr;
					if ( !PIPE_EX.AC_EX.m_right.bolr_BPT)
					{
						m_bolEXBraTaken = true;
						m_u32EXTgtAddr = u32NPC;
						m_u32MPCnt++;
					}			
				} // if (m_bolEX_BCond)
				else
				{
					// 若该指令的语义要求在EX级不进行转移				
					if (PIPE_EX.AC_EX.m_right.bolr_BPT)
					{
						m_bolEXBraTaken = true;
						// 计算顺序执行时在当前执行行之后的下一执行行的PC
						m_u32EXTgtAddr = PIPE_EX.AC_EX.m_right.uint32r_pc + PIPE_EX.AC_EX.m_right.u32r_SlotNum;
						m_u32MPCnt++;
					}
										
				}
				// 更新分支预测表
				if ( GIsBitSet(u32ro_CGCR, 13) )
				{
					WriteBPB( PIPE_EX.AC_EX.m_right.uint32r_pc, CalcBPB(u32_BPBValue, m_bolEX_BCond) );
				}
			} // if ( u32OpCode == op_ext_b_cmp_etc_c || bolIsExtBOnBit || bolIsExtBNOnAReg )
		} // if (IsExtFirstWord(u32InstrWord0))

		else if ( IsInstNoCalc(u32InstrWord0) )
		{
			u32OpCode = GetOpcodeNoCalc(u32InstrWord0);
			switch (u32OpCode)
			{
				case  op_iret_c:
				{	
					u32ExCond = 5;
					m_bolEXBraTaken = true;
					m_u32EXTgtAddr = u32ro_IRET_ADDR_ACEX;		
					m_bolEXIsIRET = true;
 
					u32NPC = m_u32EXTgtAddr;		
#ifndef BWSIM_PUB_MODE
					LogDMemOnIRET();
#endif
					break;
				}
				case  op_b_reg_c:
				{
					u32ExCond = 6;
					m_bolEXBraTaken = true;
 					if(PIPE_EX.AC_EX.m_right.arrCondRegsValid[BREG_BA] == true)
					{
						m_u32EXTgtAddr = PIPE_EX.AC_EX.m_right.arrCondRegsValue[BREG_BA];
					}
					else
					{
						m_u32EXTgtAddr = u32ro_BAR;
					}
					u32NPC = m_u32EXTgtAddr;
					break;
				}
				case  op_ret_c:
				{
					u32ExCond = 7;
					m_u32BRCnt++;
					if ( PIPE_EX.AC_EX.m_right.bol_Processed )
					{
						// 若该指令在FE2被处理过					
						if (PIPE_EX.AC_EX.m_right.u32r_RetBPC != u32ro_CJMP)
						{
							// 若该指令在FE2预测的转移目的地址不正确
							// 则进行纠错
							m_bolEXBraTaken = true;
							m_u32EXTgtAddr = u32ro_CJMP;
							m_u32MPCnt++;
						}
					}
					else
					{
						// 若该指令在FE2未被处理过					
						m_bolEXBraTaken = true;
						m_u32EXTgtAddr = u32ro_CJMP;
					}					
					u32NPC = u32ro_CJMP;
					if(m_bolABIChkEn)
					{
						if( m_u32ABIMask & CALLEE_SAVED_CHK)
						{
							CheckRegs();
						/*
							if(!CheckRegs())
							{
								bolr_TestEnd = true;
							}
						*/
						}					
					}

#ifdef TEST_FUN_STATUS
					CurFunStatus = FunStatusBuf0.top();
					FunStatusBuf0.pop();
					if(CurFunStatus.RetAddr != u32NPC)
					{
						CurFunStatus.RetAddr = u32NPC;
					}
					DSPU32 u32CylcleTemp = u32r_CyclesL;
					CurFunStatus.EndCycle = u32CylcleTemp;
					CurFunStatus.Cycles = CurFunStatus.EndCycle - CurFunStatus.BeginCycle;
					FunStatusBuf1.push(CurFunStatus);
					if(FunStatusBuf0.empty())
					{
						PrintFunStatus();
					}
#endif
					break;
				}
				case  op_call_reg_c:
				{
					u32ExCond = 8;
					m_bolEXBraTaken = true;
					if(PIPE_EX.AC_EX.m_right.arrCondRegsValid[BREG_SRP] == true)
					{
						m_u32EXTgtAddr = PIPE_EX.AC_EX.m_right.arrCondRegsValue[BREG_SRP];
					}
					else
					{
						m_u32EXTgtAddr = u32ro_SRP;
					}
					u32NPC = m_u32EXTgtAddr;
#ifdef TEST_FUN_STATUS
					DSPU32 u32CylcleTemp = u32r_CyclesL;
					CurFunStatus.BeginCycle = u32CylcleTemp;
					CurFunStatus.JumpAddr = u32NPC;
					FunStatusBuf0.push(CurFunStatus);
#endif
					break;
				}
				case op_areg_cb_reg_c:
				{
					u32ExCond = 9;
					u32NPC = PIPE_EX.AC_EX.m_right.u32CB_NPC;
					break;
				}
				
				case op_bn_label_c:
				{
					u32ExCond = 10;
					m_u32BRCnt++;
					u32NPC = ExtractBinStr(u32InstrWord0, 0, 17);
					u32NPC = ( GSignExtend(u32NPC, 17) + PIPE_EX.AC_EX.m_right.uint32r_pc);
					if(!PIPE_EX.AC_EX.m_right.bolr_BPT)
					{
						m_bolEXBraTaken = true;
						m_u32EXTgtAddr = u32NPC;
						m_u32MPCnt++;
					}
					break;
				}
				case op_strap_c:
				{
					if ( GetNestLvl(u64r_PMASK) != 0x3E )
					{
						// 若当前流水线中没有strap正在被服务
						// 即若有strap正在被服务，则忽略本次strap
						
						m_bolEXBraTaken = true;
						m_u32EXTgtAddr = 0;
					}
					break;
				}
			} // switch (u32OpCode)
		} // single word instruction

		if ((m_u32ExcpMask_EX != 0) || (u32ExcpMaskHigh != 0))
		{
			// 若检测到异常，完全清空后部流水线
			// 下一个节拍，流水线进入停顿状态		
			m_bolEXBraTaken = true;
			m_u32EXTgtAddr = u32NPC;		
			m_bolEXIsExcp = true;
//			u32NPC = m_u32EXTgtAddr;
		}

#ifdef LIBTESTCODE
		if (m_CodeCovForLibTest)
		{
			if (IsExtFirstWord(u32InstrWord0))
			{
				// 如果是双字指令
				u32OpCode = GetOpcodeExt(u32InstrWord1);
				if (u32OpCode == op_ext_b_on_bit_etc_c  &&  ExtractBinStr(u32InstrWord1, 18, 3) == 0)
				{
					//PrintConditionPCToTmpFile(PIPE_EX.AC_EX.m_right.uint32r_pc,m_bolEXBraTaken);
					if (m_bolEXBraTaken)
						m_cond_pc[PIPE_EX.AC_EX.m_right.uint32r_pc].cnttrue++;
					else
						m_cond_pc[PIPE_EX.AC_EX.m_right.uint32r_pc].cntfalse++;
				}
				else if (u32OpCode == op_ext_b_lbl_etc_c && ExtractBinStr(u32InstrWord1, 19, 2) == 0)
				{
					//PrintConditionPCToTmpFile(PIPE_EX.AC_EX.m_right.uint32r_pc,m_bolEXBraTaken);
					if (m_bolEXBraTaken)
						m_cond_pc[PIPE_EX.AC_EX.m_right.uint32r_pc].cnttrue++;
					else
						m_cond_pc[PIPE_EX.AC_EX.m_right.uint32r_pc].cntfalse++;
				}
				else if((u32OpCode == op_ext_b_cmp_etc_c) || (u32OpCode == op_ext_bn_on_u_cmp_c) || (u32OpCode == op_ext_bn_on_v_cmp_c) || (u32OpCode == op_ext_bn_on_w_cmp_c))
				{
					//PrintConditionPCToTmpFile(PIPE_EX.AC_EX.m_right.uint32r_pc,m_bolEXBraTaken);
					if (m_bolEXBraTaken)
						m_cond_pc[PIPE_EX.AC_EX.m_right.uint32r_pc].cnttrue++;
					else
						m_cond_pc[PIPE_EX.AC_EX.m_right.uint32r_pc].cntfalse++;
				}				
			}
		}				
#endif

		if(m_u32TraceState == 1) {
			char* BranchReason;
			switch (u32ExCond) {
			case 1:
			case 4:
			case 10:
				if(m_bolEX_BCond) {
					m_u32TraceCase3++;
				}
				break;
			case 2:
			case 3:
				m_u32TraceCase3++;
				break;
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
				// Base on Reg
				m_u32TraceCase1++;
				break;
			}
			if(u32ExCond > 0) {
				DSPU32 u32DeltaPC = PIPE_EX.AC_EX.m_right.uint32r_pc - m_u32TraceBasePC;
				DSPU32 u32DeltaTime = m_u32CyclesL - m_u32TraceBaseTime;
				bool bolPCRecorded = false;
				bool bolTimeRecorded = false;
				for(int i = 4; i >0; i--) {
					u32DeltaPC >>= (i*7);
					u32DeltaTime >>= (i*7);
					if(!bolPCRecorded && u32DeltaPC > 0) {							
						m_arrDeltaPC[i-1]++;
						bolPCRecorded = true;
					}
					if(!bolTimeRecorded && u32DeltaTime > 0) {							
						m_arrDeltaTime[i-1]++;
						bolTimeRecorded = true;
					}
				}				
			}
			switch(u32ExCond) {
				case 1:
					BranchReason = "ZLoop";
					break;
				case 2:
					BranchReason = "BLabel";
					break;
				case 3:
					BranchReason = "CallLabel";
					break;
				case 4:
					BranchReason = "BCmp";
					break;
				case 5:
					BranchReason = "IRet";
					break;
				case 6:
					BranchReason = "BReg";
					break;
				case 7:
					BranchReason = "Ret";
					break;
				case 8:
					BranchReason = "CallReg";
					break;
				case 9:
					BranchReason = "CB";
					break;
				case 10:
					BranchReason = "BN";
					break;
				default:
					BranchReason = "Other";
					break;					
			}

			/*
			FILE *fp = NULL;
			sprintf(g_arrFileName, "%s/EXLog.txt", g_arrIOPath);
			if ((fp = fopen(g_arrFileName, "a+")) == NULL)	{
				PrintToCerr("Error occured when open PipePC.txt\n");
			}
			fprintf(fp, "Cycle: %08x\tEPC: %08x\tReason: %s\tFrom: %08x\tTo:%08x\n", 
				(unsigned int)u32r_CyclesL, (unsigned int)u32r_EPC, BranchReason, 
				PIPE_EX.AC_EX.m_right.uint32r_pc, u32NPC);
			fclose(fp);
			*/			
		}

		
		u32r_EX_NPC = u32NPC;		
		PIPE_EX.EX_WB.m_left.u32_ExcpMask = m_u32ExcpMask_EX;
		PIPE_EX.EX_WB.m_left.u32_ExcpMaskHigh = u32ExcpMaskHigh;
		if(m_u32ExcpMask_EX != 0)
		{
			u32ri_ExcpCode = m_u32ExcpMask_EX;
			u32ri_ExcpPC = u32PC;
		}
//		UpdateECR(m_u32ExcpMask_EX, u32ExcpMaskHigh, u32PC);
}

//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::WB_ACTION()
{
		DSPU32 *arrPipeSlots, *arrSLKIdx;
		unsigned int u32InstrWord0, u32InstrWord1, u32OpCode, u32TrapCode;

		m_bolWBDone = true;		
		u32r_SeqCounter_WB = PIPE_EX.EX_WB.m_right.u32_SeqCounter;
		//m_u32ExcpMask_WB = PIPE_EX.EX_WB.m_right.u32_ExcpMask;
		//m_u32ExcpMaskHigh_WB = PIPE_EX.EX_WB.m_right.u32_ExcpMaskHigh;

#ifdef INTERRUPT_TESTING
		m_u32WBPC = PIPE_EX.EX_WB.m_right.uint32r_pc;
		m_u32WBNestLvl = PIPE_EX.EX_WB.m_right.u32_NestLvl;
#endif

#ifdef LIBTEST
		if(m_bolTestForLib)
		{
			if(m_TestLibInput.MallocAddr != 0)
			{
				if(PIPE_EX.EX_WB.m_right.uint32r_pc == m_TestLibInput.MallocAddr)
				{
					m_TestLibOutput.UseMalloc = true;
				}
			}

			if(m_TestLibInput.INTLockAddr != 0)
			{
				if(PIPE_EX.EX_WB.m_right.uint32r_pc == m_TestLibInput.INTLockAddr)
				{
					m_TestLibOutput.INTStartTime = u32r_CyclesL;
				}

				if(PIPE_EX.EX_WB.m_right.uint32r_pc == m_TestLibInput.INTUnLockAddr)
				{
					m_TestLibOutput.INTEndTime = u32r_CyclesL;
					m_TestLibOutput.IntTime = m_TestLibOutput.INTEndTime - m_TestLibOutput.INTStartTime;
				}
			}
		}
#endif

		arrPipeSlots = PIPE_EX.EX_WB.m_right.uint32r_slot;
		arrSLKIdx = PIPE_EX.EX_WB.m_right.u32r_slot_res;
		
		u32InstrWord0 = arrPipeSlots[0];
		u32InstrWord1 = arrPipeSlots[1];
		
		
		do_slots(arrPipeSlots, arrSLKIdx, PIPE_EX.EX_WB.m_right.uint32r_pc, PIPE_EX.EX_WB.m_right.u32r_SlotNum, PHASE_WB);

		UpdateOAFlags();    // Update "OR" "AND" flag registers

		UpdateBKFlags();

		if (IsExtFirstWord(u32InstrWord0))
		{
			// do nothing
		}
		else if ( IsInstNoCalc(u32InstrWord0) )
		{
			u32OpCode = GetOpcodeNoCalc(u32InstrWord0);
			switch (u32OpCode)
			{
				case  op_rtrap_c:
				{
					u32TrapCode = u32InstrWord0 & 0x3F;
					SimService(u32TrapCode, u32ro_R[50], u32ro_R[51], u32ro_R[52]);
					break;
				}
				//case  op_strap_c:
				//{
					
				//	break;
				//}

			} // switch

		} // else if ( IsInstNoCalc(u32InstrWord0) )

		//free space holding resource info
		m_WB_bolFreeWBInRes = true;

}
//-------------------------------------------------------------------------------------------------------------------------------
// 返回true表示由p_u32InstrWord0构成的单字指令或(p_u32InstrWord0, p_u32InstrWord1)构成的双字指令
// 是在EX级可能进行转移的指令
//
bool sc_iss::IsBInstInEX(DSPU32 p_u32InstrWord0, DSPU32 p_u32InstrWord1)
{
	DSPU32 u32OpCode;
	bool bolIsBInstInEX = false;
	bool bolIsExtBOnBit, bolIsExtBNOnAReg;

	bolIsExtBOnBit = false;
	bolIsExtBNOnAReg = false;
		
	if (IsExtFirstWord(p_u32InstrWord0))
	{
		// 如果是双字指令
		
		u32OpCode = GetOpcodeExt(p_u32InstrWord1);
		if (u32OpCode == op_ext_b_on_bit_etc_c)
		{
			// If {x,y,z,t}Rm[bit]==0 B <pro>
			// If {x,y,z,t}Rm[bit]==1 B <pro>

			// 因为op_ext_b_on_bit_etc_c中包含若干组指令
			// bolIsExtBOnBit为true表示为其中的分支指令
			bolIsExtBOnBit = (ExtractBinStr(p_u32InstrWord1, 18, 3) == 0)? true:false;
		}
		else if ((u32OpCode == op_ext_bn_on_u_cmp_c) || (u32OpCode == op_ext_bn_on_v_cmp_c) || (u32OpCode == op_ext_bn_on_w_cmp_c))
		{
			// If Um==C BN <pro>
			// If Um!=C BN <pro>
			bolIsExtBNOnAReg = true;
		}

		// 以上识别出双字分支指令的各种形式，便于
		// 以下根据双字分支指令的形式进一步处理
		
		if (u32OpCode == op_ext_b_lbl_etc_c)
		{
			switch ( ExtractBinStr(p_u32InstrWord1, 19, 2) )
			{
				case 0:  // zloop
				case 1:  // b label
				case 2:  // call label
					bolIsBInstInEX = true;
					break;
			}
		}
		else if ( u32OpCode == op_ext_b_cmp_etc_c || bolIsExtBOnBit || bolIsExtBNOnAReg )
		{
			bolIsBInstInEX = true;
		}
		
	} // if (IsExtFirstWord(p_u32InstrWord0))

	else if ( IsInstNoCalc(p_u32InstrWord0) )
	{
		u32OpCode = GetOpcodeNoCalc(p_u32InstrWord0);
		switch (u32OpCode)
		{
			case  op_iret_c:
			case  op_b_reg_c:
			case  op_ret_c:
			case  op_call_reg_c:
			case  op_strap_c:
			case op_bn_label_c:
				bolIsBInstInEX = true;
			break;

		}
	} // single word instruction

	
	return bolIsBInstInEX;
}
//-------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::IsIRET(DSPU32 p_u32InstrWord)
{	
	DSPU32 u32OpCode;

	if ( IsInstNoCalc(p_u32InstrWord) )
	{
		u32OpCode = GetOpcodeNoCalc(p_u32InstrWord);
		if (u32OpCode == op_iret_c)
		{
			return true;
		}	
	}
	
	return false;
}
void sc_iss::ManageDataHzdBefDC4()
{
	if (!m_bolFatalExcp && !bolro_Idle )
	{
		if ( !PIPE_EX.AC_EX.m_left.hzd_mask.bolFilled )
		{
			FillHzdMask_AC();
			PIPE_EX.AC_EX.m_left.hzd_mask.bolFilled = true;
		}
		m_AC_bolHazardStall_ACEX = DetectDataHzd_AC();
	}
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::ManageDataHazard()
{
	if ( !m_bolStall_ACEX)
	{
		// check if CPred Hazard
		m_DC4_bolCPredStall_DC4AC = DetectCPredHzd_DC4();
		if ( !m_DC4_bolCPredStall_DC4AC )
		{
			// 解除关于u32r_EX_NPC的相关性
			m_DC4_bolISRStall_DC4AC = DetectISRHzd_DC4();
			if ( !m_DC4_bolISRStall_DC4AC )
			{
				// 检查是否IRET指令位于DC4且前方紧邻一条分支指令
				m_DC4_bolIRETStall_DC4AC = DetectIRETHzd_DC4();
			}
		}

	}
}
//-------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::DetectIRETHzd_DC4()
{
	DSPU32 u32DC4IWord, u32ACIWord0, u32ACIWord1;

	u32DC4IWord = PIPE_EX.DC3_DC4.m_right.uint32r_slot[0];
	u32ACIWord0 = PIPE_EX.DC4_AC.m_right.uint32r_slot[0];
	u32ACIWord1 = PIPE_EX.DC4_AC.m_right.uint32r_slot[1];
	if ( IsIRET(u32DC4IWord) && IsBInstInEX(u32ACIWord0, u32ACIWord1) )
	{
#ifdef STALL_REASON_LOG
		LogPipeStall(IRET_HAZARD, PIPE_EX.DC3_DC4.m_right.uint32r_pc, 0, 0, PHASE_AC);
#endif
		return true;
	}

	return false;
}
//-------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::DetectISRHzd_DC4()
{
	//--------------whether the first instruction line of ISR is in DC4--------------

	// if output of DC3/DC4 or DC4/AC is bubble, then check isn't needed
	if ( (PIPE_EX.DC3_DC4.m_right.u32r_SlotNum != 0) && (PIPE_EX.DC4_AC.m_right.u32r_SlotNum != 0) )
	{
		// if output of DC4/AC and AC/EX are same, then check isn't needed
		if (PIPE_EX.DC4_AC.m_right.u32r_slot_res[0] != PIPE_EX.AC_EX.m_right.u32r_slot_res[0])
		{
			if (PIPE_EX.DC3_DC4.m_right.u32_NestLvl > PIPE_EX.DC4_AC.m_right.u32_NestLvl)
			{
#ifdef STALL_REASON_LOG
		LogPipeStall(ISR_HAZARD, PIPE_EX.DC3_DC4.m_right.uint32r_pc, 0, 0, PHASE_AC);
#endif			
				return true;
			}
		}
		else
		{
			// 此分支是否可达?
			int intNoUse = 0;
		}
	}

	return false;
}
//-------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::DetectCPredHzd_DC4()
{
	DSPU32 u32SLKIdx_DC4, u32SLKIdx_AC;
	DSPU32 u32SlotNum_DC4, u32SlotNum_AC;
	DSPU32 u32SrcCPred, u32DestCPred, u32ConfRegs;

	u32SlotNum_DC4 = PIPE_EX.DC3_DC4.m_right.u32r_SlotNum;
	u32SlotNum_AC = PIPE_EX.DC4_AC.m_right.u32r_SlotNum;

	u32SrcCPred = 0;
	for(int i = 0; i < u32SlotNum_DC4; i++)
	{
		u32SLKIdx_DC4 = PIPE_EX.DC3_DC4.m_right.u32r_slot_res[i];	
		u32SrcCPred |= m_arrResSLK[u32SLKIdx_DC4].slot_res_used.u32SrcCPred;
	}
	if ( u32SrcCPred == 0 )
	{
		return false;
	}

	u32DestCPred = 0;
	for(int i = 0; i < u32SlotNum_AC; i++)
	{
		u32SLKIdx_AC = PIPE_EX.DC4_AC.m_right.u32r_slot_res[i];
		u32DestCPred |= m_arrResSLK[u32SLKIdx_AC].slot_res_used.u32DestCPred;
	}

	u32ConfRegs = (u32SrcCPred & u32DestCPred);

	if ( u32ConfRegs == 0 )
	{
		return false;
	}
	
	#ifdef STALL_REASON_LOG
		LogPipeStall(CPRED_HAZARD, PIPE_EX.DC3_DC4.m_right.uint32r_pc, (GetLSB_32(u32ConfRegs)>>3), 0, PHASE_AC);
	#endif
	
	return true;	
}


//-------------------------------------------------------------------------------------------------------------------------------
// 返回0表示没有发现相关性

bool sc_iss::DetectDataHzd_AC()
{
	HZD_MASK_T *pHzdMask_AC, *pHzdMask_EX, *pHzdMask_WB;
	DSPU32 u32ConfSHF;
	DSPU64 u64ConfRegs = 0ULL;
	DSPU64 u64DestRegMask, u64SrcRegMask;
	#ifdef GPR_FWD
	bool bolFwdEn = true;
	#else
	bool bolFwdEn = GIsBitSet(u32ro_CGCR, 14);
	#endif

	pHzdMask_AC = &(PIPE_EX.AC_EX.m_left.hzd_mask);
	pHzdMask_EX = &(PIPE_EX.AC_EX.m_right.hzd_mask);
	pHzdMask_WB = &(PIPE_EX.EX_WB.m_right.hzd_mask);
	
	if(PIPE_EX.AC_EX.m_right.u32r_SlotNum != 0)
	{
		for(int i = 0; i < NUM_OF_UNITS*2; i++)
		{
			// EX级不能产生前推
			u64ConfRegs = (pHzdMask_AC->arrSrcRegMask[i] & pHzdMask_EX->arrDestRegMask[i]);				
			if ( u64ConfRegs != 0ULL )
			{
			#ifdef STALL_REASON_LOG
				if(PIPE_EX.DC4_AC.m_right.uint32r_pc == 0)
				{
					LogPipeStall(GPR_HAZARD_MR, PIPE_EX.DC3_DC4.m_right.uint32r_pc, (i%4), GetLSB_64(u64ConfRegs), PHASE_EX);
				}
				else
				{
					LogPipeStall(GPR_HAZARD_NI, PIPE_EX.DC4_AC.m_right.uint32r_pc, (i%4), GetLSB_64(u64ConfRegs), PHASE_EX);
				}
			#endif			
				return true;
			}
		}
		u32ConfSHF = (pHzdMask_AC->u32RdSACC & pHzdMask_EX->u32WrSACC);
		if ( u32ConfSHF != 0 )
		{
		#ifdef STALL_REASON_LOG
			LogPipeStall(SACC_HAZARD, PIPE_EX.DC4_AC.m_right.uint32r_pc, NUM_OF_UNITS, GetLSB_32(u32ConfSHF),PHASE_EX);
		#endif		
			return true;
		}

		for(int i = 0; i < NUM_OF_UNITS; i++)
		{
			u32ConfSHF = (pHzdMask_AC->u32RdSTAB[i] & pHzdMask_EX->u32WrSTAB[i]);
			if(u32ConfSHF != 0)
			{
			#ifdef STALL_REASON_LOG
				LogPipeStall(STAB_HAZARD, PIPE_EX.DC4_AC.m_right.uint32r_pc, i, GetLSB_32(u32ConfSHF), PHASE_EX);
			#endif			
				return true;
			}
			u32ConfSHF = (pHzdMask_AC->u32WrSTAB_AC[i] & pHzdMask_EX->u32WrSTAB_EX[i]);
			if(u32ConfSHF != 0)
			{
				return true;
			}
		}

		DSPU32 u32ConfAMACC = pHzdMask_AC->u32RdAMACCMask & pHzdMask_EX->u32WrAMACCMask;

		if(u32ConfAMACC != 0)
		{
				DSPU32 u32Units = (GetLSB_32(u32ConfAMACC) >> 3);
				DSPU32 u32Muls = (GetLSB_32(u32ConfAMACC) - (u32Units << 3) );
		#ifdef STALL_REASON_LOG
				LogPipeStall(AMACC_HAZARD, PIPE_EX.DC4_AC.m_right.uint32r_pc, u32Units, u32Muls, PHASE_EX);
		#endif
			return true;
		}

	}

	if(PIPE_EX.EX_WB.m_right.u32r_SlotNum != 0)
	{
		for(int i = 0; i < NUM_OF_UNITS*2; i++)
		{
			if(bolFwdEn)
			{
				u64SrcRegMask = (pHzdMask_AC->arrSrcRegMask_NUL[i] | pHzdMask_AC->arrSrcRegMask_SHF[i] | \
					pHzdMask_AC->arrSrcRegMask_ALU[i] | pHzdMask_AC->arrSrcRegMask_MUL[i]);
			
				u64DestRegMask = (pHzdMask_WB->arrDestRegMask_NUL[i] | pHzdMask_WB->arrDestRegMask_SHF[i] | \
					pHzdMask_WB->arrDestRegMask_ALU[i] | pHzdMask_WB->arrDestRegMask_MUL[i]);

				u64ConfRegs |= (pHzdMask_AC->arrSrcRegMask_NUL[i] & u64DestRegMask);
				u64ConfRegs |= (u64SrcRegMask & pHzdMask_WB->arrDestRegMask_NUL[i]);

				u64ConfRegs |= (pHzdMask_AC->arrSrcRegMask_SHF[i] & pHzdMask_WB->arrDestRegMask_MUL[i]);
				u64ConfRegs |= (pHzdMask_AC->arrSrcRegMask_ALU[i] & pHzdMask_WB->arrDestRegMask_ALU[i]);
				u64ConfRegs |= (pHzdMask_AC->arrSrcRegMask_MUL[i] & pHzdMask_WB->arrDestRegMask_SHF[i]);
				u64ConfRegs |= (pHzdMask_AC->arrSrcRegMask_MUL[i] & pHzdMask_WB->arrDestRegMask_MUL[i]);
			}
			else
			{
				u64ConfRegs = (pHzdMask_AC->arrSrcRegMask[i] & pHzdMask_WB->arrDestRegMask[i]);
			}			
			if ( u64ConfRegs != 0 )
			{
			#ifdef STALL_REASON_LOG
				if(PIPE_EX.DC4_AC.m_right.uint32r_pc == 0)
				{
					LogPipeStall(GPR_HAZARD_MR, PIPE_EX.DC3_DC4.m_right.uint32r_pc, (i%4), GetLSB_64(u64ConfRegs), PHASE_WB);
				}
				else
				{
					LogPipeStall(GPR_HAZARD_NI, PIPE_EX.DC4_AC.m_right.uint32r_pc, (i%4), GetLSB_64(u64ConfRegs), PHASE_WB);
				}
			#endif						
				return true;
			}
		}
		
		u32ConfSHF = (pHzdMask_AC->u32RdSACC & pHzdMask_WB->u32WrSACC);
		if ( u32ConfSHF != 0 )
		{
		#ifdef STALL_REASON_LOG
			LogPipeStall(SACC_HAZARD, PIPE_EX.DC4_AC.m_right.uint32r_pc, NUM_OF_UNITS, GetLSB_32(u32ConfSHF), PHASE_WB);
		#endif				
			return true;
		}
		/*
		for(int i = 0; i < NUM_OF_UNITS; i++)
		{
			u32ConfSHF = (pHzdMask_AC->u32RdSTAB[i] & pHzdMask_WB->u32WrSTAB[i]);
			if(u32ConfSHF != 0)
			{
			#ifdef STALL_REASON_LOG
				LogPipeStall(STAB_HAZARD, PIPE_EX.DC4_AC.m_right.uint32r_pc, i, GetLSB_32(u32ConfSHF), PHASE_WB);
			#endif			
				return true;
			}
		}
		*/
	}	
	return false;
}

//-------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::AccessSameBank(DSPU32 p_u32MemAddr0, DSPU32 p_u32MemAddr1)
{
	bool bolAccessFound = false;

	if ( (p_u32MemAddr0 >= BLK0_LOW_ADDR) && (p_u32MemAddr0 <= BLK0_HIGH_ADDR) )
	{
		if ( (p_u32MemAddr1 >= BLK0_LOW_ADDR) && (p_u32MemAddr1 <= BLK0_HIGH_ADDR) )
		{
			if ((p_u32MemAddr0 % 8) == (p_u32MemAddr1 % 8))
			{
				bolAccessFound = true;
			}
		}
	}
	else if ( (p_u32MemAddr0 >= BLK1_LOW_ADDR) && (p_u32MemAddr0 <= BLK1_HIGH_ADDR) )
	{
		if ( (p_u32MemAddr1 >= BLK1_LOW_ADDR) && (p_u32MemAddr1 <= BLK1_HIGH_ADDR) )
		{
			if ((p_u32MemAddr0 % 8) == (p_u32MemAddr1 % 8))
			{
				bolAccessFound = true;
			}
		}
	}
	else if ( (p_u32MemAddr0 >= BLK2_LOW_ADDR) && (p_u32MemAddr0 <= BLK2_HIGH_ADDR) )
	{
		if ( (p_u32MemAddr1 >= BLK2_LOW_ADDR) && (p_u32MemAddr1 <= BLK2_HIGH_ADDR) )
		{
			if ((p_u32MemAddr0 % 8) == (p_u32MemAddr1 % 8))
			{
				bolAccessFound = true;
			}
		}
	}

	return bolAccessFound;
}
//-------------------------------------------------------------------------------------------------------------------------------
// 检测位于DC1/DC2的指令与其前方DC2/DC3, DC3/DC4, DC4/AC间是否存在地址寄存器相关
//
// AddrRegs are read in DC2 and written in AC
// hazard between DC1/DC2 and DC2/DC3 should be checked
// hazard between DC1/DC2 and DC3/DC4 should be checked
// hazard between DC1/DC2 and DC4/AC should be checked
//
// return 1 means hazard found
//
bool sc_iss::DetectDataHzd_DC2()
{
		DSPU32 arrSLKIdx0[MAX_INUM_LINE], arrSLKIdx1[MAX_INUM_LINE];
		DSPU32 u32SlotNum0, u32SlotNum1;		
		DSPU32 arrDregsIDX[MAX_INUM_LINE];		
		DSPU32 arrSrcRegs[NUM_OF_ADDR_UNITS];		
		DSPU32 u32BpRegs = 0;
		DSPU32 u32NestLvl = PIPE_EX.DC1_DC2.m_right.u32_NestLvl;
		DSPU32 u32SLKIdx;
		bool bolAreg_is_greg;
		int i, j, k;

		enum UVW_IDX{U_IDX, V_IDX, W_IDX, MAX_IDX};

		// bubble needn't to detect hazard
		if (PIPE_EX.DC1_DC2.m_right.u32r_SlotNum == 0)  // bubble
		{
			return false;
		}
		
		for(i = 0; i < NUM_OF_ADDR_UNITS; i++)
		{
			arrSrcRegs[i] = 0;
		}
		
		// read data from pipeline to local variable
		u32SlotNum0 = PIPE_EX.DC1_DC2.m_right.u32r_SlotNum;
		for (i = 0; i < u32SlotNum0; i++)
		{
			//SLKIdx is malloced at DC2 stage in DC2_ACTION
			u32SLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i];
			arrSrcRegs[U_IDX] |= m_arrResSLK[u32SLKIdx].slot_res_used.u32SrcU;
			arrSrcRegs[V_IDX] |= m_arrResSLK[u32SLKIdx].slot_res_used.u32SrcV;
			arrSrcRegs[W_IDX] |= m_arrResSLK[u32SLKIdx].slot_res_used.u32SrcW;			
		}

		// This insn-line(at DC2 stage) use no addr reg at all (liuyu)
		if( (arrSrcRegs[U_IDX] | arrSrcRegs[V_IDX] | arrSrcRegs[W_IDX]) == 0 )
		{
			return false;
		}
		
		if ( DetectHzd_DC2(PIPE_EX.DC2_DC3.m_right.u32r_slot_res, PIPE_EX.DC2_DC3.m_right.u32r_SlotNum, arrSrcRegs, PHASE_DC3) )
		{
			return true;
		}
		else if ( DetectHzd_DC2(PIPE_EX.DC3_DC4.m_right.u32r_slot_res, PIPE_EX.DC3_DC4.m_right.u32r_SlotNum, arrSrcRegs, PHASE_DC4) )
		{
			return true;
		}
		else if( DetectHzd_DC2(PIPE_EX.DC4_AC.m_right.u32r_slot_res, PIPE_EX.DC4_AC.m_right.u32r_SlotNum, arrSrcRegs, PHASE_AC) )
		{
			return true;
		}
		else
		{
			return false;
		}
}
/*
//-----------------------------------------------------------------------------------
void sc_iss::DetectINT()
{
		DSPU64 u64BitChk, u64PMASK_R;
		unsigned int u32INTLvl;
		bool bolINTDetected, bolIntInSrv, bolEnIntNest;

		for (int i = 0; i <= MAX_INT_LVL; i++)
		{
			bolINTDetected = false;

			// from high priority to low priority
			u32INTLvl = MAX_INT_LVL - i;
			u64BitChk = GenDSPU64(0x80000000, 0) >> i;
			if ( (u64ro_ILAT & u64BitChk) != 0)
			{
				bolINTDetected = true;
			}

			if ( bolINTDetected )
			{
				u64PMASK_R = GetPMASK_R(u64r_PMASK);
				if ( u32INTLvl == EXCP_INT_LVL )  // Exception
				{
					// 软件中断不受中断嵌套控制位影响
					
					if ( (u64ro_IMASK & u64PMASK_R & u64BitChk) != 0 )
					{
						m_bolINTOccur = true;
						m_u32INTLvl = u32INTLvl;
						break;
					}
				}
				else if ( GIsBitSet(u32ro_CGCR, 0) ) // 是否全局开中断
				{
					if ( (u64ro_IMASK & u64PMASK_R & u64BitChk) != 0 )
					{
						// is there interrupt in service
						bolIntInSrv = ((u64r_PMASK & GenDSPU64(0xFFFFFFFF, 0xFFFFFFFF)) != 0)? true:false;
						// if enable interrup nesting
						bolEnIntNest = GIsBitSet(u32ro_CGCR, 1);

						if (!bolIntInSrv)
						{
							// 若没有中断服务正在执行
							m_bolINTOccur = true;
							m_u32INTLvl = u32INTLvl;
							break;
						}
						else if (bolEnIntNest)
						{
							// 若允许中断嵌套
							m_bolINTOccur = true;
							m_u32INTLvl = u32INTLvl;
							break;
						}
					}

				}  // else if ( GIsBitSet(u32ro_CGCR, 0) )

			} // if ( bolINTDetected )

		} // for (int i = 0; i <= MAX_INT_LVL; i++)

}
*/
//-----------------------------------------------------------------------------------
void sc_iss::DetectINT()
{
	int i32INTLvl, i32SrvLvl;
	bool bolEnGInt, bolEnIntNest, bolIntInSrv;

	i32INTLvl = GetMSB_64( u64ro_IMASK & u64ro_ILAT );	// IMASK和ILAT必须同时开启
	i32SrvLvl = GetMSB_64( (DSPU64)u64r_PMASK );
	
	bolEnGInt = GIsBitSet(u32ro_CGCR, 0);
	bolEnIntNest = GIsBitSet(u32ro_CGCR, 1);

	if(i32INTLvl == -1 || !bolEnGInt)
	{
		bolri_INTOccur = false;
		i32ri_INTLvl = -1;
	}
	// 新发生的中断级别大于正在被服务的中断级别[-1, 63]
	if ( i32INTLvl > i32SrvLvl )
	{
		// 1. 软件中断不受中断嵌套控制位影响
		if ( i32INTLvl == EXCP_INT_LVL )
		{
			bolri_INTOccur = true;
			i32ri_INTLvl = i32INTLvl;
		}
		// 2. 硬件中断首先检查全局中断使能位
		else if (bolEnGInt)
		{
			bolIntInSrv = (i32SrvLvl >= 0);

			// 再检查是否有中断正在服务，或允许中断嵌套(中断级别不同)
			if ( !bolIntInSrv || bolEnIntNest )
			{
				bolri_INTOccur = true;
				i32ri_INTLvl = i32INTLvl;
			}
		}
	}
}

//-----------------------------------------------------------------------------------
void sc_iss::DetectFatalExcp()
{
	if ( !m_bolFatalExcp )
	{
		if (u32ro_ExcpCode != 0)
		{
			m_bolFatalExcp = true;
//			bolr_TestEnd = true;
			sprintf(g_arrLisaMsg, "Fatal exception detected, exception code is 0x%x\n", u32ro_ExcpCode);
			PrintToCerr(g_arrLisaMsg);
		}
	}		
}
//-----------------------------------------------------------------------------------
// 供cache内部的仲裁逻辑使用
//
void sc_iss::NotifyCacheUpdatefpc()
{
	m_pICACHE->NotifyIntInfo_software(bolro_INTOccur);
}
//-----------------------------------------------------------------------------------
void sc_iss::PutFlushInfoToCache()
{
	DSPU32 u32PC = 0;

	if (m_bolEXBraTaken && (!m_bolEXIsIRET) && (!m_bolEXIsExcp) && (PIPE_EX.AC_EX.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK) ))
	{
		u32PC = m_u32EXTgtAddr;
	}
	else if( m_bolCondBraTaken && (PIPE_EX.DC2_DC3.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK)) )
	{
		u32PC = (DSPU32)u32r_CBTgtAddr;
	}
	if ( m_EX_bolFlushIABP1  || m_CB_bolFlushIABP1 )
	{
		m_pICACHE->NotifyPipeBefFlushInfo_software(true, m_u32INTLvlToCache, u32PC);
	}
	else
	{
		if(m_bolACBraTaken)
		{
			if(m_pICACHE->GetCacheBusyStatus())
			{
				// DMA过程中不需要提供中断刷流水信息，将其寄存下来直到Cache放开
				bolr_CacheBusyISRFlushed = true;
				u32r_CacheBusySavedPC = m_u32ACTgtAddr;
			}
			else
			{
				// 正常情况
				m_pICACHE->NotifyPipeBefFlushInfo_software(true, 0x3f, m_u32ACTgtAddr);
				bolr_CacheBusyISRFlushed = false;
			}			
		}
		else if(bolr_CacheBusyISRFlushed && !m_pICACHE->GetCacheBusyStatus())
		{
			// DMA完成时发现有寄存的中断撤销信息
			m_pICACHE->NotifyPipeBefFlushInfo_software(true, 0x3f, u32r_CacheBusySavedPC);
			bolr_CacheBusyISRFlushed = false;
		}
		else
		{			
			m_pICACHE->NotifyPipeBefFlushInfo_software(false, 0, 0);
		}
	}
}
//-----------------------------------------------------------------------------------
void sc_iss::UpdateFPC()
{
	DSPU32 u32PCNotAlign, u32INTLvl;
	DSPU64 u64Temp;
	DSPU32 u32Temp;

	bool bolISRFirstLine = false;
	bool bolIsNormalSeq = false;	

	if(bolro_Idle)
		m_u32IdleTick++;
	else
		m_u32IdleTick = 0;

	 bool bolHelp = false;
	 
	// 若cache中的FPC不需要更新
	// 1. DMA
	// 2. IAB HALT
	// 3. 二次冲突
	if (!m_bolFPCUsed)
	{
		UpdateINTReg();
		if ( m_bolEXBraTaken && m_bolEXIsExcp )
		{
			// 若是由于检测到异常而清流水
			u32r_SavedBranchPC = m_u32EXTgtAddr;
			u32r_SavedBranchINTLvl = 0x40; // 借用未被使用的最高中断级别
			bolr_SavedBranchValid = true;
		}
		else if ( m_bolEXBraTaken && m_bolEXIsIRET && (u32r_NestLvlAftIRET_AC_EX == GetNestLvl(u64r_PMASK) ))
		{
			// 若是IRET
			u32r_SavedBranchPC = m_u32EXTgtAddr;
			u32r_SavedBranchINTLvl = u32r_NestLvlAftIRET_AC_EX;
			bolr_SavedBranchValid = true;
		}
		// 中断被撤销: 后面肯定不会有更高优先级中断存在，因为CGCR0已经关闭，高优先级中断不能进入		
		// else if ( m_bolACBraTaken && (PIPE_EX.DC4_AC.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK)) )
		else if ( m_bolACBraTaken )
		{				
			u64r_PMASK.GetInput(&u64Temp);
			u32INTLvl = GetNestLvl(u64Temp);

			u32r_SavedBranchPC = m_u32ACTgtAddr;
			u32r_SavedBranchINTLvl = u32INTLvl;
			bolr_SavedBranchValid = true;
			bolr_FpcUsedISRFlushed = true;
		}

		// 非DMA导致FPC不能更新的情况:
		if(!m_pICACHE->GetCacheBusyStatus())
		{
			if (m_bolEXBraTaken && (!m_bolEXIsIRET) && (!m_bolEXIsExcp) && (PIPE_EX.AC_EX.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK) ))
			{
				u32r_SavedBranchPC = m_u32EXTgtAddr;
				u32r_SavedBranchINTLvl = PIPE_EX.AC_EX.m_right.u32_NestLvl;
				bolr_SavedBranchValid = true;
			}
			else if( m_bolCondBraTaken && (PIPE_EX.DC2_DC3.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK)) )
			{
				u32r_SavedBranchPC = (DSPU32)u32r_CBTgtAddr;
				u32r_SavedBranchINTLvl = PIPE_EX.DC2_DC3.m_right.u32_NestLvl;
				bolr_SavedBranchValid = true;
			}
			else if ( m_bolFE2BraTaken && m_bolIsFE2FrmL2 && (m_u32FE2INTLvl == GetNestLvl(u64r_PMASK)) )
			{
				u32r_SavedBranchPC = m_u32FE2TgtAddr;
				u32r_SavedBranchINTLvl = m_u32FE2INTLvl;
				bolr_SavedBranchValid = true;
			}			
		}
		if(m_u32IdleTick > 1000 && bolHelp)
			bolr_TestEnd = true;
		return;		
	} // if (!m_bolFPCUsed)

	if ( m_bolEXBraTaken && m_bolEXIsExcp )
	{
		// 若是由于检测到异常而清流水
		u32PCNotAlign = m_u32EXTgtAddr; 	// 目标地址置为异常指令的下一条指令
		u32INTLvl = 0x40;					// 借用未被使用的最高中断级别
		UpdateINTReg();
		goto outport;
	}
	else if (bolro_INTOccur)
	{
		// 当检测到中断发生并且ISR第一条指令可以进入流水线时
	
		if ( (i32ro_INTLvl <= (int)MAX_INT_LVL))
		{
			u32PCNotAlign = rd_u32r_IVT((DSPU32)i32ro_INTLvl);
			bolISRFirstLine = true;
			m_u64PMASKSet = GSetBit64(m_u64PMASKSet, i32ro_INTLvl);

			// 当仲裁选择了寄存的分支信息或选择了高级别的中断首指令
			// 则清除寄存的分支信息
			// 注意其不会与上方对分支信息寄存器的写入冲突
			bolr_SavedBranchValid = false;

			// 该中断已被流水线接收，可以继续监测下一个中断
			if(i32ri_INTLvl <= i32ro_INTLvl)
			{
				bolri_INTOccur = false;
			}
		}
	}
	else
	{
		bolr_SavedBranchValid = false;
		// 当发生中断嵌套时（低优先级在前，高优先级在后）
		// 若低优先级ISR中发生分支，则只能清流水，但不能修改FPC
		if ( m_bolEXBraTaken && m_bolEXIsIRET && (u32r_NestLvlAftIRET_AC_EX == GetNestLvl(u64r_PMASK) ))
		{
			// 若是IRET
			u32PCNotAlign = m_u32EXTgtAddr;
			u32INTLvl = u32r_NestLvlAftIRET_AC_EX;
			UpdateINTReg();
			goto outport;
		}
		else if (m_bolEXBraTaken && (!m_bolEXIsIRET) && (!m_bolEXIsExcp) && (PIPE_EX.AC_EX.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK) ))
		{
			u32PCNotAlign = m_u32EXTgtAddr;
		}
		// 后面肯定不会有更高优先级中断存在，因为CGCR0已经关闭，高优先级中断不能进入		
		// else if ( m_bolACBraTaken && (PIPE_EX.DC4_AC.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK)) )
		else if ( m_bolACBraTaken )
		{				
			u32PCNotAlign = m_u32ACTgtAddr;
			m_pICACHE->NotifyPipeBefFlushInfo_software(true, 0x3f, m_u32ACTgtAddr);
			bolr_FpcUsedISRFlushed = false;
		}
		else if( m_bolCondBraTaken && (PIPE_EX.DC2_DC3.m_right.u32_NestLvl == GetNestLvl(u64r_PMASK)) )
		{
			u32PCNotAlign = (DSPU32)u32r_CBTgtAddr;
		}
		else if( m_bolFE2BraTaken && (m_u32FE2INTLvl == GetNestLvl(u64r_PMASK)) )
		{
			if(m_bolIsFE2FrmL2)
			{
				// 若FE2级的分支指令是cache缺失后从L2 memory重新载入的，
				// 则将分支目标地址写入NextPC
				u32PCNotAlign = m_u32FE2TgtAddr;
			}
			else
			{
				// 若FE2级的分支指令是cache一次命中的
				// 由于cache内部已将目的地址送给cache memory，程序控制器需要将下一个PC写入NextPC
				u32PCNotAlign = (m_u32FE2TgtAddr & 0xFFFFFFF0) + 16;
			}
		}
		else if (bolr_SavedBranchValid)
		{
			// 若有寄存的分支信息		
			u32PCNotAlign = u32r_SavedBranchPC;
			u32INTLvl = u32r_SavedBranchINTLvl;			
			// 当仲裁选择了寄存的分支信息或选择了高级别的中断首指令
			// 则清除寄存的分支信息
			// 注意其不会与上方对分支信息寄存器的写入冲突
			UpdateINTReg();
			if(bolr_FpcUsedISRFlushed)
			{
				m_pICACHE->NotifyPipeBefFlushInfo_software(true, 0x3f, u32PCNotAlign);
				bolr_FpcUsedISRFlushed = false;
			}
			goto outport;
		}
		else
		{				
			// 顺序执行
			u32PCNotAlign = (m_pICACHE->RdFPC() & 0xFFFFFFF0) + 16;
			bolIsNormalSeq = true;
		}
	}		
	UpdateINTReg();
	u64r_PMASK.GetInput(&u64Temp);
	u32INTLvl = GetNestLvl(u64Temp);

outport:	
	m_pICACHE->WrFPC(u32PCNotAlign, bolISRFirstLine, u32INTLvl, bolIsNormalSeq);
	
	if ( bolHelp && u32PCNotAlign != 0 && ( m_u32IdleTick > 1000 || \
		u32PCNotAlign < 0xb000000 || u32PCNotAlign > 0xb007fff ) )
		bolr_TestEnd = true;
	return;
}

//-------------------------------------------------------------------
// 返回 ISR第一行指令已经通过AC级,正在被服务的中断级别 （ILAT相应位: 0；PMASK相应位: 1）
//	range of nest level: 0 ~ 64
//  0 means normal app and 1 ~ 64 means interrupt. 
//
DSPU32 sc_iss::GetIntLvlInServ(DSPU64 p_u64ILAT, DSPU64 p_u64PMASK)
{
	DSPU64 u64Temp;
	DSPU64 u64NotILAT;
	DSPU64 u64One = 1;
	DSPU32 u32INTLvl;
	DSPU32 u32NestLvl = 0;

	u64NotILAT = ~p_u64ILAT;
	for (int i = 0; i <= MAX_INT_LVL; i++)
	{
		// 从高位向低位检查PMASK与ILAT的每一位
		// 遇到ILAT相应位: 0, PMASK相应位: 1时停止检查
	
		u64Temp = u64One << (MAX_INT_LVL - i);
		if ( (u64NotILAT & p_u64PMASK & u64Temp) != 0 )
		{
			u32INTLvl = MAX_INT_LVL - i;           // 0 ~ 63
			u32NestLvl = u32INTLvl + 1;
			break;
		}
		else if( ((DSPU64)u64r_SameINT & u64Temp) != 0)
		{
			u32INTLvl = MAX_INT_LVL - i;
			u32NestLvl = u32INTLvl + 1;
			break;
		}
	}

	return u32NestLvl;
}
//-----------------------------------------------------------------------------------
// 由于(Us=Um CB Un)生成的PEX各级的flush信号
// 当Us=Um CB Un位于DC3级生成
// 由于中断发生时，清除DC3/DC4之前的各级流水线(即从DC3级开始清)
// 所以当Us=Um CB Un生效时，在其后方不会存在更高级别的中断服务程序
// 如果中断清到DC2(DC4 not stall)，也不会有问题，因为CB清流水和中断清流水在同一拍发生效果
//
void sc_iss::FlushOnCB_PEX()
{
	// Flush pipeline after DC2/DC3
	m_CB_bolFlush_DC2DC3 = true;
	m_CB_bolFlush_DC1DC2 = true;
	m_CB_bolFlush_EMITDC1 = true;
}
//-----------------------------------------------------------------------------------
// 由于(Us=Um CB Un)生成的PEX各级的flush信号
// 当Us=Um CB Un位于DC3级生成
// 由于中断发生时，清除DC3/DC4之前的各级流水线(即从DC3级开始清)
// 所以当Us=Um CB Un生效时，在其后方不会存在更高级别的中断服务程序
//
void sc_iss::FlushOnCB_IAB()
{
	m_CB_bolFlushIABP0 = true;
	m_CB_bolFlushIABP1 = true;
	m_u32INTLvlToCache = PIPE_EX.DC2_DC3.m_right.u32_NestLvl;
}
//-----------------------------------------------------------------------------------
// 由于中断(不含软件异常)生成PEX各级的flush信号
void sc_iss::FlushOnINT_PEX()
{
		DSPU64 u64Temp;
		unsigned int u32NestLvl;

		// Flush pipeline after DC3/DC4
		// 如果DC4 stall，那么需要清到DC3级
		// 否则，只需要清道DC2
		if(m_bolStall_DC4AC)
		{
			m_INT_bolFlush_DC3DC4 = true;	
		}
		m_INT_bolFlush_DC2DC3 = true;
		m_INT_bolFlush_DC1DC2 = true;
		m_INT_bolFlush_EMITDC1 = true;

		// 清除ISR第一行指令尚未通过DC3级(即尚未到达DC3/DC4输出侧)的中断在PMASK中的对应位
		// 在下述三者中选大确定不可被清除的中断级别INT_LVL.
			// ISR第一行指令已经通过AC级,正在被服务的中断级 （ILAT相应位: 0；PMASK相应位: 1）
			// DC4/AC中断级别
			// DC3/DC4中断级别
		// 比上述INT_LVL更高的中断级在u64r_PMASK中的对应位可以清除.
		u32NestLvl = GetIntLvlInServ(u64ro_ILAT, u64r_PMASK);
		if (PIPE_EX.DC4_AC.m_right.u32_NestLvl > u32NestLvl)
		{
			u32NestLvl = PIPE_EX.DC4_AC.m_right.u32_NestLvl;
		}

		if (PIPE_EX.DC3_DC4.m_right.u32_NestLvl > u32NestLvl)
		{
			u32NestLvl = PIPE_EX.DC3_DC4.m_right.u32_NestLvl;
		}
		if (PIPE_EX.DC2_DC3.m_right.u32_NestLvl > u32NestLvl)
		{
			u32NestLvl = PIPE_EX.DC2_DC3.m_right.u32_NestLvl;
		}
		
		u64Temp = u64r_PMASK;
		u64Temp = (u64Temp >> u32NestLvl) << u32NestLvl;
		m_u64PMASKClr = m_u64PMASKClr | u64Temp;  // 清零PMASK中的高位
		m_u64SameINTClr = m_u64SameINTClr | u64Temp;
}
//-----------------------------------------------------------------------------------
// 由于在EX级检测到异常标志而生成IAB各级的flush信号
void sc_iss::FlushOnExExcp_IAB()
{
		m_EX_bolFlushIABP0 = true;
		m_EX_bolFlushIABP1 = true;
		m_u32INTLvlToCache = 0x40;
}
//-----------------------------------------------------------------------------------
// 由于中断(不含软件异常)生成IAB各级的flush信号
void sc_iss::FlushOnINT_IAB()
{
		m_INT_bolFlushIABP0 = true;
		m_INT_bolFlushIABP1 = true;
		m_u32INTLvlToCache = (DSPU32)i32ro_INTLvl + 1;
}

//-----------------------------------------------------------------------------------
// 由于软件异常生成PEX各级的flush信号
// 由于在EX级检测到异常标志而清流水也使用该函数
void sc_iss::FlushOnExcp_PEX()
{
		DSPU64 u64Temp;
		unsigned int u32NestLvl;

		// Flush pipeline after AC/EX
		m_EX_bolFlush_ACEX = true;
		m_EX_bolFlush_DC4AC = true;
		m_EX_bolFlush_DC3DC4 = true;
		m_EX_bolFlush_DC2DC3 = true;
		m_EX_bolFlush_DC1DC2 = true;
		m_EX_bolFlush_EMITDC1 = true;

		// 清除所有尚未得到服务的中断在PMASK中的对应位(ISR第一行指令尚未通过AC级的)
		// 也就是比AC/EX中断级别更高的中断在PMASK中的对应位		
//		u32NestLvl = PIPE_EX.AC_EX.m_right.u32_NestLvl;
		u32NestLvl = GetIntLvlInServ(u64ro_ILAT, u64r_PMASK);
		u64Temp = u64r_PMASK;
		u64Temp = (u64Temp >> u32NestLvl) << u32NestLvl;
		m_u64PMASKClr = m_u64PMASKClr | u64Temp;  // 清零PMASK中的高位
}

//-----------------------------------------------------------------------------------
//由于EX级别的程序转移请求生成PEX各级的flush信号
void sc_iss::FlushOnEXB_PEX()
{
		unsigned int u32LvlToFlush;

		u32LvlToFlush = PIPE_EX.AC_EX.m_right.u32_NestLvl;

		// flush pipeline registers below
		if (PIPE_EX.DC4_AC.m_right.u32_NestLvl > u32LvlToFlush)
		{
			m_EX_bolMeetNest = true;
		}
		else
		{
			m_EX_bolFlush_ACEX = true;
		}

		if (!m_EX_bolMeetNest)
		{
			if (PIPE_EX.DC3_DC4.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_EX_bolMeetNest = true;
			}
			else
			{
				m_EX_bolFlush_DC4AC = true;
			}
		}

		if (!m_EX_bolMeetNest)
		{
			if (PIPE_EX.DC2_DC3.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_EX_bolMeetNest = true;
			}
			else
			{
				m_EX_bolFlush_DC3DC4 = true;
			}
		}

		if (!m_EX_bolMeetNest)
		{
			if (PIPE_EX.DC1_DC2.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_EX_bolMeetNest = true;
			}
			else
			{
				m_EX_bolFlush_DC2DC3 = true;
			}
		}

		if (!m_EX_bolMeetNest)
		{
			if (PIPE_EX.EMIT_DC1.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_EX_bolMeetNest = true;
			}
			else
			{
				m_EX_bolFlush_DC1DC2 = true;

/*
				Note: 该条件已经不成立
				// 因为当PEX各级的分支信号有效时，禁止从IAB发射指令
				// 所以EMIT/DC1左右侧的内容必定相同，也应当清除。
				m_EX_bolFlush_EMITDC1 = true;
*/
			}
		}

}
//-----------------------------------------------------------------------------------
//由于EX级别的程序转移请求生成IAB各级的flush信号
void sc_iss::FlushOnEXB_IAB()
{
		unsigned int u32LvlToFlush;

		u32LvlToFlush = PIPE_EX.AC_EX.m_right.u32_NestLvl;
		//----------------------------------------------------------------
		if (!m_EX_bolMeetNest)  
		{
			if ((m_arrIABP0Out[17] & 0xff) > u32LvlToFlush)
			{
				m_EX_bolMeetNest = true;
			}
			else
			{
				m_EX_bolFlushIABP0 = true;
			}
		}

		if (!m_EX_bolMeetNest)  
		{
			if ((m_arrIABP1Out[17] & 0xff) > u32LvlToFlush)
			{
				m_EX_bolMeetNest = true;
			}
			else
			{
				m_EX_bolFlushIABP1 = true;
				m_u32INTLvlToCache = u32LvlToFlush;
			}
		}

}
//-----------------------------------------------------------------------------------
void sc_iss::GenPipeEXFlushBefDC4()
{
	if (m_bolEXBraTaken && (!m_bolEXIsExcp))
	{
		// 在EX级执行的分支指令
		// 清EX级后的各级流水。

		// 仅形成各级的flush信号
		FlushOnEXB_PEX();
	}
	
	if (m_bolACBraTaken)
	{
		// 中断服务程序第一行指令到达AC级时检查是否全局关中断
		// 若全局关中断，则清AC级后的各级流水。
		// 由于中断服务程序第一行指令前总会插入一个气泡，
		// 所以AC级的清流水操作不会与EX级的清流水操作同时发生。

		// 仅形成各级的flush信号
		FlushOnACB_PEX();
	}

	if ( bolro_INTOccur )
	{
		if ( IsExcpINTLvl(i32ro_INTLvl) )
		{
			// 如果出现软件异常
			// 软件异常指令strap在EX级执行
			// 清EX级后的各级流水。

			// 除形成各级的flush信号外，还涉及PMASK的修改
			FlushOnExcp_PEX();
		}
	}

	if (m_bolEXBraTaken && m_bolEXIsExcp)
	{
		// 若由于在EX级检测到异常而清流水
		FlushOnExcp_PEX();    // 借用strap的清除操作
	}
	
	//===================================================
	
	if (m_EX_bolFlush_EMITDC1 || m_AC_bolFlush_EMITDC1)
	{
		m_bolFlush_EMITDC1 = true;
	}	
	//--------------------------------------------------------------
	if (m_EX_bolFlush_DC1DC2 || m_AC_bolFlush_DC1DC2)
	{
		m_bolFlush_DC1DC2 = true;
	}	
	//--------------------------------------------------------------
	if (m_EX_bolFlush_DC2DC3 || m_AC_bolFlush_DC2DC3)
	{
		m_bolFlush_DC2DC3 = true;
	}	
	//--------------------------------------------------------------		
	if (m_EX_bolFlush_DC3DC4 || m_AC_bolFlush_DC3DC4)
	{
		m_bolFlush_DC3DC4 = true;
	}	
	//--------------------------------------------------------------
	if (m_EX_bolFlush_DC4AC || m_AC_bolFlush_DC4AC)
	{
		m_bolFlush_DC4AC = true;
	}			
	//--------------------------------------------------------------
	if (m_EX_bolFlush_ACEX || m_AC_bolFlush_ACEX)
	{
		m_bolFlush_ACEX = true;
	}
}
//-----------------------------------------------------------------------------------
void sc_iss::GenPipeEXFlush()
{		
	if ( bolro_INTOccur && !IsExcpINTLvl(i32ro_INTLvl) && (m_pICACHE->GetCacheBusyStatus() == false))
	{
		// 如果出现中断
		// 清DC3级后的各级流水。
		// 除形成各级的flush信号外，还涉及PMASK的修改
		FlushOnINT_PEX();
	}
	if(m_bolCondBraTaken)	// Us=Um CB Un
	{
		// 仅形成各级的flush信号
		FlushOnCB_PEX();
	}	
	if (m_bolEXBraTaken && (!m_bolEXIsExcp))
	{
		if (PIPE_EX.EMIT_DC1.m_left.u32_NestLvl <= PIPE_EX.AC_EX.m_right.u32_NestLvl)
		{
			m_bolFlush_EMITDC1 = true;
		}
	}
	//===================================================

	if ( m_CB_bolFlush_EMITDC1 || m_INT_bolFlush_EMITDC1 )
	{
		m_bolFlush_EMITDC1 = true;
	}
	if ( m_CB_bolFlush_DC1DC2 || m_INT_bolFlush_DC1DC2 )
	{
		m_bolFlush_DC1DC2 = true;
	}
	if ( m_CB_bolFlush_DC2DC3 || m_INT_bolFlush_DC2DC3 )
	{
		m_bolFlush_DC2DC3 = true;
	}
	if (m_INT_bolFlush_DC3DC4)
	{
		m_bolFlush_DC3DC4 = true;
	}
}
//-----------------------------------------------------------------------------------
// 产生PEX中AC/EX及之前各级流水线寄存器的stall信号
void sc_iss::GenPipeEXStallBefDC4()
{
	//--------------------------------------------------------------
	if (bolro_Idle || m_bolFatalExcp)
	{			
		m_bolStall_EXWB = true;		
	}
	//--------------------------------------------------------------
	// m_bolStall_EXWB信号的形成见上方
	if ( m_bolStall_EXWB || m_AC_bolHazardStall_ACEX || m_AC_bolICMAStall_ACEX || m_AC_bolDMACStall_ACEX)
	{			
		m_bolStall_ACEX = true;
	}
}
//-----------------------------------------------------------------------------------
void sc_iss::GenPipeEXStall()
{
	if (HAS_MEM_REQ())
	{
		m_DC4_bolMemStall_DC4AC = true;
		if ( !(m_bolStall_ACEX || m_DC4_bolISRStall_DC4AC || m_DC4_bolCPredStall_DC4AC || m_DC4_bolIRETStall_DC4AC) )
		{
			m_u64MemStallCycles++;
		}
	}
	//--------------------------------------------------------
	// m_bolStall_ACEX信号的生成在GenPipeEXStallBefDC4()
	// m_DC4_bolMemStall_DC4AC信号的形成见上方
	if ( m_bolStall_ACEX || m_DC4_bolISRStall_DC4AC || m_DC4_bolMemStall_DC4AC || m_DC4_bolCPredStall_DC4AC || m_DC4_bolIRETStall_DC4AC)
	{
		m_bolStall_EMITDC1 = true;
		m_bolStall_DC1DC2 = true;
		m_bolStall_DC2DC3 = true;
		m_bolStall_DC3DC4 = true;
		m_bolStall_DC4AC = true;
	}
#ifdef ICMA_TESTING
	// 若存在尚未被服务的核外原子访存请求
	// 核外原子访存请求一旦获得总线，就将禁止流水线中新的指令到达DC4/AC的输出侧
	if (bolro_AtomO)
	{
		m_bolStall_EMITDC1 = true;
		m_bolStall_DC1DC2 = true;
		m_bolStall_DC2DC3 = true;
		m_bolStall_DC3DC4 = true;
		m_bolStall_DC4AC = true;
	}
#endif	
	if (!m_bolStall_DC2DC3 )
	{
		// check if ADDR REG Hazard
		m_DC2_bolStall_DC2DC3 = DetectDataHzd_DC2();				
	}

	if ( m_DC2_bolStall_DC2DC3 )
	{
		m_bolStall_EMITDC1 = true;
		m_bolStall_DC1DC2 = true;
		m_bolStall_DC2DC3 = true;
	}
	if ( m_bolStall_ACEX || m_DC4_bolISRStall_DC4AC || m_DC4_bolCPredStall_DC4AC || m_DC4_bolIRETStall_DC4AC || m_DC2_bolStall_DC2DC3 )
	{
		m_u64HzdStallCycles++;
	}
}
//-----------------------------------------------------------------------------------
// 生成IAB的flush信号
void sc_iss::GenIABFlush()
{
	//---------------------------------------------------------
	// 注:以下四者均存在对m_u32INTLvlToCache的赋值，要排除相互干扰
	// 由于m_bolEXBraTaken, m_bolACBraTaken, m_bolCondBraTaken导致给m_u32INTLvlToCache的赋值必定相同
	// 若由于m_bolINTOccur导致给m_u32INTLvlToCache，其优先级最高。
	//
	if (m_bolEXBraTaken && (!m_bolEXIsExcp))
	{
		// 由于EX级分支清流水
		FlushOnEXB_IAB();
	}
	
	if (m_bolACBraTaken)
	{
		// 由于AC级分支清流水
		FlushOnACB_IAB();
	}

	// Us=Um CB Un
	if(m_bolCondBraTaken)
	{
		// 当Us=Um CB Un位于DC3级生成
		FlushOnCB_IAB();
	}

	if ( bolro_INTOccur && (m_pICACHE->GetCacheBusyStatus() == false) )
	{
		// 由于发生中断(包括strap)清流水
		FlushOnINT_IAB();
	}

	if ( m_bolEXBraTaken && m_bolEXIsExcp )
	{
		// 由于在EX级检测到异常标志而清流水
		FlushOnExExcp_IAB();
	}

	//=================================================
	if (m_EX_bolFlushIABP0 || m_AC_bolFlushIABP0 || m_INT_bolFlushIABP0 || m_CB_bolFlushIABP0)
	{
		m_bolFlushIABP0 = true;
	}

	if (m_EX_bolFlushIABP1 || m_AC_bolFlushIABP1 || m_INT_bolFlushIABP1 || m_CB_bolFlushIABP1)
	{
		m_bolFlushIABP1 = true;
	}

}

//-----------------------------------------------------------------------------------
void sc_iss::UpdateEPC()
{
	if (PIPE_EX.AC_EX.m_right.u32r_SlotNum != 0)
	{
		if ( !m_bolStall_EXWB )
		{
			u32r_EPC = PIPE_EX.AC_EX.m_right.uint32r_pc;
		}	
	}
}

//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_IABP0()
{	
		for (int i = 0; i < IAB_WIDTH; i++)
		{
			m_arrIABP0In[i] = 0;
			m_arrIABP0Out[i] = 0;
		}
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_IABP1()
{	
		for (int i = 0; i < IAB_WIDTH; i++)
		{
			m_arrIABP1In[i] = 0;
			m_arrIABP1Out[i] = 0;
		}
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_EMIT_DC1()
{
		PIPE_EX.EMIT_DC1.flush_left();
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_DC1_DC2()
{
		PIPE_EX.EMIT_DC1.flush_right();
		PIPE_EX.DC1_DC2.flush_left();
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_DC2_DC3()
{
		for (int i = 0; i < PIPE_EX.DC2_DC3.m_left.u32r_SlotNum; i++)
		{
			FreeSlotCalcRes(PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i]);
			FreeResSLK(PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i]);
		}

		PIPE_EX.DC1_DC2.flush_right();
		PIPE_EX.DC2_DC3.flush_left();
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_DC3_DC4()
{
		for (int i = 0; i < PIPE_EX.DC3_DC4.m_left.u32r_SlotNum; i++)
		{
			FreeSlotCalcRes(PIPE_EX.DC3_DC4.m_left.u32r_slot_res[i]);
			FreeResSLK(PIPE_EX.DC3_DC4.m_left.u32r_slot_res[i]);
		}

		PIPE_EX.DC2_DC3.flush_right();
		PIPE_EX.DC3_DC4.flush_left();
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_DC4_AC()
{
		for (int i = 0; i < PIPE_EX.DC4_AC.m_left.u32r_SlotNum; i++)
		{
			FreeSlotCalcRes(PIPE_EX.DC4_AC.m_left.u32r_slot_res[i]);
			FreeResSLK(PIPE_EX.DC4_AC.m_left.u32r_slot_res[i]);
		}

		RstMemReqs_DC4();  // Because mem access reqs are put in DC4.		
		FreeMPSLK(m_u32MPReqIdx);
		PIPE_EX.DC3_DC4.flush_right();
		PIPE_EX.DC4_AC.flush_left();
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush_AC_EX()
{
		for (int i = 0; i < PIPE_EX.AC_EX.m_left.u32r_SlotNum; i++)
		{
			FreeSlotCalcRes(PIPE_EX.AC_EX.m_left.u32r_slot_res[i]);
			FreeResSLK(PIPE_EX.AC_EX.m_left.u32r_slot_res[i]);
		}
#ifdef ICMA_TESTING
		reset_icma_req();
#endif
#ifdef DMAC_TESTING
		reset_dmac_req();
#endif
		FreeMPSLK(PIPE_EX.DC4_AC.m_right.u32_MPSLKIdx);
		PIPE_EX.DC4_AC.flush_right();
		PIPE_EX.AC_EX.flush_left();
}	

//-----------------------------------------------------------------------------------
void sc_iss::Reset_PIPE_EX()
{
		PIPE_EX.flush();
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Stall()
{
	if (m_bolStall_EXWB)
	{
		PIPE_EX.EX_WB.stall();
	}

	if (m_bolStall_ACEX)
	{
		PIPE_EX.AC_EX.stall();
	}

	if (m_bolStall_DC4AC)
	{
		PIPE_EX.DC4_AC.stall();
	}

	if (m_bolStall_DC3DC4)
	{
		PIPE_EX.DC3_DC4.stall();
	}

	if (m_bolStall_DC2DC3)
	{
		PIPE_EX.DC2_DC3.stall();
	}

	if (m_bolStall_DC1DC2)
	{
		PIPE_EX.DC1_DC2.stall();
	}

	if (m_bolStall_EMITDC1)
	{
		PIPE_EX.EMIT_DC1.stall();
	}

}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_Flush()
{

		if (m_bolFlushIABP1)
		{
			DSP_Flush_IABP1();
		}

		if (m_bolFlushIABP0)
		{
			DSP_Flush_IABP0();
		}

		if (m_bolFlush_EMITDC1)
		{
			DSP_Flush_EMIT_DC1();
		}

		if (m_bolFlush_DC1DC2)
		{
			DSP_Flush_DC1_DC2();
		}

		if (m_bolFlush_DC2DC3)
		{
			DSP_Flush_DC2_DC3();
		}

		if (m_bolFlush_DC3DC4)
		{
			DSP_Flush_DC3_DC4();
		}
	
		if (m_bolFlush_DC4AC)
		{
			DSP_Flush_DC4_AC();
		}

		if (m_bolFlush_ACEX)
		{
			DSP_Flush_AC_EX();
		}

}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_PEX_POST_EXE_BEF_DC4()
{
	if (  !m_bolAbandon_AC )
	{
		if(!m_AC_bolHazardStall_ACEX && PIPE_EX.DC4_AC.m_right.u32_MPSLKIdx != 0 )
		{
			// 核外访存不会影响本核微请求取源操作数
			SrvMemReq_AC_POST();
		}
			
		if (!m_bolStall_ACEX)		
		{
			if(PIPE_EX.DC4_AC.m_right.u32_SeqCounter != 0)
			{
				AC_POST_ACT();			
			}
			INTRelated_AC_POST();
		}
	}
}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_PEX_POST_EXE()
{						
		if ( !m_bolStall_DC4AC && !m_bolAbandon_AC )
		{
			if (PIPE_EX.DC3_DC4.m_right.u32_SeqCounter != 0)			
			{
				DC4_POST_ACT();				
			}

			// 综合来自寄存器页面选择寄存器及寄存器页面切换指令的信息，
			// 将最终的寄存器页面选择信息附着在流水线上。
			// 因为以流水方式执行的读、写访存操作也需要寄存器页面信息，
			// 所以只要DC4/AC没有被stall，就附着寄存器页面信息。
//			FillPipePageIdxInfo();
		}		
		if ( !m_bolStall_DC3DC4 && !m_bolAbandon_AC )
		{
			if (PIPE_EX.DC2_DC3.m_right.u32_SeqCounter != 0)
			{
				DC3_POST_ACT();
			}
		}
		if ( !m_bolStall_DC2DC3 )
		{
			if (PIPE_EX.DC1_DC2.m_right.u32_SeqCounter != 0)			
			{
				DC2_POST_ACT();
			}
		}

}
//-----------------------------------------------------------------------------------
void sc_iss::DSP_PEX_EXE()
{
		if (PIPE_EX.EX_WB.m_right.u32_MPSLKIdx != 0)
		{
			bolFirstWB = true;
			SrvMemReq_WB();
		}		
		if (PIPE_EX.EX_WB.m_right.u32_SeqCounter != 0)
		{
			if (PIPE_EX.EX_WB.m_right.u32_SeqCounter != u32r_SeqCounter_WB)
			{
				bolFirstWB = true;
				m_u64InstNum_WB += PIPE_EX.EX_WB.m_right.u32InstrNum;
				WB_ACTION();
#ifdef LIBTESTCODE
				if (m_CodeCovForLibTest)
				{
					//PrintPCToTmpFile();
					m_pc[PIPE_EX.EX_WB.m_right.uint32r_pc]++;
				}				
#endif
				
#ifdef LOG_STEP_TESTING
	//			LogCFG_Info();
#endif				

#ifdef BWSIM_CMP_100_104
				DSPU32 u32PC_WB;
				u32PC_WB = PIPE_EX.EX_WB.m_right.uint32r_pc;
				LogGenRegs_100_104(u32PC_WB);
#endif
			}
		}
		else
		{
			m_u64WastedCycles++;
			u32r_SeqCounter_WB = 0;
		}
		//------------------------------------------------------------------------------------------------------
		if (PIPE_EX.AC_EX.m_right.u32_SeqCounter != 0)
		{
			if (PIPE_EX.AC_EX.m_right.u32_SeqCounter != u32r_SeqCounter_EX)
			{
				EX_ACTION();
			}
			bolFirstEX = true;
		}
		else
		{
			u32r_SeqCounter_EX = 0;
		}
		//------------------------------------------------------------------------------------------------------
		DetectINT();  // AC_ACTION will use strap signal generated here
		//------------------------------------------------------------------------------------------------------				
		DetectGINTEnable_AC(); // 检测全局关中断标志;产生m_bolAbandon_AC信号

		if (PIPE_EX.DC4_AC.m_right.u32_SeqCounter != 0)
		{
			if (PIPE_EX.DC4_AC.m_right.u32_SeqCounter != u32r_SeqCounter_AC)
			{
				AC_ACTION();
			}
		}
		else
		{
			u32r_SeqCounter_AC = 0;
		}
		
		//------------------------------------------------------------------------------------------------------
		if (PIPE_EX.DC3_DC4.m_right.u32_SeqCounter != 0)
		{
			if (PIPE_EX.DC3_DC4.m_right.u32_SeqCounter != u32r_SeqCounter_DC4)
			{
				DC4_ACTION();
			}
		}
		else
		{
			u32r_SeqCounter_DC4 = 0;
		}
		//------------------------------------------------------------------------------------------------------
		if (PIPE_EX.DC1_DC2.m_right.u32_SeqCounter != 0)
		{
			if (PIPE_EX.DC1_DC2.m_right.u32_SeqCounter != u32r_SeqCounter_DC2)
			{
				DC2_ACTION();
			}
		}
		else
		{
			u32r_SeqCounter_DC2 = 0;
		}

}

//-----------------------------------------------------------------------------------
//由于AC级别的程序转移请求生成PEX各级的flush信号
// 后面肯定不会有更高优先级中断存在，因为CGCR0已经关闭，高优先级中断不能进入
void sc_iss::FlushOnACB_PEX()
{
	m_AC_bolFlush_ACEX = true;
	m_AC_bolFlush_DC4AC = true;
	m_AC_bolFlush_DC3DC4 = true;
	m_AC_bolFlush_DC2DC3 = true;
	m_AC_bolFlush_DC1DC2 = true;
	m_AC_bolFlush_EMITDC1 = true;
/*

		unsigned int u32LvlToFlush;

		u32LvlToFlush = PIPE_EX.DC4_AC.m_right.u32_NestLvl;

		// flush pipeline registers below
		m_AC_bolFlush_ACEX = true;

		if (PIPE_EX.DC3_DC4.m_right.u32_NestLvl > u32LvlToFlush)
		{
			m_AC_bolMeetNest = true;
		}
		else
		{
			m_AC_bolFlush_DC4AC = true;
		}

		if (!m_AC_bolMeetNest)
		{
			if (PIPE_EX.DC2_DC3.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_AC_bolMeetNest = true;
			}
			else
			{
				m_AC_bolFlush_DC3DC4 = true;
			}
		}

		if (!m_AC_bolMeetNest)
		{
			if (PIPE_EX.DC1_DC2.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_AC_bolMeetNest = true;
			}
			else
			{
				m_AC_bolFlush_DC2DC3 = true;
			}
		}

		if (!m_AC_bolMeetNest)
		{
			if (PIPE_EX.EMIT_DC1.m_right.u32_NestLvl > u32LvlToFlush)
			{
				m_AC_bolMeetNest = true;
			}
			else
			{
				m_AC_bolFlush_DC1DC2 = true;

				// 因为当PEX各级的分支信号有效时，禁止从IAB发射指令
				// 所以EMIT/DC1左右侧的内容必定相同，也应当清除。
				m_AC_bolFlush_EMITDC1 = true;
			}
		}
*/
}
//-----------------------------------------------------------------------------------
//由于AC级别的程序转移请求生成IAB各级的flush信号
void sc_iss::FlushOnACB_IAB()
{
	m_AC_bolFlushIABP0 = true;
	m_AC_bolFlushIABP1 = true;
	m_u32INTLvlToCache = 0x3f;
/*	
		unsigned int u32LvlToFlush;

		u32LvlToFlush = PIPE_EX.DC4_AC.m_right.u32_NestLvl;
		//----------------------------------------------------------------
		if (!m_AC_bolMeetNest)  
		{
			if ((m_arrIABP0Out[17] & 0xff) > u32LvlToFlush)
			{
				m_AC_bolMeetNest = true;
			}
			else
			{
				m_AC_bolFlushIABP0 = true;
			}
		}

		if (!m_AC_bolMeetNest)  
		{
			if ((m_arrIABP1Out[17] & 0xff) > u32LvlToFlush)
			{
				m_AC_bolMeetNest = true;
			}
			else
			{
				m_AC_bolFlushIABP1 = true;
				m_u32INTLvlToCache = u32LvlToFlush;
			}
		}
*/
}

//-----------------------------------------------------------------------------------
void sc_iss::FreeWBSLKRes()
{
	if (m_WB_bolFreeWBInRes)
	{
		for (int i = 0; i < PIPE_EX.EX_WB.m_right.u32r_SlotNum; i++)
		{
			FreeSlotCalcRes(PIPE_EX.EX_WB.m_right.u32r_slot_res[i]);
			FreeResSLK(PIPE_EX.EX_WB.m_right.u32r_slot_res[i]);
		}
	}
}
//-----------------------------------------------------------------------------------
void sc_iss::FillHzdMask_AC()
{
	DSPU32 *p_arrSlots, *p_arrSlotRes;
	DSPU32 u32SlotNum, u32SLKIdx, u32SrcPageIdx, u32DestPageIdx, u32MPSLKIdx;
	DSPU32 u32SACCMask, u32STABMask, u32Temp;
	SLOT_RES_USED *pSlotResUsed;
	HZD_MASK_T *pHzdMask = &(PIPE_EX.AC_EX.m_left.hzd_mask);

	p_arrSlots = PIPE_EX.DC4_AC.m_right.uint32r_slot;
	p_arrSlotRes = PIPE_EX.DC4_AC.m_right.u32r_slot_res;
	
	u32SlotNum = PIPE_EX.DC4_AC.m_right.u32r_SlotNum;
	u32MPSLKIdx = PIPE_EX.AC_EX.m_left.u32_MPSLKIdx;
#ifdef GPR_FWD
	bool bolFwdEn = true;
#else
	bool bolFwdEn = GIsBitSet(u32ro_CGCR, 14);
#endif
	
	for(int i = 0; i < u32SlotNum; i++)
	{
		u32SLKIdx = p_arrSlotRes[i];

		if ( !CondPermitted(u32SLKIdx) )
		{
			continue;
		}
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);

		u32SrcPageIdx = pSlotResUsed->u32SrcPageIdx;
		u32DestPageIdx = pSlotResUsed->u32DestPageIdx;
		u32STABMask = pSlotResUsed->u32STABMask;

		// AMACC读写掩码
		pHzdMask->u32RdAMACCMask |= pSlotResUsed->u32RdAMACCMask;
		pHzdMask->u32WrAMACCMask |= pSlotResUsed->u32WrAMACCMask;

		for(int j = 0; j < NUM_OF_UNITS; j++)
		{
			DSPU32 u32Flag = ( (pSlotResUsed->u32FwdFlag) & ( 0xffU << (j*8) ) );
			u32Flag >>= (j*8);
			if(bolFwdEn)
			{
				switch(u32Flag)
				{
					case SHF_FWD:
						pHzdMask->arrSrcRegMask_SHF[u32SrcPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrSrcGenRegs[j];
						pHzdMask->arrDestRegMask_SHF[u32DestPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrDestGenRegs[j];						
						break;
					case ALU_FWD:
						pHzdMask->arrSrcRegMask_ALU[u32SrcPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrSrcGenRegs[j];
						pHzdMask->arrDestRegMask_ALU[u32DestPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrDestGenRegs[j];						
						break;
					case MUL_FWD:
						pHzdMask->arrSrcRegMask_MUL[u32SrcPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrSrcGenRegs[j];
						pHzdMask->arrDestRegMask_MUL[u32DestPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrDestGenRegs[j];						
						break;
					default:
						pHzdMask->arrSrcRegMask_NUL[u32SrcPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrSrcGenRegs[j];
						pHzdMask->arrDestRegMask_NUL[u32DestPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrDestGenRegs[j];
						break;
				}			
			}
			pHzdMask->arrSrcRegMask[u32SrcPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrSrcGenRegs[j];
			pHzdMask->arrDestRegMask[u32DestPageIdx * NUM_OF_UNITS + j] |= pSlotResUsed->arrDestGenRegs[j];
			
			u32Temp = pSlotResUsed->u8SHFs[j];
			if(u32Temp != 0)
			{
				u32SACCMask = (u32Temp << (j*8));
				u32Temp = GetLSB_32(u32Temp);
				
				if ( pSlotResUsed->bolRdSACC )
				{
					pHzdMask->u32RdSACC |= u32SACCMask;
				}
				if ( pSlotResUsed->bolWrSACC )
				{
					pHzdMask->u32WrSACC |= u32SACCMask;
				}
				if ( pSlotResUsed->bolRdSTAB )
				{
					pHzdMask->u32RdSTAB[j] |= u32STABMask << (u32Temp * 4);
				}
				if ( pSlotResUsed->bolWrSTAB_AC )
				{
					pHzdMask->u32WrSTAB_AC[j] |= 0xfU << (u32Temp * 4);
				}			
				if ( pSlotResUsed->bolWrSTAB_EX )
				{
					pHzdMask->u32WrSTAB[j] |= u32STABMask << (u32Temp * 4);		// 和所有AC级读判相关
					pHzdMask->u32WrSTAB_EX[j] |= 0xfU << (u32Temp * 4);			// 和所有AC级写判相关
				}
			}
		}
	}
	if ( u32SlotNum == 0 && u32MPSLKIdx != 0)
	{
		DSPU32 u32UnitIdx, u32RegIdx;
		int i, j;
		
		for(i = 0; i < m_arrMemPipeSLK[u32MPSLKIdx].u32WrElemNum; i++)
		{
			u32SrcPageIdx = m_arrMemPipeSLK[u32MPSLKIdx].arrSrcPageIdx[i];
			u32UnitIdx = m_arrMemPipeSLK[u32MPSLKIdx].arrUnitIdx[i];
			u32RegIdx = m_arrMemPipeSLK[u32MPSLKIdx].arrRegIdx[i];

			if ( !GIsBitSet(m_arrMemPipeSLK[u32MPSLKIdx].u32SpecWrMask, i) )
			{
				j = u32SrcPageIdx * NUM_OF_UNITS + u32UnitIdx;
				
				pHzdMask->arrSrcRegMask_NUL[j] = GSetBit64(pHzdMask->arrSrcRegMask_NUL[j], u32RegIdx);			
				pHzdMask->arrSrcRegMask[j] = GSetBit64(pHzdMask->arrSrcRegMask[j], u32RegIdx);			
			}

		}
	}
}
//-----------------------------------------------------------------------------------------------
void sc_iss::DetectGINTEnable_AC()
{
	DSPU32 u32NestLvl;

	// 两次清流水
	if (bolr_ISRFlushedOnce)
	{
		m_bolACBraTaken = true;
		m_u32ACTgtAddr = u32r_EX_NPC;
		bolr_ISRFlushedOnce = false;
	}
	else if (PIPE_EX.DC4_AC.m_right.bol_ISRFirstLn)
	{
		u32NestLvl = PIPE_EX.DC4_AC.m_right.u32_NestLvl;
		// Check if global HW INT is disabled.
		if ( IsHwINTLvl(u32NestLvl - 1) && (!GIsBitSet(u32ro_CGCR, 0)) )
		{
			// 若为硬件中断且CGCR中已关闭全局中断
			// 则废弃当前执行行并转移程序流。
			// 相应的，需清PMASK中的相应位表示中断不在服务中。
			m_bolACBraTaken = true;
			m_u32ACTgtAddr = 0;			
			bolr_ISRFlushedOnce = true;
			ClrPMASKBit(u32NestLvl - 1);
		}
	}

	if ( (bolro_INTOccur && IsExcpINTLvl(i32ro_INTLvl)) || m_bolEXBraTaken || m_bolACBraTaken )
	{
		//禁止在AC级的指令生效
		m_bolAbandon_AC = true;
	}
}
//-----------------------------------------------------------------------------------------------
void sc_iss::INTRelated_AC_POST()
{
	DSPU32 u32NestLvl;

	u32NestLvl = PIPE_EX.DC4_AC.m_right.u32_NestLvl;

	if ( PIPE_EX.DC4_AC.m_right.bol_ISRFirstLn )
	{
		DSPU64 u64TrigMode = u32ro_ITMRh;
		u64TrigMode <<= 32;
		u64TrigMode |= u32ro_ITMRl;
		if(!GIsBitSet64(u64TrigMode, u32NestLvl-1))
		{
			// 则清ILAT中的相应位，表示中断请求已被响应。
			ClrINTReq(u32NestLvl - 1);			
		}

		// this is the first instruction line of ISR and doesn't contain IRET instruction.
		SetIRA(u32NestLvl - 1, u32r_EX_NPC); // 记录中断返回地址
	}

}

//-----------------------------------------------------------------------------------------------
bool sc_iss::IsFlushed(DSPU32 p_u32Phase)
{
	DSPU32 u32NestLvl = 0;
	DSPU32 u32FlushLvl = 0;
	bool bolFlushOccur = false;

	if (m_bolAbandon_AC)
	{
		u32FlushLvl = PIPE_EX.AC_EX.m_right.u32_NestLvl;
		if (u32FlushLvl < PIPE_EX.DC4_AC.m_right.u32_NestLvl)
		{
			u32FlushLvl = PIPE_EX.DC4_AC.m_right.u32_NestLvl;
		}
		bolFlushOccur = true;
	}
	switch ( p_u32Phase )
	{
		case PHASE_DC2:
		case PHASE_DC2_POST:
		{
			if (m_bolCondBraTaken)
			{
				if (u32FlushLvl < PIPE_EX.DC2_DC3.m_right.u32_NestLvl)
				{
					u32FlushLvl = PIPE_EX.DC2_DC3.m_right.u32_NestLvl;
				}
				u32NestLvl = PIPE_EX.DC1_DC2.m_right.u32_NestLvl;
				bolFlushOccur = true;
			}
		}
		case PHASE_DC3:
		case PHASE_DC3_POST:
		{
			u32NestLvl = PIPE_EX.DC2_DC3.m_right.u32_NestLvl;
		}
		case PHASE_DC4:
		case PHASE_DC4_POST:
		{
			u32NestLvl = PIPE_EX.DC3_DC4.m_right.u32_NestLvl;
		}
	}


	if ( bolFlushOccur && (u32FlushLvl >= u32NestLvl) )
	{
		return true;
	}
	return false;
}

void sc_iss::SetGenRegFwd(unsigned int *p_pSlots,unsigned int *p_pSlotsRes,DSPU32 p_u32SlotNum)
{
	int i=0,j=0;
	DSPU32 u32SLKIdx,u32Opcode;
	for (i = 0; i < p_u32SlotNum; i++)
	{
		u32SLKIdx = p_pSlotsRes[i];	

		if(IsExtSecondWord(p_pSlots[i]) || IsInstNoCalc(p_pSlots[i]))
		{
			continue;
		}

		if ( !(IsExtFirstWord(p_pSlots[i])))
		{
			u32Opcode = GetOpcode(p_pSlots[i]);
			if(u32Opcode == op_set_spec_reg_c || u32Opcode == op_read_spec_reg_c)
			{
				continue;
			}
		}

		for(j = 0; j < NUM_OF_UNITS; j++)
		{
			bool bolIsFwd = true;
			if(m_arrResSLK[u32SLKIdx].slot_res_used.u8ALUs[j])
			{
				if ( IsExtFirstWord(p_pSlots[i]))   //双字指令
				{
					u32Opcode = GetOpcodeExt(p_pSlots[i + 1]);
					if ((u32Opcode == op_ext_b_on_bit_etc_c) && (ExtractBinStr(p_pSlots[i + 1], 18, 3) == 2))
					{
						bolIsFwd = true;
					}
					else
					{
						bolIsFwd = false;
					}
				}
				else  //单字指令
				{
					u32Opcode = GetOpcode(p_pSlots[i]);
					switch (u32Opcode)
					{
						case  op_max_32_c:	// 32
						case op_max_16_c:  //33
						case op_max_flo32_c: //34
						case op_min_32_c: //35
						case op_min_16_c: //36
						case op_min_flo32_c: //37
						case op_max_32_u_c: //38
						case op_max_16_u_c: //39
						case op_min_32_u_c: //40
						case op_min_16_u_c: //41
						case op_hl_add_sub_c: //46
						case op_max_min_hlreg_c: //47
						case op_max_min_32_c: //65
						case op_max_min_16_c://66
						case op_max_min_flo32_c: //67
						case op_max_min_32_u_c://68
						case op_max_min_16_u_c://69
						case op_max_min_mn_c://70

						case op_ht_c:
						case op_he_c:

						case op_acf_is_ht_32_c://88
						case op_acf_is_ht_d16_c://89
						case op_acf_is_ht_f32_c://90
						case op_acc_max_fix32_c://93
						case op_acc_max_4fix16_c://94
						case op_acc_max_reg_acc_c://95
						case op_acc_maxr_2fix32_MN_c://96
						case op_acc_maxr_2fix16_c://97
						case op_acc_maxr_reg_acc_c://98
						case op_ht_hlreg_tohl_c://100
						case op_he_hlreg_tohl_c://101
						case op_is_eq_16_sz_c://102
						case op_reg_shf_acf_c://103
						case op_reg_is_acc_c://104
						case op_like_acc_is_zero_c://110
							bolIsFwd = false;
						break;
						case op_acc_fix16_manh_c://99
							if (((p_pSlots[i] >> 12) & 0x7) == 6 || ((p_pSlots[i] >> 12) & 0x7) == 7)
							{
								bolIsFwd = true;
							}
							else
							{
								bolIsFwd = false;
							}
						break;
					}
				}

				if(bolIsFwd)
				{
					m_arrResSLK[u32SLKIdx].slot_res_used.u32FwdFlag |= (ALU_FWD << (j*8));
					//break;
				}
			}
			else if(m_arrResSLK[u32SLKIdx].slot_res_used.u8SHFs[j])
			{
				if ( IsExtFirstWord(p_pSlots[i]))   //双字指令
				{
					u32Opcode = GetOpcodeExt(p_pSlots[i + 1]);
					if(u32Opcode == op_ext_fext_etc_c)
					{
						if (ExtractBinStr(p_pSlots[i + 1], 18, 3)==5)
						{
							bolIsFwd = false;
						}
						else if (ExtractBinStr(p_pSlots[i + 1], 18, 3)==6)
						{
							if((p_pSlots[i + 1] & 0x3)==1 || (p_pSlots[i + 1] & 0x3)==3)
							{
								bolIsFwd = false;
							}
						}
					}
				}
				else  //单字指令
				{
					u32Opcode = GetOpcode(p_pSlots[i]);
					switch (u32Opcode)
					{
						case op_jlh_32_c://173
						case op_jlh_d16_c://174
						case op_like_h16_to_f32_c://186
						//case op_sigma_sc_c://217
						{
							bolIsFwd = false;
							break;
						}
						case op_like_fix_flo32_c://192
						{
							DSPU32 u32tmp = ExtractBinStr(p_pSlots[i], 8, 3);
							if(u32tmp==1 || u32tmp==3 || u32tmp==4)
							{
								bolIsFwd = false;
							}
							break;
						}
						case op_expan_hhreg_etc_c://180
						{
							if(GIsBitSet(p_pSlots[i], 17))
							{
								DSPU32 u32Tag = ExtractBinStr(p_pSlots[i], 14, 3);
								if(u32Tag == 2 || u32Tag == 3 || u32Tag == 4 || u32Tag == 6)
								{
									bolIsFwd = false;
								}
							}
							break;
						}
					}
				}
				if(bolIsFwd)
				{
					m_arrResSLK[u32SLKIdx].slot_res_used.u32FwdFlag |= (SHF_FWD << (j*8));
					//break;
				}
			}
			else if(m_arrResSLK[u32SLKIdx].slot_res_used.u8MULs[j])
			{
				u32Opcode = GetOpcode(p_pSlots[i]);
				bolIsFwd = false;
				//116,127,146
				if(u32Opcode==op_mul_flo32_c || u32Opcode==op_mul_cflo32_flo32_c || u32Opcode==op_mulfr_to_reg_c)
				{
					bolIsFwd = true;
				}
				else if (u32Opcode==op_mul_cf32_etc_c)
				{
					if(ExtractBinStr(p_pSlots[i], 12, 4)==0 || ExtractBinStr(p_pSlots[i], 12, 4)==0xe || ExtractBinStr(p_pSlots[i], 12, 4)==0xf)
					{
						bolIsFwd = true;
					}
				}
				if(bolIsFwd)
				{
					m_arrResSLK[u32SLKIdx].slot_res_used.u32FwdFlag |= (MUL_FWD << (j*8));
					//break;
				}
			}

			
		}	//end for(j = 0; j < NUM_OF_UNITS; j++)
	}//end for (i = 0; i < p_u32SlotNum; i++)
}
#if 0
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::CondClrHzd_DC2_POST()
{
	DSPU32 u32SlotNum;
	DSPU32 u32SLKIdx;
	DSPU32 u32IWord1, u32IWord2;

	u32IWord1 = PIPE_EX.DC2_DC3.m_left.uint32r_slot[0];
	u32IWord2 = PIPE_EX.DC2_DC3.m_left.uint32r_slot[1];
	
	if(IsExtFirstWord(u32IWord1) && IsCondDoInst(u32IWord2))
	{
		u32SlotNum = PIPE_EX.DC1_DC2.m_right.u32r_SlotNum;;

		for(int i = 2; i < u32SlotNum; i++)
		{
			u32SLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i];
			u32IWord1 = PIPE_EX.DC2_DC3.m_left.uint32r_slot[i];

			if(!CondPermitted(u32SLKIdx))
			{
				// 若根据条件判断不执行
				// 清除所有数据相关性信息
				memset(&m_arrResSLK[u32SLKIdx].slot_res_used, 0, sizeof(SLOT_RES_USED));
			}
			// Double words case
			if(IsExtFirstWord(u32IWord1))
				i++;			
		}
	}	
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::CondClrHzd_AC()
{
	DSPU32 u32SlotNum;
	DSPU32 u32SLKIdx;
	DSPU32 u32IWord1, u32IWord2;

	u32IWord1 = PIPE_EX.DC4_AC.m_right.uint32r_slot[0];
	u32IWord2 = PIPE_EX.DC4_AC.m_right.uint32r_slot[1];
	
	if(IsExtFirstWord(u32IWord1) && IsCondDoInst(u32IWord2))
	{
		u32SlotNum = PIPE_EX.DC4_AC.m_right.u32r_SlotNum;;

		for(int i = 2; i < u32SlotNum; i++)
		{
			u32SLKIdx = PIPE_EX.DC4_AC.m_right.u32r_slot_res[i];
			u32IWord1 = PIPE_EX.DC4_AC.m_right.uint32r_slot[i];
			
			if(!CondPermitted(u32SLKIdx))
			{
				for(int j = 0; j < NUM_OF_UNITS; j++)
				{
					memset(&m_arrResSLK[u32SLKIdx].slot_res_used, 0, sizeof(SLOT_RES_USED));
				}
			}
			// Double words case
			if(IsExtFirstWord(u32IWord1))
				i++;
		}
		
	}
}
//-------------------------------------------------------------------------------------------------------------------------------
void sc_iss::ChkMemReqAddr_DC2()
{
	unsigned int arrSLKIdx[2], arrAddrMask[2], arrAddr[2][8], arrAddrType[2], arrAddrNum[2];
	unsigned int u32SLKIdx, u32WrInsnNum, u32AddrType;
	unsigned int u32Temp;
	int i,j,k;
	SLOT_RES_USED *pSlotResUsed = NULL;

	// 在当前执行行中，逐条访存指令判断其访存地址类型
	// 由于是逐条指令判断，所以并不能检测出两条写访存指令间的地址冲突(相同)
	for (i = 0; i < PIPE_EX.DC1_DC2.m_right.u32r_SlotNum; i++)
	{
		u32SLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i];
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);

		if( IsExtSecondWord(PIPE_EX.DC1_DC2.m_right.uint32r_slot[i]) ||(!CondPermitted(u32SLKIdx)) )
		{
			continue;
		}
		if(pSlotResUsed->bolAtom)
		{
			// An exe-line could have one atom insn at most(exclude other mem-req)
			pSlotResUsed->u32AddrType = getAtomAddrType(pSlotResUsed->u32AtomAddr);
			// thus just return
			return;
		}

		if ( pSlotResUsed->bolMemAcs)
		{
			pSlotResUsed->u32AddrType = GetAddrType(u32SLKIdx);
			if ( (pSlotResUsed->u32AddrType & 0x7) == 0 )
			{
				// 若地址非法(越界或跨界)	(bit[0..2] of u32AddrType == 0)			
				if ( pSlotResUsed->bolRead )
				{
					// 当读访存指令地址非法时，返回全0
					// 设置内核地址非法标志寄存器的RAI=1 (寄存器定义待定)
					memset(pSlotResUsed->arrValues, 0, sizeof(DSPU32) * NUM_OF_UNITS * 2);
				}
				else
				{
					// 当写访存指令地址非法时
					// 设置内核地址非法标志寄存器的WAI=1 (寄存器定义待定)					
				}
			}
			else if ( GIsBitSet(pSlotResUsed->u32AddrType, 3) )
			{
				// 当单条访存指令地址冲突时，设置异常标志
				// 异常码待定
				PIPE_EX.DC2_DC3.m_left.u32_ExcpMask = PIPE_EX.DC2_DC3.m_left.u32_ExcpMask | 2;
			}
		}
	}

	// 检测是否有两条写访存指令间存在地址冲突(相同)
	u32WrInsnNum = 0;
	for (i = 0; i < PIPE_EX.DC1_DC2.m_right.u32r_SlotNum; i++)
	{
		u32SLKIdx = PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i];
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);
		
		if(!pSlotResUsed->bolMemAcs || pSlotResUsed->bolRead)
		{
			continue;	
		}
		if( IsExtSecondWord(PIPE_EX.DC1_DC2.m_right.uint32r_slot[i]) ||(!CondPermitted(u32SLKIdx)) )
		{
			continue;	
		}
		u32AddrType = pSlotResUsed->u32AddrType;
		if( (u32AddrType & 0x7U) != 0 )		// 过滤非法地址
		{
			if (u32WrInsnNum >= 2)
			{
				// 一个执行行中最多两条写访存指令
				printf("ChkMemReqAddr_DC2: error here\n");
				return;
			}
			arrSLKIdx[u32WrInsnNum] = u32SLKIdx;
			arrAddrType[u32WrInsnNum] = pSlotResUsed->u32AddrType;
			arrAddrMask[u32WrInsnNum] = pSlotResUsed->u32AddrMask;
			
			memcpy(arrAddr[u32WrInsnNum], pSlotResUsed->arrAddrs, NUM_OF_UNITS*2*sizeof(DSPU32));
			
			// special write has 2 wr-addrs at most
			// normal write has 8 wr-addrs at most
			arrAddrNum[u32WrInsnNum] = (pSlotResUsed->bolSpecWr) ? 2 : 8;
			u32WrInsnNum++;
		}		
	}
	// 若存在两条写访存指令且地址类型相同
	if ((u32WrInsnNum == 2U) && ((arrAddrType[0] & 0x7U) == (arrAddrType[1]) & 0x7U))
	{
		// 若为当前核内地址，将其统一转变为私有地址形式
		if (GIsBitSet(arrAddrType[0], 0))
		{
			for(i = 0; i < arrAddrNum[0]; i++)
			{
				if(GIsBitSet(arrAddrMask[0], i))
					ToCurrentCorePAddr(arrAddr[0][i], arrAddr[0][i]);
			}
			for(i = 0; i < arrAddrNum[1]; i++)
			{
				if(GIsBitSet(arrAddrMask[1], i))
					ToCurrentCorePAddr(arrAddr[1][i], arrAddr[1][i]);
			}
		}	

		for (i = 0; i < arrAddrNum[0]; i++) // 扫描第一个指令
		{
			if (GIsBitSet(arrAddrMask[0], i)) // 结合地址掩码判断是否为有效地址
			{
				for (j = 0; j < arrAddrNum[1]; j++) // 扫描第二个指令
				{
					if (GIsBitSet(arrAddrMask[1], j)) // 结合地址掩码判断是否为有效地址
					{
						if (arrAddr[0][i] == arrAddr[1][j])
						{
							// 发现两条写访存指令间有访存地址相同
							// 设置各指令的地址冲突标志
							m_arrResSLK[arrSLKIdx[0]].slot_res_used.u32AddrType = GSetBit(m_arrResSLK[arrSLKIdx[0]].slot_res_used.u32AddrType, 4);
							m_arrResSLK[arrSLKIdx[1]].slot_res_used.u32AddrType = GSetBit(m_arrResSLK[arrSLKIdx[1]].slot_res_used.u32AddrType, 4);
							// 异常码待定
							PIPE_EX.DC2_DC3.m_left.u32_ExcpMask = PIPE_EX.DC2_DC3.m_left.u32_ExcpMask | 2;
							break;						
						}
					}
				}
			}
		}		
	}	
}
//-------------------------------------------------------------------------------------------------------------------------------
// 当IAB0为空时拼接发射指令
//
void sc_iss::emit_when_iab0_empty()
{
	unsigned int  arrIAB[MAX_INUM_LINE], u32StartPC, u32SeqCounter, u32Index;
	int intFirstPos, i;

	// read instruction words from IAB1 into arrIAB
	for (i = 0; i < MAX_INUM_LINE; i++)
	{
		arrIAB[i] = m_arrIABP1Out[i];
	}

	// locate the first instruction word in arrIAB
	// In IAB, instruction words used before were cleaned to zero already
	//第一个有效指令在arrIAB中的位置zx
	intFirstPos = LocFirstWord(arrIAB, 16);

	// point u32StartPC to the first instruction word in arrIAB
	u32StartPC = m_arrIABP1Out[16] + intFirstPos;

	if (HasLineEndTag(arrIAB, 16))
	{
		// transfer instruction words from arrIAB to m_u32slot_EMIT[...]
		// and set fields in arrIAB to zero.
		FindExeLineIn16Words(intFirstPos, arrIAB);

		for (i = 0; i < MAX_INUM_LINE; i++)
		{
			PIPE_EX.EMIT_DC1.m_left.uint32r_slot[i] = m_u32slot_EMIT[i];
		}
		PIPE_EX.EMIT_DC1.m_left.u32r_SlotNum = m_u32SlotNum_EMIT;
		PIPE_EX.EMIT_DC1.m_left.uint32r_pc = u32StartPC;
		PIPE_EX.EMIT_DC1.m_left.u32_NestLvl = m_arrIABP1Out[17] & 0xff;
		if (GIsBitSet(m_arrIABP1Out[17], 8))
		{
			// bit 8 of [17] is bol_ISRFirstLn (first line of ISR)
			// 传递并清除ISR_firstline标志信息
			PIPE_EX.EMIT_DC1.m_left.bol_ISRFirstLn = true;
			m_arrIABP1Out[17] = GClrBit(m_arrIABP1Out[17], 8);
		}

		if (intFirstPos % 4 == 0)
		{
			// 若执行行的起始位置是取指行的slot0、slot4、slot8、slot12
			// 传递分支预测相关信息到前级流水线
			u32Index = intFirstPos / 4;
			if (GIsBitSet(m_arrIABP1Out[19 + u32Index * 2], 0))
			{
				// 当发射的执行行在FE2已被处理过
				PIPE_EX.EMIT_DC1.m_left.bol_Processed = true;
				PIPE_EX.EMIT_DC1.m_left.u32r_RetBPC = m_arrIABP1Out[18 + u32Index * 2];
				if (GIsBitSet(m_arrIABP1Out[19 + u32Index * 2], 1))
				{
					PIPE_EX.EMIT_DC1.m_left.bolr_BPT = true;
				}	
			}			
		} // if (intFirstPos % 4 == 0)

		u32SeqCounter = IncSeqCounter(u32r_SeqCounter_EMIT);  // inc seqcounter
		u32r_SeqCounter_EMIT = u32SeqCounter;
		PIPE_EX.EMIT_DC1.m_left.u32_SeqCounter = u32SeqCounter;

		PIPE_EX.EMIT_DC1.m_left.bol_InstValid = true; // 是有效执行行

		// 将arrIAB中剩余的指令字写回IAB1
		for (i = 0; i < MAX_INUM_LINE; i++)
		{
			m_arrIABP1In[i] = arrIAB[i];
			m_arrIABP1Out[i] = arrIAB[i];
		}
		
		if (Is16WordsZero(arrIAB))
		{
			// 若所有指令字均已发射完，则将PC值也清零
			m_arrIABP1In[16] = 0;
			m_arrIABP1Out[16] = 0;
		}
		
	} // if (HasLineEndTag(arrIAB, 16))
}
//-------------------------------------------------------------------------------------------------------------------------------
// 当IAB0非空时拼接发射指令
//
void sc_iss::emit_when_iab0_not_empty()
{
	unsigned int  arrIAB[MAX_INUM_LINE * 2], u32StartPC, u32SeqCounter, u32Index;
	int intFirstPos, i;

	// read instruction words from IAB0 and IAB1 into arrIAB
	// IAB1-->arrIAB[16..31] and IAB0-->arrIAB[0..15]
	for (i = 0; i < MAX_INUM_LINE; i++)
	{
		arrIAB[i] = m_arrIABP0Out[i];
		arrIAB[i + MAX_INUM_LINE] = m_arrIABP1Out[i];
	}

	// locate the first instruction word in arrIAB
	// In IAB, instruction words used before were cleaned to zero already
	//第一个有效指令在arrIAB中的位置zx
	intFirstPos = LocFirstWord(arrIAB, 32);

	// 若允许发射指令，则尝试拼接出一个执行行

	// point u32StartPC to the first instruction word in arrIAB
	u32StartPC = m_arrIABP0Out[16] + intFirstPos;
	if ((m_arrIABP1Out[17] & 0xff) == (m_arrIABP0Out[17] & 0xff)) // whether content of IAB0 and IAB1 belong to the same INT nest
	{
		// content of IAB0 and IAB1 belong to the same INT nest
		
		if (HasLineEndTag(arrIAB, 32))
		{
			// transfer instruction words from arrIAB to m_u32slot_EMIT[...]
			// and set fields in arrIAB to zero.
			FindExeLineIn32Words(intFirstPos, arrIAB);

			for (i = 0; i < MAX_INUM_LINE; i++)
			{
				PIPE_EX.EMIT_DC1.m_left.uint32r_slot[i] = m_u32slot_EMIT[i];
			}
			PIPE_EX.EMIT_DC1.m_left.u32r_SlotNum = m_u32SlotNum_EMIT;
			PIPE_EX.EMIT_DC1.m_left.uint32r_pc = u32StartPC;
			PIPE_EX.EMIT_DC1.m_left.u32_NestLvl = m_arrIABP0Out[17] & 0xff;
			if (GIsBitSet(m_arrIABP0Out[17], 8))
			{
				// bit 8 of [17] is bol_ISRFirstLn (first line of ISR)
				// 传递并清除ISR_firstline标志信息
				PIPE_EX.EMIT_DC1.m_left.bol_ISRFirstLn = true;
				m_arrIABP0Out[17] = GClrBit(m_arrIABP0Out[17], 8);
			}

			if (intFirstPos % 4 == 0)
			{
				// 若执行行的起始位置是取指行的slot0、slot4、slot8、slot12
				// 传递分支预测相关信息到前级流水线
				u32Index = intFirstPos / 4;
				if (GIsBitSet(m_arrIABP0Out[19 + u32Index * 2], 0))
				{
					// 当发射的执行行在FE2已被处理过

					PIPE_EX.EMIT_DC1.m_left.bol_Processed = true;
					PIPE_EX.EMIT_DC1.m_left.u32r_RetBPC = m_arrIABP0Out[18 + u32Index * 2];
					if (GIsBitSet(m_arrIABP0Out[19 + u32Index * 2], 1))
					{
						PIPE_EX.EMIT_DC1.m_left.bolr_BPT = true;
					}
				}				
			} // if (intFirstPos % 4 == 0)

			u32SeqCounter = IncSeqCounter(u32r_SeqCounter_EMIT);  // inc seqcounter
			u32r_SeqCounter_EMIT = u32SeqCounter;
			PIPE_EX.EMIT_DC1.m_left.u32_SeqCounter = u32SeqCounter;

			PIPE_EX.EMIT_DC1.m_left.bol_InstValid = true; // 是有效执行行
			
		} // if (HasLineEndTag(arrIAB, 32))
		else
		{
			printf("emit: maybe error here and start pc is 0x%x\n", u32StartPC);
		}
	} // if content of IAB0 and IAB1 belong to the same INT nest
	else
	{
		// IAB0 and IAB1 don't belong to the same INT nest
		// IAB1必定是更高优先级中断，不可能为气泡
		// (因为当IAB0非空时，IAB1必定非空)
		
		if (HasLineEndTag(arrIAB, 16))
		{
			// transfer instruction words from arrIAB to m_u32slot_EMIT
			// and set fields in arrIAB to zero
			FindExeLineIn16Words(intFirstPos, arrIAB);

			for (i = 0; i < MAX_INUM_LINE; i++)
			{
				PIPE_EX.EMIT_DC1.m_left.uint32r_slot[i] = m_u32slot_EMIT[i];
			}
			PIPE_EX.EMIT_DC1.m_left.u32r_SlotNum = m_u32SlotNum_EMIT;
			PIPE_EX.EMIT_DC1.m_left.uint32r_pc = u32StartPC;					
			PIPE_EX.EMIT_DC1.m_left.u32_NestLvl = m_arrIABP0Out[17] & 0xff;
			if (GIsBitSet(m_arrIABP0Out[17], 8))
			{
				// bit 8 of [17] is bol_ISRFirstLn (first line of ISR)
				
				// 传递并清除ISR_firstline标志信息
				PIPE_EX.EMIT_DC1.m_left.bol_ISRFirstLn = true;
				m_arrIABP0Out[17] = GClrBit(m_arrIABP0Out[17], 8);
			}

			if (intFirstPos % 4 == 0)
			{
				// 若执行行的起始位置是取指行的slot0、slot4、slot8、slot12
				// 传递分支预测相关信息到前级流水线
				u32Index = intFirstPos / 4;
				if (GIsBitSet(m_arrIABP0Out[19 + u32Index * 2], 0))
				{
					// 当发射的执行行在FE2已被处理过
					PIPE_EX.EMIT_DC1.m_left.bol_Processed = true;
					PIPE_EX.EMIT_DC1.m_left.u32r_RetBPC = m_arrIABP0Out[18 + u32Index * 2];
					if (GIsBitSet(m_arrIABP0Out[19 + u32Index * 2], 1))
					{
						PIPE_EX.EMIT_DC1.m_left.bolr_BPT = true;
					}	
				}			
			} // if (intFirstPos % 4 == 0)

			u32SeqCounter = IncSeqCounter(u32r_SeqCounter_EMIT);  // inc seq counter
			u32r_SeqCounter_EMIT = u32SeqCounter;
			PIPE_EX.EMIT_DC1.m_left.u32_SeqCounter = u32SeqCounter;

			PIPE_EX.EMIT_DC1.m_left.bol_InstValid = true;
			
		} // if (HasLineEndTag(arrIAB, 16))


	} // 若 IAB0 和 IAB1 中断级别不相同

	// 将arrIAB中剩余的指令字写回IAB0, IAB1
	// IAB1<--arrIAB[16..31] and IAB0<--arrIAB[0..15]
	for (i = 0; i < MAX_INUM_LINE; i++)
	{
		m_arrIABP0In[i] = arrIAB[i];
		m_arrIABP0Out[i] = arrIAB[i];
		m_arrIABP1In[i] = arrIAB[i + MAX_INUM_LINE];
		m_arrIABP1Out[i] = arrIAB[i + MAX_INUM_LINE];
	}

	if (IsLow16WordsZero(arrIAB))
	{
		// 若IAB0中所有指令字均已发射完，则将PC值也清零
		m_arrIABP0In[16] = 0;
		m_arrIABP0Out[16] = 0;
	}

	if (IsHigh16WordsZero(arrIAB))
	{
		// 若IAB1中所有指令字均已发射完，则将PC值也清零
		m_arrIABP1In[16] = 0;
		m_arrIABP1Out[16] = 0;
	}
}

 
//-------------------------------------------------------------------------------------------------------------------------------
// 流水线中的中断级别模型: 由前向后递增,但中间允许插入气泡(中断级别为0)
//
// 从IAB中拼接、发射指令
//
// use m_bolStall_EMITDC1
//
void sc_iss::EMIT_ACTION()
{
	m_bolEMITDone = true;

	// 尝试发射指令的条件: 若EMIT_DC1不被stall
	if ( !m_bolStall_EMITDC1 )
	{
		if (IsLow16WordsZero(m_arrIABP0Out))
		{
			emit_when_iab0_empty();
		}
		else
		{
			emit_when_iab0_not_empty();
		}

	}


#ifdef PIPE_FE_TESTING
	unsigned int u32InstrWord0;

	for (int i = 0; i < 16; i++)
	{
		m_arrEmittedLine[i] = PIPE_EX.EMIT_DC1.m_left.uint32r_slot[i];
	}
	m_arrEmittedLine[16] =PIPE_EX.EMIT_DC1.m_left.uint32r_pc;
	m_arrEmittedLine[17] =PIPE_EX.EMIT_DC1.m_left.u32_NestLvl;

	if(m_arrEmittedLine[0] != 0)
	{
		LogIAB();
	}

	//u32InstrWord0 = PIPE_EX.EMIT_DC1.m_left.uint32r_slot[0];
	//if ( IsInstNoCalc(u32InstrWord0) && (GetOpcodeNoCalc(u32InstrWord0) == op_rtrap_c) )
	//{
		// emit current execution line
	//}
	//else
	//{
		//PIPE_EX.EMIT_DC1.flush_left();

		for (int i = 0; i < 16; i++)
		{
			PIPE_EX.EMIT_DC1.m_left.uint32r_slot[i] = 0;
			
		}
	//}
	
#endif 

}
//-----------------------------------------------------------------------------------
DSPU32 sc_iss::DetectDataHzd_DC2()
{
		unsigned int arrInstLine0[16], arrInstLine1[16];
		unsigned int arrSLKIdx0[16], arrSLKIdx1[16];
		unsigned int u32SlotNum0, u32SlotNum1;
		unsigned int u32Mode = 0;

		// bubble needn't to detect hazard
		if (PIPE_EX.DC1_DC2.m_right.u32r_SlotNum == 0)  // bubble
		{
			return 0;
		}

		// read data from pipeline to local variable
		u32SlotNum0 = PIPE_EX.DC1_DC2.m_right.u32r_SlotNum;
		for (int i = 0; i < u32SlotNum0; i++)
		{
			arrInstLine0[i] = PIPE_EX.DC1_DC2.m_right.uint32r_slot[i];
			//SLKIdx is malloced at DC2 stage in DC2_ACTION
			arrSLKIdx0[i] = PIPE_EX.DC2_DC3.m_left.u32r_slot_res[i];
		}
		//----------------------------------------------------------------------------------------------
		u32SlotNum1 = PIPE_EX.DC2_DC3.m_right.u32r_SlotNum;
		if (u32SlotNum1 != 0) // bubble needn't check.
		{
			for (int i = 0; i < u32SlotNum1; i++)
			{
				arrInstLine1[i] = PIPE_EX.DC2_DC3.m_right.uint32r_slot[i];
				arrSLKIdx1[i] = PIPE_EX.DC2_DC3.m_right.u32r_slot_res[i];
			}

			u32Mode = DetectAddrRegHazard_DC2(arrInstLine0, arrSLKIdx0, u32SlotNum0, arrInstLine1, arrSLKIdx1, u32SlotNum1);

			// decide if the current line should be stalled one cycle
			// bit 2 of u32Mode is "1" indicate AddrReg data hazard detected
			if ( GIsBitSet(u32Mode, 2) )
			{
				// AddrReg data hazard detected and should stall one cycle
				return 1;
			}
		} //if (u32SlotNum1 != 0)

		//----------------------------------------------------------------------------------------------
		u32SlotNum1 = PIPE_EX.DC3_DC4.m_right.u32r_SlotNum;
		if (u32SlotNum1 != 0) // bubble needn't check.
		{
			for (int i = 0; i < u32SlotNum1; i++)
			{
				arrInstLine1[i] = PIPE_EX.DC3_DC4.m_right.uint32r_slot[i];
				arrSLKIdx1[i] = PIPE_EX.DC3_DC4.m_right.u32r_slot_res[i];
			}

			u32Mode = DetectAddrRegHazard_DC2(arrInstLine0, arrSLKIdx0, u32SlotNum0, arrInstLine1, arrSLKIdx1, u32SlotNum1);

			// decide if the current line should be stalled one cycle
			// bit 2 of u32Mode is "1" indicate AddrReg data hazard detected
			if ( GIsBitSet(u32Mode, 2) )
			{
				// AddrReg data hazard detected and should stall one cycle
				return 1;
			}
		} //if (u32SlotNum1 != 0)
		//----------------------------------------------------------------------------------------------
		u32SlotNum1 = PIPE_EX.DC4_AC.m_right.u32r_SlotNum;
		if (u32SlotNum1 != 0) // bubble needn't check.
		{
			for (int i = 0; i < u32SlotNum1; i++)
			{
				arrInstLine1[i] = PIPE_EX.DC4_AC.m_right.uint32r_slot[i];
				arrSLKIdx1[i] = PIPE_EX.DC4_AC.m_right.u32r_slot_res[i];
			}

			u32Mode = DetectAddrRegHazard_DC2(arrInstLine0, arrSLKIdx0, u32SlotNum0, arrInstLine1, arrSLKIdx1, u32SlotNum1);

			// decide if the current line should be stalled one cycle
			// bit 2 of u32Mode is "1" indicate AddrReg data hazard detected
			if ( GIsBitSet(u32Mode, 2) )
			{
				// AddrReg data hazard detected and should stall one cycle
				return 1;
			}
		} //if (u32SlotNum1 != 0)

		return 0;
}
//-----------------------------------------------------------------------------------
void sc_iss::FillPipePageIdxInfo()
{
		REGFS_WORD regfs_word;

		regfs_word.u32Value = u32r_REGFS;
		if ( !PIPE_EX.DC4_AC.m_left.arrPageIdxEnable[0] )
		{
			PIPE_EX.DC4_AC.m_left.arrSrcPageIdx[0] = regfs_word.details.u1XSrcPageIdx;
			PIPE_EX.DC4_AC.m_left.arrDestPageIdx[0] = regfs_word.details.u1XDestPageIdx;
		}

		if ( !PIPE_EX.DC4_AC.m_left.arrPageIdxEnable[1] )
		{
			PIPE_EX.DC4_AC.m_left.arrSrcPageIdx[1] = regfs_word.details.u1YSrcPageIdx;
			PIPE_EX.DC4_AC.m_left.arrDestPageIdx[1] = regfs_word.details.u1YDestPageIdx;
		}

		if ( !PIPE_EX.DC4_AC.m_left.arrPageIdxEnable[2] )
		{
			PIPE_EX.DC4_AC.m_left.arrSrcPageIdx[2] = regfs_word.details.u1ZSrcPageIdx;
			PIPE_EX.DC4_AC.m_left.arrDestPageIdx[2] = regfs_word.details.u1ZDestPageIdx;
		}

		if ( !PIPE_EX.DC4_AC.m_left.arrPageIdxEnable[3] )
		{
			PIPE_EX.DC4_AC.m_left.arrSrcPageIdx[3] = regfs_word.details.u1TSrcPageIdx;
			PIPE_EX.DC4_AC.m_left.arrDestPageIdx[3] = regfs_word.details.u1TDestPageIdx;
		}

}

//-----------------------------------------------------------------------------------
// 在以p_u32IAB为起始地址的32个字中找出一个执行行并写入m_u32slot_EMIT[]
//
void sc_iss::FindExeLineIn32Words(int p_intFirstPos, unsigned int *p_u32IAB)
{
	int i, j;
	DSPU32 u32InsWord;

	j = 0;
	for (i = p_intFirstPos; i < 32; i++)
	{
		// transfer an instruction word from arrIAB to pipeline registers
		// and set the field in arrIAB to zero
		u32InsWord = p_u32IAB[i];
		p_u32IAB[i] = 0;
		m_u32slot_EMIT[ j++ ] = u32InsWord;

		// if reach the end of an execution packet
		if ((u32InsWord & 0x80000000) != 0)
		{
			m_u32SlotNum_EMIT = j;
			break;
		}

		if ( j > 15 )
		{
			printf("FindExeLineIn32Words: pipeline registers are full\n");
			break;
		}
	}
}
//-----------------------------------------------------------------------------------
// 在以p_u32IAB为起始地址的16个字中找出一个执行行并写入m_u32slot_EMIT[]
//
void sc_iss::FindExeLineIn16Words(int p_intFirstPos, unsigned int *p_u32IAB)
{
	int i, j;
	DSPU32 u32InsWord;

	j = 0;
	for (i = p_intFirstPos; i < 16; i++)
	{
		// transfer an instruction word from arrIAB to pipeline registers
		// and set the field in arrIAB to zero
		u32InsWord = p_u32IAB[i];
		p_u32IAB[i] = 0;
		m_u32slot_EMIT[ j++ ] = u32InsWord;

		// if reach the end of an execution packet
		if ((u32InsWord & 0x80000000) != 0)
		{
			m_u32SlotNum_EMIT = j;
			break;
		}
	}
}

#ifndef RW_BUS_TESTING

//-----------------------------------
// 提交核内访存请求
void sc_iss::PutCoreMemReq_DC4()
{
	DSPU32 u32SLKIdx, u32AddrMask, u32AddrType, u32BlkIdx, u32Value;
	bool bolAddrIllegal;
	DSPU32 u32SrcPageIdx;
	SLOT_RES_USED *pSlotResUsed = NULL;
	DSPU32 *p_arrSlotRes = PIPE_EX.DC3_DC4.m_right.u32r_slot_res;
	
	// 遍历每一个指令槽，根据需要提交核内访存请求
	for (int intSlot = 0; intSlot < PIPE_EX.DC3_DC4.m_right.u32r_SlotNum; intSlot++)
	{
		u32SLKIdx = p_arrSlotRes[intSlot];
		pSlotResUsed = &(m_arrResSLK[u32SLKIdx].slot_res_used);

		if ( !CondPermitted(u32SLKIdx) )
		{
			continue;
		}

		u32AddrType	= pSlotResUsed->u32AddrType;
		u32AddrMask	= pSlotResUsed->u32AddrMask;
		
		if (!pSlotResUsed->bolMemAcs || !IS_LOCAL_REQ(u32AddrType) )
		{
			continue;
		}
		
		u32BlkIdx	= TYPE_BLK_IDX(u32AddrType);
		bolAddrIllegal	= (TYPE_FAULT_CODE(u32AddrType) == 0) ? false : true;

		u32SrcPageIdx = pSlotResUsed->u32SrcPageIdx;
		if( pSlotResUsed->bolAtom )
		{
			for(int k = 0; k < NUM_OF_UNITS; k++)
			{
				if(GIsBitSet(pSlotResUsed->u32AtomUnit, k))
				{
					PutRdReq(pSlotResUsed->u32AtomAddr, intSlot, true, bolAddrIllegal, u32BlkIdx);
					PutWrReq(pSlotResUsed->u32AtomAddr, 0, k, pSlotResUsed->u32AtomSrcIdx, intSlot, true, bolAddrIllegal, u32BlkIdx, false, u32SrcPageIdx);
					break;
				}
			}
			return;
		}

		if ( pSlotResUsed->bolRead )
		{	
			for (int k = 0; k < NUM_OF_UNITS; k++)
			{
				if ( GIsBitSet(u32AddrMask, k * 2) ) // 同GIsBitSet(u32Units, j)
				{               	
					PutRdReq(pSlotResUsed->arrAddrs[k][0], intSlot, false, bolAddrIllegal, u32BlkIdx);
					if ( GIsBitSet(u32AddrMask, k * 2 + 1) ) // 是否为双字访存请求
					{							
						PutRdReq(pSlotResUsed->arrAddrs[k][1], intSlot, false, bolAddrIllegal, u32BlkIdx);
					}
				}
			}
		}
		else
		{
			for (int k = 0; k < NUM_OF_UNITS; k++)
			{
				if ( GIsBitSet(u32AddrMask, k * 2) ) // 同GIsBitSet(u32Units, j)
				{
					PutWrReq(pSlotResUsed->arrAddrs[k][0], pSlotResUsed->arrValues[k][0], k, pSlotResUsed->arrMemSrcReg[k], intSlot, false, bolAddrIllegal, u32BlkIdx, pSlotResUsed->bolSpecWr, u32SrcPageIdx);
					if ( GIsBitSet(u32AddrMask, k * 2 + 1) ) // 是否为双字访存请求
					{
						PutWrReq(pSlotResUsed->arrAddrs[k][1], pSlotResUsed->arrValues[k][1], k, pSlotResUsed->arrMemSrcReg[k] + 1, intSlot, false, bolAddrIllegal, u32BlkIdx, pSlotResUsed->bolSpecWr, u32SrcPageIdx);
					}
				}
			} 
		}
	}
}
#endif
#endif

