
#include "sc_iss.h"
//-----------------------------------------------------------------------------------
DSPU32 sc_iss::BKF_I32(DSPU32 p_u32Value)
{
	DSPU32 u32Temp;
	DSPU32 u32Rtn = 0;

	u32Temp = p_u32Value >> 28;
	switch (u32Temp)
	{
		case 0:
			u32Rtn = 0;
			break;
		case 1:
			u32Rtn = 1;
			break;
		case 14:
			u32Rtn = 1;
			break;
		case 15:
			u32Rtn = 0;
			break;
		default:
			u32Temp = u32Temp >>1;
			if ( (u32Temp == 6) || (u32Temp == 1) )
			{
				u32Rtn = 2;
			}

			u32Temp = u32Temp >>1;
			if ( (u32Temp == 2) || (u32Temp == 1) )
			{
				u32Rtn = 3;
			}

	}  // switch

	return u32Rtn;
}
//-----------------------------------------------------------------------------------
DSPU32 sc_iss:: BKF_DI16(DSPU32 p_u32Value)
{
	DSPU32 u32Temp;
	DSPU32 u32FlagLow, u32FlagHigh;
	DSPU32 u32Rtn;

	u32Temp = p_u32Value & 0xFFFF0000;
	u32FlagHigh = BKF_I32(u32Temp);
	
	u32Temp = (p_u32Value & 0x0000FFFF) << 16;
	u32FlagLow = BKF_I32(u32Temp);

	u32Rtn = (u32FlagHigh > u32FlagLow)? u32FlagHigh : u32FlagLow;
	return u32Rtn;
}
//-----------------------------------------------------------------------------------
inline DSP_BIT40 U64ToU40(DSPU64 p_u64Temp)
{
	DSP_BIT40 u40Temp;

	u40Temp.u32Low = p_u64Temp;
	u40Temp.u8High = p_u64Temp >> 32;

	return u40Temp;
}

/*---------------------------------------------------ALU Operations---------------------------------------------------*/
bool sc_iss::like_add_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_add_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_add_32_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
			{
				DSPU32  u32Value;
		    	struct  SPLIT_VALUE
		    	{
		    		DSPU32    	u6SrcN: 6;
			    	DSPU32    	u6SrcM: 6;
					DSPU32    	u6Dest: 6;
					DSPU32    	u8Opcode: 8;
					DSPU32      u1MultiWord: 1;
					DSPU32      u4Units: 4;
		 		   	DSPU32      u1Line: 1;
				} details;
			} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		// Which macros(units) will be used?
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// this instruction just need 1 ALU or 1 SHF
		m_arrDCResNeeded[p_u32Slot].bolOneALUOrSHF = true;
        // Don't need to use specific ALU, such as alu_2.
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data hazard detection of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				if ( m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i] != 0 )
				{
					// ALU was malloced in current unit
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
				}
				else
				{
					// SHF was malloced in current unit
					// read SHFCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadSHFCR(i);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32Result = 0;
		DSPU32 u32ALUOrSHFIdx, u32ALUOrSHFCR;
		bool bolUseALU, bolIsMacroInstr;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{	
				if ( m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i] != 0 )
				{
					bolUseALU = true;
					u32ALUOrSHFIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				}
				else
				{
					bolUseALU = false;
					u32ALUOrSHFIdx = GetSHFIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8SHFs[i], 1);
				}				

				u32ALUOrSHFCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				switch (p_u32Opcode)
        		{
					// get result
					case op_add_32_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = Add32SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_sub_32_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = Sub32SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}                    	
                   		break;
					case op_add_16_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = AddD16(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = AddD16SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}                    	
                   		break;
					case op_sub_16_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = SubD16(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = SubD16SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}                    	
                   		break;
					case op_addhalf_32_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = Add32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}                    	
                   		break;
					case op_subhalf_32_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = Sub32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_addhalf_16_c:
						// set bit[0] of u32ALUOrSHFCR indicate this is signed operation
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = AddD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = AddD16HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_subhalf_16_c:
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = SubD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = SubD16HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_cj_add_16_c:
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = AddD16CJ(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = AddD16CJSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_cj_sub_16_c:
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = SubD16CJ(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = SubD16CJSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_cj_addhalf_16_c:
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = AddD16HalfCJ(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = AddD16HalfCJSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
					case op_cj_subhalf_16_c:
						u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
						if (bolUseALU)
						{
							u32Result = SubD16HalfCJ(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
						{
							u32Result = SubD16HalfCJSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
                   		break;
                   	case op_add_8_c:
                   		u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
                   		if (bolUseALU)
							u32Result = AddQ8(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = AddQ8SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						break;
                   	case op_sub_8_c:
                   		u32ALUOrSHFCR = GSetBit(u32ALUOrSHFCR, 0);
                   		if (bolUseALU)
							u32Result = SubQ8(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = SubQ8SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						break;
                   	case op_add_32_u_c:
                   		if (bolUseALU)
							u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		else
                   		    u32Result = Add32SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_sub_32_u_c:
						if (bolUseALU)
						    u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = Sub32SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_add_16_u_c:
						if (bolUseALU)
                    		u32Result = AddD16(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = AddD16SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_sub_16_u_c:
						if (bolUseALU)
                    		u32Result = SubD16(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = SubD16SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_addhalf_32_u_c:
						if (bolUseALU)
                    		u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = Add32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_subhalf_32_u_c:
						if (bolUseALU)
                    		u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = Sub32HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_addhalf_16_u_c:
						if (bolUseALU)
                    		u32Result = AddD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = AddD16HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_subhalf_16_u_c:
						if (bolUseALU)
                    		u32Result = SubD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						else
							u32Result = SubD16HalfSHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
               		case op_add_q8_c:
               			if (bolUseALU)
							// no need to set or clr bit[0] of ALUCR
                    		u32Result = AddQ8(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
               			else
               				u32Result = AddQ8SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					case op_sub_q8_c:
						if (bolUseALU)
						{
							// no need to set or clr bit[0] of ALUCR
                    		u32Result = SubQ8(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
						}
						else
							u32Result = SubQ8SHF(u32SrcA, u32SrcB, &u32Status, u32ALUOrSHFCR);
                   		break;
					
               		default:
						printf("like_add_32_cores: opcode not found\n");
                    	u32Result = 0;
        		}				
				
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				if (bolUseALU)
				{
					u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUOrSHFIdx], u32Status);
					u32ri_ALUFR[i][u32ALUOrSHFIdx] = u32Flag;
				}
				else
				{
					u32Flag = SetSHFFlags(u32ri_SHFFR[i][u32ALUOrSHFIdx], u32Status);
					u32ri_SHFFR[i][u32ALUOrSHFIdx] = u32Flag;
				}								
		
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_add_flo32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_add_flo32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_add_flo32_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
			{
				DSPU32  u32Value;
		    	struct  SPLIT_VALUE
		    	{
		    		DSPU32    	u6SrcN: 6;
			    	DSPU32    	u6SrcM: 6;
					DSPU32    	u6Dest: 6;
					DSPU32    	u8Opcode: 8;
					DSPU32      u1MultiWord: 1;
					DSPU32      u4Units: 4;
		 		   	DSPU32      u1Line: 1;
				} details;
			} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		// Which macros(units) will be used?
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// this instruction just need 1 ALU
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 1;
        // Don't need to use specific ALU, such as alu_2.
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data hazard detection of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				if( (p_u32Opcode != op_c_add_16_c) && (p_u32Opcode != op_c_sub_16_c))
				{
					SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				if(p_u32Opcode==op_c_add_16_c || p_u32Opcode==op_c_sub_16_c)
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32SrcNIdx;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				switch (p_u32Opcode)
        		{	
					case op_c_add_16_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);	
						u32SrcB = GSignExtend(u32SrcB,6);
						u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);					
						break;
					case op_c_sub_16_c:					
						u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);				
						break;
					case op_add_flo32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_sub_flo32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_addhalf_flo32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_subhalf_flo32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_add_abs_32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = AddAbs32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_add_abs_f32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = AddAbsF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_max_32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = Max32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_max_16_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = MaxD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_max_flo32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = MaxF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_min_32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = Min32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_min_16_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = MinD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_min_flo32_c:
						u32ALUCR = GSetBit(u32ALUCR, 0);
                    	u32Result = MinF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_max_32_u_c:
                    	u32Result = Max32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_max_16_u_c:
                    	u32Result = MaxD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_min_32_u_c:
                    	u32Result = Min32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					case op_min_16_u_c:
                    	u32Result = MinD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
                   		break;
					
               		default:
						PrintToCerr("like_add_flo32_cores: opcode not found\n");
                    	u32Result = 0;
        		}
				
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;				

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_accum_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_accum_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_accum_32_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32ALUIdx, u32ChgCON;
		union INSTR_WORD
		{
			DSPU32 u32Value;
   	 		struct  SPLIT_VALUE
    		{
    			DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u2Mode: 2;
				DSPU32    	u1ChgCON: 1;
				DSPU32    	u3ALUIdx: 3;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u1ChgCON;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32ChgCON = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		// which macros(units) are involved
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// which ALU in one macro is used
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		// this instruction will use specific calc resource
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.
				if (u32ChgCON == 1)
				{
					// in this condition, R[u32SrcMIdx] is source operand
					SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}

				// R[u32SrcNIdx] must be source operand
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx, u32ChgCON;
		DSPU32 u32SrcMValue, u32CON, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ChgCON = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		u32SrcMValue = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
				if (u32ChgCON == 1)
				{
					// get the value of R[u32SrcMIdx] in current macro directly or by data forward
					// the value of R[u32SrcMIdx] will be used in current phase
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						u32SrcMValue = u32Result;
					}
					else
					{
						u32SrcMValue = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}

				// get the value of R[u32SrcNIdx] in current macro directly or by data forward
				// the value of R[u32SrcNIdx] will be carried to next phase
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// read CON register
				u32CON = ReadCON(i, u32ALUIdx);
				// carry the value of CON to next phase
				u32r_ALUCON_AC[i][u32ALUIdx] = u32CON;
				switch (u32Mode)
				{
					case 0:
						if (u32ChgCON == 1)
						{
							// if "CON = Rm" specified
							WriteCON(i, u32ALUIdx, u32SrcMValue);
						}
						break;
					case 1:
						if (u32ChgCON == 1)
						{
							// if "CON = Rm" specified
							WriteCON(i, u32ALUIdx, u32SrcMValue);
						}
						break;
					case 2:
						if (u32ChgCON == 1)
						{
							// if "CON = Rm" specified
							WriteCON(i, u32ALUIdx, u32SrcMValue);
						}
						break;
					case 3:  // (CONC)
						if (u32ChgCON == 1)
						{
							// if "CON = Rm" specified
							WriteCON(i, u32ALUIdx, u32SrcMValue);
						}
						else
						{
							// update CON register in this manner when "CON = Rm" not specified
							if (p_u32Opcode == op_accum_32_c) // opcode 75
							{
								u32CON = u32CON << 1;
							}
							else if (p_u32Opcode == op_accum_16_c) // opcode 76
							{
								u32CON = (u32CON << 1) & 0xFFFEFFFF;  // GRQ here 
							}
							else if (p_u32Opcode == op_accum_32_u_c) // opcode 77
							{
								u32CON = u32CON << 1;
							}
							else if (p_u32Opcode == op_accum_16_u_c) // opcode 78
							{
								u32CON = (u32CON << 1) & 0xFFFEFFFF; 
							}

							else if (p_u32Opcode == op_acc_add_q8_c || p_u32Opcode == op_oacc_8_c) // opcode 79,74
							{
								u32CON = (u32CON << 1) & 0xFEFEFEFE;  // GRQ here
							}

							else if (p_u32Opcode == op_accum_flo32_c) // opcode 80
							{
								u32CON = u32CON << 1;
							}
							// opcode 81 has been deleted
							WriteCON(i, u32ALUIdx, u32CON);
						}
						break;
					default:
						PrintToCerr("like_accum_32_cores: Invalid parameter\n");
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32ALUIdx, u32Status, u32ALUCR, u32CON, u32Mode, u32SrcB;
		DSP_BIT40 b40Temp;
		DSPU8 u8EXP = 0;
		DSP_BIT48 b48Temp;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			b40Temp.u32Low = 0;
			b40Temp.u8High = 0;
			b48Temp.u32Low = 0;
			b48Temp.u8Mid = 0;
			b48Temp.u8High = 0;
			u8EXP = 0;
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				// read value of CON from pipeline register
				u32CON = u32r_ALUCON_AC[i][u32ALUIdx];
				u32Status = 0;

				if (p_u32Opcode == op_oacc_8_c)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
					switch (u32Mode)
					{
						case 0:  // OACCs = ORn
							ACCAddQ8(u32SrcB, b48Temp, &u32Status, u32ALUCR);
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						case 1:  // OACCs += ORn
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCAddQ8(u32SrcB, b48Temp, &u32Status, u32ALUCR);
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						case 2:  // OACCs -= ORn
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCSubQ8(u32SrcB, b48Temp, &u32Status, u32ALUCR);
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						case 3:  // OACCs += ORn (conc)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCQ8OnCON(u32SrcB, b48Temp,  &u32Status, &u32CON, u32ALUCR); 
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");

					} //switch (u32Mode)
				}
				else if (p_u32Opcode == op_accum_32_c)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
					switch (u32Mode)
					{
						case 0:  // ACCs = Rn
							ACCAdd32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 1:  // ACCs += Rn
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCAdd32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 2:  // ACCs -= Rn
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCSub32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 3:  // ACCs += Rn (CONC)
							// GRQ
							b40Temp = ReadACC(i, u32ALUIdx);
							ACC32OnCON(u32SrcB, &b40Temp, &u32Status, &u32CON, u32ALUCR);
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_accum_16_c)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
					switch (u32Mode)
					{
						case 0:  // HACCs = HRn
							ACCAddD16(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 1:  // HACCs += HRn
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCAddD16(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 2:  // HACCs -= HRn
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCSubD16(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 3:  // HACCs += HRn (CONC)
							// GRQ
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCD16OnCON(u32SrcB, &b40Temp, &u32Status, &u32CON, u32ALUCR);
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_accum_32_u_c)
				{
					switch (u32Mode)
					{
						case 0:  // ACC1 = R1
							ACCAdd32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 1:  // ACC1 += R1
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCAdd32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 2:  // ACC1 -= R1
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCSub32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 3:  // ACC1 += R1 (CONC)
							// GRQ
							b40Temp = ReadACC(i, u32ALUIdx);
							ACC32OnCON(u32SrcB, &b40Temp, &u32Status, &u32CON, u32ALUCR);
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_accum_16_u_c)
				{
					switch (u32Mode)
					{
						case 0:  // HACCs = HRn (U)
							ACCAddD16(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 1:  // HACCs += HRn (U)
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCAddD16(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 2:  // HACCs -= HRn (U)
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCSubD16(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
							break;
						case 3:  // HACCs += HRn (U, conc)
							b40Temp = ReadACC(i, u32ALUIdx);
							ACCD16OnCON(u32SrcB, &b40Temp, &u32Status, &u32CON, u32ALUCR);
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");

					} //switch (u32Mode)

				}
				else if (p_u32Opcode == op_acc_add_q8_c)
				{
					switch (u32Mode)
					{
						case 0:  // OACCs = ORn (U)
							ACCAddQ8(u32SrcB, b48Temp, &u32Status, u32ALUCR);
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						case 1:  // OACCs += ORn  (U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCAddQ8(u32SrcB, b48Temp, &u32Status, u32ALUCR);
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						case 2:  // OACCs -= ORn (U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCSubQ8(u32SrcB, b48Temp, &u32Status, u32ALUCR);
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						case 3:  // OACCs += ORn (U, conc)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCQ8OnCON(u32SrcB, b48Temp,  &u32Status, &u32CON, u32ALUCR); 
							b40Temp.u32Low = b48Temp.u32Low;
							b40Temp.u8High = b48Temp.u8Mid;
							u8EXP = b48Temp.u8High;
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");

					} //switch (u32Mode)
				}
				else if (p_u32Opcode == op_accum_flo32_c)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
					switch (u32Mode)
					{
						case 0:  // FACCs = FRn
							ACCAddF32(u32SrcB, &b40Temp, &u8EXP, &u32Status, u32ALUCR);
							break;
						case 1:  // FACCs += FRn
							b40Temp = ReadACC(i, u32ALUIdx);
							u8EXP = ReadACCExp(i, u32ALUIdx);
							ACCAddF32(u32SrcB, &b40Temp, &u8EXP, &u32Status, u32ALUCR);
							break;
						case 2:  // FACCs -= FRn
							b40Temp = ReadACC(i, u32ALUIdx);
							u8EXP = ReadACCExp(i, u32ALUIdx);
							ACCSubF32(u32SrcB, &b40Temp, &u8EXP, &u32Status, u32ALUCR);
							break;
						case 3:  // FACCs += FRn (CONC)
							// GRQ
							b40Temp = ReadACC(i, u32ALUIdx);
							u8EXP = ReadACCExp(i, u32ALUIdx);
							ACCF32OnCON(u32SrcB, &b40Temp, &u8EXP, &u32Status, &u32CON, u32ALUCR);
							break;
						default:
							PrintToCerr("like_accum_32_cores: Invalid parameter\n");
					}
				}
				// opcode 81 has been deleted
				u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;
				WriteACC(i, u32ALUIdx, b40Temp);
				WriteACCExp(i, u32ALUIdx, u8EXP);
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read flag info from pipeline and write ALUFR register
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

bool sc_iss::like_ht_he_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	ISS_ASSERT(p_u32SLKIdx < RES_SLK_SIZE && p_u32SLKIdx != 0);
	ISS_ASSERT(p_u32Slot < MAX_INUM_LINE && p_u32Phase < PHASE_MAX);
	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32ALUIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
  	  		struct  SPLIT_VALUE
			{
				DSPU32	u6SrcN: 6;
				DSPU32	u6SrcM: 6;
				DSPU32	u3Mode: 3;
				DSPU32	u3ALUIdx: 3;
				DSPU32	u8Opcode: 8;
				DSPU32	u1MultiWord: 1;
				DSPU32	u4Units: 4;
 			   	DSPU32	u1Line: 1;
			} details;
		} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3ALUIdx;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		// Which macros(units) will be used?
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// which ALU in one macro is used
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		// this instruction will use specific calc resource
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = ReadGPR_Page(i, u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
				m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = ReadGPR_Page(i, u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx);
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32Status,  u32Mode, u32SrcMIdx, u32SrcA, u32SrcB;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32ALUCFR;
		
		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				// read ACF register directly
				u32ALUCFR = u32r_ALU_ACF[i][u32ALUIdx];				

				if (p_u32Opcode == op_ht_c) // opcode 82
				{
					if (u32Mode == 1 || u32Mode == 3 || u32Mode == 4)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}

					switch (u32Mode)
					{
						case 0: // Rm=Rm>Rn?(Rm-Rn):0(U,k)
						case 1:
							u32Result = IsHT32_SZ(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
						case 2: // HRm=HRm>HRn?(HRm-HRn):0(U,k)
						case 3: 
							u32Result = IsHTD16_SZ(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
						case 4: // FRm=FRm> FRn? (FRm-FRn):0(k)
							u32Result = IsHTF32_SZ(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
					}				
				}				
				else if (p_u32Opcode == op_he_c) // opcode 83
				{
					if (u32Mode == 1 || u32Mode == 3 || u32Mode == 4)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}

					switch (u32Mode)
					{
						case 0: // Rm=Rm>=Rn?Rm:Rn(U,k)
						case 1:
							u32Result = IsHE32_MN(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
						case 2: // HRm=HRm>=HRn?HRm:HRn(U,k)
						case 3:
							u32Result = IsHED16_MN(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
						case 4: // FRm=FRm>=FRn?FRm:FRn(k)
							u32Result = IsHEF32_MN(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
					}				
				}
				// write ACF register
				u32r_ALU_ACF[i][u32ALUIdx] = u32ALUCFR;
				// write ALUFR register
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				// write result
				WriteGPR_Page(i, u32SrcMIdx, u32Result, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_acf_is_ht_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_acf_is_ht_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_acf_is_ht_32_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32ALUIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
  	  		struct  SPLIT_VALUE
	    	{
 	 	  		DSPU32    	u6SrcN: 6;
	 	 	  	DSPU32    	u6SrcM: 6;
				DSPU32    	u3Mode: 3;
				DSPU32    	u3ALUIdx: 3;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3ALUIdx;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		// Which macros(units) will be used?
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// which ALU in one macro is used
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		// this instruction will use specific calc resource
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] in current macro directly or by data forward
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}				

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32Status, u32Mode, u32SrcMIdx, u32SrcA, u32SrcB;
		DSPU32 u32ALUIdx, u32ALUCR, u32ALUCFR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				// read ACF register directly
				u32ALUCFR = u32r_ALU_ACF[i][u32ALUIdx];				

				if (p_u32Opcode == op_acf_is_ht_32_c) // opcode 88
				{
					if ((u32Mode & 1) == 1)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}

					switch (u32Mode)
					{
						case 0: // ACFs=Rm>Rn?1:0(U)
						case 1:
							ACFIsHT32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 2: // ACFs=Rm>=Rn?1:0(U)
						case 3:
							ACFIsHE32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 4: // ACFs=Rm==Rn?1:0(U)
						case 5:
							ACFIsEQ32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 6: // ACFs=Rm!=Rn?1:0(U)
						case 7:
							ACFIsNEQ32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						default:
							PrintToCerr("like_acf_is_ht_32_cores: Invalid parameter\n");
					}				
				}
				else if (p_u32Opcode == op_acf_is_ht_d16_c) // opcode 89
				{
					if ((u32Mode & 1) == 1)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}

					switch (u32Mode)
					{
						case 0: // ACFs=HRm>HRn?1:0(U)
						case 1:
							ACFIsHTD16(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR,  u32ALUCR);
							break;
						case 2: // ACFs=HRm>=HRn?1:0(U)
						case 3:
							ACFIsHED16(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR,  u32ALUCR);
							break;
						case 4: // ACFs=HRm==HRn?1:0(U)
						case 5:
							ACFIsEQD16(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR,  u32ALUCR);
							break;
						case 6: // ACFs=HRm!=HRn?1:0(U)
						case 7:
							ACFIsNEQD16(u32SrcA, u32SrcB, &u32Status, &u32ALUCFR, u32ALUCR);
							break;
						default:
							PrintToCerr("like_acf_is_ht_32_cores: Invalid parameter\n");
					}				
				}
				else if (p_u32Opcode == op_acf_is_ht_f32_c) // opcode 90
				{
					if (u32Mode < 4)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}				

					switch (u32Mode)
					{
						case 0: // ACFs=FRm>FRn?1:0
							ACFIsHTF32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 1: // ACFs=FRm>=FRn?1:0
							ACFIsHEF32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 2: // ACFs=FRm==FRn?1:0
							ACFIsEQF32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 3: // ACFs=FRm!=FRn?1:0
							ACFIsNEQF32(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 4: // ACFs=ORm>ORn?1:0(U)
							ACFIsHTQ8(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 5: // ACFs=ORm>=ORn?1:0(U)
							ACFIsHEQ8(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 6: // ACFs=ORm==ORn?1:0(U)
							ACFIsEQQ8(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;
						case 7: // ACFs=ORm!=ORn?1:0(U)
							ACFIsNEQQ8(u32SrcA, u32SrcB,  u32ALUCR, &u32Status, &u32ALUCFR);
							break;

						default:
							PrintToCerr("like_acf_is_ht_32_cores: Invalid parameter\n");
					}				
				}		
				
				// write ACF register
				u32r_ALU_ACF[i][u32ALUIdx] = u32ALUCFR;
				// write ALUFR register
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
			}

		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_acc_addsub_d16_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_acc_addsub_d16_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_acc_addsub_d16_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32ALUIdx, u32Mode;
		union INSTR_WORD
		{
			DSPU32 u32Value;
   	 		struct  SPLIT_VALUE
    		{
    			DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u3Mode: 3;
				DSPU32    	u3ALUIdx: 3;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		// which macros(units) are involved
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// which ALU in one macro is used
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		// this instruction will use specific calc resource
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.				
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				if(p_u32Opcode!=op_acc_fix16_manh_c)
				{
					SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				else
				{
					if(u32Mode!=2 && u32Mode!=3)
					{
						SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
					}
				}			
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;		

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
				
				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] in current macro directly or by data forward
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				//DFHACCs=DFHRm+DFHRn和DFLACCs=DFLRm+DFLRn会影响DFIRR寄存器
				DSPU32 u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
				if((p_u32Opcode == op_acc_fix16_manh_c && u32Mode == 6) || 
					(p_u32Opcode == op_acc_fix16_manh_c && u32Mode == 7))
				{
					DSP_BIT64 DFIRRTemp = ReadALUDFIRR(i, u32ALUIdx);
					//DFHACCs=DFHRm+DFHRn
					if(u32Mode == 6)
					{
						ACCAddF64HToDFIRR(m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0], m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0], DFIRRTemp);
					}
					else //DFLACCs=DFLRm+DFLRn
					{
						ACCAddF64LToDFIRR(m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0], m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0], DFIRRTemp);
					}
					WriteALUDFIRR(i, u32ALUIdx, DFIRRTemp.u32Low, false);
					WriteALUDFIRR(i, u32ALUIdx, DFIRRTemp.u32High, true);
				}

				if((p_u32Opcode == op_acc_addsub_d16_c && u32Mode == 6) || 
					(p_u32Opcode == op_acc_addsub_d16_c && u32Mode == 7))
				{
					DSP_BIT64 DFIRRTemp = ReadALUDFIRR(i, u32ALUIdx);
					
					//DFHACCs=DFHRm-DFHRn
					if(u32Mode == 6)
					{
						ACCSubF64HToDFIRR(m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0], m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0], DFIRRTemp);
					}
					else //DFLACCs=DFLRm-DFLRn
					{
						ACCSubF64LToDFIRR(m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0], m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0], DFIRRTemp);
					}
					WriteALUDFIRR(i, u32ALUIdx, DFIRRTemp.u32Low, false);
					WriteALUDFIRR(i, u32ALUIdx, DFIRRTemp.u32High, true);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32ALUIdx, u32Status, u32ALUCR, u32Mode, u32SrcA, u32SrcB;
		DSPU32 u32SrcMIdx, u32SrcNIdx;
		DSP_BIT48 b48Temp;
		DSP_BIT80 b80Temp;
		DSPU32 u32CA;

		DSP_BIT64 DFIRRTemp;
		DSP_BIT64 u64DFMRTemp;
		DSPU32 u32DFERTemp;
		DSPU64 u64Temp;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				b48Temp.u32Low = 0;
				b48Temp.u8Mid = 0;
				b48Temp.u8High = 0;
				b80Temp.u64Low = 0;
				b80Temp.u16High = 0;
				DFIRRTemp.u32High=0;
				DFIRRTemp.u32Low=0;
				u64DFMRTemp.u32High=0;
				u64DFMRTemp.u32Low=0;
				u32DFERTemp=0;
				if (p_u32Opcode == op_acc_addsub_d16_c) // opcode 91
				{
					switch (u32Mode)
					{
						case 0:  // HACCs = compose(LHRm, HHRn) (U)
							ACCAddSubD16(u32SrcA, u32SrcB, b48Temp, &u32Status, u32ALUCR, 0);
							break;
						case 1:  // HACCs = compose(HHRm, LHRn) (U)
							ACCAddSubD16(u32SrcA, u32SrcB, b48Temp, &u32Status, u32ALUCR, 1);
							break;
						case 2:  // HACCs +/-= compose(LHRm, HHRn) (U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCAddSubD16(u32SrcA, u32SrcB, b48Temp, &u32Status, u32ALUCR, 2);
							break;
						case 3:  // HACCs -/+= compose(LHRm, HHRn) (U)
							ReadACC_48(i, u32ALUIdx, b48Temp);  // GRQ: phase right?
							ACCAddSubD16(u32SrcA, u32SrcB, b48Temp, &u32Status, u32ALUCR, 3);
							break;
						case 4:  // HACCs +/-= compose(HHRm, LHRn) (U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCAddSubD16(u32SrcA, u32SrcB, b48Temp, &u32Status, u32ALUCR, 4);
							break;
						case 5:  // HACCs -/+= compose(HHRm, LHRn) (U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCAddSubD16(u32SrcA, u32SrcB, b48Temp, &u32Status, u32ALUCR, 5);
							break;
						case 6:  //DFHACCs=DFHRm-DFHRn
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u64DFMRTemp = ReadALUDFMR(i, u32ALUIdx);
							u32DFERTemp = ReadALUDFER(i, u32ALUIdx);
							u64Temp = u64DFMRTemp.u32High;
							u64Temp = (u64Temp << 32) | u64DFMRTemp.u32Low;
							b80Temp.u64Low = u64Temp;
							b80Temp.u16High = u32DFERTemp;
							ACCSubF64H(u32SrcA, u32SrcB, b80Temp, &u32Status, u32ALUCR);
							break;
						default:  //DFLACCs=DFLRm-DFLRn	
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u64DFMRTemp = ReadALUDFMR(i, u32ALUIdx);
							u32DFERTemp = ReadALUDFER(i, u32ALUIdx);
							u64Temp = u64DFMRTemp.u32High;
							u64Temp = (u64Temp << 32) | u64DFMRTemp.u32Low;
							b80Temp.u64Low = u64Temp;
							b80Temp.u16High = u32DFERTemp;
							DFIRRTemp = ReadALUDFIRR(i, u32ALUIdx);
							ACCSubF64L(u32SrcA, u32SrcB, b80Temp,DFIRRTemp, &u32Status, u32ALUCR);  	
					}
				}
				else if (p_u32Opcode == op_add_32_ca_c) // opcode 92
				{			
					u32CA = ReadALUCA(i,u32ALUIdx);
					switch (u32Mode)
					{
						case 0:  // ACCs=Rm+Rn+Ca(U)
							Add32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 1);
							break;
						case 1:  // ACCs=Rm+Rn+Ca
							u32ALUCR = GSetBit(u32ALUCR, 0);
							Add32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 1);
							break;
						case 2:  // ACCs=Rm-Rn-Ca(U)
							Sub32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 1);
							break;
						case 3:  // ACCs=Rm-Rn-Ca
							u32ALUCR = GSetBit(u32ALUCR, 0);
							Sub32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 1);
							break;
						case 4:  // ACCs=Rm+Rn(U)
							Add32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 0);
							break;
						case 5:  // ACCs=Rm+Rn
							u32ALUCR = GSetBit(u32ALUCR, 0);
							Add32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 0);
							break;
						case 6:  // ACCs=Rm-Rn(U)
							Sub32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 0);
							break;
						case 7:  // ACCs=Rm-Rn
							u32ALUCR = GSetBit(u32ALUCR, 0);
							Sub32CA(u32SrcA, u32SrcB, u32ALUCR, b48Temp, &u32Status, u32CA, 0);
							break;
						default:
							PrintToCerr("like_acc_addsub_d16_cores: Invalid parameter\n");
					}
					WriteALUCA(i,u32ALUIdx,u32CA);
				}
				else if (p_u32Opcode == op_acc_max_fix32_c) // opcode 93
				{
					DSPU32 u32PageIdx = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx;
					switch (u32Mode)
					{
						case 0:  // ACCs=MAX_S(Rm,Rn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
                            AccMaxFix32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 1);
							break;
						case 1:  // ACCs=MIN_S(Rm,Rn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinFix32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 1);
							break;
						case 2:  // ACCs=MAX_S(Rm,Rn,ACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxFix32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 0);
							break;
						case 3:  // ACCs=MIN_S(Rm,Rn,ACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinFix32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 0);
							break;
						case 4:  // ACCs=MAX_S(FRm,FRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxFlo32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 1, &u32Status);
							break;
						case 5:  // ACCs=MIN_S(FRm,FRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinFlo32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 1, &u32Status);
							break;
						case 6:  // ACCs=MAX_S(FRm,FRn,ACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxFlo32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 0, &u32Status);
							break;
						case 7:  // ACCs=MIN_S(FRm,FRn,ACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinFlo32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 0, &u32Status);
							break;
						default:
							PrintToCerr("like_acc_addsub_d16_cores: Invalid parameter\n");
					}
				}

				else if (p_u32Opcode == op_acc_max_4fix16_c) // opcode 94
				{
					DSPU32 u32PageIdx = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx;
					switch (u32Mode)
					{
						case 0:  // LHACCs=MAX_S(HRm,HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMax4Fix16(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR);
							break;
						case 1:  // LHACCs=MIN_S(HRm,HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMin4Fix16(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR);
							break;
						case 2:  // LHACCs=MAX_S(HRm,HRn,LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMax5Fix16(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR);
							break;
						case 3:  // LHACCs=MIN_S(HRm,HRn,LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMin5Fix16(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR);
							break;
						case 4:  // LOACCs=MAX_S(ORm,ORn)(U)
							AccMaxFix8(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 1);
							break;
						case 5:  // LOACCs=MIN_S(ORm,ORn)(U)
							AccMinFix8(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 1);
							break;
						case 6:  // LOACCs=MAX_S(ORm,ORn,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxFix8(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 0);
							break;
						case 7:  // LOACCs=MIN_S(ORm,ORn,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinFix8(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 0);
							break;
						default:
							PrintToCerr("like_acc_addsub_d16_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_acc_maxr_2fix32_MN_c) // opcode 96
				{
					switch (u32Mode)
					{
						case 0:  // ACCs=MAX_R(Rm, Rn,ACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxR2Fix32MN(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 1:  // ACCs=MIN_R(Rm, Rn,ACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinR2Fix32MN(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 2:  // ACCs=compose(Rm, Rn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccIsFix32MN(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						
						case 4:  // FACCs=MAX_R(FRm, Rn,FACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxR2Flo32MN(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 5:  // FACCs=MIN_R(FRm, Rn,FACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinR2Flo32MN(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 6:  // FACCs=compose(FRm, FRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccIsFlo32MN(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						
						default:
							PrintToCerr("like_acc_addsub_d16_cores: Invalid parameter\n");
					}
				}				
				else if (p_u32Opcode == op_acc_maxr_2fix16_c) // opcode 97
				{
					switch (u32Mode)
					{
						case 0:  // LHACCs=MAX_R(HRm,HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxR2Fix16Reg(u32SrcA, u32SrcB, b48Temp, u32ALUCR); // GRui
							break;
						case 1:  // LHACCs=MIN_R(HRm,HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinR2Fix16Reg(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 2:  // LHACCs=MAX_R(HRm,HRn,LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxR3Fix16(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 3:  // LHACCs=MIN_R(HRm,HRn,LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinR3Fix16(u32SrcA, u32SrcB, b48Temp, u32ALUCR);
							break;
						case 4:  // LOACCs=MAX_R(ORm,ORn)(U)
							AccMaxRFix8(u32SrcA, u32SrcB, b48Temp, u32ALUCR, 1);
							break;
						case 5:  // LOACCs=MIN_R(ORm,ORn)(U)
							AccMinRFix8(u32SrcA, u32SrcB, b48Temp, u32ALUCR, 1);
							break;
						case 6:  // LOACCs=MAX_R(ORm,ORn,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxRFix8(u32SrcA, u32SrcB, b48Temp, u32ALUCR, 0);
							break;
						case 7:  // LOACCs=MIN_R(ORm,ORn,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinRFix8(u32SrcA, u32SrcB, b48Temp, u32ALUCR, 0);
							break;
						default:
							PrintToCerr("like_acc_addsub_d16_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_acc_maxr_reg_acc_c) // opcode 98
				{
					switch (u32Mode)
					{
						case 4:  // ACCs = ABS(ORm-ORn)(U)
							ACCABSQ8(u32SrcA, u32SrcB, b48Temp, u32ALUCR, &u32Status);
							break;
						case 5:  // ACCs += ABS(ORm-ORn)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCABSQ8(u32SrcA, u32SrcB, b48Temp, u32ALUCR, &u32Status);
							break;
						case 6:  // ACCs = ABS(HRm-HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ACCABSD16(u32SrcA, u32SrcB, b48Temp, u32ALUCR, &u32Status);
							break;
						case 7:  // ACCs += ABS(HRm-HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							ACCABSD16(u32SrcA, u32SrcB, b48Temp, u32ALUCR, &u32Status);
							break;
						default:
							PrintToCerr("like_acc_addsub_d16_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_acc_fix16_manh_c) // opcode 99
				{
					DSPU32 u32PageIdx = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx;
					switch (u32Mode)
					{
						case 0:  // LHACCs=MAX_S(manh(CHRm),manh(CHRn))
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxFix16Manh(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, &u32Status, u32ALUCR);
							break;
						case 1:  // LHACCs=MIN_S(manh(CHRm),manh(CHRn))
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinFix16Manh(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, &u32Status, u32ALUCR);
							break;
						case 2:  //LHACCs=MAX_S(manh(CHRm),LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							MaxManhRmACC(u32SrcA, u32SrcMIdx, u32PageIdx, b48Temp, &u32Status, u32ALUCR);
							break;
						case 3:  //LHACCs=Min_S(manh(CHRm),LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							MinManhRmACC(u32SrcA, u32SrcMIdx, u32PageIdx, b48Temp, &u32Status, u32ALUCR);
							break;
						case 4: //LHACCs=MAX_S(manh(CHRm),manh(CHRn),LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							MaxManhRmRnACC(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, &u32Status, u32ALUCR);
							break;
						case 5: //LHACCs=Min_S(manh(CHRm),manh(CHRn),LHACCs)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							ReadACC_48(i, u32ALUIdx, b48Temp);
							MinManhRmRnACC(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, &u32Status, u32ALUCR);
							break;
						case 6: //DFHACCs=DFHRm+DFHRn
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u64DFMRTemp = ReadALUDFMR(i, u32ALUIdx);
							u32DFERTemp = ReadALUDFER(i, u32ALUIdx);
							u64Temp = u64DFMRTemp.u32High;
							u64Temp = (u64Temp << 32) | u64DFMRTemp.u32Low;
							b80Temp.u64Low = u64Temp;
							b80Temp.u16High = u32DFERTemp;
							ACCAddF64H(u32SrcA, u32SrcB, b80Temp, &u32Status, u32ALUCR);
							break;
						default: //DFLACCs=DFLRm+DFLRn
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u64DFMRTemp = ReadALUDFMR(i, u32ALUIdx);
							u32DFERTemp = ReadALUDFER(i, u32ALUIdx);
							u64Temp = u64DFMRTemp.u32High;
							u64Temp = (u64Temp << 32) | u64DFMRTemp.u32Low;
							b80Temp.u64Low = u64Temp;
							b80Temp.u16High = u32DFERTemp;
							DFIRRTemp = ReadALUDFIRR(i,u32ALUIdx);
							ACCAddF64L(u32SrcA, u32SrcB, b80Temp, DFIRRTemp,&u32Status, u32ALUCR);  
					}
				}

				if((p_u32Opcode == op_acc_fix16_manh_c && u32Mode == 6) || 
				  (p_u32Opcode == op_acc_fix16_manh_c && u32Mode == 7) ||
				  (p_u32Opcode == op_acc_addsub_d16_c && u32Mode == 6) ||
				  (p_u32Opcode == op_acc_addsub_d16_c && u32Mode == 7) )
				{
					u64DFMRTemp.u32Low = b80Temp.u64Low & 0xffffffff;
					u64DFMRTemp.u32High = (b80Temp.u64Low >> 32) & 0xffffffff;
					WriteALUDFMR(i, u32ALUIdx, u64DFMRTemp.u32High, true);
					WriteALUDFMR(i, u32ALUIdx, u64DFMRTemp.u32Low, false);
					WriteALUDFER(i, u32ALUIdx, b80Temp.u16High);
				}
				else
				{
					WriteACC_48(i, u32ALUIdx, b48Temp);
				}
				u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;
				
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read flag info from pipeline and write ALUFR register
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_acc_max_reg_acc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_acc_max_reg_acc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_acc_max_reg_acc_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32ALUIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
   	 		struct  SPLIT_VALUE
    		{
    			DSPU32    	u6Rev0: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u3Mode: 3;
				DSPU32    	u3ALUIdx: 3;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		// which macros(units) are involved
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// which ALU in one macro is used
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		// this instruction will use specific calc resource
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.				
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32ALUIdx;		

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
				
				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32ALUIdx, u32Status, u32ALUCR, u32Mode;
		DSPU32 u32SrcMIdx, u32SrcNIdx, u32SrcA, u32SrcB, u32PageIdx;
		DSP_BIT48 b48Temp;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = 0;
				u32SrcNIdx = 0;
				u32PageIdx = m_arrResSLK[p_u32SLKIdx].slot_res_used.u32SrcPageIdx;

				u32Status = 0;
				b48Temp.u8High=0;
				b48Temp.u32Low=0;
				b48Temp.u8Mid=0;
				if (p_u32Opcode == op_acc_max_reg_acc_c) // opcode 95
				{					
					switch (u32Mode)
					{
						case 0:  // ACCs=MAX_S(Rm,ACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxFix32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 2);
							break;
						case 1:  // ACCs=MIN_S(Rm,ACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinFix32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 2);
							break;
						case 2:  // ACCs=MAX_S(FRm,ACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxFlo32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 2, &u32Status);
							break;
						case 3:  // ACCs=MIN_S(FRm,ACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinFlo32(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 2, &u32Status);
							break;
						case 4:  // LHACCs=MAX_S(HRm,LHACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxS3Fix16(u32SrcA, u32SrcMIdx, u32PageIdx, b48Temp, u32ALUCR);
							break;
						case 5:  // LHACCs=MIN_S(HRm,LHACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinS3Fix16(u32SrcA, u32SrcMIdx, u32PageIdx, b48Temp, u32ALUCR);
							break;
						case 6:  // LOACCs=MAX_S(ORm,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxFix8(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 2);
							break;
						case 7:  // LOACCs=MIN_S(ORm,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinFix8(u32SrcA, u32SrcB, u32SrcMIdx, u32SrcNIdx, u32PageIdx, b48Temp, u32ALUCR, 2);
							break;
						default:
							PrintToCerr("like_acc_max_reg_acc_cores: Invalid parameter\n");
					}
				}
				else if (p_u32Opcode == op_acc_maxr_reg_acc_c) // opcode 98
				{
					switch (u32Mode)
					{
						case 0:  // LHACCs=MAX_R(HRm,LHACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMaxR2Fix16(u32SrcA, b48Temp, u32ALUCR);
							break;
						case 1:  // LHACCs=MIN_R(HRm,LHACCs)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							u32ALUCR = GSetBit(u32ALUCR, 0);
							AccMinR2Fix16(u32SrcA, b48Temp, u32ALUCR);
							break;
						case 2:  // LOACCs=MAX_R(ORm,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMaxRFix8(u32SrcA, 0, b48Temp, u32ALUCR, 2);
							break;
						case 3:  // LOACCs=MIN_R(ORm,LOACCs)(U)
							ReadACC_48(i, u32ALUIdx, b48Temp);
							AccMinRFix8(u32SrcA, 0, b48Temp, u32ALUCR, 2);
							break;
						default:
							PrintToCerr("like_acc_max_reg_acc_cores: Invalid parameter\n");
					}
				}
				
				WriteACC_48(i, u32ALUIdx, b48Temp);
				u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read flag info from pipeline and write ALUFR register
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_hl_add_sub_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{	
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_hl_add_sub_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_hl_add_sub_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units;

		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
    			DSPU32    	u1Half: 1;
				DSPU32    	u4Mode: 4;
				DSPU32    	u1Signed: 1;
		    	DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32   	u1MultiWord: 1;
				DSPU32   	u4Units: 4;
 			   	DSPU32   	u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u1Half;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Signed;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		// Which macros(units) will be used?
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		// this instruction just need 1 ALU
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 1;
		// Don't need to use specific ALU
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolDestHL = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Result;
		DSPU32 u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				// get the value of R[u32SrcMIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}			

			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32SrcMIdx, u32DestIdx, u32Units, u32Status, u32Flag, u32Mode, u32Sign;
		DSPU32 u32Temp, u32Result, u32SrcValue, u32ALUCR;
		bool bolHalf;
		DSPU32 u32ALUIdx, u32DestRegValue;
				
		bolHalf = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Temp = 0;
		u32Result = 0;
		u32Flag = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcValue = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				if (u32Sign == 1)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
				}
				u32Status = 0;
				//u32DestRegValue = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.EX_WB.m_right.arrSrcPageIdx[i]);
				u32DestRegValue = ReadGPR_Page(i, u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
				switch (u32Mode)
				{
					case 1:  // HHRs=HHRm+LHRm
						u32Result = u32DestRegValue;
						u32Temp = InAdd16ToH(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Result = (u32Result & 0xFFFF) | (u32Temp & 0xFFFF0000);
						u32Flag = u32Status;
						break;
					case 2:  // LHRs=HHRm+LHRm
						u32Result = u32DestRegValue;
						u32Temp = InAdd16ToL(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Result = (u32Result & 0xFFFF0000) | (u32Temp & 0xFFFF);
						u32Flag = u32Status;
						break;
					case 3:  // HHRs=HHRm-LHRm
						u32Result = u32DestRegValue;
						u32Temp = InSub16ToH(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Result = (u32Result & 0xFFFF) | (u32Temp & 0xFFFF0000);
						u32Flag = u32Status;
						break;
					case 4:  // LHRs=HHRm-LHRm
						u32Result = u32DestRegValue;
						u32Temp = InSub16ToL(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Result = (u32Result & 0xFFFF0000) | (u32Temp & 0xFFFF) ;
						u32Flag = u32Status;
						break;

					case 5:  // HHRs=LHRm-HHRm
						u32Result = u32DestRegValue;
						u32Temp = InSub16LHToH(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Result = (u32Result & 0xFFFF) | (u32Temp & 0xFFFF0000);
						u32Flag = u32Status;
						break;
					case 6:  // LHRs=LHRm-HHRm
						u32Result = u32DestRegValue;
						u32Temp = InSub16LHToL(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Result = (u32Result & 0xFFFF0000) | (u32Temp & 0xFFFF);
						u32Flag = u32Status;
						break;

					case 7:  // HHRs=HHRm+/-LHRm
						u32Result = InAddSub16ToHL(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Flag = u32Status;
						break;
					case 8:  // LHRs=HHRm+/-LHRm
						u32Result = InAddSub16ToLH(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Flag = u32Status;
						break;
					case 9:  // HHRs=LHRm+/-HHRm
						u32Result = InAddSub16LHToH(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Flag = u32Status;
						break;
					case 10:  // LHRs=LHRm+/-HHRm
						u32Result = InAddSub16LHToL(u32SrcValue, &u32Status, u32ALUCR, bolHalf);
						u32Flag = u32Status;
						break;
					default: 
						PrintToCerr("like_hl_add_sub_cores: invalid option\n");
				}

				if ( GIsBitSet(u32ALUCR, 3) && (u32Sign == 1))  // GRQ
				{
					if ((u32Mode >= 7) &&  (u32Mode <= 10))
					{
						m_arrChgBKF[i] = true;
						m_arrALU_BKFlag[i][u32ALUIdx] = BKF_DI16(u32Result);
					}					
				}
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Flag);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_ht_hlreg_tohl_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_ht_hlreg_tohl_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_ht_hlreg_tohl_cores: parameter is invalid\n");
		return false;
	}	

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32DestIdx, u32ALUIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
	    	struct  SPLIT_VALUE
	    	{	    		
				DSPU32      u3ALUIdx: 3;
				DSPU32    	u2Mode: 2;
				DSPU32    	u1Signed: 1;
		    	DSPU32      u6SrcM: 6;
				DSPU32      u6Dest: 6;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
	 		   	DSPU32      u1Line: 1;
			} details;
		} instr_word;
		
		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u1Signed;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		
		// Which macros(units) will be used?
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;		
		// need to use specific ALU
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		// GRQ: read part about bolDestHL
		m_arrResSLK[p_u32SLKIdx].slot_res_used.bolDestHL = true;  

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result;
		DSPU32 u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				// get the index of the first ALU allocated for this instruction in current macro
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				// get the value of R[u32SrcMIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32Flag, u32DestIdx, u32Status, u32Mode, u32Sign, u32SrcA;
		DSPU32 u32ALUIdx, u32Result, u32GenResultIdx, u32ALUCR, u32ALUCFR;
		DSPU32 u32DestRegValue;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		u32GenResultIdx = 0;
		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{

				// get the index of the first ALU allocated for this instruction
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				// set sign flag
				if (u32Sign == 1)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
				}

				u32Status = 0;
				u32ALUCFR = u32r_ALU_ACF[i][u32ALUIdx];
				u32DestRegValue = ReadGPR_Page(i, u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);

				switch (p_u32Opcode)
        		{
					case op_ht_hlreg_tohl_c:   // opcode 100
						if (u32Mode == 0)      //HHRs=HHRm>LHRm?(HHRm-LHRm):0(U,k)
						{
							u32Result = IsHT16HL(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF | (u32Result << 16);
						}
						else if (u32Mode == 1) //HHRs=LHRm>HHRm?(LHRm-HHRm):0(U,k)
						{
							u32Result = IsHT16LH(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF | (u32Result << 16);
						}
						else if (u32Mode == 2) //LHRs=HHRm>LHRm?(HHRm-LHRm):0(U,k)
						{
							u32Result = IsHT16HL(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF0000 | u32Result;
						}
						else if (u32Mode == 3) //LHRs=LHRm>HHRm?(LHRm-HHRm):0(U,k)
						{
							u32Result = IsHT16LH(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF0000 | u32Result;
						}
						
                   		break;
					case op_he_hlreg_tohl_c:   // opcode 101
						if (u32Mode == 0)      //HHRs=HHRm>=LHRm?HHRm:LHRm(U,k)
						{
							u32Result = IsHE16HL(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF | (u32Result << 16);
						}
						else if (u32Mode == 1) //HHRs=LHRm>=HHRm?LHRm:HHRm(U,k)
						{
							u32Result = IsHE16LH(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF | (u32Result << 16);
						}
						else if (u32Mode == 2) //LHRs=HHRm>=LHRm?HHRm:LHRm(U,k)
						{
							u32Result = IsHE16HL(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF0000 | u32Result;
						}
						else if (u32Mode == 3) //LHRs=LHRm>=HHRm?LHRm:HHRm(U,k)
						{
							u32Result = IsHE16LH(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF0000 | u32Result;
						}

                   		break;
					case op_is_eq_16_sz_c:   // opcode 102
						if (u32Mode == 0)      //HHRs=HHRm==LHRm?(HHRm-LHRm):0(U,k)
						{
							u32Result = IsEQ16SZ(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF | (u32Result << 16);
						}
						else if (u32Mode == 1) //LHRs=HHRm==LHRm?(HHRm-LHRm):0(U,k)
						{
							u32Result = IsEQ16SZ(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF0000 | u32Result;							
						}
						else if (u32Mode == 2) //HHRs=HHRm==LHRm?HHRm:LHRm(U,k)
						{
							u32Result = IsEQ16HL(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF | (u32Result << 16);
						}
						else if (u32Mode == 3) //LHRs=HHRm==LHRm?HHRm:LHRm(U,k)
						{
							u32Result = IsEQ16HL(u32SrcA, &u32Status, &u32ALUCFR, u32ALUCR);
							u32Result = u32DestRegValue & 0xFFFF0000 | u32Result;
						}

                   		break;
					default:
						PrintToCerr("like_ht_hlreg_tohl_cores: opcode not found\n");
                    	u32Result = 0;
				}

				// write ALUFR register
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				// write ALUCFR register
				u32r_ALU_ACF[i][u32ALUIdx] = u32ALUCFR;
				// write GPR
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32Result);
				u32GenResultIdx++;

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_reg_is_acc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_reg_is_acc_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_reg_is_acc_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32DestIdx, u32Units,u32ALUIdx,u32Mode;

		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
    			DSPU32    	u3ALUIdx: 3;
    			DSPU32    	u1Signed: 1;
		    	DSPU32    	u4CutPos: 4;
				DSPU32    	u4Mode: 4;
				//DSPU32    	u2Flag: 2;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Signed;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4CutPos;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
			//g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u2Flag;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		DSPU32 u32MaskTemp = 0U;
		DSPU32 MulIdx = u32ALUIdx;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				if(u32Mode==0x5U)
				{
					u32MaskTemp = GSetBit(u32MaskTemp,i*8 + MulIdx);
				}

				if(u32Mode>=0 && u32Mode<=0x4U)
				{
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}

				if(u32Mode==0x6U || u32Mode==0x7U)
				{
					SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		if(u32Mode==0x5U)
		{
			m_arrResSLK[p_u32SLKIdx].slot_res_used.u32RdAMACCMask = u32MaskTemp;
		}
		
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units,u32Mode,u32Result,u32SrNIdx;
		DSPU32 u32ALUIdx;
		DSP_BIT64 DFIRRTemp;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32SrNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);
				
				if(u32Mode==0x6U || u32Mode==0x7U)
				{
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrNIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
				}
			}
		}
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32Status, u32ALUCR, u32Sign, u32CutPos, u32Mode,u32Src;
		DSPU32 u32ALUIdx;
		DSP_BIT40 u40Temp;
		DSPU8 u8EXP;
		DSP_BIT64 DFIRRTemp;
				
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32CutPos = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				
				DFIRRTemp.u32High=0;
				DFIRRTemp.u32Low=0;
				u8EXP = 0;
				u40Temp.u32Low=0;
				u40Temp.u8High=0;
				if (u32Sign == 1)
				{
					u32ALUCR = GSetBit(u32ALUCR, 0);
				}

				u32Status = 0;
				
					switch (u32Mode)
					{
						case 0: // Rs=ACCm(U,cut=C)
							u40Temp = ReadACC(i, u32ALUIdx);
							u32r_ALUA_EX[i][u32ALUIdx] = ACCTo32(u40Temp, &u32Status, u32ALUCR, u32CutPos);
						break;
						case 1: // HRs=ACCm(U,cut=C)
							u40Temp = ReadACC(i, u32ALUIdx);
							u32r_ALUA_EX[i][u32ALUIdx] = ACCToD16(u40Temp, &u32Status, u32ALUCR, u32CutPos);
						break;
						case 2: // ORs=OACCm(U,cut=C)
							DSP_BIT48 u48Temp;
							ReadACC_48(i, u32ALUIdx,u48Temp);
							u32r_ALUA_EX[i][u32ALUIdx] = ACCToQ8(u48Temp, &u32Status, u32ALUCR, u32CutPos);
						break;
						case 3: // FRs=ACCs
							u32ALUCR = GSetBit(u32ALUCR, 0);	
							u8EXP = ReadACCExp(i, u32ALUIdx);
							u40Temp = ReadACC(i, u32ALUIdx);
							u32ALUCR |= 0x2;
							u32r_ALUA_EX[i][u32ALUIdx] = ACCToF32(u40Temp, &u32Status, u32ALUCR, u8EXP, false);
						break;
						case 4: 
							{
								u32ALUCR = GSetBit(u32ALUCR, 0);
								DSP_BIT80 u80Temp;
								DSP_BIT64 u64DFMRTemp;
								DSPU32 u32DFERTemp;
								DSPU64 u64Temp;

								u64DFMRTemp = ReadALUDFMR(i, u32ALUIdx);
								u32DFERTemp = ReadALUDFER(i, u32ALUIdx);
								u64Temp = u64DFMRTemp.u32High;
								u64Temp = (u64Temp << 32) | u64DFMRTemp.u32Low;
								u80Temp.u64Low = u64Temp;
								u80Temp.u16High = u32DFERTemp;
								DFIRRTemp=ReadALUDFIRR(i,u32ALUIdx);
								if (u32Sign == 0) // DFHRs = DFHACCm
								{
									u32r_ALUA_EX[i][u32ALUIdx] = ACCToF64H(u80Temp,DFIRRTemp,&u32Status, u32ALUCR);
								}
								else if (u32Sign == 1) // DFLRs = DFLACCm
								{
									u32r_ALUA_EX[i][u32ALUIdx] = ACCToF64L(u80Temp, DFIRRTemp, &u32Status, u32ALUCR);
								}
							}							
							break;
						case 5:
							{
								u32ALUCR = GSetBit(u32ALUCR, 0);
								DSP_BIT40 b40Temp = ReadACC(i, u32ALUIdx);
								DSPU8 u8EXP = ReadACCExp(i, u32ALUIdx);
								DSP_BIT128  xu128Temp = ReadMACC(i, u32ALUIdx);
								DSP_BIT40 u40AMACC;
								u40AMACC.u32Low = xu128Temp.u32LL;
								u40AMACC.u8High = xu128Temp.u32HL & 0xff;						
								if(u32Sign==0)
								{
									//ACCs+=AMACC
									ACCAddAMACC(u40AMACC, &b40Temp, &u8EXP, &u32Status, u32ALUCR); 
								}
								else //if(u32Sign==1)
								{
									//ACCs-=AMACC
									ACCSubAMACC(u40AMACC, &b40Temp, &u8EXP, &u32Status, u32ALUCR); 
								}
								WriteACC(i, u32ALUIdx, b40Temp);
								WriteACCExp(i, u32ALUIdx, u8EXP);
							}
							break;
						case 6: //HACCm=ABS(HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u32Src = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
							ACCAddAbs16(u32Src, &u40Temp,&u8EXP,&u32Status, u32ALUCR);
							WriteACC(i, u32ALUIdx, u40Temp);
							WriteACCExp(i, u32ALUIdx, u8EXP);
							break;
						case 7: //HACCm+=ABS(HRn)
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u32Src = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
							u40Temp = ReadACC(i, u32ALUIdx);
							u8EXP = ReadACCExp(i, u32ALUIdx);
							ACCAddAbs16(u32Src, &u40Temp,&u8EXP,&u32Status, u32ALUCR);
							WriteACC(i, u32ALUIdx, u40Temp);
							WriteACCExp(i, u32ALUIdx, u8EXP);
							break;
						case 9: //LHACCm=HHACC+LHACC(U)
							u40Temp = ReadACC(i, u32ALUIdx);
							u8EXP = ReadACCExp(i, u32ALUIdx);
							ACCSelfAdd(&u40Temp,&u8EXP,&u32Status, u32ALUCR);
							WriteACC(i, u32ALUIdx, u40Temp);
							WriteACCExp(i, u32ALUIdx, u8EXP);
							break;
						case 10://LHACCm=HHACC+LHACC,LHACCm=HHACC-LHACC,LHACCm=LHACC-HHACC,LHACCm=-HHACC-LHACC
						{
							u32ALUCR = GSetBit(u32ALUCR, 0);
							DSPU32 u32Flag = ExtractBinStr(p_u32InstrWord, 3, 2);
							u8EXP = ReadACCExp(i, u32ALUIdx);
							u40Temp = ReadACC(i, u32ALUIdx);
							if(u32Flag == 0)
							{
								ACCSelfAdd(&u40Temp, &u8EXP,&u32Status, u32ALUCR);
							}
							else
							{
								ACCSelfSub(&u40Temp, &u8EXP,&u32Status, u32ALUCR, u32Flag);
							}
							WriteACC(i, u32ALUIdx, u40Temp);
							WriteACCExp(i, u32ALUIdx, u8EXP);
							break;

						}
						default: 
							PrintToCerr("like_reg_is_acc_cores: invalid option\n");
					}
					
			
												
				u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;
			}
		}
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32GenResultIdx, u32Flag, u32DestIdx,u32Mode;
		DSPU32 u32ALUIdx;

		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				if(u32Mode<=0x4U)
				{
					wr_u32r_R_new(i, u32DestIdx, u32r_ALUA_EX[i][u32ALUIdx], PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				}			

				SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx, u32r_ALUA_EX[i][u32ALUIdx]);
				u32GenResultIdx++;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::rd_wr_acc_mode0_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("rd_wr_acc_mode0_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("rd_wr_acc_mode0_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32ALUIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
  		  	struct  SPLIT_VALUE
    		{
    			DSPU32    	u3ALUIdx: 3;
				DSPU32    	u2BitMode: 2;
				DSPU32    	u1Mode: 1;
	 	 	  	DSPU32    	u6SrcM: 6;
				DSPU32    	u6Rev0: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32       u1MultiWord: 1;
				DSPU32       u4Units: 4;
 			   	DSPU32       u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];	
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		}
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32ALUIdx, u32SrcA, u32Status;
		DSPU32 u32ALUCR;
		DSP_BIT40 b40Temp;
		DSP_BIT48 b48Temp;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				u32Status = 0;
				
				// ACCs=ACCs & Rm
				ReadACC_48(i, u32ALUIdx, b48Temp);
				AccAnd32(u32SrcA, b48Temp, &u32Status, u32ALUCR);
				WriteACC_48(i, u32ALUIdx, b48Temp);
				
				u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;
			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < NUM_OF_UNITS; i++)

	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::rd_wr_acc_mode1_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("rd_wr_acc_mode1_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("rd_wr_acc_mode1_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32DestIdx, u32ALUIdx, u32BitMode;

		union INSTR_WORD
		{
			DSPU32 u32Value;
  		  	struct  SPLIT_VALUE
    		{
    			DSPU32    	u3ALUIdx: 3;
				DSPU32    	u2BitMode: 2;
				DSPU32    	u1Mode: 1;
	 		   	DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32       u1MultiWord: 1;
				DSPU32       u4Units: 4;
	 		   	DSPU32       u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				
			}
		}
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32ALUIdx, u32Status, u32ALUCR, u32SrcA;
		DSP_BIT48 b48Temp;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				u32Status = 0;
				
				// Rs=HHACCm+Rm(U)
				ReadACC_48(i, u32ALUIdx, b48Temp);
				u32r_ALUA_EX[i][u32ALUIdx] = AccAddHH32(u32SrcA, b48Temp, &u32Status, u32ALUCR);
			
				u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;
			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Result, u32Flag, u32DestIdx, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

				u32Result = u32r_ALUA_EX[i][u32ALUIdx];
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < NUM_OF_UNITS; i++)

	}

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_c_add_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_c_add_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_c_add_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcMIdx, u32SrcNIdx, u32DestIdx, u32Units;

		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
	    	{
 		   		DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32       u1MultiWord: 1;
				DSPU32       u4Units: 4;
	 		   	DSPU32       u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;
		DSPU32 u32SrcMIdxSel, u32SrcNIdxSel;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32SrcMIdxSel = 0;
		u32SrcNIdxSel = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
                {
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);

					switch (p_u32Opcode)
	        		{
						case op_c_add_32_c:
						case op_c_sub_32_c:
						case op_c_addhalf_32_c:
						case op_c_subhalf_32_c:
						case op_c_add_flo32_c:
						case op_c_sub_flo32_c:
						case op_c_addhalf_flo32_c:
						case op_c_subhalf_flo32_c:
							u32SrcMIdxSel = u32SrcMIdx + k;
							u32SrcNIdxSel = u32SrcNIdx + k;
							break;
						case op_cj_add_32_c:
						case op_cj_sub_32_c:
						case op_cj_addhalf_32_c:
						case op_cj_subhalf_32_c:
						case op_cj_add_flo32_c:
						case op_cj_sub_flo32_c:
						case op_cj_addhalf_flo32_c:
						case op_cj_subhalf_flo32_c:
							if (k == 0)
							{
								u32SrcMIdxSel = u32SrcMIdx;
								u32SrcNIdxSel = u32SrcNIdx + 1;
							}
							else
							{
								u32SrcMIdxSel = u32SrcMIdx + 1;
								u32SrcNIdxSel = u32SrcNIdx;									
							}
							break;
						default:
							PrintToCerr("like_c_add_32_cores: parameter is invalid\n");

					} // switch (p_u32Opcode)

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}
					
                } // for (k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32ALUIdx, u32Result, u32GenResultIdx, u32ALUCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					switch (p_u32Opcode)
	        		{
						case op_c_add_32_c:  // opcode 49							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_c_sub_32_c:  // opcode 50
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_cj_add_32_c:  // opcode 51
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
							if (k == 0)
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						case op_cj_sub_32_c:  // opcode 52
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
							if (k == 0)
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;

						case op_c_addhalf_32_c:  // opcode 53							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
							u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_c_subhalf_32_c:  // opcode 54							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);     		               	
							u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_cj_addhalf_32_c:  // opcode 55							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	if (k == 0)
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						case op_cj_subhalf_32_c:  // opcode 56							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	if (k == 0)
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						case op_c_add_flo32_c:  // opcode 57							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_c_sub_flo32_c:  // opcode 58							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_cj_add_flo32_c:  // opcode 59							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	if (k == 0)
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						case op_cj_sub_flo32_c:  // opcode 60							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	if (k == 0)
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						case op_c_addhalf_flo32_c:  // opcode 61							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_c_subhalf_flo32_c:  // opcode 62							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
       	            		break;
						case op_cj_addhalf_flo32_c:  // opcode 63							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	if (k == 0)
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						case op_cj_subhalf_flo32_c:  // opcode 64							
							// set bit[0] of ALUCR indicate this is signed operation
							u32ALUCR = GSetBit(u32ALUCR, 0);
     		               	if (k == 0)
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
       	            		break;
						default:
							PrintToCerr("like_c_add_32_cores: opcode not found\n");
 		                   	u32Result = 0;
					}
										
					wr_u32r_R_new(i, u32DestIdx + k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

					SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx + k, u32Result);
					u32GenResultIdx++;

				} // for (int k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_inc_imm_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_inc_imm_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_inc_imm_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32Imm;

		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
    			DSPU32      u12Imm: 12;
				DSPU32      u6Dest: 6;
				DSPU32      u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			//u32Imm = instr_word.details.u12Imm;
			//g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = GSignExtend(u32Imm, 12);
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u12Imm;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32Result, u32ALUIdx, u32DestIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.		
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32Imm;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32SrcA;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{	
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				u32Status = 0;
				switch (p_u32Opcode)
        		{
					case op_inc_imm_u_c:  // opcode 43
						// set bit[0] of ALUCR indicate this is signed operation
						u32Result = Add32(u32SrcA, u32Imm, &u32Status, u32ALUCR);
                   		break;
					case op_dec_imm_u_c:  // opcode 44
						// set bit[0] of ALUCR indicate this is signed operation
                    	u32Result = Sub32(u32SrcA, u32Imm, &u32Status, u32ALUCR);
                   		break;
					case op_inc_imm_c:  // opcode 45
						// set bit[0] of ALUCR indicate this is signed operation
						u32ALUCR = GSetBit(u32ALUCR, 0);
						u32Imm = GSignExtend(u32Imm, 12);
                    	u32Result = Add32(u32SrcA, u32Imm, &u32Status, u32ALUCR);
                   		break;
					case op_dec_imm_c:  // opcode 46
						// set bit[0] of ALUCR indicate this is signed operation
						u32ALUCR = GSetBit(u32ALUCR, 0);
						u32Imm = GSignExtend(u32Imm, 12);
                    	u32Result = Sub32(u32SrcA, u32Imm, &u32Status, u32ALUCR);
                   		break;
               		default:
						PrintToCerr("like_inc_imm_cores: opcode not found\n");
                    	u32Result = 0;
        		}

				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::max_min_hlreg_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("max_min_hlreg_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("max_min_hlreg_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
				DSPU32    	u2Rev0: 2;
				DSPU32    	u1MaxToL: 1;
				DSPU32    	u2Rev1: 2;
				DSPU32      u1Signed: 1;
    			DSPU32    	u6SrcM: 6;
		    	DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
 			   	DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u1MaxToL;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Signed;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u2Rev0;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
				
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32ALUCFR, u32Sign, u32MaxToL;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32SrcA;
		DSPU32 u2Rev0;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32MaxToL = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];		
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];		
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u2Rev0 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		u32Result = 0;
		
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				
				u32Status = 0;
				if(u2Rev0==0)
				{
					u32ALUCFR = u32r_ALU_ACF[i][u32ALUIdx];	

					if (u32Sign == 1)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}		
				
					if (u32MaxToL == 1)
					{
						u32Result = MaxMin16(u32SrcA, &u32ALUCFR, u32ALUCR, false);
					}
					else
					{
						u32Result = MaxMin16(u32SrcA, &u32ALUCFR, u32ALUCR, true);
					}
					u32r_ALU_ACF[i][u32ALUIdx] = u32ALUCFR;
				}
				else if(u2Rev0==1)  //LHRs=abs(HHRm)+abs(LHRm)
				{
					DSPU32 u32DestRegValue = ReadGPR_Page(i, u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.u32DestPageIdx);
					u32ALUCR = GSetBit(u32ALUCR, 0);
					u32Result = AddAbs16(u32SrcA, &u32Status, u32ALUCR);
					u32Result = (u32DestRegValue & 0xFFFF0000) | (u32Result & 0xFFFF);
				}

				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_max_min_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_max_min_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_max_min_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
	    	struct  SPLIT_VALUE
	    	{
	    		DSPU32    	u6SrcN: 6;
		    	DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
	 		   	DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;		
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k + 1);
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (k = 0; k < 2; k++)
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
		DSPU32 u32ALUIdx, u32Result, u32GenResultIdx, u32ALUCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k + 1);
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					switch (p_u32Opcode)
	        		{
						case op_max_min_32_c:  // opcode 65
							u32ALUCR = GSetBit(u32ALUCR, 0);
							if (k == 0)
							{
								u32Result = Min32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Max32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
   	                		break;
						case op_max_min_16_c:  // opcode 66
							u32ALUCR = GSetBit(u32ALUCR, 0);
							if (k == 0)
							{
								u32Result = MinD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = MaxD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
   	                		break;
						case op_max_min_flo32_c:  // opcode 67
							u32ALUCR = GSetBit(u32ALUCR, 0);
							if (k == 0)
							{
								u32Result = MinF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = MaxF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
   	                		break;
						case op_max_min_32_u_c:  // opcode 68
							if (k == 0)
							{
								u32Result = Min32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Max32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
   	                		break;
						case op_max_min_16_u_c:  // opcode 69
							if (k == 0)
							{
								u32Result = MinD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = MaxD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
   	                		break;
					
    	           		default:
							PrintToCerr("like_max_min_32_cores: opcode not found\n");
      		              	u32Result = 0;
        			}

					u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestIdx + k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestIdx + k, u32Result);
					u32GenResultIdx++;

				} // for (k = 0; k < 2; k++)
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::max_min_mn_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{	
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("max_min_mn_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("max_min_mn_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
	    	struct  SPLIT_VALUE
	    	{
	    		DSPU32    	u6SrcN: 6;
		    	DSPU32    	u6SrcM: 6;
				DSPU32    	u2Rev0: 2;
				DSPU32    	u1MaxToN: 1;
				DSPU32      u1Signed: 1;
				DSPU32    	u2Mode: 2;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
	 		   	DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1MaxToN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1Signed;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k + 1);
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (k = 0; k < 2; k++)
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32SrcNIdx, u32SrcMIdx, u32Flag, u32Status, u32MaxToN, u32Sign;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32Mode, u32DestIdx, u32SrcA, u32SrcB;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32MaxToN = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		u32DestIdx = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k + 1);
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					switch (u32Mode)
	        		{
						case 0:  // fix 32
							if (u32Sign == 1)
							{
								u32ALUCR = GSetBit(u32ALUCR, 0);
							}

							if (k == 0)
							{
								u32Result = Min32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
								u32DestIdx = (u32MaxToN == 1)? u32SrcMIdx : u32SrcNIdx;
							}
							else
							{
								u32Result = Max32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
								u32DestIdx = (u32MaxToN == 1)? u32SrcNIdx : u32SrcMIdx;
							}

    	               		break;
						case 1:  // fix 16
							if (u32Sign == 1)
							{
								u32ALUCR = GSetBit(u32ALUCR, 0);
							}						

							if (k == 0)
							{
								u32Result = MinD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
								u32DestIdx = (u32MaxToN == 1)? u32SrcMIdx : u32SrcNIdx;
							}
							else
							{
								u32Result = MaxD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
								u32DestIdx = (u32MaxToN == 1)? u32SrcNIdx : u32SrcMIdx;
							}
    	               		break;
						case 2:  // float 32
							u32ALUCR = GSetBit(u32ALUCR, 0);
							if (k == 0)
							{
								u32Result = MinF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
								u32DestIdx = (u32MaxToN == 1)? u32SrcMIdx : u32SrcNIdx;
							}
							else
							{
								u32Result = MaxF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
								u32DestIdx = (u32MaxToN == 1)? u32SrcNIdx : u32SrcMIdx;
							}
    	               		break;
											
    	           		default:
							PrintToCerr("max_min_mn_cores: invalid mode\n");
    	                	u32Result = 0;
    	    		}
					
					wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;					

				} // for (k = 0; k < 2; k++)
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_conj_c32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_conj_c32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_conj_c32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
				DSPU32    	u6SrcN: 6;
    			DSPU32    	u1Neg: 1;
				DSPU32    	u1Mode: 1;
				DSPU32    	u1Permute: 1;
				DSPU32    	u1Rev1: 1;
				DSPU32    	u1Conj: 1;
				DSPU32    	u1Rev2: 1;			
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32   	u1MultiWord: 1;
				DSPU32   	u4Units: 4;
 			   	DSPU32   	u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u1Neg;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Permute;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1Conj;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[6] = instr_word.details.u1Mode;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 7; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];
		
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcNIdx, u32Result, u32ALUIdx, u32Permute, u32SrcIdxSel;
		DSPU32 u32Temp;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Permute = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32SrcIdxSel = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
                {
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));

					// read ALUCR and carry the value to next phase.
					u32Temp = GSetBit(ReadALUCR(i), 0);
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = GSetBit(u32Temp, 1);

					if ( u32Permute != 1 ) // I/Q
							{
								if (k == 0)
								{
									u32SrcIdxSel = u32SrcNIdx;
								}
								else if (k == 1)
								{
									u32SrcIdxSel = u32SrcNIdx + 1;
								}
							}
							else
							{
								if (k == 0)
								{
									u32SrcIdxSel = u32SrcNIdx + 1;
								}
								else if (k == 1)
								{
									u32SrcIdxSel = u32SrcNIdx;
								}
							}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcIdxSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcIdxSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (int k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32Neg, u32Conj, u32Mode;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32SrcA;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Neg = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Conj = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[6];

		u32Result = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k + 1);
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					
					u32Status = 0;
					if (k == 0) // the first ALU malloced
					{
						if ( u32Neg != 1 )
						{
							if ( u32Conj != 1 )
							{
								if (u32Mode == 0)
								{
									u32Result = Add32(0, u32SrcA, &u32Status, u32ALUCR);
								}
								else
								{
									u32Result = AddF32(0, u32SrcA, &u32Status, u32ALUCR);
								}				
							}
							else // if ( u32Conj == 1 )
							{
								if (u32Mode == 0)
								{
									u32Result = Sub32(0, u32SrcA, &u32Status, u32ALUCR);
								}
								else
								{
									u32Result = SubF32(0, u32SrcA, &u32Status, u32ALUCR);
								}												
							}
						}
						else  // if ( u32Neg == 1 )
						{
							if ( u32Conj != 1 )
							{
								if (u32Mode == 0)
								{
									u32Result = Sub32(0, u32SrcA, &u32Status, u32ALUCR);
								}
								else
								{
									u32Result = SubF32(0, u32SrcA, &u32Status, u32ALUCR);
								}					
							}
							else
							{
								if (u32Mode == 0)
								{
									u32Result = Add32(0, u32SrcA, &u32Status, u32ALUCR);
									
								}
								else
								{
									u32Result = AddF32(0, u32SrcA, &u32Status, u32ALUCR);
								}
							}
						}
					}
					else if (k == 1)  // // the second ALU malloced
					{
						if ( u32Neg != 1 )
						{
							if (u32Mode == 0)
							{
								u32Result = Add32(0, u32SrcA, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(0, u32SrcA, &u32Status, u32ALUCR);
							}
						}
						else
						{
							if (u32Mode == 0)
							{
								u32Result = Sub32(0, u32SrcA, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(0, u32SrcA, &u32Status, u32ALUCR);
							}
						}
					}
					
					u32Flag = SetALUCFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestIdx + k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				} // for (int k = 0; k < 2; k++)				

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::like_addsub_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_addsub_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_addsub_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcNIdx, u32SrcMIdx, u32Units;
		union INSTR_WORD
		{
			DSPU32 u32Value;
	    	struct  SPLIT_VALUE
	    	{
	    		DSPU32    	u6SrcN: 6;
		    	DSPU32    	u6SrcM: 6;
				DSPU32    	u1Half: 1;
				DSPU32    	u1Signed: 1;
				DSPU32    	u3Mode: 3;
				DSPU32    	u1Rev0: 1;
				DSPU32    	u8Opcode: 8;
				DSPU32       u1MultiWord: 1;
				DSPU32       u4Units: 4;
	 		   	DSPU32       u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Half;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1Signed;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < 4; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
                {
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}		

				} // for (int k = 0; k < 2; k++)					
			}
		} // for (int i = 0; i < 4; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32Status, u32Half, u32Sign, u32Mode;
		DSPU32 u32ALUIdx, u32Result, u32GenResultIdx, u32ALUCR;
		DSPU32 u32SrcMIdx, u32SrcNIdx, u32DestSel, u32SrcA, u32SrcB;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Half = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Sign = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32GenResultIdx = 0;
		u32Result = 0;
		u32DestSel = 0;

		for (int i = 0; i < 4; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32Status = 0;
					if (u32Mode == 0)  // Rm_n = Rm +/- Rn
					{
						if (u32Sign == 1)
						{
							u32ALUCR = GSetBit(u32ALUCR, 0);
						}
						
						if (k == 0)
						{
							if (u32Half)
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}

							u32DestSel = u32SrcMIdx;
						}
						else
						{
							if (u32Half)
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
						
							u32DestSel = u32SrcNIdx;
						}						

						if ( GIsBitSet(u32ALUCR, 3) && (u32Sign == 1) )
						{
							m_arrChgBKF[i] = true;
							m_arrALU_BKFlag[i][u32ALUIdx] = BKF_I32(u32Result);
						}
					}
					else if (u32Mode == 1) // HRm_n = HRm +/- HRn
					{
						if (u32Sign == 1)
						{
							u32ALUCR = GSetBit(u32ALUCR, 0);
						}
						
						if (k == 0)
						{
							if (u32Half)
							{
								u32Result = AddD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}

							u32DestSel = u32SrcMIdx;
						}
						else
						{
							if (u32Half)
							{
								u32Result = SubD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
						
							u32DestSel = u32SrcNIdx;
						}

						if ( GIsBitSet(u32ALUCR, 3) && (u32Sign == 1))
						{
							m_arrChgBKF[i] = true;
							m_arrALU_BKFlag[i][u32ALUIdx] = BKF_DI16(u32Result);
						}
					}
					else if (u32Mode == 2) // FRm_n = FRm +/- FRn
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
						
						if (k == 0)
						{
							if (u32Half)
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}

							u32DestSel = u32SrcMIdx;
						}
						else
						{
							if (u32Half)
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
						
							u32DestSel = u32SrcNIdx;
						}
						
					}
					else if (u32Mode == 3) // CHRm_n = CHRm +/- CHRn
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
						
						if (k == 0)
						{
							if (u32Half)
							{
								u32Result = AddD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}

							u32DestSel = u32SrcMIdx;
						}
						else
						{
							if (u32Half)
							{
								u32Result = SubD16Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubD16(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
						
							u32DestSel = u32SrcNIdx;
						}

						if ( GIsBitSet(u32ALUCR, 3) )
						{
							m_arrChgBKF[i] = true;
							m_arrALU_BKFlag[i][u32ALUIdx] = BKF_DI16(u32Result);
						}					
					}
					else if (u32Mode == 4) // CHRm_n = CHRm +/- jCHRn
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
						
						if (k == 0)
						{
							if (u32Half)
							{
								u32Result = AddD16HalfCJ(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddD16CJ(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}

							u32DestSel = u32SrcMIdx;
						}
						else
						{
							if (u32Half)
							{
								u32Result = SubD16HalfCJ(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubD16CJ(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
						
							u32DestSel = u32SrcNIdx;
						}

						if ( GIsBitSet(u32ALUCR, 3) )  // GRQ
						{
							m_arrChgBKF[i] = true;
							m_arrALU_BKFlag[i][u32ALUIdx] = BKF_DI16(u32Result);
						}								
					}

					u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
					wr_u32r_R_new(i, u32DestSel, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
						
					SetWBGenRegInfo(p_u32Slot, u32GenResultIdx, i, u32DestSel, u32Result);
					u32GenResultIdx++;

				} // for (int k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )				

		} // for (i = 0; i < 4; i++)
	}
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_c_addsub_32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_c_addsub_32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_c_addsub_32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
    		struct  SPLIT_VALUE
    		{
    			DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u1Half: 1;
				DSPU32    	u1Rev0: 1;
				DSPU32    	u2Mode: 2;
				DSPU32    	u2Rev1: 2;
				DSPU32    	u8Opcode: 8;
				DSPU32   	u1MultiWord: 1;
				DSPU32   	u4Units: 4;
 			   	DSPU32   	u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Half;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 4;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);

				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcMIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx;
		DSPU32 u32SrcASel, u32SrcBSel, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32SrcASel = 0;
		u32SrcBSel = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 4; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);

					// mode == 0: CRm+1:m_n+1:n=(CRm+1:m+/-CRn+1:n)/2
					// mode == 2: CFRm+1:m_n+1:n=(CFRm+1:m+/-CFRn+1:n)/2
					if ((u32Mode == 0) || (u32Mode == 2))
					{
						if (k == 0)
						{
							u32SrcASel = u32SrcMIdx;
							u32SrcBSel = u32SrcNIdx;
						}
						else if (k == 1)
						{
							u32SrcASel = u32SrcMIdx + 1;
							u32SrcBSel = u32SrcNIdx + 1;						
						}
						else if (k == 2)
						{
							u32SrcASel = u32SrcMIdx;
							u32SrcBSel = u32SrcNIdx;						
						}
						else if (k == 3)
						{
							u32SrcASel = u32SrcMIdx + 1;
							u32SrcBSel = u32SrcNIdx + 1;						
						}
					}
					// mode == 1: CRm+1:m_n+1:n=(CRm+1:m+/-jCRn+1:n)/2
					// mode == 3: CFRm+1:m_n+1:n=(CFRm+1:m+/-jCFRn+1:n)/2
					else if ((u32Mode == 1) || (u32Mode == 3))
					{
						if (k == 0)
						{
							u32SrcASel = u32SrcMIdx;
							u32SrcBSel = u32SrcNIdx + 1;
						}
						else if (k == 1)
						{
							u32SrcASel = u32SrcMIdx + 1;
							u32SrcBSel = u32SrcNIdx;						
						}
						else if (k == 2)
						{
							u32SrcASel = u32SrcMIdx;
							u32SrcBSel = u32SrcNIdx + 1;						
						}
						else if (k == 3)
						{
							u32SrcASel = u32SrcMIdx + 1;
							u32SrcBSel = u32SrcNIdx;						
						}
					}
					
					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcASel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k] = rd_u32r_R_new(i, u32SrcASel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcBSel) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcBSel, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

				} // for (k = 0; k < 4; k++)
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32Flag, u32Status, u32DestSel, u32Half, u32Mode, u32SrcMIdx;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32SrcNIdx, u32SrcA, u32SrcB;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Half = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		u32DestSel = 0;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 4; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][k]; 
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k]; 

					u32ALUCR = GSetBit(u32ALUCR, 0);
					u32Status = 0;
					if (u32Mode == 0) // CRm+1:m_n+1:n=(CRm+1:m+/-CRn+1:n)/2
					{
						if (k == 0)
						{
							if (u32Half == 1)
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx;
						}
						else if (k == 1)
						{
							if (u32Half == 1)
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx + 1;
						}
						else if (k == 2)
						{
							if (u32Half == 1)
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx;
						}
						else if (k == 3)
						{
							if (u32Half == 1)
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx + 1;
						}

						if ( GIsBitSet(u32ALUCR, 3) )
						{
							m_arrChgBKF[i] = true;
							m_arrALU_BKFlag[i][u32ALUIdx] = BKF_I32(u32Result);
						}
					}
					else if (u32Mode == 1) // CRm+1:m_n+1:n=(CRm+1:m+/-jCRn+1:n)/2
					{
						if (k == 0)
						{
							if (u32Half == 1)
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx;
						}
						else if (k == 1)
						{
							if (u32Half == 1)
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx + 1;
						}
						else if (k == 2)
						{
							if (u32Half == 1)
							{
								u32Result = Sub32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Sub32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx;
						}
						else if (k == 3)
						{
							if (u32Half == 1)
							{
								u32Result = Add32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = Add32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx + 1;
						}

						if ( GIsBitSet(u32ALUCR, 3) )
						{
							m_arrChgBKF[i] = true;
							m_arrALU_BKFlag[i][u32ALUIdx] = BKF_I32(u32Result);
						}
					}
					else if (u32Mode == 2) // CFRm+1:m_n+1:n=(CFRm+1:m+/-CFRn+1:n)/2
					{
						if (k == 0)
						{
							if (u32Half == 1)
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx;
						}
						else if (k == 1)
						{
							if (u32Half == 1)
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx + 1;
						}
						else if (k == 2)
						{
							if (u32Half == 1)
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx;
						}
						else if (k == 3)
						{
							if (u32Half == 1)
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx + 1;
						}

					}
					else if (u32Mode == 3) // CFRm+1:m_n+1:n=(CFRm+1:m+/-jCFRn+1:n)/2
					{
						if (k == 0)
						{
							if (u32Half == 1)
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx;
						}
						else if (k == 1)
						{
							if (u32Half == 1)
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcMIdx + 1;
						}
						else if (k == 2)
						{
							if (u32Half == 1)
							{
								u32Result = SubF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = SubF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx;
						}
						else if (k == 3)
						{
							if (u32Half == 1)
							{
								u32Result = AddF32Half(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							else
							{
								u32Result = AddF32(u32SrcA, u32SrcB, &u32Status, u32ALUCR);
							}
							u32DestSel = u32SrcNIdx + 1;
						}
					}											
									
					u32Flag = SetALUCFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

					wr_u32r_R_new(i, u32DestSel, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
					
				} // for (k = 0; k < 4; k++)

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_accum_c32_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{	
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("like_accum_c32_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("like_accum_c32_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx, u32ChgCON, u32ALUIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
	    	struct  SPLIT_VALUE
	    	{
	    		DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u2Mode: 2;
				DSPU32    	u1ChgCON: 1;
				DSPU32    	u3ALUIdx: 3;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
	 		   	DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u2Mode;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u1ChgCON;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u3ALUIdx;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
		for (int i = 0; i < 6; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32ChgCON = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		SetCalcResIdx(u32ALUIdx + 1, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				if (u32ChgCON == 1)
				{
					SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				}
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx + 1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result, u32ALUIdx, u32SrcMValue;
		DSPU32 u32CON, u32ChgCON, u32Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ChgCON = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32SrcMValue = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);

					if (u32ChgCON == 1)
					{
						if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
						{
							u32SrcMValue = u32Result;
						}
						else
						{
							u32SrcMValue = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
						}
					}

					if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx + k) )
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = u32Result;
					}
					else
					{
						m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k] = rd_u32r_R_new(i, u32SrcNIdx + k, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
					}

					u32CON = ReadCON(i, u32ALUIdx);
					u32r_ALUCON_AC[i][u32ALUIdx] = u32CON;
					switch (u32Mode)
					{
						case 0:  // CACCs+1:s=CRn+1:n(con=Rm)
							if (u32ChgCON == 1)
							{
								WriteCON(i, u32ALUIdx, u32SrcMValue);
							}
							break;
						case 1:  // CACCs+1:s+=CRn+1:n(con=Rm)
							if (u32ChgCON == 1)
							{
								WriteCON(i, u32ALUIdx, u32SrcMValue);
							}
							break;
						case 2:  // CACCs+1:s-=CRn+1:n(con=Rm)
							if (u32ChgCON == 1)
							{
								WriteCON(i, u32ALUIdx, u32SrcMValue);
							}
							break;
						case 3:  // CACCs+1:s+=CRn+1:n(conc,con=Rm)
							if (u32ChgCON == 1)
							{
								WriteCON(i, u32ALUIdx, u32SrcMValue);
							}
							else
							{
								u32CON = u32CON << 1;
								WriteCON(i, u32ALUIdx, u32CON);
							}
							break;
						default:
							PrintToCerr("like_accum_c32_cores: Invalid parameter\n");
					}

				} // for (k = 0; k < 2; k++)
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32Units, u32ALUIdx, u32Status, u32ALUCR, u32Mode;
		DSPU32 u32SrcMIdx, u32SrcNIdx, u32CON, u32ChgCON, u32SrcB;
		DSP_BIT40 b40Temp;
		DSPU64 u64Temp;
		DSPU8 u8EXP;		

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32ChgCON = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			b40Temp.u32Low = 0;
			b40Temp.u8High = 0;
			u64Temp = 0;
			u8EXP = 0;
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][k];

					u32CON = u32r_ALUCON_AC[i][u32ALUIdx];
					u32Status = 0;
					u32ALUCR = GSetBit(u32ALUCR, 0);
					if (p_u32Opcode == op_accum_c32_c) // 108
					{						
						u8EXP = 0;
						switch (u32Mode)
						{
							case 0:  // CACCs+1:s=CRn+1:n(con=Rm)
								u64Temp = 0;
								b40Temp = U64ToU40(u64Temp);
								ACCAdd32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
								break;
							case 1:  // CACCs+1:s+=CRn+1:n(con=Rm)
								b40Temp = ReadACC(i, u32ALUIdx);
								ACCAdd32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
								break;
							case 2:  // CACCs+1:s-=CRn+1:n(con=Rm)
								b40Temp = ReadACC(i, u32ALUIdx);
								ACCSub32(u32SrcB, &b40Temp, &u32Status, u32ALUCR);
								break;
							case 3:  // CACCs+1:s+=CRn+1:n(conc,con=Rm)
								b40Temp = ReadACC(i, u32ALUIdx);
								ACC32OnCON(u32SrcB, &b40Temp, &u32Status, &u32CON, u32ALUCR);
								break;
							default:
								PrintToCerr("like_accum_c32_cores: Invalid parameter\n");

						} // switch (instr_word.details.u2Mode)
					}
					else if (p_u32Opcode == op_accum_cflo32_c) // 109
					{
						u8EXP = ReadACCExp(i, u32ALUIdx);
						switch (u32Mode)
						{
							case 0:  // CFACCs+1:s=CFRn+1:n(con=Rm)
								u64Temp = 0;
								b40Temp = U64ToU40(u64Temp);
								u8EXP = 0;
								ACCAddF32(u32SrcB, &b40Temp, &u8EXP, &u32Status, u32ALUCR);
								break;
							case 1:  // CFACCs+1:s+=CFRn+1:n(con=Rm)
								b40Temp = ReadACC(i, u32ALUIdx);
								ACCAddF32(u32SrcB, &b40Temp, &u8EXP, &u32Status, u32ALUCR);
								break;
							case 2:  // CFACCs+1:s-=CFRn+1:n(con=Rm)
								b40Temp = ReadACC(i, u32ALUIdx);
								ACCSubF32(u32SrcB, &b40Temp, &u8EXP, &u32Status, u32ALUCR);
								break;
							case 3:  // CFACCs+1:s=CFRn+1:n(conc, con=Rm)
								b40Temp = ReadACC(i, u32ALUIdx);
								ACCF32OnCON(u32SrcB, &b40Temp, &u8EXP, &u32Status, &u32CON, u32ALUCR);
								break;
							default:
								PrintToCerr("like_accum_c32_cores: Invalid parameter\n");

						} // switch (instr_word.details.u2Mode)
					}
					
					WriteACC(i, u32ALUIdx, b40Temp);
					WriteACCExp(i, u32ALUIdx, u8EXP);
					u32r_ALUFR_EX[i][u32ALUIdx] = u32Status;

				} // for (k = 0; k < 2; k++)

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32ALUIdx, u32Flag;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], (k + 1));

					u32Flag = SetALUCFlags(u32ri_ALUFR[i][u32ALUIdx], u32r_ALUFR_EX[i][u32ALUIdx]);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	}
	return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::like_acc_is_zero_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{    
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("like_acc_is_zero_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("like_acc_is_zero_cores: parameter is invalid\n");
        return false;
    }

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32ALUs, u32Units;
    
        union INSTR_WORD
        {
            DSPU32 u32Value;
            struct  SPLIT_VALUE
            {
            	DSPU32      u4Mode: 4;
            	DSPU32      u4Rev0: 4;
                DSPU32      u8ALUSel: 8;
                DSPU32      u2Rev1: 2;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
    
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u8ALUSel;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u4Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 3; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable
        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];    

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if(p_u32Phase == PHASE_AC_POST)
    {
    	DSPU32 u32ALUs, u32Mode, u32Units;
    
        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
	u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                for (int j = 0; j < ALU_NUM_OF_UNIT; j++)
                {
                    if ( GIsBitSet(u32ALUs, j) )
                    {
                        if (u32Mode == 7)
                        {
                            WriteALUDFIRR(i, j, 0, false);
                            WriteALUDFIRR(i, j, 0, true);
                        }
						else if (u32Mode == 1)
						{
							WriteCON(i, j, 0);                        
						}
                    }
                } // for

            }
        }
    }
    else if (p_u32Phase == PHASE_EX)
    {
        DSPU32 u32ALUs, u32Mode, u32Units;
        DSP_BIT40 b40Temp;
    
        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
	u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                for (int j = 0; j < ALU_NUM_OF_UNIT; j++)
                {
                    if ( GIsBitSet(u32ALUs, j) )
                    {
                        if (u32Mode == 0)
                        {
                            b40Temp.u32Low = 0;
                            b40Temp.u8High = 0;
                            WriteACC(i, j, b40Temp);
                            WriteACCExp(i, j, 0);
                        }
                        else if(u32Mode == 4)
                        {
                        	WriteALUCA(i, j, 0);
                        }
                        else if(u32Mode == 5)
                        {
							WriteALUDFER(i,j,0);
                        }
                        else if(u32Mode == 6)
                        {
                        	WriteALUDFMR(i, j, 0, false);
                        	WriteALUDFMR(i, j, 0, true);
                        }
                    }
                } // for

            }
        }
    }
    else if (p_u32Phase == PHASE_WB)
    {
        DSPU32 u32ALUs, u32Units, u32Flag, u32Mode;
    
        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
	u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
    
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {
                for (int j = 0; j < ALU_NUM_OF_UNIT; j++)
                {
                    if ( GIsBitSet(u32ALUs, j) )
                    {
                        if (u32Mode == 2)
                        {
                            u32r_ALU_ACF[ i ][ j ] = 0;
                        }

						if(u32Mode == 3)
						{
                        	u32ri_ALUFR[i][j] = 0;
						}
						else
						{
							u32Flag = SetALUFlags(u32ri_ALUFR[i][j], 0);
							u32ri_ALUFR[i][j] = u32Flag;
						}
						
                    }
                } // for

            }
        }
    }

    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::reg_shf_acf_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
    if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
    {
        PrintToCerr("reg_shf_acf_cores: parameter is invalid\n");
        return false;
    }

    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
    {
        PrintToCerr("reg_shf_acf_cores: parameter is invalid\n");
        return false;
    }   

    if (p_u32Phase == PHASE_DC2)
    {
        DSPU32 u32Units, u32SrcMIdx, u32DestIdx, u32ALUIdx;
        union INSTR_WORD
        {
            DSPU32  u32Value;
            struct  SPLIT_VALUE
            {
                DSPU32      u3ALUIdx: 3;
                DSPU32      u2Imm: 2;
                DSPU32      u1Mode: 1;
                DSPU32      u6SrcM: 6;
                DSPU32      u6Dest: 6;
                DSPU32      u8Opcode: 8;
                DSPU32      u1MultiWord: 1;
                DSPU32      u4Units: 4;
                DSPU32      u1Line: 1;
            } details;
        } instr_word;
        
        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
        {
            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
            instr_word.u32Value = p_u32InstrWord;
            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;         
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u3ALUIdx;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u2Imm;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u1Mode;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6SrcM;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u6Dest;
            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[5] = instr_word.details.u4Units;
        }

        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
        // accross pipe phases.
        for (int i = 0; i < 6; i++)
        {
            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
        }

        // use variable below is more readable      
        u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[5];

        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
        SetCalcResIdx(u32ALUIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);
        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
        
        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {               
                // log info necessary for data forward of general purpose register.
                SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
                SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
            }
        }

        // 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
    }
    else if (p_u32Phase == PHASE_AC_POST)
    {
        DSPU32 u32Units, u32SrcMIdx, u32Result, u32Imm;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Imm = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
        u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
	u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            // whether current macro(unit) is used.
            if ( GIsBitSet(u32Units, i) )
            {
                // read ALUCR and carry the value to next phase.
                m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

                if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
                {
                    // data forward to get the value of R[u32SrcMIdx] of current macro
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
                }
                else
                {
                    // read the value of R[u32SrcMIdx] from register heap directly
                    m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
                }

                m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Imm;                                

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < NUM_OF_UNITS; i++)
    }
    else if (p_u32Phase == PHASE_WB)
    {               
        DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB;
        DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32ALUCFR;
		DSPU32 u32Mode;

        // read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
        u32Mode = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
        u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[4];
	u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

        for (int i = 0; i < NUM_OF_UNITS; i++)
        {
            if ( GIsBitSet(u32Units, i) )
            {               
                // get the index of the first ALU allocated for this instruction in current macro
                u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
                u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
                u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
                u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];
                u32ALUCFR = u32r_ALU_ACF[i][u32ALUIdx];

                u32Status = 0;
                switch (u32Mode)
                {
                    // get result
                    case 0: // HRs = HRm lshift ACFk(c)
                        u32ALUCR = GSetBit(u32ALUCR, 0);
                       	u32Result = LShiftD16ACF(u32SrcA, u32ALUCFR, u32SrcB, u32ALUCR, &u32Status);
                        break;
                    case 1: // Rs = Rm lshift ACFk(c)
                        u32ALUCR = GSetBit(u32ALUCR, 0);
                        u32Result = LShift32ACF(u32SrcA, u32ALUCFR, u32SrcB, u32ALUCR, &u32Status);
                        break;
                    
                    default:
                        PrintToCerr("like_add_32_cores: opcode not found\n");
                        u32Result = 0;
                }
                
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
                u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
                u32ri_ALUFR[i][u32ALUIdx] = u32Flag;                

            } // if ( GIsBitSet(u32Units, i) )
        } // for (i = 0; i < 4; i++)
    } // else if (p_u32Phase == PHASE_WB)

    return true;
}

//-----------------------------------------------------------------------------------
bool sc_iss::wr_bkfr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE)) {
		PrintToCerr("wr_bkfr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX)) {
		PrintToCerr("wr_bkfr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32SrcM, u32Units;

		union INSTR_WORD {
			DSPU32 u32Value;
			struct SPLIT_VALUE {
				DSPU32 u6SrcM :6;
				DSPU32 u12Addr :12;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord) {
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6SrcM;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u12Addr;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++) {
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];

		//资源分配使用ABFPR写通道
		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolABFPRWrBus = true;

		//数据相关设置
		for (int i = 0; i < NUM_OF_UNITS; i++) {
			if (GIsBitSet(u32Units, i)) {
				SetGenRegIdx(
						u32SrcM,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
			} // if ( GIsBitSet(u32Units, i) )
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	    else if (p_u32Phase == PHASE_AC_POST)
	    	{
	    		DSPU32 u32Units, u32SrcMIdx, u32Result;

	    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
	    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

	    		for (int i = 0; i < NUM_OF_UNITS; i++)
	    		{
	    			// whether current macro(unit) is used.
	    			if ( GIsBitSet(u32Units, i) )
	    			{
	    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
	    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
	    				{
	    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
	    				}
	    				else
	    				{
	    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
	    				}

	    			} // if ( GIsBitSet(u32Units, i) )
	    		} // for (i = 0; i < NUM_OF_UNITS; i++)
	    	}
	    else if (p_u32Phase == PHASE_WB)
	    {
	        DSPU32 u32SrcA, u32Units;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

	        for (int i = 0; i < NUM_OF_UNITS; i++)
	        {
	            if ( GIsBitSet(u32Units, i) )
	            {
	            	u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
	            	//写需要同时写ALU 和SHF
	            	WriteALUBKFlag(i, u32SrcA & 0x3);
	            	WriteSHFBKFlag(i, u32SrcA & 0x3);
	            } // if ( GIsBitSet(u32Units, i) )

	        } // for (i = 0; i < NUM_OF_UNITS; i++)

	    } // else if (p_u32Phase == PHASE_WB)

	    return true;
}
//-----------------------------------------------------------------------------------
bool sc_iss::wr_alufr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_alufr_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_alufr_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ALUFR;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		        //m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
		    				}
		    				else
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32SrcA, u32Units, u32ALUs;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
		            	u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
		            	u32ri_ALUFR[i][u32ALUs] = u32SrcA & 0x7F7F;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//------------------------------------------------------------------------------------------------
bool sc_iss::wr_acf_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_acf_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_acf_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ACF;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		        //m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
		    				}
		    				else
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32SrcA, u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		            	u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
		            	u32r_ALU_ACF[i][u32ALUs] = u32SrcA;

		            	u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//------------------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_con_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_con_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_con_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_CON;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		        //m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result, u32SrcMValue, u32ALUs;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		    		//u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					u32SrcMValue = u32Result;
		    				}
		    				else
		    				{
		    					u32SrcMValue = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}
							WriteCON(i, u32ALUs, u32SrcMValue);

		    			} // if ( GIsBitSet(u32Units, i) )
		    			 
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		               	u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//--------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_alucafr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_alucafr_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_alucafr_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ALUCAFR;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		        //m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
		    				}
		    				else
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_EX)
		    {
		    	 DSPU32 u32Units, u32ALUs, u32Flag, u32SrcA;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    	 //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		    	 for (int i = 0; i < NUM_OF_UNITS; i++)
		    	 {
		    	        if ( GIsBitSet(u32Units, i) )
		    	         {
		    	        	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

	    	 		        u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
	    	 		        WriteALUCA(i,u32ALUs,u32SrcA & 0x1);  // ALUCAFR仅[0]位有效
		    	 		 }
		    	 }
		    }
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		                u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//--------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_aludefr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_aludefr_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_aludefr_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ALUDFER;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		       // m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
		    				}
		    				else
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_EX)
		    {
		    	 DSPU32 u32Units, u32ALUs, u32Flag, u32SrcA;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    	 //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		    	 for (int i = 0; i < NUM_OF_UNITS; i++)
		    	 {
		    	        if ( GIsBitSet(u32Units, i) )
		    	         {
		    	        	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		    	        	u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
		    	 		    WriteALUDFER(i,u32ALUs,u32SrcA & 0x7FF);
		    	 		 }
		    	 }
		    }
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		                u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//--------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_aludfmr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_aludfmr_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_aludfmr_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ALUDFMR;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		        //m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
		    				}
		    				else
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_EX)
		    {
		    	 DSPU32 u32Units, u32ALUs, u32Flag, u32SrcA;
		    	 bool bIsHighBits;   // 是否为 ALUDFMR的高32位

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    	 //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;
		    	 bIsHighBits = (m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] >= ALU_NUM_OF_UNIT);

		    	 for (int i = 0; i < NUM_OF_UNITS; i++)
		    	 {
		    	        if ( GIsBitSet(u32Units, i) )
		    	         {
		    	        	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

	    	 		        u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
	    	 		        if(bIsHighBits) {
	    	 		        	WriteALUDFMR(i, u32ALUs, u32SrcA & 0xFFFFFF, true);
	    	 		        } else
	    	 		        {
	    	 		        	WriteALUDFMR(i, u32ALUs, u32SrcA, false);
	    	 		        }
		    	 		 }
		    	 }
		    }
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		                u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//--------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_aludfirr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_aludfirr_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_aludfirr_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ALUDFIRR;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		       // m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    	{
		    		DSPU32 u32Units, u32SrcMIdx, u32Result, u32SrcMValue, u32ALUs;
		    		bool bIsHighBits;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		    		//u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;
		    		bIsHighBits = (m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] >= 8);

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					u32SrcMValue = u32Result;
		    				}
		    				else
		    				{
		    					u32SrcMValue = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    				if(bIsHighBits)
		    				{
		    					WriteALUDFIRR(i, u32ALUs, u32SrcMValue & 0x7FFFFFFF, true);
		    				} else
		    				{
		    					WriteALUDFIRR(i, u32ALUs, u32SrcMValue, false);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
		                u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}
//--------------------------------------------------------------------------------------------------------------------
bool sc_iss::wr_acc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
		    {
		        PrintToCerr("wr_acc_cores: parameter is invalid\n");
		        return false;
		    }

		    if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
		    {
		        PrintToCerr("wr_acc_cores: parameter is invalid\n");
		        return false;
		    }

		    if (p_u32Phase == PHASE_DC2)
		    {
		        DSPU32 u32SrcM, u32Units, u32ALUs;

		        union INSTR_WORD
		        {
		            DSPU32 u32Value;
		            struct  SPLIT_VALUE
		            {
		                DSPU32      u6SrcM: 6;
						DSPU32      u12Addr: 12;
		                DSPU32      u8Opcode: 8;
		                DSPU32      u1MultiWord: 1;
		                DSPU32      u4Units: 4;
		                DSPU32      u1Line: 1;
		            } details;
		        } instr_word;

		        // Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		        if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		        {
		            // fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
		            instr_word.u32Value = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcM;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u12Addr - SPEC_ADDR_ACC;
		            g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u4Units;
		        }

		        // read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		        // accross pipe phases.
		        for (int i = 0; i < 3; i++)
		        {
		            m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		        }

		        // use variable below is more readable
		        u32SrcM = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		        u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		        u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;

		        m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		        //m_arrDCResNeeded[p_u32Slot].u8ALUs = u32ALUs;
				SetCalcResIdx(u32ALUs, m_arrDCResNeeded[p_u32Slot].u8ALUs);
		        m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;


		        //数据相关设置
		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	SetGenRegIdx(u32SrcM, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
		            } // if ( GIsBitSet(u32Units, i) )
		        }

		        // 当前指令是宏内指令，用于支持条件执行
				m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		    }
		    else if (p_u32Phase == PHASE_AC_POST)
		    {
		    		DSPU32 u32Units, u32SrcMIdx, u32Result;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			// whether current macro(unit) is used.
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				// get the value of R[u32SrcMIdx] in current macro directly or by data forward
		    				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
		    				}
		    				else
		    				{
		    					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
		    				}

		    			} // if ( GIsBitSet(u32Units, i) )
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    }
		    else if (p_u32Phase == PHASE_EX)
		    	{
		    		DSPU32 u32Units, u32ALUIdx, u32SrcA, u32Pos;

		    		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		    		//u32ALUIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;
		    		u32Pos = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] / ALU_NUM_OF_UNIT; //[31-0]:0 [39-32]:1 [47-40]:2

		    		for (int i = 0; i < NUM_OF_UNITS; i++)
		    		{
		    			if ( GIsBitSet(u32Units, i) )
		    			{
		    				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
		    				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

		    				switch(u32Pos)
		    				{
		    				case 0:
		    					u40ri_ALU_ACC[i][u32ALUIdx].u32Low = u32SrcA;
		    					break;
		    				case 1:
		    					u40ri_ALU_ACC[i][u32ALUIdx].u8High = u32SrcA;
		    					break;
		    				case 2:
		    					u8ri_ALU_EXP[i][u32ALUIdx] = u32SrcA;
		    					break;
		    				default:
		    					PrintToCerr("wr_acc_cores: invalid bit field!\n");
		    				}
		    			}
		    		} // for (i = 0; i < NUM_OF_UNITS; i++)
		    	}
		    else if (p_u32Phase == PHASE_WB)
		    {
		        DSPU32 u32Units, u32ALUs, u32Flag;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		        //u32ALUs = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1] % ALU_NUM_OF_UNIT;

		        for (int i = 0; i < NUM_OF_UNITS; i++)
		        {
		            if ( GIsBitSet(u32Units, i) )
		            {
		            	u32ALUs = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);

		                u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUs], 0);
		            	u32ri_ALUFR[i][u32ALUs] = u32Flag;
		            } // if ( GIsBitSet(u32Units, i) )

		        } // for (i = 0; i < NUM_OF_UNITS; i++)

		    } // else if (p_u32Phase == PHASE_WB)

	return true;
}

bool sc_iss::rd_bkfr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_bkfr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_bkfr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;
		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolABFPRRdBus = true;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if (GIsBitSet(u32Units, i))
			{
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag;
		DSPU32 u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32Result = (u32r_ALU_BKFlag[ i ]>u32r_SHF_BKFlag[ i ])? u32r_ALU_BKFlag[ i ]: u32r_SHF_BKFlag[ i ];
				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_alufr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_alufr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_alufr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] = instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] = instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] = instr_word.details.u12Addr - SPEC_ADDR_ALUFR;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = u32ro_ALUFR[i][u32CalcResIdx];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_acf_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_acf_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_acf_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_ACF;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = u32r_ALU_ACF[i][u32CalcResIdx];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_con_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_con_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_con_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_CON;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32ALUIdx, u32Mode, u32Units;
		DSP_BIT64 u64res;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32ALUIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = ReadCON(i,
											u32ALUIdx);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_alucafr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
		{
			PrintToCerr("rd_alucafr_cores: parameter is invalid\n");
			return false;
		}

		if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
		{
			PrintToCerr("rd_alucafr_cores: parameter is invalid\n");
			return false;
		}

		if (p_u32Phase == PHASE_DC2)
		{
			DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

			union INSTR_WORD
			{
				DSPU32 u32Value;
				struct SPLIT_VALUE
				{
					DSPU32 u12Addr :12;
					DSPU32 u6Dest :6;
					DSPU32 u8Opcode :8;
					DSPU32 u1MultiWord :1;
					DSPU32 u4Units :4;
					DSPU32 u1Line :1;
				} details;
			} instr_word;

			// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
			if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
			{
				// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

				instr_word.u32Value = p_u32InstrWord;
				g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
				g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
						instr_word.details.u6Dest;
				g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
						instr_word.details.u4Units;
				g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
						instr_word.details.u12Addr - SPEC_ADDR_ALUCAFR;
			}

			// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
			// accross pipe phases.
			for (int i = 0; i < 3; i++)
			{
				m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
						g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
			}

			// use variable below is more readable
			u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
			u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
			u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

			m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
			m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
			SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				if (GIsBitSet(u32Units, i))
				{
					SetGenRegIdx(
							u32DestIdx,
							m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				}
			} // for (int i = 0; i < NUM_OF_UNITS; i++)

			// 当前指令是宏内指令，用于支持条件执行
			m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
		}
		else if (p_u32Phase == PHASE_EX)
		{
			DSPU32 u32ALUIdx, u32Units;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				if (GIsBitSet(u32Units, i))
				{
					u32ALUIdx = GetALUIdx(
							m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = ReadALUCA(i,
												u32ALUIdx);

				} // if ( GIsBitSet(u32Units, i) )
			} // for (i = 0; i < NUM_OF_UNITS; i++)
		}
		else if (p_u32Phase == PHASE_WB)
		{
			DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
			DSPU32 u32Result, u2Mode;

			// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
			u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

			u32Result = 0;
			for (int i = 0; i < NUM_OF_UNITS; i++)
			{
				if (GIsBitSet(u32Units, i))
				{
					u32CalcResIdx = GetALUIdx(
							m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
					u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
					u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
					u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

					wr_u32r_R_new(i, u32DestIdx, u32Result,
							PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

				} // if ( GIsBitSet(u32Units, i) )

			} // for (i = 0; i < 4; i++)

		} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_aludefr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_aludefr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_aludefr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_ALUDFER;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32ALUIdx, u32Units;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32ALUIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = ReadALUDFER(i,
						u32ALUIdx);

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_aludfmr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_aludfmr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_aludfmr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_ALUDFMR;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2] % ALU_NUM_OF_UNIT;
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32ALUIdx, u32Units;
		DSP_BIT64 u32Res;
		bool bolIsHBs;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		bolIsHBs = (m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2] >= ALU_NUM_OF_UNIT);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32ALUIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Res = ReadALUDFMR(i, u32ALUIdx);
				if(bolIsHBs)
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Res.u32High;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Res.u32Low;
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_aludfirr_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_aludfirr_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_aludfirr_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_ALUDFIRR;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2]
				% ALU_NUM_OF_UNIT;
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32ALUIdx, u32Units;
		DSP_BIT64 u32Res;
		bool bolIsHBs;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		bolIsHBs = (m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2]
				>= ALU_NUM_OF_UNIT);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32ALUIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Res = ReadALUDFIRR(i, u32ALUIdx);
				if (bolIsHBs)
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Res.u32High;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Res.u32Low;
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}

bool sc_iss::rd_acc_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx,
		DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx,
		DSPU32 p_u32Opcode)
{
	if ((p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE))
	{
		PrintToCerr("rd_acc_cores: parameter is invalid\n");
		return false;
	}

	if ((p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX))
	{
		PrintToCerr("rd_acc_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32DestIdx, u32CalcResIdx;

		union INSTR_WORD
		{
			DSPU32 u32Value;
			struct SPLIT_VALUE
			{
				DSPU32 u12Addr :12;
				DSPU32 u6Dest :6;
				DSPU32 u8Opcode :8;
				DSPU32 u1MultiWord :1;
				DSPU32 u4Units :4;
				DSPU32 u1Line :1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[p_u32JITIdx].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]

			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32Inst0 = p_u32InstrWord;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[0] =
					instr_word.details.u6Dest;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[1] =
					instr_word.details.u4Units;
			g_arrJITCache[p_u32JITIdx].u32DecodeInfo[2] =
					instr_word.details.u12Addr - SPEC_ADDR_ACC;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried
		// accross pipe phases.
		for (int i = 0; i < 3; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] =
					g_arrJITCache[p_u32JITIdx].u32DecodeInfo[i];
		}

		// use variable below is more readable
		u32CalcResIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2]
				% ALU_NUM_OF_UNIT;
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = true;
		SetCalcResIdx(u32CalcResIdx, m_arrDCResNeeded[p_u32Slot].u8ALUs);

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				SetGenRegIdx(
						u32DestIdx,
						m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		} // for (int i = 0; i < NUM_OF_UNITS; i++)

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_EX)
	{
		DSPU32 u32ALUIdx, u32Units;
		DSP_BIT40 b40Temp;
		DSPU32  u32Pos;

		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;
		u32Pos = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2] / ALU_NUM_OF_UNIT; //[31-0]:0 [39-32]:1 [47-40]:2

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32ALUIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				b40Temp = ReadACC(i, u32ALUIdx);
				switch(u32Pos)
				{
				case 0: //[31-0]
					u32r_ALUA_EX[i][u32ALUIdx] = b40Temp.u32Low;
					break;
				case 1: //[39-32]
					u32r_ALUA_EX[i][u32ALUIdx] = b40Temp.u8High;
					break;
				case 2:   //[47-40]
					u32r_ALUA_EX[i][u32ALUIdx] = ReadACCExp(i, u32ALUIdx);
					break;
				default:
					PrintToCerr("wr_acc_cores: invalid bit field!\n");
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32CalcResIdx, u32Flag, u32DestIdx;
		DSPU32 u32Result, u2Mode;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if (GIsBitSet(u32Units, i))
			{
				u32CalcResIdx = GetALUIdx(
						m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32CalcResIdx], 0);
				u32ri_ALUFR[i][u32CalcResIdx] = u32Flag;
				u32Result = u32r_ALUA_EX[i][u32CalcResIdx];

				wr_u32r_R_new(i, u32DestIdx, u32Result,
						PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

			} // if ( GIsBitSet(u32Units, i) )

		} // for (i = 0; i < 4; i++)

	} // else if (p_u32Phase == PHASE_WB)
	return true;
}



bool sc_iss::alu_add8or16_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("alu_add8or16_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("alu_add8or16_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32  u32Value;
			struct  SPLIT_VALUE
			{
				DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
				DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{				
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32Rm, u32Rn;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k+1);
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					if(p_u32Opcode == op_shf_add_8_c || p_u32Opcode == op_shf_add_16_c)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}
					
					if(k==0)
					{
						u32Rm = u32SrcA & 0xffffU;
						u32Rn = u32SrcB & 0xffffU;
					}
					else
					{
						u32Rm = (u32SrcA>>16) & 0xffffU;
						u32Rn = (u32SrcB>>16) & 0xffffU;
					}

					if(p_u32Opcode == op_shf_add_8_c || p_u32Opcode == op_shf_add_8_u_c)
					{
						//HRs+1:s=ORm+ORn,HRs+1:s=ORm+ORn(U)
						u32Result = AddOReg(u32Rm,u32Rn,&u32Status,u32ALUCR);
					}
					else  //if(p_u32Opcode == op_shf_add_16_c || p_u32Opcode == op_shf_add_16_u_c)
					{
						//Rs+1:s =HRm+HRn,Rs+1:s =HRm+HRn(U)
						u32Result = AddD16Reg(u32Rm,u32Rn,&u32Status,u32ALUCR);
					}

					wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					u32Flag = SetSHFFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

bool sc_iss::alu_sub8or16_cores(DSPU32 p_u32InstrWord, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("alu_sub8or16_cores: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("alu_sub8or16_cores: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32DestIdx;
		union INSTR_WORD
		{
			DSPU32  u32Value;
			struct  SPLIT_VALUE
			{
				DSPU32    	u6SrcN: 6;
				DSPU32    	u6SrcM: 6;
				DSPU32    	u6Dest: 6;
				DSPU32    	u8Opcode: 8;
				DSPU32      u1MultiWord: 1;
				DSPU32      u4Units: 4;
				DSPU32      u1Line: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if (g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32InstrWord)
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.u32Value = p_u32InstrWord;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32InstrWord;			
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u6SrcN;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = instr_word.details.u6SrcM;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u4Units;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 4; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		// use variable below is more readable		
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 2;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{				
				// log info necessary for data forward of general purpose register.
				SetGenRegIdx(u32SrcMIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32SrcNIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
				SetGenRegIdx(u32DestIdx+1, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 当前指令是宏内指令，用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32SrcMIdx, u32SrcNIdx, u32Result;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32SrcNIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32SrcMIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			// whether current macro(unit) is used.
			if ( GIsBitSet(u32Units, i) )
			{
				for (int k = 0; k < 2; k++)
				{
					// read ALUCR and carry the value to next phase.
					m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k] = ReadALUCR(i);
				}

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcMIdx) )
				{
					// data forward to get the value of R[u32SrcMIdx] of current macro
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					// read the value of R[u32SrcMIdx] from register heap directly
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32SrcMIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

				// get the value of R[u32SrcNIdx] of current macro
				// data forward or directly
				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32SrcNIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0] = rd_u32r_R_new(i, u32SrcNIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}
			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{				
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32SrcA, u32SrcB, u32Rm, u32Rn;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[2];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		u32Result = 0;
		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{		
				// get the index of the first ALU allocated for this instruction in current macro
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32SrcB = m_arrResSLK[p_u32SLKIdx].arrSrcB[i][0];

				u32Status = 0;
				for (int k = 0; k < 2; k++)
				{
					u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], k+1);
					u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][k];
					if(p_u32Opcode == op_alu_sub16_to_32_c || p_u32Opcode == op_alu_sub8_to_16_c)
					{
						u32ALUCR = GSetBit(u32ALUCR, 0);
					}

					if(k==0)
					{
						u32Rm = u32SrcA & 0xffffU;
						u32Rn = u32SrcB & 0xffffU;
					}
					else
					{
						u32Rm = (u32SrcA>>16) & 0xffffU;
						u32Rn = (u32SrcB>>16) & 0xffffU;
					}

					if(p_u32Opcode == op_alu_sub8_to_16_c || p_u32Opcode == op_alu_sub8_to_16_u_c)
					{
						//HRs+1:s=ORm-ORn,HRs+1:s=ORm-ORn(U)
						u32Result = SubOReg(u32Rm,u32Rn,&u32Status,u32ALUCR);
					}
					else  //if(p_u32Opcode == 84 || p_u32Opcode == 85)
					{
						//Rs+1:s =HRm-HRn,Rs+1:s =HRm-HRn(U)
						u32Result = SubD16Reg(u32Rm,u32Rn,&u32Status,u32ALUCR);
					}

					wr_u32r_R_new(i, u32DestIdx+k, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);

					u32Flag = SetSHFFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
					u32ri_ALUFR[i][u32ALUIdx] = u32Flag;
				}

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

#if 0
//-----------------------------------------------------------------------------------
//The TestForFix16AddC() add by zhaoxiang  2014-06-19
//For test HRs+=C   HRs+=C(U) opcode 48
bool sc_iss::TestForFix16AddC(DSPU32 p_u32IWordLow, DSPU32 p_u32IWordHigh, DSPU32 p_u32SLKIdx, DSPU32 p_u32Slot, DSPU32 p_u32Phase, DSPU32 p_u32JITIdx, DSPU32 p_u32Opcode)
{
	if ( (p_u32SLKIdx == 0) || (p_u32SLKIdx >= RES_SLK_SIZE ) )
	{
		PrintToCerr("TestForFix16AddC: parameter is invalid\n");
		return false;
	}

	if ( (p_u32Slot >= MAX_INUM_LINE) || (p_u32Phase >= PHASE_MAX) )
	{
		PrintToCerr("TestForFix16AddC: parameter is invalid\n");
		return false;
	}

	if (p_u32Phase == PHASE_DC2)
	{
		DSPU32 u32DestIdx, u32Units;
		DSPU32 u32ImmLow, u32ImmHigh;

		union INSTR_WORD
		{
			struct  INST_WORD
			{
				DSPU32 u32Low;
				DSPU32 u32High;
			} ext_words;

			struct  SPLIT_VALUE
			{
				DSPU32      u16Imm1: 16;
				DSPU32		u9Imm2Low: 9;
				DSPU32      u1MWSL: 1;
				DSPU32      u1MWL: 1;
				DSPU32      u4Rev1: 4;
				DSPU32      u1LineL: 1;

				DSPU32      u7Imm2High: 7;
				DSPU32      u5Rev0: 5;
				DSPU32      u6Dest: 6;
				DSPU32      u3Flag: 3;
				DSPU32      u4Opcode: 4;
				DSPU32      u1MWSH: 1;
				DSPU32      u1MWH: 1;
				DSPU32      u4UnitsH: 4;
				DSPU32      u1LineH: 1;
			} details;
		} instr_word;

		// Whether content of g_arrJITCache[ p_u32JITIdx ] is the decode info of p_u32InstrWord?
		if ((g_arrJITCache[ p_u32JITIdx ].u32Inst0 != p_u32IWordLow) || (g_arrJITCache[ p_u32JITIdx ].u32Inst1 != p_u32IWordHigh))
		{
			// fill decode info which is necessary to g_arrJITCache[ p_u32JITIdx ]
			instr_word.ext_words.u32Low = p_u32IWordLow;
			instr_word.ext_words.u32High = p_u32IWordHigh;
			g_arrJITCache[ p_u32JITIdx ].u32Inst0 = p_u32IWordLow;
			g_arrJITCache[ p_u32JITIdx ].u32Inst1 = p_u32IWordHigh;
			u32ImmLow = instr_word.details.u9Imm2Low;
			u32ImmHigh = instr_word.details.u7Imm2High;

			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[0] = instr_word.details.u16Imm1;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[1] = u32ImmLow | (u32ImmHigh << 9);
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[2] = instr_word.details.u3Flag;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3] = instr_word.details.u6Dest;
			g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4] = instr_word.details.u4UnitsH;
		}

		// read decode info from JIT cache to m_arrResSLK[p_u32SLKIdx] which will be carried 
		// accross pipe phases.
		for (int i = 0; i < 5; i++)
		{
			m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[i] = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[i];
		}

		u32DestIdx = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[3];
		u32Units = g_arrJITCache[ p_u32JITIdx ].u32DecodeInfo[4];

		m_arrDCResNeeded[p_u32Slot].u8UnitsUseCalc = u32Units;
		m_arrDCResNeeded[p_u32Slot].i32ALUNum = 1;
		m_arrDCResNeeded[p_u32Slot].bolUseSpecCalc = false;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrSrcGenRegs[i]);
				SetGenRegIdx(u32DestIdx, m_arrResSLK[p_u32SLKIdx].slot_res_used.arrDestGenRegs[i]);
			}
		}

		// 用于支持条件执行
		m_arrResSLK[p_u32SLKIdx].bolIsMacroInstr = true;
	}
	else if (p_u32Phase == PHASE_AC_POST)
	{
		DSPU32 u32Units, u32Result, u32ALUIdx, u32DestIdx;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.		
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				// read ALUCR and carry the value to next phase.
				m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0] = ReadALUCR(i);

				if ( GenRegForward(u32Result, p_u32SLKIdx, i, u32DestIdx) )
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = u32Result;
				}
				else
				{
					m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0] = rd_u32r_R_new(i, u32DestIdx, PIPE_EX.AC_EX.m_left.arrSrcPageIdx[i]);
				}

			}
		} // for (i = 0; i < NUM_OF_UNITS; i++)
	}
	else if (p_u32Phase == PHASE_WB)
	{
		DSPU32 u32Units, u32DestIdx, u32Flag, u32Status, u32Imm, u32Imm1, u32Imm2;
		DSPU32 u32ALUIdx, u32Result, u32ALUCR, u32SrcA;

		// read decode info from m_arrResSLK[ ] which is carried accross pipe phases.
		u32Imm1 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[0];
		u32Imm2 = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[1];
		u32DestIdx = m_arrResSLK[p_u32SLKIdx].u32DecodeInfo[3];
		u32Units = m_arrResSLK[p_u32SLKIdx].cond_do_info.u32UnitMask;

		for (int i = 0; i < NUM_OF_UNITS; i++)
		{
			if ( GIsBitSet(u32Units, i) )
			{	
				u32ALUIdx = GetALUIdx(m_arrResSLK[p_u32SLKIdx].slot_res_used.u8ALUs[i], 1);
				u32ALUCR = m_arrResSLK[p_u32SLKIdx].arrCtrlWord[i][0];
				u32ALUCR = GSetBit(u32ALUCR, 0);
				u32SrcA = m_arrResSLK[p_u32SLKIdx].arrSrcA[i][0];
				u32Status = 0;

				//HRs+=(C1,C2) Rs的低16位与C1相加，高16位与C2相加
				u32Imm = (u32Imm2 << 16) | u32Imm1;

				u32Result = AddD16(u32SrcA,u32Imm,&u32Status, u32ALUCR);

				wr_u32r_R_new(i, u32DestIdx, u32Result, PIPE_EX.EX_WB.m_right.arrDestPageIdx[i]);
				u32Flag = SetALUFlags(u32ri_ALUFR[i][u32ALUIdx], u32Status);
				u32ri_ALUFR[i][u32ALUIdx] = u32Flag;

			} // if ( GIsBitSet(u32Units, i) )
		} // for (i = 0; i < 4; i++)
	} // else if (p_u32Phase == PHASE_WB)

	return true;
}

#endif
