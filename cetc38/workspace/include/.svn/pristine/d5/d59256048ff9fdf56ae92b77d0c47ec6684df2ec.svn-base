//#include "stdafx.h"
#include "CALU.h"


/*---------------------------Include Files-------------------------*/
//#include <fenv.h>
#include <iostream>
#include <cmath>
#include "GlobleDef.h"
#include "Cfloat32.h"
#include "DSPU40.h"
#include "DSPU20.h"
#include "DSPU10.h"
//#include "alutestcase.h"

#ifdef DSP_WIN32
    #pragma warning( disable : 4800 ) 
#endif

using namespace std;

//内部函数声明 f


void ACCAdd16Once(DSPU16 p_u16Src, DSPU20 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);
void ACCSub16Once(DSPU16 p_u16Src, DSPU20 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR);    
DSP_BIT40 U32ToAcc(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 *u8Exp, bool *bolIsNAN);
extern DSPU32 ACCToF32_new(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 u8Exp, bool bolIsNAN)
{
    //考虑不改变标志位  ,(结论:还是改变,把该指令当成一条运算指令) 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
    //按照硬件要求，当指数为0时，数不能被清0  
   /* if (u8Exp == 0)
    {
        if(TestBit(p_u40ACC.u8High, 7))
        {
            return 0x80000000; //返回-0;
        }
        else
        {
            return 0; //返回+0;
        } 
    }
    */
    //2008.10.31 addd
	DSPU32 u32TempFrac = 0;
	DSPU32 AccIsNeg = 0;
    DSPU32 u32HaccLow = 0;
	DSPU8 u8HaccHigh = 0;

    DSPU32 u32Frac;
    //实际尾数共25位,23位数位,1位隐藏位,1位符号位,其它为符号位扩展 
    bool bolFracSign = (p_u40ACC.u8High & 0x80) != 0;
    if (bolFracSign)
    {
        u32Frac = ~(p_u40ACC.u32Low) + 1;  
    }
    else
    {
        u32Frac = p_u40ACC.u32Low;
    }
    //输入是个无效数 
    //if((p_u40ACC.u32Low==0xffffffff)&&(p_u40ACC.u8Exp==0xff)&&(p_u40ACC.u8High==0xff)) 
	////修改 用u8Exp，而不用p_u40ACC.u8Exp
	if((p_u40ACC.u32Low==0xffffffff)&&(u8Exp==0xff)&&(p_u40ACC.u8High==0xff))
     {
          SetFlag(*p_pStatReg, ALU_Invalid);         
          SetFlag(*p_pStatReg, ALU_AIS);
     }

	//2008.10.31.增加非数,做非数处理。非数：只要指数是全f，就是非数，标志设置
	//48位数..	中只要指数是全f
	//非规格化数，指数全f
    //A：
	if(u8Exp==0xff)
	{ 
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
	
	}

	//B：非规格化数
	if(u8Exp==0)
	{ 		
        return 0;
	
	}

	//C：不满足格式的数：指数不等于0 ，尾数的第bit[23-0]与符号位不同的
	if(u8Exp!=0)
	
	{
		
                
		AccIsNeg = p_u40ACC.u8High;
		AccIsNeg = AccIsNeg&0x80;

		//C1：正数,高16位是符号位，要么全0，要么全1
        //高16位为0，[23] = 0，不符合格式
		///A:[39] = 0 ,mag[39:23] !=17'h00001，当浮点0处理
		if(AccIsNeg == 0)
		{

			u32TempFrac = (p_u40ACC.u8High<<9)|(p_u40ACC.u32Low >>23); 
			////其它非法格式：高17位不为0x1，结果为0 
			/*
			if(u32TempFrac != 0x1)
			{    
				return 0;              
			}  
			*/

		}
	  //C2：负数,高16位是符号位，要么全0，要么全1
	  //高16位为1，先求补，再判断，位[23] = 0，不符合格式
	  ///B:mag[39]==1'b1（负数）的情况下，对mag[39:0]求补，
	  ///即neg_mag[39:0]= - mag[39:0],如果neg_mag[39:23] !=17'h00001，当浮点0处理。              
		if(AccIsNeg == 0x80)
		{    
			if(p_u40ACC.u32Low == 0)
			{              
				u32HaccLow = ~p_u40ACC.u32Low +1;///尾数只有在全f情况下才会出现加1后溢出； 
				u8HaccHigh = ~p_u40ACC.u8High +1;					
			}

			else
			{
				u32HaccLow = ~p_u40ACC.u32Low +1;
				u8HaccHigh = ~p_u40ACC.u8High ; //带符号求反 ，但是P_pACC的值没有变 ，只有 Hacc的值变了 					
			}
			

			u32TempFrac = (u8HaccHigh<<9)|(u32HaccLow>>23);
			////高17位不为0x1，结果为0 
			/*
			if(u32TempFrac != 0x1)
			{
				return 0;
			}
			*/
			
		}
	
	}
	

    if (bolIsNAN)
    {
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    } 
    //return (DSPU32)bolFracSign << 31 | (DSPU32)u8Exp << 23 | (u32Frac & 0x007fffff); //尾数保留23位是 0x007fffff  
	return (DSPU32)bolFracSign << 31 | (DSPU32)u8Exp << 23 | ((u32Frac >> 8) & 0x007fffff); //尾数保留23位是 0x007fffff  
}
/******************************************************************
	函数名：		Add32

	描述:			32位定点数据相加。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 Add32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    unsigned int OpBits = sizeof(p_u32Src1) * 8;
    if ((p_u32Src1 == 0x46a08bb8) && (p_u32Src2 == 0xb0f1acd9))
	{
		//int i = 0;
	}  
    //-----------执行级(EX级)操作-----------------------  
    bool bolSrc1Sign = TestBit(p_u32Src1, OpBits - 1);
    bool bolSrc2Sign = TestBit(p_u32Src2, OpBits - 1);
     
    //先设置结果寄存器，
    DSPU32 uDest;
    uDest = p_u32Src1 + p_u32Src2;
 

    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI .而AC,AV,AZ,AN在下面设置   
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
                 
    bool bolDestSign = TestBit(uDest, OpBits - 1);
    //再设置状态寄存器AC，AV（以及相关的AOS）
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;     
    bool bolOvfFlag = bolOverflow || bolUnderflow;                         
 
    //这里的AC是MSB进位   
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = bolCarryFlag; 
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow) ) //26-10-07 08:54
    {
        SetFlag(*p_pStatReg, ALU_OverFlow);
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 6);
		SetFlag(*p_pStatReg, 14); 
    }           
    
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                            
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
             
             //饱和模式下，溢出处理  （判断溢出在前面） 
             if (bolOverflow)
             { 
                 uDest = MAX_SN(OpBits);
             }
             if (bolUnderflow)
             {
                 uDest = MIN_SN(OpBits); 
             }        
             break;
             
        case BaoHe_unsigned:
             
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {                    
                 uDest = 0xffffffff;  //fixme: 32结果ffffffff,正确 ;OpBits结果却是fffffffe... why??? 
             }   
             break;
             
        //default: 
             //break;
    }                   
    
    return uDest;
}

/******************************************************************
	函数名：		Sub32

	描述:			32位定点数据相减。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 Sub32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    
    
    //-----------执行级(EX级)操作-----------------------    
    //只取反，后面AC，AV的结果只和取反的结果有关 
    p_u32Src2 = ~p_u32Src2;
    
    //取得两个源操作数的MSB,带入下一级流水计算 
    bool bolSrc1Sign = TestBit(p_u32Src1 , (OpBits - 1));
    bool bolSrc2Sign = TestBit(p_u32Src2 , (OpBits - 1));    
    
    //设置结果寄存器，
    DSPU32 uDest;
    uDest = p_u32Src1 + p_u32Src2 + 1;    
    
    
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI                      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    bool bolDestSign = TestBit(uDest , (OpBits - 1));           
    //再设置状态寄存器AC，AV（以及相关的AOS），AI，
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;      
    bool bolOvfFlag = bolOverflow || bolUnderflow;              
       
    //这里的AC只是符号位进位           
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) 
                        || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = !bolCarryFlag; 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow) ) //26-10-07 08:54
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS); 
		SetFlag(*p_pStatReg, 6); 
        SetFlag(*p_pStatReg, 14); 
    }           
   
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                                 
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
             if (TestBit(*p_pStatReg, ALU_OverFlow))
             {
                 //饱和模式下，溢出处理  （判断溢出在前面） 
                 if (bolOverflow || ( !bolSrc1Sign &&  (p_u32Src2 == (unsigned int)MIN_SN(OpBits))) )
                 { 
                     uDest = MAX_SN(OpBits);
                 }
                 else
                 {
                     if (bolUnderflow)
                     {
                         uDest = MIN_SN(OpBits); 
                     }   
                 }   
             }  
             break;
             
        case BaoHe_unsigned:
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {
                 uDest = 0;  
             }   
             break;
             
        //default: 
             //break;
    }
    
    return uDest;
}      

/******************************************************************
函数名：		Add16

描述:			16位定点数据相加。

	参数:			p_u16Src1 -- 源操作数1。
					p_u16Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

返回值：		计算结果。

注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位，其它位清零。


修改记录:   2007-8-6 : 删除此函数,改为两个函数add 和adc  

	--------------------------------------
	日期			作者			修改处
*******************************************************************/  
extern DSPU16 Add16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;

  
    //-----------执行级(EX级)操作----------------------- 
    bool bolSrc1Sign = TestBit(p_u16Src1, OpBits - 1);
    bool bolSrc2Sign = TestBit(p_u16Src2, OpBits - 1); 
    //设置结果寄存器，
    DSPU16 uDest;
    uDest = p_u16Src1 + p_u16Src2;
    
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI .而AC,AV,AZ,AN在下面设置   
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);  
    
    bool bolDestSign = TestBit(uDest, OpBits - 1);
    //再设置状态寄存器AC，AV（以及相关的AOS）
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;                        
 
    //这里的AC是MSB进位   
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsignedOverflow = bolCarryFlag; 
      
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed );                    
    if (bolSigned && (bolOverflow || bolUnderflow) || !bolSigned && bolUnsignedOverflow)
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS); 
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13); 
    }     
                                      
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                               
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
		
             
             //饱和模式下，溢出处理  （判断溢出在前面） 
             if (bolOverflow)
             { 
                 uDest = MAX_SN(OpBits);
             }
             if (bolUnderflow)
             {
                 uDest = MIN_SN(OpBits); 
             }        
             break;
             
        case BaoHe_unsigned:
             
             //饱和模式下，溢出处理  
             if (bolUnsignedOverflow)
             {
                 uDest = MAX_UN(OpBits);   
             }   
             break;
             
        default: 
             break;
    }                   
    
    return uDest;    
}


/******************************************************************
函数名：		Add8

描述:			8位定点数据相加。

	参数:			p_u16Src1 -- 源操作数1。
					p_u16Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

返回值：		计算结果。

注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位，其它位清零。


修改记录:   2007-8-6 : 删除此函数,改为两个函数add 和adc  

	--------------------------------------
	日期			作者			修改处
*******************************************************************/ 
extern DSPU8 Add8_alu(DSPU8 p_u16Src1, DSPU8 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;

  
    //-----------执行级(EX级)操作----------------------- 
    bool bolSrc1Sign = TestBit(p_u16Src1, OpBits - 1);
    bool bolSrc2Sign = TestBit(p_u16Src2, OpBits - 1); 
    //设置结果寄存器，
    DSPU8 uDest;
    uDest = p_u16Src1 + p_u16Src2;
    
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI .而AC,AV,AZ,AN在下面设置   
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);  
    
    bool bolDestSign = TestBit(uDest, OpBits - 1);
    //再设置状态寄存器AC，AV（以及相关的AOS）
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;                        
 
    //这里的AC是MSB进位   
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsignedOverflow = bolCarryFlag; 
      
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed );                    
    if (bolSigned && (bolOverflow || bolUnderflow) || !bolSigned && bolUnsignedOverflow)
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS); 
		SetFlag(*p_pStatReg, 4); 
        SetFlag(*p_pStatReg, 12); 
    }     
                                      
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                               
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
		
             
             //饱和模式下，溢出处理  （判断溢出在前面） 
             if (bolOverflow)
             { 
                 uDest = MAX_SN(OpBits);
             }
             if (bolUnderflow)
             {
                 uDest = MIN_SN(OpBits); 
             }        
             break;
             
        case BaoHe_unsigned:
             
             //饱和模式下，溢出处理  
             if (bolUnsignedOverflow)
             {
                 uDest = MAX_UN(OpBits);   
             }   
             break;
             
        default: 
             break;
    }                   
    
    return uDest;    
}
/******************************************************************
函数名：		Sub8

描述:			16位定点数据相减。

参数:			p_u16Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器的指针。
                    p_i32SMode -- 饱和模式。
						BaoHe_none：饱和模式关闭；
						BaoHe_signed：有符号数的饱和模式；
						BaoHe_unsigned：无符号数的饱和模式。

返回值：		计算结果。

注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位，其它位清零。

修改记录
--------------------------------------
日期			作者			修改处
	
*******************************************************************/
extern DSPU8 Sub8_alu(DSPU8 p_u16Src1, DSPU8 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    
    
    //-----------执行级(EX级)操作-----------------------    
    
    //只取反，后面AC，AV的结果只和取反的结果有关 
    p_u16Src2 = ~p_u16Src2;
    
    //取得两个源操作数的MSB,带入下一级流水计算 
    bool bolSrc1Sign = TestBit(p_u16Src1 , (OpBits - 1));
    bool bolSrc2Sign = TestBit(p_u16Src2 , (OpBits - 1));    
    
    //设置结果寄存器，
    DSPU8 uDest;
    uDest = p_u16Src1 + p_u16Src2 + 1;    
    
    
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI                      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    bool bolDestSign = TestBit(uDest , (OpBits - 1));             
    //再设置状态寄存器AC，AV（以及相关的AOS），AI，
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;      
    bool bolOvfFlag = bolOverflow || bolUnderflow;              
       
    //这里的AC只是符号位进位           
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) 
                        || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = !bolCarryFlag; 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow) )
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 4); 
        SetFlag(*p_pStatReg, 12); 
    }     
    
   
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                                 
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
             if (TestBit(*p_pStatReg, ALU_OverFlow))
             {
                 //饱和模式下，溢出处理  （判断溢出在前面） 
                 if (bolOverflow || ( !bolSrc1Sign &&  (p_u16Src2 == (unsigned int)MIN_SN(OpBits))) )
                 { 
                     uDest = MAX_SN(OpBits);
                 }
                 else
                 {
                     if (bolUnderflow)
                     {
                         uDest = MIN_SN(OpBits); 
                     }   
                 }   
             }  
             break;
             
        case BaoHe_unsigned:
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {
                 uDest = 0;  
             }   
             break;
             
        //default: 
             //break;
    }
    
    return uDest;
}
/******************************************************************
函数名：		Sub16

描述:			16位定点数据相减。

参数:			p_u16Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器的指针。
                    p_i32SMode -- 饱和模式。
						BaoHe_none：饱和模式关闭；
						BaoHe_signed：有符号数的饱和模式；
						BaoHe_unsigned：无符号数的饱和模式。

返回值：		计算结果。

注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位，其它位清零。

修改记录
--------------------------------------
日期			作者			修改处
	
*******************************************************************/
extern DSPU16 Sub16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    
    
    //-----------执行级(EX级)操作-----------------------    
    
    //只取反，后面AC，AV的结果只和取反的结果有关 
    p_u16Src2 = ~p_u16Src2;
    
    //取得两个源操作数的MSB,带入下一级流水计算 
    bool bolSrc1Sign = TestBit(p_u16Src1 , (OpBits - 1));
    bool bolSrc2Sign = TestBit(p_u16Src2 , (OpBits - 1));    
    
    //设置结果寄存器，
    DSPU16 uDest;
    uDest = p_u16Src1 + p_u16Src2 + 1;    
    
    
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI                      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    bool bolDestSign = TestBit(uDest , (OpBits - 1));             
    //再设置状态寄存器AC，AV（以及相关的AOS），AI，
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;      
    bool bolOvfFlag = bolOverflow || bolUnderflow;              
       
    //这里的AC只是符号位进位           
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) 
                        || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = !bolCarryFlag; 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow) )
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13); 
    }     
    
   
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                                 
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
             if (TestBit(*p_pStatReg, ALU_OverFlow))
             {
                 //饱和模式下，溢出处理  （判断溢出在前面） 
                 if (bolOverflow || ( !bolSrc1Sign &&  (p_u16Src2 == (unsigned int)MIN_SN(OpBits))) )
                 { 
                     uDest = MAX_SN(OpBits);
                 }
                 else
                 {
                     if (bolUnderflow)
                     {
                         uDest = MIN_SN(OpBits); 
                     }   
                 }   
             }  
             break;
             
        case BaoHe_unsigned:
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {
                 uDest = 0;  
             }   
             break;
             
        //default: 
             //break;
    }
    
    return uDest;
}

extern DSPU8 Sub8_abs(DSPU8 p_u16Src1, DSPU8 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    
	if (p_u16Src1 < p_u16Src2)
	{
		DSPU8 temp = p_u16Src1;
		p_u16Src1 = p_u16Src2;
		p_u16Src2 = temp;
	}
    
    //-----------执行级(EX级)操作-----------------------    
    
    //只取反，后面AC，AV的结果只和取反的结果有关 
    //p_u16Src2 = ~p_u16Src2;
    
    //取得两个源操作数的MSB,带入下一级流水计算 
    bool bolSrc1Sign = TestBit(p_u16Src1 , (OpBits - 1));
    bool bolSrc2Sign = TestBit(p_u16Src2 , (OpBits - 1));    
    
    //设置结果寄存器，
    DSPU8 uDest;
    //uDest = p_u16Src1 + p_u16Src2 + 1;    
    uDest = p_u16Src1 - p_u16Src2 ;
    return uDest;
	/*
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI                      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    bool bolDestSign = TestBit(uDest , (OpBits - 1));             
    //再设置状态寄存器AC，AV（以及相关的AOS），AI，
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;      
    bool bolOvfFlag = bolOverflow || bolUnderflow;              
       
    //这里的AC只是符号位进位           
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) 
                        || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = !bolCarryFlag; 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow) )
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);  
		SetFlag(*p_pStatReg, 4); 
        SetFlag(*p_pStatReg, 12); 
    }     
    
   
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                                 
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
             if (TestBit(*p_pStatReg, ALU_OverFlow))
             {
                 //饱和模式下，溢出处理  （判断溢出在前面） 
                 if (bolOverflow || ( !bolSrc1Sign &&  (p_u16Src2 == (unsigned int)MIN_SN(OpBits))) )
                 { 
                     uDest = MAX_SN(OpBits);
                 }
                 else
                 {
                     if (bolUnderflow)
                     {
                         uDest = MIN_SN(OpBits); 
                     }   
                 }   
             }  
             break;
             
        case BaoHe_unsigned:
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {
                 uDest = 0;  
             }   
             break;
             
        default: 
             break;
    }
    
    return uDest;
	*/
}

extern DSPU16 Sub16_abs(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
	if (bolSigned)
	{
		DSPI16 src1 = (DSPI16)p_u16Src1;
		DSPI16 src2 = (DSPI16)p_u16Src2;
		if ((src1- src2) < 0 )
		{
			DSPU16 temp = p_u16Src1;
			p_u16Src1 = p_u16Src2;
			p_u16Src2 = temp;
		}
	}
	else{
		if (p_u16Src1 < p_u16Src2)
		{
			DSPU16 temp = p_u16Src1;
			p_u16Src1 = p_u16Src2;
			p_u16Src2 = temp;
		}
	}
    
    //-----------执行级(EX级)操作-----------------------    
    
    //只取反，后面AC，AV的结果只和取反的结果有关 
    p_u16Src2 = ~p_u16Src2;
    
    //取得两个源操作数的MSB,带入下一级流水计算 
    bool bolSrc1Sign = TestBit(p_u16Src1 , (OpBits - 1));
    bool bolSrc2Sign = TestBit(p_u16Src2 , (OpBits - 1));    
    
    //设置结果寄存器，
    DSPU16 uDest;
    uDest = p_u16Src1 + p_u16Src2 + 1;    
    //uDest = p_u16Src1 - p_u16Src2 ;
    return uDest;
	/*
    //-----------写回级(WB级)操作-----------------------       
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI                      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    bool bolDestSign = TestBit(uDest , (OpBits - 1));             
    //再设置状态寄存器AC，AV（以及相关的AOS），AI，
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;      
    bool bolOvfFlag = bolOverflow || bolUnderflow;              
       
    //这里的AC只是符号位进位           
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) 
                        || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = !bolCarryFlag; 
    
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsingedOverflow) )
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);  
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13); 
    }     
    
   
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                                 
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;             
             
        case BaoHe_signed:
             if (TestBit(*p_pStatReg, ALU_OverFlow))
             {
                 //饱和模式下，溢出处理  （判断溢出在前面） 
                 if (bolOverflow || ( !bolSrc1Sign &&  (p_u16Src2 == (unsigned int)MIN_SN(OpBits))) )
                 { 
                     uDest = MAX_SN(OpBits);
                 }
                 else
                 {
                     if (bolUnderflow)
                     {
                         uDest = MIN_SN(OpBits); 
                     }   
                 }   
             }  
             break;
             
        case BaoHe_unsigned:
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {
                 uDest = 0;  
             }   
             break;
             
        default: 
             break;
    }
    
    return uDest;
	*/
}

/******************************************************************
	函数名：		AddD16

	描述:			输入数据的高低16位分别作定点数据相加。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Add16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Add16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;      
}


/******************************************************************
	函数名：		SubD16

	描述:			输入数据的高低16位分别作定点数据相减。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Sub16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Sub16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;      
}

/******************************************************************
	函数名：		Add32Half

	描述:			32位定点数据相加，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Add32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI .而AC,AV,AZ,AN在下面设置   
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);   
    
    //-----------执行级(EX级)操作-----------------------                   
    //先设置结果寄存器，
    bool bolSrc1LSB = p_u32Src1 & 0x1;
    bool bolSrc2LSB = p_u32Src2 & 0x1;

    DSPU32 uDest;
    uDest = (p_u32Src1 >> 1) + (p_u32Src2 >> 1); 
    
    DSPU32 iDest;
    DSPI32 i32Src1Tmp = p_u32Src1;
    DSPI32 i32Src2Tmp = p_u32Src2;
    iDest = (i32Src1Tmp >> 1) + (i32Src2Tmp >> 1); 
    
    if (bolSrc1LSB && bolSrc2LSB)
    {
        uDest += 1;
        iDest += 1;
    }       
    
    //BWDSP 规定截断模式恒定为向0舍入,即截断 
    DSPU32 u1TruncateMode = md_to_zero;                                                      
    //参数处理，（ 截断(向0取舍)T，向最近取舍（0） ） 
    if ( (u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB) && (uDest & 0x1) )
    {
        uDest += 1;
        iDest += 1;
    }     
          
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);                
    if (bolSigned)
    {
        uDest = iDest;              
    }
    
    return uDest;   
}   

/******************************************************************
	函数名：		Sub32Half

	描述:			32位定点数据相减，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Sub32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 

    //-----------执行级(EX级)操作-----------------------         
    DSPU32 uOrignSrc2 = p_u32Src2;               
    p_u32Src2 = ~p_u32Src2 + 1;
                       
    bool bolSrc1LSB = p_u32Src1 & 0x1;
    bool bolSrc2LSB = p_u32Src2 & 0x1;

    DSPU32 uDest;
    uDest = (p_u32Src1 >> 1) + (p_u32Src2 >> 1); 
    
    DSPU32 iDest;
    DSPI32 i32Src1Tmp = p_u32Src1;
    DSPI32 i32Src2Tmp = p_u32Src2;
    iDest = (i32Src1Tmp >> 1) + (i32Src2Tmp >> 1);

    if (bolSrc1LSB && bolSrc2LSB)
    {
        uDest += 1;
        iDest += 1;
    }   
    
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);  
    bool bolOvctr =  TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    
    //BWDSP 规定截断模式恒定为向0舍入,即截断 
    DSPU32 u1TruncateMode = md_to_zero;   
        
    if (bolSigned)
    {
        if (p_u32Src2 == 0x80000000)
        {          
            ClearBit(iDest,OpBits - 1);
        }            
        if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB) && (iDest & 0x1))
        {
            iDest += 1;
        }
    }
    else 
    {
        if(p_u32Src1 >= uOrignSrc2)
        {
            ClearFlag(uDest, OpBits - 1);
            if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB) && (uDest & 0x1))
            {
                uDest += 1;
            }
        }
        else 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS);
			SetFlag(*p_pStatReg, 6); 
			SetFlag(*p_pStatReg, 14); 
            if (bolOvctr) 
            {          
                uDest = 0;                                               //baohua amend 2007 10.24 
            }
            else                                                           //baohua add 2007 10.24 
            { 
                SetFlag(uDest, OpBits - 1);                                // 不够减借位，baohua add 2007.10.24  

            }
        }
    } 
    
    if (bolSigned)
    {
        uDest = iDest;              
    }   

    //-----------写回级(WB级)操作-----------------------        
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;              
}

/******************************************************************
	函数名：		Add16Half

	描述:			16位定点数据相加，再求平均。

	参数:			p_u16Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器的指针。
					p_bolSigned -- 是否为有符号数。
						true: 有符号数；
						false：无符号数。
					p_i32TMode -- 舍入方式。
						md_to_zero：向零舍入，即截断；
						md_to_nearest：最近舍入。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位，其它位清零。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU16 Add16Half(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI .而AC,AV,AZ,AN在下面设置   
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);   
    
    //-----------执行级(EX级)操作-----------------------                   
    //先设置结果寄存器，
    bool bolSrc1LSB = p_u16Src1 & 0x1;
    bool bolSrc2LSB = p_u16Src2 & 0x1;

    DSPU16 uDest;
    uDest = (p_u16Src1 >> 1) + (p_u16Src2 >> 1); 
    
    DSPU16 iDest;
    DSPI16 i16Src1Tmp = p_u16Src1;
    DSPI16 i16Src2Tmp = p_u16Src2;
    iDest = (i16Src1Tmp >> 1) + (i16Src2Tmp >> 1); 
    
    if (bolSrc1LSB && bolSrc2LSB)
    {
        uDest += 1;
        iDest += 1;
    }       
    
    //BWDSP 规定截断模式恒定为向0舍入,即截断 
    DSPU32 u1TruncateMode = md_to_zero;                                                      
    //参数处理，（ 截断(向0取舍)T，向最近取舍（0） ） 
    if ( (u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB) && (uDest & 0x1) )
    {
        uDest += 1;
        iDest += 1;
    }     
         
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);                
    if (bolSigned)
    {
        uDest = iDest;              
    }
    
    
    //-----------写回级(WB级)操作-----------------------               
    
    return uDest;  
}

/******************************************************************
	函数名：		Sub16Half

	描述:			16位定点数据相减，再求平均。

	参数:			p_u16Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器的指针。
					p_bolSigned -- 是否为有符号数。
						true: 有符号数；
						false：无符号数。
					p_i32TMode -- 舍入方式。
						md_to_zero：向零舍入，即截断；
						md_to_nearest：最近舍入。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位，其它位清零。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU16 Sub16Half(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 

    //-----------执行级(EX级)操作-----------------------         
    DSPU16 uOrignSrc2 = p_u16Src2;               
    p_u16Src2 = ~p_u16Src2 + 1;
                       
    bool bolSrc1LSB = p_u16Src1 & 0x1;
    bool bolSrc2LSB = p_u16Src2 & 0x1;

    DSPU16 uDest;
    uDest = (p_u16Src1 >> 1) + (p_u16Src2 >> 1); 
    
    DSPU16 iDest;
    DSPI16 i16Src1Tmp = p_u16Src1;
    DSPI16 i16Src2Tmp = p_u16Src2;
    iDest = (i16Src1Tmp >> 1) + (i16Src2Tmp >> 1);

    if (bolSrc1LSB && bolSrc2LSB)
    {
        uDest += 1;
        iDest += 1;
    }   
    
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);  
    bool bolOvctr =  TestFlag(p_u32ALUCR, ALU_Ctl_Saturation); 
    
    //BWDSP 规定截断模式恒定为向0舍入,即截断 
    DSPU32 u1TruncateMode = md_to_zero;   
        
    if (bolSigned)
    {
        if (p_u16Src2 == 0x8000)
        {          
            ClearBit(iDest,OpBits - 1);
        }            
        if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB) && (iDest & 0x1))
        {
            iDest += 1;
        }
    }
    else 
    {
        if(p_u16Src1 >= uOrignSrc2)
        {
            ClearFlag(uDest, OpBits - 1);
            if ((u1TruncateMode == md_to_nearest) && (bolSrc1LSB ^ bolSrc2LSB) && (uDest & 0x1))
            {
                uDest += 1;
            }
        }
        else 
        {
             if (bolOvctr)    // add by baohua 2007.10.24 
            
            {
                         uDest = 0;
            
            }                                                      // baohua add 2007.10.24
             else  
            {
                   //uDest = 0;  
                    SetFlag(uDest, OpBits - 1);                    // baohua add 2007.10.24                  
            }
            SetFlag(*p_pStatReg, ALU_OverFlow);
            SetFlag(*p_pStatReg, ALU_AOS); 
			SetFlag(*p_pStatReg, 5); 
            SetFlag(*p_pStatReg, 13); 
        }
    } 
    
    if (bolSigned)
    {
        uDest = iDest;              
    }   

    //-----------写回级(WB级)操作-----------------------        
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;          
}

/******************************************************************
	函数名：		AddD16Half

	描述:			输入数据的高低16位分别作定点数据相加，再求平均。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Add16Half(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Add16Half(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;  
}      

/******************************************************************
	函数名：		SubD16Half

	描述:			输入数据的高低16位分别作定点数据相减，再求平均。

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Sub16Half(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Sub16Half(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 
} 

/******************************************************************
	函数名：		Abs32

	描述:			求32位定点数的绝对值。

	参数:			p_u32Src -- 源操作数（32位有符号数）。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。				

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。
					2. 源操作数总认为是有符号数, 结果始终做饱和处理 

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/* 
DSPU32 alu_Abs32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
 
 
    //-----------执行级(EX级)操作-----------------------        
    bool bolSrcSign = TestBit(p_u32Src, 31);
 
    DSPU32 uDest;
    if (bolSrcSign)
    {
        if(p_u32Src != 0x80000000)
        {           
            uDest = -(DSPI32)p_u32Src;
        }
        else
        {
            uDest = 0x80000000;
            SetFlag(*p_pStatReg, ALU_OverFlow);
            SetFlag(*p_pStatReg, ALU_AOS);
			SetFlag(*p_pStatReg, 6); 
			SetFlag(*p_pStatReg, 14); 
        }
            
    }
    else
    {
        uDest = p_u32Src;
    }   
    
    
    //-----------写回级(WB级)操作-----------------------       
    
    return uDest;          
} 
*/
 DSPU32 alu_Abs32_NEW(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
 
 
    //-----------执行级(EX级)操作-----------------------        
    bool bolSrcSign1 = TestBit(p_u32Src, 31);
	bool bolSrcSign = p_u32ALUCR &0x1;
	
    DSPU32 uDest;
    if (bolSrcSign && bolSrcSign1)
    {
        if(p_u32Src != 0x80000000)
        {           
            uDest = -(DSPI32)p_u32Src;
        }
        else
        {
            uDest = 0x80000000;
            SetFlag(*p_pStatReg, ALU_OverFlow);
            SetFlag(*p_pStatReg, ALU_AOS);
			SetFlag(*p_pStatReg, 6); 
			SetFlag(*p_pStatReg, 14); 
        }
            
    }
    else
    {
        uDest = p_u32Src;
    }   
    
    
    //-----------写回级(WB级)操作-----------------------       
    
    return uDest;          
}

/******************************************************************
	函数名:		    ALU_Abs16

	描述:			求16位定点数的绝对值。

	参数:			p_u16Src -- 源操作数(16位有符号数).
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0.	
					p_u32ALUCR -- ALU控制寄存器, 结果始终做饱和处理				

	返回值:		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。
					2. 源操作数总认为是有符号数。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 ALU_Abs16(DSPU16 p_u16Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
 
 
    //-----------执行级(EX级)操作-----------------------        
    bool bolSrcSign = TestBit(p_u16Src, 15);
 
    DSPU16 uDest;
    if (bolSrcSign)
    {
        if(p_u16Src != 0x8000)
        {           
            uDest = -p_u16Src;
        }
        else
        {
            uDest = 0x8000;
            SetFlag(*p_pStatReg, ALU_OverFlow);
            SetFlag(*p_pStatReg, ALU_AOS);
			SetFlag(*p_pStatReg, 5); 
			SetFlag(*p_pStatReg, 13); 
        }
            
    }
    else
    {
        uDest = p_u16Src;
    }   
    
    
    //-----------写回级(WB级)操作-----------------------     
    
    return uDest;          
} 

extern DSPU16 ALU_Abs16_new(DSPU16 p_u16Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
 
 
    //-----------执行级(EX级)操作-----------------------        
    bool bolSrcSign1 = TestBit(p_u16Src, 15);
	bool bolSrcSign = p_u32ALUCR & 0x1;
 
    DSPU16 uDest;
    if (bolSrcSign && bolSrcSign1)
    {
        if(p_u16Src != 0x8000)
        {           
            uDest = -p_u16Src;
        }
        else
        {
            uDest = 0x8000;
            SetFlag(*p_pStatReg, ALU_OverFlow);
            SetFlag(*p_pStatReg, ALU_AOS);
			SetFlag(*p_pStatReg, 5); 
			SetFlag(*p_pStatReg, 13); 
        }
            
    }
    else
    {
        uDest = p_u16Src;
    }   
    
    
    //-----------写回级(WB级)操作-----------------------     
    
    return uDest;          
} 

/******************************************************************
	函数名：		AbsD16

	描述:			输入数据的高低16位分别求绝对值。

	参数:			p_u32Src -- 源操作数（包括高低16位两个定点有符号数）。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。				

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。
					2. 源操作数总认为是有符号数。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/

DSPU32 alu_AbsD16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);

    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = ALU_Abs16(u16UpperSrc, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = ALU_Abs16(u16LowerSrc, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
	//u32Result = u32Result & 0xffff;
    return  u32Result; 
}

/******************************************************************
	函数名：		AddAbs16

	对应指令形式: LHRs=abs(HHRm)+abs(LHRm)

	描述:		两个16位有符号定点数分别求绝对值并相加。

	参数:		p_u32Src -- 源操作数，其高16位和低16位分别是两个16位有符号定点数。					
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddAbs16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(8) | BIT(14) | BIT(13) ;


	if ((p_u32Src == 0x80000001))
	{
	//int i = 0;
	}


	DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);

    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = ALU_Abs16_new(u16UpperSrc, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = ALU_Abs16_new(u16LowerSrc, &LowerReg, p_u32ALUCR); 
    
	DSPU16 result  =  Add16(u16UpperResult,u16LowerResult,p_pStatReg,p_u32ALUCR);
	DSPU16 resultz =  Add16(u16UpperResult,u16LowerResult,p_pStatReg,p_u32ALUCR & 0xfffffffe);
    if (
		((p_u32ALUCR & 0x1) == 0x1)
		)
	{
		if (resultz > 0x7fff)
		{
			if ((p_u32ALUCR & 0x2) == 0x2)
			{
				result = 0x7fff;
			}

			SetFlag(*p_pStatReg, ALU_OverFlow); 
			SetFlag(*p_pStatReg, ALU_AOS); 
			SetFlag(*p_pStatReg, 5); 
			SetFlag(*p_pStatReg, 13); 
		}
	}
    
	DSPU32 u32Result = result & 0xffff;
    return  u32Result; 
}

/******************************************************************
	函数名：		AbsFlo32

	描述:			求32位浮点数的绝对值。

	参数:			p_u32Src -- 源操作数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。				

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/

 DSPU32 alu_AbsFlo32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
   Cfloat32 cf32Src(p_u32Src);
   
   if (cf32Src.IsNAN())
   {
       SetFlag(*p_pStatReg, ALU_Invalid); 
       SetFlag(*p_pStatReg, ALU_AIS);
       return N_A_N;
   } 
   
   if(cf32Src.IsINF())
   {
      ///2008.10.31 add
	   
	  SetFlag(*p_pStatReg, ALU_FOverFlow); 
      SetFlag(*p_pStatReg, ALU_AVS);
      return POS_INF;
	  //return MAX_NORM ;
   }      
   
   if (cf32Src.IsDNORM())
   {
       cf32Src.SetZero();
   }
   
   
   
   //NRM,INF,0  符号位清0 
   return cf32Src.GetU32() & 0x7fffffff;
} 

/******************************************************************
	函数名：		Add32ci

	描述:			32位定点数据带进位加。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。
					p_bolCSet -- ALU标志寄存器中进位标志是否为'1'。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
/*
 extern DSPU32 Add32ci(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolCSet)
{
    unsigned int OpBits = sizeof(p_u32Src1) * 8;
    
    //-----------执行级(EX级)操作----------------------- 
    //先设置结果寄存器，
    DSPU32 uDest;
    if (p_bolCSet)
    {
        uDest = p_u32Src1 + p_u32Src2 + 1;
    }
    else 
    {
        uDest = p_u32Src1 + p_u32Src2;
    }
    
    bool bolSrc1Sign = TestBit(p_u32Src1, OpBits - 1);
    bool bolSrc2Sign = TestBit(p_u32Src2, OpBits - 1);
    
    
    //-----------写回级(WB级)操作-----------------------         
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    bool bolDestSign = TestBit(uDest, OpBits - 1);

    //再设置状态寄存器AC，AV（以及相关的AOS）
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;                        
    if (bolOverflow || bolUnderflow)
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS); 
		SetFlag(*p_pStatReg, 6);
		SetFlag(*p_pStatReg, 14);
    }   
 
    //这里的AC是MSB进位   
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = bolCarryFlag; 
                                                               
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                            
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;
                          
        case BaoHe_signed:
             
             //饱和模式下，溢出处理  （判断溢出在前面） 
             if (bolOverflow)
             { 
                 uDest = MAX_SN(OpBits);
             }
             if (bolUnderflow)
             {
                 uDest = MIN_SN(OpBits); 
             }        
             break;
             
        case BaoHe_unsigned:
             
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {                    
                 uDest = 0xffffffff;  //fixme: 32结果ffffffff,正确 ;OpBits结果却是fffffffe... why??? 
             }   
             break;
             
        default: 
             break;
    }                   
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
}
*/
/******************************************************************
	函数名：		Sub32ci

	描述:			32位定点数据带借位减。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。
					p_bolCSet -- ALU标志寄存器中进位标志是否为'1'。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
/*
extern DSPU32 Sub32ci(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolCSet)
{
    int OpBits = sizeof(p_u32Src1) * 8;

    //-----------执行级(EX级)操作-----------------------       
    //先设置结果寄存器，
    DSPU32 uDest;
    //只取反，后面AC，AV的结果只和取反的结果有关 
    p_u32Src2 = ~p_u32Src2 ;
    if (p_bolCSet)
    {
        uDest = p_u32Src1 + p_u32Src2 + 1 ;
    }
    else 
    {
        uDest = p_u32Src1 + p_u32Src2;
    }
    
    bool bolSrc1Sign = TestBit(p_u32Src1 , (OpBits - 1));
    bool bolSrc2Sign = TestBit(p_u32Src2 , (OpBits - 1));
    
    
    //-----------写回级(WB级)操作-----------------------  
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);    
    bool bolDestSign = TestBit(uDest , (OpBits - 1));
                     
    //再设置状态寄存器AC，AV（以及相关的AOS），AI，
    bool bolOverflow = !bolSrc1Sign && !bolSrc2Sign && bolDestSign;
    bool bolUnderflow = bolSrc1Sign && bolSrc2Sign && !bolDestSign;      
    bool bolOvfFlag = bolOverflow || bolUnderflow;              
    if (bolOvfFlag)
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 6);
		SetFlag(*p_pStatReg, 14);
    }   
       
    //这里的AC只是符号位进位           
    bool bolCarryFlag = ((bolSrc1Sign != bolSrc2Sign) && !bolDestSign) 
                        || (bolSrc1Sign && bolSrc2Sign);        
        
    bool bolUnsingedOverflow = !bolCarryFlag; 
                                                               
    unsigned int u2SatuMode = p_u32ALUCR & ( BIT(ALU_Ctl_Signed) | BIT(ALU_Ctl_Saturation) );                                                            
    //参数处理，（饱和，饱和关闭） 
    switch (u2SatuMode)
    {
        case BaoHe_none: 
        case BaoHe_none_unsigned: 
             break;
                         
        case BaoHe_signed:
             if (TestBit(*p_pStatReg, ALU_OverFlow))
             {
                 //饱和模式下，溢出处理  （判断溢出在前面） 
                 if (bolOverflow || ( !bolSrc1Sign &&  (p_u32Src2 == (unsigned int)MIN_SN(OpBits))) )
                 { 
                     uDest = MAX_SN(OpBits);
                 }
                 else
                 {
                     if (bolUnderflow)
                     {
                         uDest = MIN_SN(OpBits); 
                     }   
                 }   
             }  
             break;
             
        case BaoHe_unsigned:
             //饱和模式下，溢出处理  
             if (bolUnsingedOverflow)
             {
                 uDest = 0;  
             }   
             break;
             
        default: 
             break;
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
} 
*/

DSPU32 AddF32_xiaoyu1(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

{
	//DSPU32 tmp108_StatReg = 0;
	//DSPU32 tmp108 = AddF32_yichu( p_u32Src1,  p_u32Src2, &tmp108_StatReg,3);

	DSPU32 tmp_sishewuru = p_u32ALUCR & 0x4;
	
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
	
	

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
            return POS_INF  | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS); 
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM(); //u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM(); //指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
    }  
    
    DSPU32 u32Src1Fra = cfSrc1.GetFrac();
   
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
    if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    }     
    DSPU32 u32Src2Fra = cfSrc2.GetFrac();    
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}   
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI32 i32Src1Frac = (DSPI32)u32Src1Fra;
    DSPI32 i32Src2Frac = (DSPI32)u32Src2Fra;
    
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (cfSrc1.GetFrac() != cfSrc2.GetFrac())
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
      
        return 0;
	}

    Cfloat32 cfTemp;
	DSPI32 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		i32Src2Frac = i32Temp;
	}
    DSPI32 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
   
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1; 
		i32Src2Frac = i32Src2Frac >> 1;
		 if (i > 31)
         break;
   }
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   //added by flyu 浮点加法四舍五入




   //added by flyu 浮点加法四舍五入 end
   i32DestExp = cfSrc1.GetExp(); //01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI32 i32CodeDestFrac = i32DestFrac;
   if (i32DestNeg != 0)
   {
	  
       //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
       //2008.10.22.33位求补 ，前面符号位扩展，不用考滤 
       //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           ////2008.11.3特殊情况设置，如果第bit[24-0]：1000000,设置保护位为0
		   
		   if((i32DestFrac & 0x1ffffff)==0x1000000)
		   {
			   bolProteckBit = 0;		   
		   }
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }
	


   //移位时,包括符号位.
   //这里使用的是原码进行判断
   bool bolFacOvf = ((i32CodeDestFrac >> 24) != 0x0);
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
		    if(tmp_sishewuru !=0 )
			{
				if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
				{
					SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
					SetFlag(*p_pStatReg,ALU_AVS);
					return MAX_NORM | (i32DestNeg << 31);
				}
				else
				{
            		SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
					SetFlag(*p_pStatReg,ALU_AVS);
					return POS_INF |(i32DestNeg << 31);
				}
			}
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   if(!TestBit(i32CodeDestFrac,23))
	   {
		    
            //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
			//2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
            i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			                   
                i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }


   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }

   Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
     cfDest.SetExp((DSPU32)i32DestExp);
	   cfDest.SetFrac((DSPU32)i32DestFrac);
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
	}
	
   	if (tmp_sishewuru == 0x0) //四舍五入
	{
	float f1 = 0;
	float f2 = 0;
	//

	if((p_u32Src1 & 0x7f800000)==0x0)
	{
		if((p_u32Src1 & 0x80000000)==0x80000000)
		{
			p_u32Src1=0x80000000;
		}
		else
		{
			p_u32Src1=0x0;
		}
	}
	if((p_u32Src2 & 0x7f800000)==0x0)
	{ 
		if((p_u32Src2 & 0x80000000)==0x80000000)
		{
			p_u32Src2=0x80000000;
		}
		else
		{
			p_u32Src2=0x0;
		}
	}
	Cfloat32 m_cfSrc1(p_u32Src1);
    Cfloat32 m_cfSrc2(p_u32Src2);
	f1 = m_cfSrc1.GetF32();
	f2 = m_cfSrc2.GetF32();
	f1 = f1 + f2;
	
	DSPU32 *p1;
	p1 = (DSPU32 *) &f1;

	DSPU32 mask0=(*p1) & 0x7f800000;
	DSPU32 mask1=(*p1) & 0x007fffff;
	if((mask0==0x7f800000) && (mask1!=0x0))
	{
		*p1 = 0xffffffff;
	}

	if((mask0==0x0) && (mask1!=0x0))
	{
		if(((*p1) & 0x80000000)==0x80000000)
		{
			*p1=0x80000000;
		}
		else
		{
			*p1=0x0;
		}
	}
	

	DSPU32 u32s1;
	u32s1 = *p1;
	if ((u32s1 == 0x7f800000)||(u32s1 == 0xff800000))
	{
		
		if ( ((p_u32Src1 == 0x7f7fffff)&&((p_u32Src2 & 0xff800000) == 0x73000000 ))
			 ||  ((p_u32Src2 == 0x7f7fffff)&&((p_u32Src1 & 0xff800000) == 0x73000000 ))
			 ||  ((p_u32Src1 == 0xff7fffff)&&((p_u32Src2 & 0xff800000) == 0xf3000000 )&&((p_u32Src2&0x7fffff) <= 0x7f0000))
			 ||  ((p_u32Src2 == 0xff7fffff)&&((p_u32Src1 & 0xff800000) == 0xf3000000 )&&((p_u32Src1&0x7fffff) <= 0x7f0000))
			 //|| (tmp108_StatReg == 0)
			)
		{
		}
		else
		//if (tmp108_StatReg != 0)
		{
		SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
        SetFlag(*p_pStatReg,ALU_AVS);
		 if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
		  {
			 if (u32s1 == 0x7f800000)
			 {
				u32s1 = 0x7f7fffff;
			 }
			 else if ((u32s1 == 0xff800000))
			 {
				u32s1 = 0xff7fffff;
			 }
		  }

		}
	 
	}

	float d1 = (float &) u32s1;
	if (tmp_sishewuru == 0x0) //四舍五入
	{
		return u32s1;
	}
	
	}

    //return u32s1;
	return cfDest.GetU32();       
}

DSPU32 AddF32_yichu(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

{
	Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
     
    DSPI32 i32ExpDiff = 0;
    if (cfSrc1.GetExp() >= cfSrc2.GetExp() )
	{
		i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
	}
	else
	{
		i32ExpDiff = cfSrc2.GetExp() - cfSrc1.GetExp();
	}
     if (i32ExpDiff <=  1)
	 {
		DSPU32 test = AddF32_xiaoyu1( p_u32Src1,  p_u32Src2, p_pStatReg, 4);
	 }
	 else
	 {
		 DSP_BIT40 p_pACC;
		 DSPU8 p_pEXP = 0;
		 p_pACC.u32Low = 0x0;
		 p_pACC.u8High = 0x0;

		 ACCAddF32(p_u32Src1, &p_pACC, &p_pEXP, p_pStatReg,  p_u32ALUCR);
		 ACCAddF32(p_u32Src2, &p_pACC, &p_pEXP, p_pStatReg,  p_u32ALUCR);

	 }
	 return 0;
}


/******************************************************************
	函数名：		AddF32

	描述:			32位浮点数据相加。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
DSPU32 AddF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

{
	DSPU32 tmp108_StatReg = 0;
	DSPU32 tmp108 = AddF32_yichu( p_u32Src1,  p_u32Src2, &tmp108_StatReg,3);

	DSPU32 tmp_sishewuru = p_u32ALUCR & 0x4;
	
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
	
	

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
            return POS_INF  | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS); 
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM(); //u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM(); //指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
    }  
    
    DSPU32 u32Src1Fra = cfSrc1.GetFrac();
   
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
    if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    }     
    DSPU32 u32Src2Fra = cfSrc2.GetFrac();    
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}   
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI32 i32Src1Frac = (DSPI32)u32Src1Fra;
    DSPI32 i32Src2Frac = (DSPI32)u32Src2Fra;
    
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (cfSrc1.GetFrac() != cfSrc2.GetFrac())
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
      
        return 0;
	}

    Cfloat32 cfTemp;
	DSPI32 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		i32Src2Frac = i32Temp;
	}
    DSPI32 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
   
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1; 
		i32Src2Frac = i32Src2Frac >> 1;
		 if (i > 31)
         break;
   }
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   //added by flyu 浮点加法四舍五入




   //added by flyu 浮点加法四舍五入 end
   i32DestExp = cfSrc1.GetExp(); //01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI32 i32CodeDestFrac = i32DestFrac;
   if (i32DestNeg != 0)
   {
	  
       //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
       //2008.10.22.33位求补 ，前面符号位扩展，不用考滤 
       //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           ////2008.11.3特殊情况设置，如果第bit[24-0]：1000000,设置保护位为0
		   
		   if((i32DestFrac & 0x1ffffff)==0x1000000)
		   {
			   bolProteckBit = 0;		   
		   }
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }
	


   //移位时,包括符号位.
   //这里使用的是原码进行判断
   bool bolFacOvf = ((i32CodeDestFrac >> 24) != 0x0);
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
		    if(tmp_sishewuru !=0 )
			{
				if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
				{
					SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
					SetFlag(*p_pStatReg,ALU_AVS);
					return MAX_NORM | (i32DestNeg << 31);
				}
				else
				{
            		SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
					SetFlag(*p_pStatReg,ALU_AVS);
					return POS_INF |(i32DestNeg << 31);
				}
			}
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   if(!TestBit(i32CodeDestFrac,23))
	   {
		    
            //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
			//2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
            i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			                   
                i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }


   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }

   Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
     cfDest.SetExp((DSPU32)i32DestExp);
	   cfDest.SetFrac((DSPU32)i32DestFrac);
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
	}
	
   	if (tmp_sishewuru == 0x0) //四舍五入
	{
	float f1 = 0;
	float f2 = 0;
	//

	if((p_u32Src1 & 0x7f800000)==0x0)
	{
		if((p_u32Src1 & 0x80000000)==0x80000000)
		{
			p_u32Src1=0x80000000;
		}
		else
		{
			p_u32Src1=0x0;
		}
	}
	if((p_u32Src2 & 0x7f800000)==0x0)
	{ 
		if((p_u32Src2 & 0x80000000)==0x80000000)
		{
			p_u32Src2=0x80000000;
		}
		else
		{
			p_u32Src2=0x0;
		}
	}
	Cfloat32 m_cfSrc1(p_u32Src1);
    Cfloat32 m_cfSrc2(p_u32Src2);
	f1 = m_cfSrc1.GetF32();
	f2 = m_cfSrc2.GetF32();
	f1 = f1 + f2;
	
	DSPU32 *p1;
	p1 = (DSPU32 *) &f1;

	DSPU32 mask0=(*p1) & 0x7f800000;
	DSPU32 mask1=(*p1) & 0x007fffff;
	if((mask0==0x7f800000) && (mask1!=0x0))
	{
		*p1 = 0xffffffff;
	}

	if((mask0==0x0) && (mask1!=0x0))
	{
		if(((*p1) & 0x80000000)==0x80000000)
		{
			*p1=0x80000000;
		}
		else
		{
			*p1=0x0;
		}
	}
	

	DSPU32 u32s1;
	u32s1 = *p1;
	if ((u32s1 == 0x7f800000)||(u32s1 == 0xff800000))
	{
		
		if ( ((p_u32Src1 == 0x7f7fffff)&&((p_u32Src2 & 0xff800000) == 0x73000000 ))
			 ||  ((p_u32Src2 == 0x7f7fffff)&&((p_u32Src1 & 0xff800000) == 0x73000000 ))
			 ||  ((p_u32Src1 == 0xff7fffff)&&((p_u32Src2 & 0xff800000) == 0xf3000000 )&&((p_u32Src2&0x7fffff) <= 0x7f0000))
			 ||  ((p_u32Src2 == 0xff7fffff)&&((p_u32Src1 & 0xff800000) == 0xf3000000 )&&((p_u32Src1&0x7fffff) <= 0x7f0000))
			 || (tmp108_StatReg == 0)
			)
		{
		}
		else
		//if (tmp108_StatReg != 0)
		{
		SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
        SetFlag(*p_pStatReg,ALU_AVS);
		 if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
		  {
			 if (u32s1 == 0x7f800000)
			 {
				u32s1 = 0x7f7fffff;
			 }
			 else if ((u32s1 == 0xff800000))
			 {
				u32s1 = 0xff7fffff;
			 }
		  }

		}
	 
	}

	float d1 = (float &) u32s1;
	if (tmp_sishewuru == 0x0) //四舍五入
	{
		return u32s1;
	}
	
	}

    //return u32s1;
	return cfDest.GetU32();       
}

//四舍五入
DSPU32 AddF32_SSWR(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
            return POS_INF  | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS); 
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM(); //u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM(); //指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
    }  
    
    DSPU32 u32Src1Fra = cfSrc1.GetFrac();
   
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
    if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    }     
    DSPU32 u32Src2Fra = cfSrc2.GetFrac();    
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}   
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI32 i32Src1Frac = (DSPI32)u32Src1Fra;
    DSPI32 i32Src2Frac = (DSPI32)u32Src2Fra;
    
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (cfSrc1.GetFrac() != cfSrc2.GetFrac())
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
      
        return 0;
	}

    Cfloat32 cfTemp;
	DSPI32 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		i32Src2Frac = i32Temp;
	}
    DSPI32 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
   
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1; 
		i32Src2Frac = i32Src2Frac >> 1;
		 if (i > 31)
         break;
   }
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   //added by flyu 浮点加法四舍五入




   //added by flyu 浮点加法四舍五入 end
   i32DestExp = cfSrc1.GetExp(); //01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI32 i32CodeDestFrac = i32DestFrac;
   if (i32DestNeg != 0)
   {
	  
       //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
       //2008.10.22.33位求补 ，前面符号位扩展，不用考滤 
       //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           ////2008.11.3特殊情况设置，如果第bit[24-0]：1000000,设置保护位为0
		   
		   if((i32DestFrac & 0x1ffffff)==0x1000000)
		   {
			   bolProteckBit = 0;		   
		   }
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }

   //移位时,包括符号位.
   //这里使用的是原码进行判断
   bool bolFacOvf = ((i32CodeDestFrac >> 24) != 0x0);
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   if(!TestBit(i32CodeDestFrac,23))
	   {
		    
            //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
			//2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
            i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			                   
                i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }


   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }

   Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
     cfDest.SetExp((DSPU32)i32DestExp);
	   cfDest.SetFrac((DSPU32)i32DestFrac);
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
	}
	float f1 = 0;
	float f2 = 0;
	//
	Cfloat32 m_cfSrc1(p_u32Src1);
    Cfloat32 m_cfSrc2(p_u32Src2);
	f1 = m_cfSrc1.GetF32();
	f2 = m_cfSrc2.GetF32();
	f1 = f1 + f2;
	
	DSPU32 *p1;
	p1 = (DSPU32 *) &f1;

	
	DSPU32 u32s1;
	u32s1 = *p1;

	float d1 = (float &) u32s1;
    return u32s1;
	//return cfDest.GetU32();       
}
//AddF32_SSWR
extern DSPU32 SubF32_SSWR(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
   
     p_u32Src2 = p_u32Src2 ^ 0x80000000; //符号位取反  
    
    return AddF32_SSWR(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);       
}



/******************************************************************
	函数名：		SubF32

	描述:			32位浮点数据相减。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 SubF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
   
     p_u32Src2 = p_u32Src2 ^ 0x80000000; //符号位取反  
    
    return AddF32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);       
}

/******************************************************************
	函数名：		AddF32Half

	描述:			32位浮点数据相加，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddF32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    DSPU32 tmp_sishewuru = p_u32ALUCR & 0x4;
 
    Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
    //源操作为非数或者无穷大数相加，都返回无效数，无效位溢出 
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
        SetFlag(*p_pStatReg,ALU_Invalid);  //baohua 无效数置位 07-11-07 11:53
        SetFlag(*p_pStatReg,ALU_AIS);
        
        return N_A_N;
    }   
    
    bool bolSatu = TestFlag(p_u32ALUCR,ALU_Ctl_Saturation);
    if (cfSrc1.IsINF())//如果Src1无穷大 
    {
            SetFlag(*p_pStatReg,ALU_FOverFlow);  //baohua 上溢出置位 07-11-07 11:53
            SetFlag(*p_pStatReg,ALU_AVS);
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数              
        if (bolSatu)  //饱和控制输出最大有效值 
        {

            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else// 不饱和控制，输出正无穷大 
        {
            return POS_INF | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
        SetFlag(*p_pStatReg,ALU_FOverFlow);  //baohua 上溢出置位 07-11-07 11:53
        SetFlag(*p_pStatReg,ALU_AVS);
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数              
        if (bolSatu)
        {
            return MAX_NORM | (cfSrc2.GetNega() << 31);

        }
        else
        {
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM();//非规格化数 ，u8Exp == 0 && u23Frac != 0 
    if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM();//非规格化数 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
    }  
    
    DSPU32 u32Src1Fra = cfSrc1.GetFrac();
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
    if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    } 
    
    DSPU32 u32Src2Fra = cfSrc2.GetFrac();
    
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
	}
    
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 
    }   

    DSPI32 i32ExpDiff = 0;
    DSPI32 i32Src1Frac = (DSPI32)u32Src1Fra;
    DSPI32 i32Src2Frac = (DSPI32)u32Src2Fra;

    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (cfSrc1.GetFrac() != cfSrc2.GetFrac())
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); 
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
        return 0;
	}
	
    Cfloat32 cfTemp;
	DSPI32 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		i32Src2Frac = i32Temp;
	}
    
    
    DSPI32 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

   i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
   for ( int i = 0; i < i32ExpDiff; i++)
   {
	   bolProteckBit = i32Src2Frac & 0x1; 
       i32Src2Frac = i32Src2Frac >> 1;
   }
   i32DestFrac = i32Src1Frac + i32Src2Frac;
   
   i32DestExp = cfSrc1.GetExp();

   i32DestNeg = cfSrc1.GetNega();

   //由补码求原码,用来判断需不需要左规或右规
   DSPI32 i32CodeDestFrac = i32DestFrac;
 
   if (i32DestNeg != 0)
   {
	  
       //i32CodeDestFrac = ~i32DestFrac + 1;
	   //2008.10.6修改为带保护位左移
	   //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
        //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
            ////2008.11.3特殊情况设置，如果第bit[24-0]：1000000,设置保护位为0
		   
		   if((i32DestFrac & 0x1ffffff)==0x1000000)
		   {
			   bolProteckBit = 0;		   
		   }
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }

   //移位时,包括符号位.
   //这里使用的是原码进行判断
   bool bolFacOvf = ((i32CodeDestFrac >> 24) != 0x0);
  
   
   //2008.10.17.结果指数值为1，在没有进位的情况下，除以2后指数无法表示，即下溢出
   //2008.10.31 修改
	if((i32DestExp == 0x1)&&(!bolFacOvf))
   
	{
		SetFlag(*p_pStatReg,ALU_UnderFlow);  
		SetFlag(*p_pStatReg,ALU_AUS);
		
	}

   
   //在这里,指数减一达到除2的目的 
   i32DestExp-- ;



   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;   
	   
       if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i32CodeDestFrac,23))
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
				
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
					
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }


   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }

    Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
		 cfDest.SetExp((DSPU32)i32DestExp);
		 cfDest.SetFrac((DSPU32)i32DestFrac);
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
	}
    
	float f1 = 0;
	float f2 = 0;
	//
	if((p_u32Src1 & 0x7f800000)==0x0)
	{
		//cout<<"T1"<<endl;
		if((p_u32Src1 & 0x80000000)==0x80000000)
		{
			p_u32Src1=0x80000000;
		}
		else
		{
			p_u32Src1=0x0;
		}
	}
	if((p_u32Src2 & 0x7f800000)==0x0)
	{ 
		//cout<<"T2"<<endl;
		if((p_u32Src2 & 0x80000000)==0x80000000)
		{
			//cout<<"T3"<<endl;
			p_u32Src2=0x80000000;
		}
		else
		{
			p_u32Src2=0x0;
		}
	}

	Cfloat32 m_cfSrc1(p_u32Src1);
    Cfloat32 m_cfSrc2(p_u32Src2);
	f1 = m_cfSrc1.GetF32();
	f2 = m_cfSrc2.GetF32();
	double aug1,add1;
	//aug1 = f1 ;
	//add1 = f2 ;
	if (f1==0 && fabs(f2)<pow(2.0,-125.0))
        aug1=f2/2;
    else
		aug1=f2;
    if(f2==0 && fabs(f1)<pow(2.0,-125.0))
        add1=f1/2;
    else                           
		add1=f1;


	aug1 = aug1 + add1;
    aug1 = aug1 / 2;

	//f1 = (f1 + f2) / 2;
	f1 = aug1;

	 DSPU32 *p1;
	p1 = (DSPU32 *) &f1;

	
	DSPU32 u32s1;
	u32s1 = *p1;

	//float d1 = (float &) u32s1;
#ifdef DSP_LINUX
    __asm__ __volatile__("": : :"memory");
#endif

	//cout<<"T1 = "<<endl;

	 DSPU32 mask0=(*p1) & 0x7f800000;
	 DSPU32 mask1=(*p1) & 0x007fffff;

	if(mask1!=0) {	
		
		if((mask0==0x7f800000))
	{
		*p1 = 0xffffffff;
	}

		if(mask0==0x0)
	{
		if(((*p1) & 0x80000000)==0x80000000)
		{
			*p1=0x80000000;
		}
		else
		{
			//cout<<"T5"<<endl;
			*p1=0x0;
		}
	  }
	}




	//DSPU32 u32s1;
	u32s1 = *p1;

	float d1 = (float &) u32s1;
	if (tmp_sishewuru == 0x0) //四舍五入
	{
		//cout<<"T6"<<endl;
		return u32s1;
	}

    //return u32s1;

    return cfDest.GetU32();       

}
/******************************************************************
	函数名：		SubF32Half

	描述:			32位浮点数据相减，再求平均。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 SubF32Half(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    p_u32Src2 = p_u32Src2 ^ 0x80000000; //符号位取反  
    
    return AddF32Half(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);   
}

/*****************************************************************

******************************************************************/
void ACCAdd16Once(DSPU16 p_u16Src, DSPU20 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS) | BIT(13); 
     
    DSPU20 Src1(p_u16Src);
    
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    ///添加080718 按照主任要求累加/累减受饱和控制位 控制 
    bool p_bolStau   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    
    if (p_bolSigned)
    {
        Src1.SignExtend();
    }    
    DSPU20 Src2 = *p_pACC;
    DSPU20 u20Result;
    u20Result = Src1 + Src2;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u20Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u20Result.Sign();                        
    
    bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u20Result.Sign()) 
                        || (Src1.Sign() && Src2.Sign());        
    
    bool bolUnsignedOverflow = bolCarryFlag;   
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolOvfFlag = bolOverflow  || bolUnderflow;    
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsignedOverflow) ) //26-10-07 08:54
    {
        ///只有饱和才会置位标志位 
        if(p_bolStau) 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS);  
			SetFlag(*p_pStatReg, 5); 
            SetFlag(*p_pStatReg, 13);  
        }                 
    }    
    
    
    if (p_bolSigned)
    { 
        ///0722添加受饱和控制 
        if (bolOverflow&&p_bolStau)
        {
            u20Result.SetToMAX_SN_20();
        }
        ///0722添加受饱和控制 
        if (bolUnderflow&&p_bolStau)
        {
            u20Result.SetToMIN_SN_20();
        }   
    } 
    else         
        {
            ///0722添加受饱和控制 
            if (bolUnsignedOverflow&&p_bolStau)
            {                    
                 u20Result.SetToMAX_UN_20();   
            }   
        }
    
    *p_pACC = u20Result;       
}


/*****************************************************************

******************************************************************/
void ACCSub16Once(DSPU16 p_u16Src, DSPU20 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS)|BIT(13); 
     
    DSPU20 Src1(p_u16Src);    
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    ///添加080718 按照主任要求累加/累减受饱和控制位 控制 
    bool p_bolStau   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    
    if (p_bolSigned)
    {
        Src1.SignExtend();
    }    
    DSPU20 Src2 = *p_pACC;
    DSPU20 u20Result;
    
    Src1.OverturnAll();
    u20Result = Src2 + Src1 + 1;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u20Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u20Result.Sign();                        
    
    bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u20Result.Sign()) 
                        || (Src1.Sign() && Src2.Sign());        
    
    bool bolUnsignedOverflow = !bolCarryFlag; 
  
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolOvfFlag = bolOverflow  || bolUnderflow;
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsignedOverflow) ) //26-10-07 08:54

    {
       ///只有饱和才会置位标志位 
        if(p_bolStau) 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS); 
			SetFlag(*p_pStatReg, 5); 
            SetFlag(*p_pStatReg, 13); 
        }                               
    }  

    if (p_bolSigned)
    { 
        if (TestFlag(*p_pStatReg, ALU_OverFlow))
        {
            ///0722添加受饱和控制 
            if ( (bolOverflow || 
            (!Src2.Sign() && Src1.GetU32() == 0x80000000)) &&p_bolStau)
            {
                u20Result.SetToMAX_SN_20();
            }
            else if (bolUnderflow&&p_bolStau)
                {
                    u20Result.SetToMIN_SN_20();
                }   
        } 
    }
    else         
    {
        ///0722添加受饱和控制 
        if (bolUnsignedOverflow&&p_bolStau)
        {                    
            u20Result.SetToZero(); 
			
        }   
    }
    
    *p_pACC = u20Result.GetDSPBIT();    

	
}

void ACCAdd8Once(DSPU8 p_u16Src, DSPU10 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS) | BIT(13); 
     
    DSPU10 Src1(p_u16Src);
    
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    ///添加080718 按照主任要求累加/累减受饱和控制位 控制 
    bool p_bolStau   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    
    if (p_bolSigned)
    {
        Src1.SignExtend();
    }    
    DSPU10 Src2 = *p_pACC;
    DSPU10 u20Result;
    u20Result = Src1 + Src2;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u20Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u20Result.Sign();                        
    
    bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u20Result.Sign()) 
                        || (Src1.Sign() && Src2.Sign());        
    
    bool bolUnsignedOverflow = bolCarryFlag;   
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolOvfFlag = bolOverflow  || bolUnderflow;    
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsignedOverflow) ) //26-10-07 08:54
    {
        ///只有饱和才会置位标志位 
        if(p_bolStau) 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS);  
			SetFlag(*p_pStatReg, 4); 
            SetFlag(*p_pStatReg, 12);  
        }                 
    }    
    
    
    if (p_bolSigned)
    { 
        ///0722添加受饱和控制 
        if (bolOverflow&&p_bolStau)
        {
            u20Result.SetToMAX_SN_20();
        }
        ///0722添加受饱和控制 
        if (bolUnderflow&&p_bolStau)
        {
            u20Result.SetToMIN_SN_20();
        }   
    } 
    else         
        {
            ///0722添加受饱和控制 
            if (bolUnsignedOverflow&&p_bolStau)
            {                    
                 u20Result.SetToMAX_UN_20();   
            }   
        }
    
    *p_pACC = u20Result;       
}

void ACCSub8Once(DSPU8 p_u16Src, DSPU10 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS)|BIT(13); 
     
    DSPU10 Src1(p_u16Src);    
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    ///添加080718 按照主任要求累加/累减受饱和控制位 控制 
    bool p_bolStau   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    
    if (p_bolSigned)
    {
        Src1.SignExtend();
    }    
    DSPU10 Src2 = *p_pACC;
    DSPU10 u20Result;
    
    Src1.OverturnAll();
    u20Result = Src2 + Src1 + 1;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u20Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u20Result.Sign();                        
    
    bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u20Result.Sign()) 
                        || (Src1.Sign() && Src2.Sign());        
    
    bool bolUnsignedOverflow = !bolCarryFlag; 
  
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolOvfFlag = bolOverflow  || bolUnderflow;
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsignedOverflow) ) //26-10-07 08:54

    {
       ///只有饱和才会置位标志位 
        if(p_bolStau) 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS); 
			SetFlag(*p_pStatReg, 4); 
            SetFlag(*p_pStatReg, 12); 
        }                               
    }  

    if (p_bolSigned)
    { 
        if (TestFlag(*p_pStatReg, ALU_OverFlow))
        {
            ///0722添加受饱和控制 
            if ( (bolOverflow || 
            (!Src2.Sign() && Src1.GetU32() == 0x80000000)) &&p_bolStau)
            {
                u20Result.SetToMAX_SN_20();
            }
            else if (bolUnderflow&&p_bolStau)
                {
                    u20Result.SetToMIN_SN_20();
                }   
        } 
    }
    else         
    {
        ///0722添加受饱和控制 
        if (bolUnsignedOverflow&&p_bolStau)
        {                    
            u20Result.SetToZero(); 
			
        }   
    }
    
    *p_pACC = u20Result.GetDSPBIT();    

	
}

/******************************************************************
	函数名：		ACCAddD16

	描述:			源操作数的高低16位定点数据分别累加，累加结果寄存器分为两个20位寄存器以适应短字操作。					
					定点数据累加过程：16位数据扩展为20位数据，再与ACC中的20位数据累加。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCAddD16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);    
    
    DSPU20 u20UpperSrc2 ((DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) ));
    DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low)); 
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    ACCAdd16Once(u16UpperSrc1, &u20UpperSrc2, &UpperReg, p_u32ALUCR);
    ACCAdd16Once(u16LowerSrc1, &u20LowerSrc2, &LowerReg, p_u32ALUCR);

    DSP_BIT40 u40Result;
    u40Result.u32Low = u20UpperSrc2.GetU32() << 20 | u20LowerSrc2.GetU32();
    u40Result.u8High = (DSPU8)(u20UpperSrc2.GetU32() >> 12);
    
    *p_pACC = u40Result;
    *p_pStatReg = UpperReg | LowerReg;
    
}

/******************************************************************
	函数名：		ACCSubD16

	描述:			源操作数的高低16位定点数据分别累减，累加结果寄存器分为两个20位寄存器以适应短字操作。					
					定点数据累减过程：16位数据扩展为20位数据，再与ACC中的20位数据累减。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCSubD16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);    
    
    DSPU20 u20UpperSrc2 ( (DSPU32)((((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20)) );
    DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low)); 
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;

    ACCSub16Once(u16UpperSrc1, &u20UpperSrc2, &UpperReg, p_u32ALUCR);
    ACCSub16Once(u16LowerSrc1, &u20LowerSrc2, &LowerReg, p_u32ALUCR);
    
    DSP_BIT40 u40Result;
    u40Result.u32Low = u20UpperSrc2.GetU32() << 20 | u20LowerSrc2.GetU32();
    u40Result.u8High = (DSPU8)(u20UpperSrc2.GetU32() >> 12);
    
    *p_pACC = u40Result;
    *p_pStatReg = UpperReg | LowerReg;     
} 
/******************************************************************* 
	函数名：		AddF32InAcc_new

	描述:			32位浮点累加。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录        2008.10.23和addf32()没有区别 
	--------------------------------------
	日期			作者			修改处
********************************************************************/
DSPU32 AddF32InAcc_new(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,DSP_BIT40 *p_pACC, DSPU8 *p_pEXP)

{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    DSPU32 bunderflow = 0;
	Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
		p_pACC->u32Low = 0xffffffff ;
		p_pACC->u8High = 0xff;
		*p_pEXP = 0xff;
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);  
        if (bolSatu)
        {
			
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;
            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);                        
        if (bolSatu)
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM();//u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM();//指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
		/*
		p_pACC->u32Low = 0;
		p_pACC->u8High = 0;
		*p_pEXP = 0;
		return 0x0;
		*/
    }  
    
    //DSPU32 u32Src1Fra = cfSrc1.GetFrac();
	DSPU64 u32Src1Fra = p_pACC->u32Low;
	DSPU64 tmp64 = p_pACC->u8High;
	u32Src1Fra = u32Src1Fra | (tmp64 << 32);
	/*
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
	*/
    /*
	if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    } 
	*/
    //DSPU32 u32Src2Fra = cfSrc2.GetFrac();
	DSPU64 u32Src2Fra = cfSrc2.GetFrac();
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}   
	u32Src2Fra = u32Src2Fra << 8;
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI64 i32Src1Frac = (DSPI64)u32Src1Fra;
    DSPI64 i32Src2Frac = (DSPI64)u32Src2Fra;
    //
	DSPU32 u32newFrac1 = 0;
	DSPU32 u32newFrac2 = cfSrc2.GetFrac();
	u32newFrac2 = u32newFrac2 << 8;//尾数补8个0
	bool bolnewFracSign1 = (p_pACC->u8High & 0x80) != 0;
    if (bolnewFracSign1)
    {
        u32newFrac1 = ~(p_pACC->u32Low) + 1;  
    }
    else
    {
        u32newFrac1 = p_pACC->u32Low;
    }
	u32newFrac1 = u32newFrac1 & 0x7fffffff;
	//
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (u32newFrac1 != u32newFrac2)
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
		p_pACC->u32Low = 0;
		p_pACC->u8High = 0;
		*p_pEXP = 0;
        return 0;
	}
		if (cfSrc2.IsZero())
	{
		return 0;
	}
    Cfloat32 cfTemp;
	DSPI64 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		//i32Src1Frac = i32Src1Frac << 8;
		i32Src2Frac = i32Temp;
		if (cfSrc2.IsNega())
		{
			//i32Src2Frac = ~i32Src2Frac + 1;
		}
	}
	if (cfSrc2.IsNega())
	{
		i32Src2Frac = i32Src2Frac | 0xffffffff00000000ull;
	}
	if (cfSrc1.IsNega())
	{
		i32Src1Frac = i32Src1Frac | 0xffffffff00000000ull;
	}
    DSPI64 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
    //cout<<hex<<i32Src2Frac<<endl;
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1;
		if (cfSrc2.IsNega())
		{
			i32Src2Frac = i32Src2Frac | 0x8000000000000000ull;
		}
		i32Src2Frac = i32Src2Frac >> 1;
		

		 if (i > 63)//31
         break;
   }
   //cout<<hex<<i32Src2Frac<<endl;
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   i32DestExp = cfSrc1.GetExp();//01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI64 i32CodeDestFrac = i32DestFrac;
	/*
   if (i32DestNeg != 0)
   {
	  
       //i32CodeDestFrac = ~i32DestFrac + 1;
	   //2008.10.6修改为带保护位左移
	   //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
        //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }
	*/

	bool bolFacOvf = true;
   DSPI64 i64CodeDestFrac = i32CodeDestFrac;

	//if (cfSrc1.IsNega())
   if (i64CodeDestFrac < 0)
	{
		i64CodeDestFrac = ~i64CodeDestFrac + 1;
	}
	 bolFacOvf = ((i64CodeDestFrac >> 32) != 0x0);

	if (bolFacOvf)
	{
		i32DestExp ++ ;
		 if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);

				if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;

                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
				if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;

                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32CodeDestFrac = i32CodeDestFrac >> 1;  //移动补码 
	}
	else
	{
		     //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i64CodeDestFrac,31))//23
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
				bunderflow = 1;
				if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
				{
					    p_pACC->u8High = 0x0;
						p_pACC->u32Low = 0x0;
				}
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   //i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    //i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   i32CodeDestFrac = i32CodeDestFrac << 1;  //移动补码
		   i64CodeDestFrac = i64CodeDestFrac << 1;

		 while (!TestBit(i64CodeDestFrac,31) && (i64CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
					bunderflow = 1;
				if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
				{
					    p_pACC->u8High = 0x0;
						p_pACC->u32Low = 0x0;
				}
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				//i32DestFrac = i32DestFrac << 1;
				//i32CodeDestFrac = i32CodeDestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;  //移动补码
				i64CodeDestFrac = i64CodeDestFrac << 1;
		   }
	   }
	}
   //移位时,包括符号位.
   //这里使用的是原码进行判断 24
   //bool bolFacOvf = ((i32CodeDestFrac >> 32) != 0x0);//24
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
   /*
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i32CodeDestFrac,31))//23
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }
	*/
	/*
   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }
	*/
    Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
		 cfDest.SetExp((DSPU32)i32DestExp);
		 cfDest.SetFrac((DSPU32)i32DestFrac);
		 *p_pEXP = (DSPU32)i32DestExp;
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
		*p_pEXP = (DSPU32)0;
	}
	p_pACC->u32Low = ((DSPU32)i32CodeDestFrac) ;
	p_pACC->u8High = ((DSPU64)i32CodeDestFrac) >> 32;
	
	if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
	{
		   if (bunderflow == 1)
		   {
			p_pACC->u8High = 0x0;
			p_pACC->u32Low = 0x0;
		   }
	}
	if (i32CodeDestFrac == 0)
	{
		*p_pEXP = (DSPU32)0;
	}
	
	return (((DSPU32)(i32DestFrac)));
    //return cfDest.GetU32();       
}

/******************************************************************* 
	函数名：		AddF32InAcc

	描述:			32位浮点累加。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录        2008.10.23和addf32()没有区别 
	--------------------------------------
	日期			作者			修改处
********************************************************************/
DSPU32 AddF32InAcc(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,DSP_BIT40 *p_pACC, DSPU8 *p_pEXP)

{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);  
        if (bolSatu)
        {
					
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;

            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);                        
        if (bolSatu)
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM();//u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM();//指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
    }  
    
    DSPU32 u32Src1Fra = cfSrc1.GetFrac();
   
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
    if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    }     
    DSPU32 u32Src2Fra = cfSrc2.GetFrac();    
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}    
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI32 i32Src1Frac = (DSPI32)u32Src1Fra;
    DSPI32 i32Src2Frac = (DSPI32)u32Src2Fra;
    
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (cfSrc1.GetFrac() != cfSrc2.GetFrac())
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
      
        return 0;
	}

    Cfloat32 cfTemp;
	DSPI32 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		i32Src2Frac = i32Temp;
	}
    DSPI32 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
   
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1; 
		i32Src2Frac = i32Src2Frac >> 1;
		 if (i > 31)
         break;
   }
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   i32DestExp = cfSrc1.GetExp();//01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI32 i32CodeDestFrac = i32DestFrac;

   if (i32DestNeg != 0)
   {
	  
       //i32CodeDestFrac = ~i32DestFrac + 1;
	   //2008.10.6修改为带保护位左移
	   //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
        //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }

   //移位时,包括符号位.
   //这里使用的是原码进行判断
   bool bolFacOvf = ((i32CodeDestFrac >> 24) != 0x0);
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i32CodeDestFrac,23))
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }

	/*
   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }
	*/
    Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
		 cfDest.SetExp((DSPU32)i32DestExp);
		 cfDest.SetFrac((DSPU32)i32DestFrac);
		 *p_pEXP = (DSPU32)i32DestExp;
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
		*p_pEXP = (DSPU32)0;
	}
	p_pACC->u32Low = ((DSPU32)i32DestFrac) << 8 ;
	if (i32DestNeg != 0)
   {
	    p_pACC->u8High = 0xff;
	}
	else
	{
		p_pACC->u8High = 0x0;
	}
	return (((DSPU32)(i32DestFrac<<8)));
    //return cfDest.GetU32();       
}

/******************************************************************
	函数名：		ACCAddF32   opcode_
		
	描述:			32位浮点累加。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{


    //
	if ((p_u32Src == 0x7f800000)
		&& (p_pACC->u32Low == 0x0)
		&& (p_pACC->u8High == 0x0)
		)
	{
		//int i = 0;
	}
	DSP_BIT40 Tmp_pACC = *p_pACC;
	DSPU8     Tmp_exp = *p_pEXP;
	DSPU32    Tmp_src = p_u32Src;
	if (p_u32Src == 0x7fa228fc)
	{
		//int i = 0;
	}
	//
     //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     //2008.10.30,LXM规定不再分饱和和不饱和，都置标志位     
     //结果强制做饱和 
	 SetFlag(p_u32ALUCR,ALU_Ctl_Saturation);
     //先取控制信号 
	 bool bolStau =  TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
	 DSPU32 U32StatReg = 0; 
     U32StatReg = *p_pStatReg &0x200; 
     
     ////add 2008-07-31 
     DSPU8  u8HaccHigh = 0;    
     DSPU32 u32HaccLow = 0;
     DSPU32 u32TempFrac = 0;

	Cfloat32 tmp13(p_u32Src);
	if (tmp13.IsNAN())
	{
		SetFlag(*p_pStatReg, ALU_Invalid);         
		SetFlag(*p_pStatReg, ALU_AIS);

		*p_pEXP = 0xff;
		p_pACC->u32Low = 0xffffffff;
		p_pACC->u8High = 0xff; 	

		return;
	}
     
	 
	
     //只是针对定点累加结果转为浮点运算时，指数为0情况
     //2008.07.30指数为0 ，累加输入就是为0 ，无效数LXM规定 
     ////将40尾数为0视为指数为0 的情况，2008-07-31

	 //(1)指数为0
     if(*p_pEXP == 0)
     //if((*p_pEXP == 0) || ((p_pACC->u8High == 0)&&(p_pACC->u32Low == 0)))    
     {
        DSPU32 u32StatTemp = 0; 
		DSPU32 u32Frac = 0;
		
        bool bolAccIsNaN = (*p_pEXP == 0xff) && (p_pACC->u32Low == 0xffffffff) && (p_pACC->u8High == 0xff);

        //实际尾数共25位,23位数位,1位隐藏位,1位符号位,其它为符号位扩展 
        bool bolFracSign = (p_pACC->u8High & 0x80) != 0;
        
        if (bolAccIsNaN)
        {
            SetFlag(*p_pStatReg, ALU_Invalid);         
            SetFlag(*p_pStatReg, ALU_AIS);
            return;
        }
        
         ///如果指数为0，无效数，就是该累加输入为0,当作浮点0处理，其它都不变 
        p_pACC->u8High = 0;
        p_pACC->u32Low = 0; 
         
        //
        Cfloat32 cf32Src (p_u32Src);
    	
    	DSPU8 iExp = cf32Src.GetExp()-*p_pEXP;//取原操作数与ACC指数的差值
    	DSPU32 u8HignLSB = 0;
    	if (*p_pEXP <= cf32Src.GetExp())//如果ACC指数小于等于原操作数的指数(加上一个等于号，解决结果在指数都为0时的差异) 
    	{
        	           
 	        int i = 1;//循环计数，最大数不能超过31即32次
			int i_cnt= iExp; //差值作为右移次数值
          	{  
        	
					while (i_cnt && i <= 31)
    				{
    					i++;
						i_cnt--;

						//如果指数差值大于0，ACC40位数带符号右移，为负左补1
    					u8HignLSB = p_pACC->u8High & 0x01;
    					p_pACC->u32Low =  p_pACC->u32Low >> 1 | u8HignLSB << 31;
    					p_pACC->u8High = (DSPI8)p_pACC->u8High >> 1;//带符号右移，为负左补1

						////指数不用加1？2008.09.26,应该加上？
						//*p_pEXP ++;
		    			
    				}	

			}

//        	//只有指数为0时才会出现定点结果转换为浮点累加源操作数时会发生错误，下面可能用不到 21-11-07 16:45
//           else
//        	{
//        		while (*p_pEXP < cf32Src.GetExp() && i <= 31)
//        		{
//        			i++;
//        			u8HignLSB = p_pACC->u8High & 0x01;
//        			p_pACC->u32Low =  p_pACC->u32Low >> 1 | u8HignLSB << 31;
//       			p_pACC->u8High = (DSPI8)p_pACC->u8High >> 1;
//       			*p_pEXP ++;
//       		}
//        	}
        ////如果指数差小于等于1，截取25位值 
			if(iExp<=1)
			{
				p_pACC->u8High = 0;
				p_pACC->u32Low &=0x03ffffff;//截取26位 
			} 
			
			 DSPU32 u32AccFValue = ACCToF32_new(*p_pACC, &u32StatTemp, p_u32ALUCR, *p_pEXP, bolAccIsNaN);//0x007ffff

			 DSPU32 u32FinalResult = AddF32InAcc(u32AccFValue, p_u32Src, p_pStatReg, p_u32ALUCR,p_pACC,p_pEXP);//0
			 bool bolIsNAN = TestFlag(*p_pStatReg, ALU_Invalid);
			 //*p_pACC = U32ToAcc(u32FinalResult, p_pStatReg, p_u32ALUCR, p_pEXP, &bolIsNAN);
			 //p_pACC->u32Low = u32FinalResult;
		}                    
         
    }


  
     
   //(3)其它，最开始即原来的算法，amend 2008.09.25
   //当不是定点累加结果转为浮点输入时，按照正常浮点累加结果进行运算22-11-07 10:59
   //如果40位尾数不为0 ，按照指数不为0 情况处理 

   else	
    {
        //在分段赋值后出现 ，指数不为0，尾数不符合格式时尾数为0 
        //2008-09-16 正确的数据格式：指数有值，符号位全为0(正数.负数先对40位数求补)，位[23]位数为1；
        //2008-09-16 其它格式被作为非法格式，全按0数处理，LXM。
    	 //(2)指数不为0
    	 if(*p_pEXP != 0)
         {		
    			DSPU32 u32StatTemp = 0;//add 2008.09.25
    			///C:非数直接返回
    		    //2008.10.06 与LXM约定，在做浮点累加时，只要指数为ff，直接返回非数值
				bool bolAccIsNaN = *p_pEXP == 0xff; 
    			if (bolAccIsNaN)
    			{
    				SetFlag(*p_pStatReg, ALU_Invalid);         
    				SetFlag(*p_pStatReg, ALU_AIS);

					*p_pEXP = 0xff;
					p_pACC->u32Low = 0xffffffff;
					p_pACC->u8High = 0xff; 	

    				return;
    			}
    			DSPU32 AccIsNeg = p_pACC->u8High;
    			AccIsNeg = AccIsNeg&0x80;
    			///A:[39] = 0 ,mag[39:23] !=17'h00001，当浮点0处理
				///A:[39] = 0 ,mag[39:31] !=9'h00001，当浮点0处理
    			if(AccIsNeg == 0)
    			{
    
    				u32TempFrac = (p_pACC->u8High<<1)|(p_pACC->u32Low >>31); 
    				////其它非法格式：高17位不为0x1，结果为0 
    				
					if(u32TempFrac != 0x1)
    				{    
    					*p_pEXP = 0;
    					p_pACC->u8High = 0; 
    					p_pACC->u32Low = 0;              
    				}
					
	    			}    
				
              ///B:mag[39]==1'b1（负数）的情况下，对mag[39:0]求补，
              ///即neg_mag[39:0]= - mag[39:0],如果neg_mag[39:23] !=17'h00001，当浮点0处理。
				
              ///B:mag[39]==1'b1（负数）的情况下，对mag[39:0]求补，
              ///即neg_mag[39:0]= - mag[39:0],如果neg_mag[39:31] !=9'h00001，当浮点0处理。 

    			if(AccIsNeg == 0x80)
    			{    
    				if(p_pACC->u32Low == 0)
    				{              
    					u32HaccLow = ~p_pACC->u32Low +1;///尾数只有在全f情况下才会出现加1后溢出； 
    					u8HaccHigh = ~p_pACC->u8High +1;					
    				}
    				else
    				{
    					u32HaccLow = ~p_pACC->u32Low +1;
    					u8HaccHigh = ~p_pACC->u8High ; //带符号求反 ，但是P_pACC的值没有变 ，只有 Hacc的值变了 					
    				}
    				
    
    				u32TempFrac = (u8HaccHigh<<1)|(u32HaccLow>>31);
    				////高17位不为0x1，结果为0 
    				
					if(u32TempFrac != 0x1)
    				{
    					*p_pEXP = 0;
    					p_pACC->u8High = 0; 
    					p_pACC->u32Low = 0;
    				}
					
					
    			}
    			 
    		
          }
         DSPU32 u32StatTemp = 0;  
         bool bolAccIsNaN = (*p_pEXP == 0xff) && (p_pACC->u32Low == 0xffffffff) && (p_pACC->u8High == 0xff);
         
		 DSPU32 u32AccFValue = ACCToF32_new(*p_pACC, &u32StatTemp, p_u32ALUCR, *p_pEXP, bolAccIsNaN);
		 DSPU32 u32FinalResult = AddF32InAcc_new(u32AccFValue, p_u32Src, p_pStatReg, p_u32ALUCR,p_pACC,p_pEXP);//0
		 //DSPU32 u32FinalResult = AddF32(p_u32Src, u32AccFValue, p_pStatReg, p_u32ALUCR);
         bool bolIsNAN = TestFlag(*p_pStatReg, ALU_Invalid);
        // *p_pACC = U32ToAcc(u32FinalResult, p_pStatReg, p_u32ALUCR, p_pEXP, &bolIsNAN); 


    }
}
/******************************************************************
	函数名：		ACCSubF32

	描述:			32位浮点累减。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{

     //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
     SetFlag(p_u32ALUCR,ALU_Ctl_Saturation);
     
//     DSPU32 u32StatTemp = 0;  
//     bool bolAccIsNaN = (*p_pEXP == 0xff) && (p_pACC->u32Low == 0xffffffff) && (p_pACC->u8High == 0xff);
//     DSPU32 u32AccFValue = ACCToF32(*p_pACC, &u32StatTemp, p_u32ALUCR, *p_pEXP, bolAccIsNaN);
//     DSPU32 u32FinalResult = SubF32(u32AccFValue,p_u32Src, p_pStatReg, p_u32ALUCR);
//     bool bolIsNAN = TestFlag(*p_pStatReg, ALU_Invalid);
//     *p_pACC = U32ToAcc(u32FinalResult, p_pStatReg, p_u32ALUCR, p_pEXP, &bolIsNAN);


 ACCAddF32(p_u32Src ^ 0x80000000, p_pACC, p_pEXP, p_pStatReg, p_u32ALUCR);
     
}

/******************************************************************
	函数名：		AddD16CJ

	描述:			实现16位定点复数运算：(a + bi) + j(c + di) = (a - d) + (b + c)j

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16CJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Sub16(u16UpperSrc1, u16LowerSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Add16(u16LowerSrc1, u16UpperSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 
}

/******************************************************************
	函数名：		SubD16CJ

	描述:			实现16位定点复数运算：(a + bi) - j(c + di) = (a + d) + (b - c)j

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16CJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Add16(u16UpperSrc1, u16LowerSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Sub16(u16LowerSrc1, u16UpperSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 
}

/******************************************************************
	函数名:		AddD16HalfCJ

	描述:			实现16位定点复数运算:[(a + bi) + j(c + di)] / 2

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值:		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddD16HalfCJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Sub16Half(u16UpperSrc1, u16LowerSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Add16Half(u16LowerSrc1, u16UpperSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 
}

/******************************************************************
	函数名：		SubD16HalfCJ

	描述:			实现16位定点复数运算：[(a + bi) - j(c + di)] / 2

	参数:			p_u32Src1 -- 源操作数1，包含高低两个16位定点数据(a + bi)，低16位存放虚部。
					p_u32Src2 -- 源操作数2，包含高低两个16位定点数据(c + di)，低16位存放虚部。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					本操作包括两个16位操作，标志寄存器设置为两次结果的相或。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubD16HalfCJ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Add16Half(u16UpperSrc1, u16LowerSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Sub16Half(u16LowerSrc1, u16UpperSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 
}

/******************************************************************
	函数名：		BIsHT32

	描述:			源操作数p_u32Src1是否大于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位定点数据。
					p_u32Src2 -- 源操作数2，32位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHT32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u32ALUCR)
{
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    DSPI32 i32Src1 = p_u32Src1;
    DSPI32 i32Src2 = p_u32Src2;
    
    if (bolSigned)
    {
        return i32Src1 > i32Src2;
    }
    else
    {
        return p_u32Src1 > p_u32Src2;
    }
}

/******************************************************************
	函数名：		BIsHE32

	描述:			源操作数p_u32Src1是否大于等于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位定点数据。
					p_u32Src2 -- 源操作数2，32位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于等于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHE32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u32ALUCR)
{
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    DSPI32 i32Src1 = p_u32Src1;
    DSPI32 i32Src2 = p_u32Src2;
    
    if (bolSigned)
    {
        return i32Src1 >= i32Src2;
    }
    else
    {
        return p_u32Src1 >= p_u32Src2;
    }
}

/******************************************************************
	函数名：		BIsHT16

	描述:			源操作数p_u16Src1是否大于源操作数p_u16Src2?

	参数:			p_u16Src1 -- 源操作数1，16位定点数据。
					p_u16Src2 -- 源操作数2，16位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u16Src1大于源操作数p_u16Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHT16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 p_u32ALUCR)   
{
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    DSPI16 i16Src1 = p_u16Src1;
    DSPI16 i16Src2 = p_u16Src2;
    
    if (bolSigned)
    {
        return i16Src1 > i16Src2;
    }
    else
    {
        return p_u16Src1 > p_u16Src2;
    }
}

/******************************************************************
	函数名：		BIsHE16

	描述:			源操作数p_u16Src1是否大于等于源操作数p_u16Src2?

	参数:			p_u16Src1 -- 源操作数1，16位定点数据。
					p_u16Src2 -- 源操作数2，16位定点数据。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u16Src1大于等于源操作数p_u16Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHE16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 p_u32ALUCR)
{
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    DSPI16 i16Src1 = p_u16Src1;
    DSPI16 i16Src2 = p_u16Src2;
    
    if (bolSigned)
    {
        return i16Src1 >= i16Src2;
    }
    else
    {
        return p_u16Src1 >= p_u16Src2;
    }
}

/******************************************************************
	函数名：		BIsHTF32

	描述:			源操作数p_u32Src1是否大于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHTF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    
    //17-10-07 15:18  修改,认为正0比负0要大  负0比正0要小 
    if (cf32Src1.GetU32() == 0x0 && cf32Src2.GetU32() == 0x80000000)
    {
        return true;
    }     
    
    //与compare指令不同 标志寄存器只AI,AIS置位 
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return false;
    } 

    if ((cf32Src1.GetF32() > cf32Src2.GetF32()) )    
    {
        return true;
    }
    else
    {
        return false;
    }
}  

/******************************************************************
	函数名：		BIsHEF32

	描述:			源操作数p_u32Src1是否大于等于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1大于等于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsHEF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    
    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        if (cf32Src1.GetU32() == 0x80000000 && cf32Src2.GetU32() == 0)
        {
          return false;
        }
        else
        {
            return true;
        }
    }         
    
    //与compare指令不同 标志寄存器只AI,AIS置位 
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return false;
    } 

    if ((cf32Src1.GetF32() >= cf32Src2.GetF32()) )    
    {
        return true;
    }
    else
    {
        return false;
    }
}  
 
/******************************************************************
	函数名：		BIsHTF32

	描述:			源操作数p_u32Src1是否等于源操作数p_u32Src2?

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		若源操作数p_u32Src1等于源操作数p_u32Src2，返回true，
					否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsEQF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    } 
    
    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 两者也不相等. 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        if (cf32Src1.GetU32() == cf32Src2.GetU32())
        {
            return true;
        }
        else
        {
            return false;
        }
    }      

    //与compare指令不同 标志寄存器只AI,AIS置位 
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return false;
    } 

    if ((cf32Src1.GetF32() == cf32Src2.GetF32()) )    
    {
        return true;
    }
    else
    {
        return false;
    }
}  

/******************************************************************
	函数名：		ACCAdd32

	描述:			32位定点累加。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAdd32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //累加运算不再改变动态标志位 ??
    //累加修改为受饱和控制，2008.8.16  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
    DSPU40 Src1(p_u32Src);
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolstau =  TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);//饱和位 
    if (bolSigned)
    {
        Src1.SignExtend();
    }
    DSPU40 Src2(*p_pACC);
    DSPU40 u40Result;
    u40Result = Src1 + Src2;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u40Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u40Result.Sign();                        
    
    //A：不饱和处理有标志位,2008.11.3 
    if (!bolstau)
    {
       *p_pACC = u40Result.GetDSPBIT(); 
    
    }
    
    //B：饱和 
    if (bolstau)
    {
         //定点溢出标志 
    
        if (bolOverflow || bolUnderflow)
        {
            if (bolSigned)
            {
            	SetFlag(*p_pStatReg, ALU_OverFlow);
                SetFlag(*p_pStatReg, ALU_AOS);
				SetFlag(*p_pStatReg, 6);
				SetFlag(*p_pStatReg, 14);
            }
        }   
        
        bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u40Result.Sign()) 
                            || (Src1.Sign() && Src2.Sign());        
        if (bolCarryFlag)
        {
            if (!bolSigned)
            {
                SetFlag(*p_pStatReg, ALU_OverFlow);
                SetFlag(*p_pStatReg, ALU_AOS);
				SetFlag(*p_pStatReg, 6);
				SetFlag(*p_pStatReg, 14);
            }
			//SetFlag(*p_pStatReg, 16);
        }
        
        bool bolUnsignedOverflow = bolCarryFlag; 
        
        
        if (bolSigned)
        { 
            if (bolOverflow)
            {
                u40Result.SetToMAX_SN_40();
            }
            if (bolUnderflow)
            {
                u40Result.SetToMIN_SN_40();
            }   
        } 
        else         
            {
                if (bolUnsignedOverflow)
                {                    
                     u40Result.SetToMAX_UN_40();   
                }   
            }
    }
    
    *p_pACC = u40Result.GetDSPBIT();    

  
}
/******************************************************************
	函数名：		ACCSub32

	描述:			32位定点累减。每一个ALU都配备一个累加结果寄存器，
					累加结果寄存器字长为40位，也可以分为两个20位寄存
					器以适应短字操作。

	参数:			p_u32Src -- 源操作数。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSub32(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //累加运算改变动态标志位 ???保留意见---zxz 26-10-07 10:41
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
    DSPU40 Src1(p_u32Src);
    ///是否做有无符号运算 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolstau =  TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);//饱和位 
    if (bolSigned)
    {
        Src1.SignExtend();
    }    
    DSPU40 Src2(*p_pACC);
    DSPU40 u40Result;
        
    //Src1.OverturnAll();//取反 
    Src1.u8High = ~Src1.u8High;
    Src1.u32Low = ~Src1.u32Low;
       
    u40Result = Src2 + Src1 + 1;
    
    //SCR1 负数 scr2负数  结果正 上溢出 
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u40Result.Sign();
    //SCR1 正数 scr2正数  结果负 下溢出 
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u40Result.Sign();                        
    
    //A：不饱和处理没有标志位 
    if (!bolstau)
    {        
        //*p_pStatReg = 0; //deleted by flyu on 20140115
        *p_pACC = u40Result.GetDSPBIT();     
    }
    
    //B：饱和 
    if (bolstau)
    {
         //定点溢出标志 
        if (bolOverflow || bolUnderflow)
        {
            //有符号 ，设标志位 
            if (bolSigned)
            {
            	SetFlag(*p_pStatReg, ALU_OverFlow); 
                SetFlag(*p_pStatReg, ALU_AOS);
				SetFlag(*p_pStatReg, 6);
				SetFlag(*p_pStatReg, 14);
            }
        } 
       
        //两数符号不同，结果为正 或两数为负 ，截位输出 
        bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u40Result.Sign()) 
                            || (Src1.Sign() && Src2.Sign());        
        //无符号无截位，上溢出 
        if (!bolCarryFlag)
        {
            //A: 截位，不够减 饱和情况下才有标志位
            //不饱和处理没有标志位 
            //if ((!bolSigned)&&(bolstau))
            if (!bolSigned)
            {
            	SetFlag(*p_pStatReg, ALU_OverFlow); 
                SetFlag(*p_pStatReg, ALU_AOS); 
				SetFlag(*p_pStatReg, 6);
				SetFlag(*p_pStatReg, 14);
            }        
        }
         
        bool bolUnsignedOverflow = !bolCarryFlag; 
    
        if (bolSigned)
        { 
            if (TestFlag(*p_pStatReg, ALU_OverFlow))
            {
                DSPU40 MIN_SN_40 (0x80, 0x0);           
                if ( bolOverflow 
                     || (!Src2.Sign() && (Src1 == MIN_SN_40)))
                {
                    u40Result.SetToMAX_SN_40();
                }
                else if (bolUnderflow)//下溢出，出现在 
                    {
                        u40Result.u32Low = 0;
                        u40Result.u8High = 0x80;//累减出现下溢出受饱和控制应该返回 负的最大有效值0x800000000baohua 13-11-07 14:48 
                    }   
            } 
        }
        
        ////不够减在无符号情况下，饱和处理时就是设置为0
        else         
        {
            if (bolUnsignedOverflow)
            {                    
                u40Result.u32Low = 0;
                u40Result.u8High = 0; 
            }   
        }
    
    
    *p_pACC = u40Result.GetDSPBIT();
    }
        
    //*p_pACC = u40Result.GetDSPBIT();    
}


/******************************************************************
	函数名：		ACCTo32

	描述:			累加结果寄存器ACC截位输出为32位定点数据。

	参数:			p_u40ACC -- 40位累加结果。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。
					p_intCutPos -- 截位信息。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					此函数中截位信息来自p_intCutPos而不是p_u32ALUCR。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCTo32(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)

//extern DSPU32 ACCTo32(DSP_BIT40 p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);    
    DSPU8 u8ACCHigh = p_u40ACC.u8High;
    DSPU32 u32ACCLow  = p_u40ACC.u32Low; 
    
    DSPI8 i8ACCHigh = (DSPI8 &)u8ACCHigh;
    DSPI32  i32ACCLow = (DSPI32 &)u32ACCLow;
    
    DSPU32 u32Result = 0;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolSatu   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    
    bool u40Sign = (u8ACCHigh & 0x80)  != 0;
    bool bolSignOverFlow = false;
    bool bolUnsignOverFlow = false;
    bool bolResultSign;
    
   
    ////模拟lxm 
    switch(p_intCutPos)
    {
                       
        case  0: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = p_u40ACC.u32Low; 
                if  (p_u40ACC.u8High == 0)
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if(p_u40ACC.u8High == 0)
                {
                    u32Result = p_u40ACC.u32Low; 
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = p_u40ACC.u32Low ;
                
                ///溢出标志设置 
                if  ((p_u40ACC.u8High == 0)&&((p_u40ACC.u32Low >>31) == 0)
                    || (p_u40ACC.u8High == 0xff)&&((p_u40ACC.u32Low >>31) == 1))
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  ((p_u40ACC.u8High == 0)&&((p_u40ACC.u32Low >>31) == 0)
                    || (p_u40ACC.u8High == 0xff)&&((p_u40ACC.u32Low >>31) == 1))
                    {
                       u32Result = p_u40ACC.u32Low ;
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break; 
        
        case  1: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<7<<24)|p_u40ACC.u32Low>>1); //32:1
                
                if  ((p_u40ACC.u8High>>1) == 0)
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>1)== 0)//7"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<7<<24)|p_u40ACC.u32Low>>1); //32:1
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<7<<24)|p_u40ACC.u32Low>>1); //32:1
                
                ///溢出标志设置 
                if  ((p_u40ACC.u8High == 0)||(p_u40ACC.u8High == 0xff))
                  
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  ((p_u40ACC.u8High == 0)
                    || (p_u40ACC.u8High == 0xff))
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<7<<24)|p_u40ACC.u32Low>>1); //32:1
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
     break;
    
    
     case  2: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<6<<24)|p_u40ACC.u32Low>>2); //33:2
                
                if  ((p_u40ACC.u8High>>2) == 0)//6"b0
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>2)== 0)//6"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<6<<24)|p_u40ACC.u32Low>>2); //33:2
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<6<<24)|p_u40ACC.u32Low>>2); //33:2
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>1) == 0)
                    || ((p_u40ACC.u8High>>1) == 0x7f))//39:33 7'b0||7'b1
                  
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>1) == 0)
                    || ((p_u40ACC.u8High>>1) == 0x7f))//39:33 7'b0||7'b1
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<6<<24)|p_u40ACC.u32Low>>2); //33:2
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break;
        
       case  3: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<5<<24)|p_u40ACC.u32Low>>3); //34:3
                
                if  ((p_u40ACC.u8High>>3) == 0)//5"b0
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>3)== 0)//5"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<5<<24)|p_u40ACC.u32Low>>3); //34:3
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<5<<24)|p_u40ACC.u32Low>>3); //34:3
                
               if  (((p_u40ACC.u8High>>2) == 0)
                    || ((p_u40ACC.u8High>>2) == 0x3f))//39:34 6'b0||6'b1
                  
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>2) == 0)
                    || ((p_u40ACC.u8High>>2) == 0x3f))//39:34 6'b0||6'b1
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<5<<24)|p_u40ACC.u32Low>>3); //34:3
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break; 
        
        case  4: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<4<<24)|p_u40ACC.u32Low>>4); //35:4
                
                if  ((p_u40ACC.u8High>>4) == 0)//4"b0
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>4)== 0)//4"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<4<<24)|p_u40ACC.u32Low>>4); //35:4
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<4<<24)|p_u40ACC.u32Low>>4); //35:4
                
                  ///溢出标志设置 
                if  (((p_u40ACC.u8High>>3) == 0)
                    || ((p_u40ACC.u8High>>3) == 0x1f))//5"b0  //多一位 
                  
                {
                   bolSignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>3) == 0)
                    || ((p_u40ACC.u8High>>3) == 0x1f))//39:35 5'b0||5'b1
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<4<<24)|p_u40ACC.u32Low>>4); //35:4
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break;
        
        case  5: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<3<<24)|p_u40ACC.u32Low>>5); //36:5
                
                if  ((p_u40ACC.u8High>>5) == 0)//3"b0
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>5)== 0)//3"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<3<<24)|p_u40ACC.u32Low>>5); //36:5
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<3<<24)|p_u40ACC.u32Low>>5); //36:5
                
                ///溢出标志设置 
                if  (((p_u40ACC.u8High>>4) == 0)
                    || ((p_u40ACC.u8High>>4) == 0xf))//39:36 4'b0||4'b1//多一位 
                  
                {
                   bolSignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>4) == 0)
                    || ((p_u40ACC.u8High>>4) == 0xf))//39:36 4'b0||4'b1
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<3<<24)|p_u40ACC.u32Low>>5); //36:5
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break;
        
        case  6: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<2<<24)|p_u40ACC.u32Low>>6); //37:6
                
                if  ((p_u40ACC.u8High>>6) == 0)//2"b0
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>6)== 0)//2"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<2<<24)|p_u40ACC.u32Low>>6); //37:6
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<2<<24)|p_u40ACC.u32Low>>6); //37:6
                
                ///溢出标志设置 
                if  (((p_u40ACC.u8High>>5) == 0)
                    || ((p_u40ACC.u8High>>5) == 0x7))//39:37 3'b0||3'b1//多一位 
                  
                {
                   bolSignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>5) == 0)
                    || ((p_u40ACC.u8High>>5) == 0x7))//39:37 3'b0||3'b1
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<2<<24)|p_u40ACC.u32Low>>6); //37:6
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break;
        
        case  7: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<1<<24)|p_u40ACC.u32Low>>7); //38:7
                
                if  ((p_u40ACC.u8High>>7) == 0)//1"b0
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = true;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u40ACC.u8High >>7)== 0)//1"b0
                {
                    u32Result = (DSPU32(p_u40ACC.u8High<<1<<24)|p_u40ACC.u32Low>>7); //38:7
                }
                ////溢出 
                else 
                {
                     u32Result = 0xffffffff ;
                     bolUnsignOverFlow = true;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u32Result = (DSPU32(p_u40ACC.u8High<<1<<24)|p_u40ACC.u32Low>>7); //38:7
                
                ///溢出标志设置 
                if  (((p_u40ACC.u8High>>6) == 0)
                    || ((p_u40ACC.u8High>>6) == 0x3))//39:38 2'b0||2'b1//多一位 
                  
                {
                   bolSignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                     
                   bolSignOverFlow = true;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u40ACC.u8High>>6) == 0)
                    || ((p_u40ACC.u8High>>6) == 0x3))//39:38 2'b0||2'b1
                    {
                       u32Result = (DSPU32(p_u40ACC.u8High<<1<<24)|p_u40ACC.u32Low>>7); //38:7
                       bolSignOverFlow = false;                 
                    }
                else if  ((p_u40ACC.u8High >> 7) == 0x0 )                
                {
                    u32Result = 0x7fffffff ;
                    bolSignOverFlow = true;
                }
                ////溢出 
                else 
                {
                     u32Result = 0x80000000;
                     bolSignOverFlow = true;
                } 
             
             }
              
        break;
        
        default:
                
             u32Result = (DSPU32(p_u40ACC.u8High<<24)|(p_u40ACC.u32Low>>8)); //39:8 
             bolSignOverFlow = false;
             bolUnsignOverFlow = false; 
                
        
        break;
    }
    
     //不饱和不设定标志位，饱和才会设定标志位 
	//if (bolSatu&&(bolSignOverFlow || bolUnsignOverFlow))
	//2008.10.29 依据LXM说明修改为不饱和也设定标志位    
    
	if (bolSignOverFlow || bolUnsignOverFlow)
    
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 6);
		SetFlag(*p_pStatReg, 14);
    }
    
         
    return u32Result;
}
//added by flyu on 20130926
DSPU16 ACCTo8(DSP_BIT20 p_u20ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);    
  
    DSPU8 u4ACCHigh =  0x0;
    DSPU16 u16ACCLow  = p_u20ACC.u16Low;     
    DSPI8   i4ACCHigh = 0x0;
    bool bolSignOverFlow = false;
    bool bolUnsignOverFlow = false;
    bool bolResultSign;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); //符号位 
    bool bolSatu   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation); //饱和位 
    DSPU16 u16Result = 0;
    
    if ((u16ACCLow & 0x200) != 0)
	{
		DSPU16 temp = u16ACCLow & 0x1ff;
		temp = temp | 0x8000;
		//i16ACCLow = temp;
	}
    //DSPI16  i16ACCLow = (DSPI16 &)u16ACCLow;
  
      
    
    //    模拟LXM0719  
    
    switch(p_intCutPos)
    {
                       
        case  0: 
			
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                if  ((u16Result & 0x300) == 0)
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                    
                     bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
				 u16Result = p_u20ACC.u16Low ;
                if  ((u16Result & 0x300) == 0)
                {
                    u16Result = p_u20ACC.u16Low ;
                }
                ////溢出 
                else 
                {
                     u16Result = 0xff ;
                     bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                
				if (  (((p_u20ACC.u16Low & 0x300) == 0x300) && ((p_u20ACC.u16Low & 0x80) == 0x80))
					||(((p_u20ACC.u16Low & 0x300) == 0x0) && ((p_u20ACC.u16Low & 0x80) == 0x0))
					)  //无溢出             
					///溢出标志设置
                {
                   bolSignOverFlow = 0;
                }
                ////溢出 
                else 
                {
                    
                     bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
             		if (  (((p_u20ACC.u16Low & 0x300) == 0x300) && ((p_u20ACC.u16Low & 0x80) == 0x80))
					||(((p_u20ACC.u16Low & 0x300) == 0x0) && ((p_u20ACC.u16Low & 0x80) == 0x0))
					)  //无溢出  
                    {
                       u16Result = p_u20ACC.u16Low ;
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u16Low & 0x200) == 0x0 )                
                {
                    u16Result = 0x7f ;
                    bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     u16Result = 0x80;
                     bolSignOverFlow = 1;
                } 
             
             }
              
        break; 
        
        case  0x1: 
                         //A:无符号 
             //A1:不饱和： 
			p_u20ACC.u16Low = p_u20ACC.u16Low >>1;
             if((!bolSigned) && (!bolSatu)) 
             { 
				
                u16Result = p_u20ACC.u16Low;
                if  ((u16Result & 0x100) == 0)
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                    
                     bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
			    u16Result = p_u20ACC.u16Low;
                if  ((u16Result & 0x100) == 0)
                {
                    u16Result = p_u20ACC.u16Low ;
                }
                ////溢出 
                else 
                {
                     u16Result = 0xff ;
                     bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                
				if (  (((p_u20ACC.u16Low & 0x100) == 0x100) && ((p_u20ACC.u16Low & 0x80) == 0x80))
					||(((p_u20ACC.u16Low & 0x100) == 0x0) && ((p_u20ACC.u16Low & 0x80) == 0x0))
					)  //无溢出             
					///溢出标志设置
                {
                   bolSignOverFlow = 0;
                }
                ////溢出 
                else 
                {
                    
                     bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
             		if (  (((p_u20ACC.u16Low & 0x100) == 0x100) && ((p_u20ACC.u16Low & 0x80) == 0x80))
					||(((p_u20ACC.u16Low & 0x100) == 0x0) && ((p_u20ACC.u16Low & 0x80) == 0x0))
					)  //无溢出  
                    {
                       u16Result = p_u20ACC.u16Low ;
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u16Low & 0x100) == 0x0 )                
                {
                    u16Result = 0x7f ;
                    bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     u16Result = 0x80;
                     bolSignOverFlow = 1;
                } 
             
             }
              
          break; 
        
          default: 
                                      //A:无符号 
             //A1:不饱和：
			 p_u20ACC.u16Low = p_u20ACC.u16Low >>2;
             if((!bolSigned) && (!bolSatu)) 
             { 
				
                u16Result = p_u20ACC.u16Low;
                if  ((u16Result & 0x300) == 0)
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                    
                     //bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
				 u16Result = p_u20ACC.u16Low;
                if  ((u16Result & 0x300) == 0)
                {
                    u16Result = p_u20ACC.u16Low ;
                }
                ////溢出 
                else 
                {
                     //u16Result = 0xff ;
                     //bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                
				if (  (((p_u20ACC.u16Low & 0x300) == 0x300) && ((p_u20ACC.u16Low & 0x80) == 0x80))
					||(((p_u20ACC.u16Low & 0x300) == 0x0) && ((p_u20ACC.u16Low & 0x80) == 0x0))
					)  //无溢出             
					///溢出标志设置
                {
                   bolSignOverFlow = 0;
                }
                ////溢出 
                else 
                {
                    
                     //bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                 ///溢出标志设置 
             		if (  (((p_u20ACC.u16Low & 0x300) == 0x300) && ((p_u20ACC.u16Low & 0x80) == 0x80))
					||(((p_u20ACC.u16Low & 0x300) == 0x0) && ((p_u20ACC.u16Low & 0x80) == 0x0))
					)  //无溢出  
                    {
                       u16Result = p_u20ACC.u16Low ;
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u16Low & 0x200) == 0x0 )                
                {
                    //u16Result = 0x7f ;
                    //bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     //u16Result = 0x80;
                     //bolSignOverFlow = 1;
                } 
             
             }
              
      break; 
        

                       
    }  
    //不饱和不设定标志位，饱和才会设定标志位 
	//if (bolSatu&&(bolSignOverFlow || bolUnsignOverFlow))
	//2008.10.29 依据LXM说明修改为不饱和也设定标志位    
    
	if (bolSignOverFlow || bolUnsignOverFlow)
    
    {
       
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 4); 
        SetFlag(*p_pStatReg, 12);
    }                                        
       
   return u16Result;      
}
DSPU16 ACCTo16(DSP_BIT20 p_u20ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);    
  
    DSPU8 u4ACCHigh = p_u20ACC.u4High;
    DSPU16 u16ACCLow  = p_u20ACC.u16Low;     
    DSPI8   i4ACCHigh;
    bool bolSignOverFlow = false;
    bool bolUnsignOverFlow = false;
    bool bolResultSign;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); //符号位 
    bool bolSatu   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation); //饱和位 
    DSPU16 u16Result = 0;
    
    if ((u4ACCHigh & 0x8) == 0)
    {
        i4ACCHigh = u4ACCHigh;
    }
    else
    {
        i4ACCHigh = u4ACCHigh | 0xf0;
    }        
    DSPI16  i16ACCLow = (DSPI16 &)u16ACCLow;
  
      
    
    //    模拟LXM0719  
    
    switch(p_intCutPos)
    {
                       
        case  0: 
			
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                if  (p_u20ACC.u4High == 0)
                {
                   bolUnsignOverFlow = false; 
                }
                ////溢出 
                else 
                {
                    
                     bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  (p_u20ACC.u4High == 0)
                {
                    u16Result = p_u20ACC.u16Low ;
                }
                ////溢出 
                else 
                {
                     u16Result = 0xffff ;
                     bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = p_u20ACC.u16Low ;
                
                ///溢出标志设置 
                if  (((p_u20ACC.u4High == 0)&&((p_u20ACC.u16Low >>15) == 0))
                    || ((p_u20ACC.u4High == 0xf)&&((p_u20ACC.u16Low >>15) == 1)))
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                    
                     bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u20ACC.u4High == 0)&&((p_u20ACC.u16Low >>15) == 0))
                    || ((p_u20ACC.u4High == 0xf)&&((p_u20ACC.u16Low >>15) == 1)))
                    {
                       u16Result = p_u20ACC.u16Low ;
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u4High >> 3) == 0x0 )                
                {
                    u16Result = 0x7fff ;
                    bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     u16Result = 0x8000;
                     bolSignOverFlow = 1;
                } 
             
             }
              
        break; 
        
        case  0x1: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                
                u16Result = (p_u20ACC.u4High << 3 << 12) | (p_u20ACC.u16Low >> 1);
                
                if  ((p_u20ACC.u4High>>1) == 0)
                {
                   bolUnsignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u20ACC.u4High>>1) == 0)
                {
                    u16Result = (p_u20ACC.u4High << 3 << 12) | (p_u20ACC.u16Low >> 1);
                }
                ////溢出 
                else 
                {
                     u16Result = 0xffff ;
                     bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = (p_u20ACC.u4High << 3 << 12) | (p_u20ACC.u16Low >> 1);
                
                ///溢出标志设置 
                if  ((p_u20ACC.u4High == 0)|| (p_u20ACC.u4High == 0xf))
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  ((p_u20ACC.u4High == 0) || (p_u20ACC.u4High == 0xf))
                    {
                       u16Result = (p_u20ACC.u4High << 3 << 12) | (p_u20ACC.u16Low >> 1);
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u4High >> 3) == 0x0 )                
                {
                    u16Result = 0x7fff ;
                    bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     u16Result = 0x8000;
                     bolSignOverFlow = 1;
                } 
             
             }
              
          break; 
        
          case  0x2: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u16Result = (p_u20ACC.u4High << 2 << 12) | (p_u20ACC.u16Low >> 2);
                if  ((p_u20ACC.u4High>>2) == 0)
                {
                   bolUnsignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u20ACC.u4High>>2) == 0)
                {
                    u16Result = (p_u20ACC.u4High << 2 << 12) | (p_u20ACC.u16Low >> 2);
                    bolUnsignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     u16Result = 0xffff ;
                     bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = (p_u20ACC.u4High << 2 << 12) | (p_u20ACC.u16Low >> 2);
                
                ///溢出标志设置 
                if  (((p_u20ACC.u4High >>1) == 0)|| ((p_u20ACC.u4High >>1)== 0x7))
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u20ACC.u4High >>1) == 0)|| ((p_u20ACC.u4High >>1)== 0x7))
                    {
                      u16Result = (p_u20ACC.u4High << 2 << 12) | (p_u20ACC.u16Low >> 2);
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u4High >> 3) == 0x0 )                
                {
                    u16Result = 0x7fff ;
                    bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     u16Result = 0x8000;
                     bolSignOverFlow = 1;
                } 
             
              }
              
      break; 
        
      case  0x3: 
             //A:无符号 
             //A1:不饱和： 
             if((!bolSigned) && (!bolSatu)) 
             { 
                u16Result = (p_u20ACC.u4High << 1 << 12) | (p_u20ACC.u16Low >> 3);
                if  ((p_u20ACC.u4High>>3) == 0)
                {
                   bolUnsignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolUnsignOverFlow = 1;
                } 
             
             }
             //A:无符号 
             //A2:饱和： 
             if((!bolSigned) && (bolSatu)) 
             { 
                if  ((p_u20ACC.u4High>>3) == 0)
                {
                    u16Result = (p_u20ACC.u4High << 1 << 12) | (p_u20ACC.u16Low >> 3);
                    bolUnsignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     u16Result = 0xffff ;
                     bolUnsignOverFlow = 1;
                } 
             }
                
             //B:有符号 
             //B1:不饱和： 
             if((bolSigned) && (!bolSatu)) 
             { 
                u16Result = (p_u20ACC.u4High << 1 << 12) | (p_u20ACC.u16Low >> 3);
                
                ///溢出标志设置 
                if  (((p_u20ACC.u4High >>2) == 0)|| ((p_u20ACC.u4High >>2)== 3))
                {
                   bolSignOverFlow = 0; 
                }
                ////溢出 
                else 
                {
                     
                     bolSignOverFlow = 1;
                } 
             
             }
             //B:有符号 
             //B2:饱和： 
             if((bolSigned) && (bolSatu)) 
             { 
                
                 ///溢出标志设置 
                if  (((p_u20ACC.u4High >>2) == 0)|| ((p_u20ACC.u4High >>2)== 3))
                    {
                      u16Result = (p_u20ACC.u4High << 1 << 12) | (p_u20ACC.u16Low >> 3);
                       bolUnsignOverFlow = 0;                 
                    }
                else if  ((p_u20ACC.u4High >> 3) == 0x0 )                
                {
                    u16Result = 0x7fff ;
                    bolSignOverFlow = 1;
                }
                ////溢出 
                else 
                {
                     u16Result = 0x8000;
                     bolSignOverFlow = 1;
                } 
             
             }
              
        break;
        
        ///cutnum>=4 
        default:  
                u16Result = (p_u20ACC.u4High << 12) | (p_u20ACC.u16Low >> 4);
                bolSignOverFlow = false; 
                bolUnsignOverFlow = false; 
                 
        break;
                       
    }  
    //不饱和不设定标志位，饱和才会设定标志位 
	//if (bolSatu&&(bolSignOverFlow || bolUnsignOverFlow))
	//2008.10.29 依据LXM说明修改为不饱和也设定标志位    
    
	if (bolSignOverFlow || bolUnsignOverFlow)
    
    {
       
        SetFlag(*p_pStatReg, ALU_OverFlow); 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13);
    }                                        
       
   return u16Result;      
}

/******************************************************************
	函数名：		ACCToD16

	描述:			累加结果寄存器ACC截位输出为高低16位定点数据。

	参数:			p_u40ACC -- 40位累加结果。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。
					p_intCutPos -- 截位信息。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；
					此函数中截位信息来自p_intCutPos而不是p_u32ALUCR。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToD16(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)

//extern DSPU32 ACCToD16(DSP_BIT40 p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)    
{
    DSPU32 u32ACCHign = (DSPU32)p_u40ACC.u8High << 12 | p_u40ACC.u32Low >> 20;   //左边8位加上后边12个0共20位,右边32位右移20位剩高12位补左边的12位空 
    DSPU32 u32ACCLow  = p_u40ACC.u32Low & 0x000fffff; //低20位 
    
    DSPU20 uACCHign(u32ACCHign); 
    DSPU20 uACCLow (u32ACCLow);

    DSP_BIT20 u20ACCHign = uACCHign.GetDSPBIT();
    DSP_BIT20 u20ACCLow  = uACCLow.GetDSPBIT();
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = ACCTo16(u20ACCHign, &UpperReg, p_u32ALUCR, p_intCutPos);
    DSPU16 u16LowerResult = ACCTo16(u20ACCLow,  &LowerReg, p_u32ALUCR, p_intCutPos); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
    
    return  u32Result;      
    
}



/******************************************************************
	函数名：		ACCToF32

	描述:			累加结果寄存器ACC截位输出为32位浮点数据。

	参数:			p_u40ACC -- 40位累加结果。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置相关标志位。

	修改记录 
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToF32(const DSP_BIT40 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 u8Exp, bool bolIsNAN)
{
    //考虑不改变标志位  ,(结论:还是改变,把该指令当成一条运算指令) 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
    //按照硬件要求，当指数为0时，数不能被清0  
   /* if (u8Exp == 0)
    {
        if(TestBit(p_u40ACC.u8High, 7))
        {
            return 0x80000000; //返回-0;
        }
        else
        {
            return 0; //返回+0;
        } 
    }
    */
    //2008.10.31 addd
	DSPU32 u32TempFrac = 0;
	DSPU32 AccIsNeg = 0;
    DSPU32 u32HaccLow = 0;
	DSPU8 u8HaccHigh = 0;

    DSPU32 u32Frac;
    //实际尾数共25位,23位数位,1位隐藏位,1位符号位,其它为符号位扩展 
    bool bolFracSign = (p_u40ACC.u8High & 0x80) != 0;
    if (bolFracSign)
    {
        u32Frac = ~(p_u40ACC.u32Low) + 1;  
    }
    else
    {
        u32Frac = p_u40ACC.u32Low;
    }
    //输入是个无效数 
    //if((p_u40ACC.u32Low==0xffffffff)&&(p_u40ACC.u8Exp==0xff)&&(p_u40ACC.u8High==0xff)) 
	////修改 用u8Exp，而不用p_u40ACC.u8Exp
	if((p_u40ACC.u32Low==0xffffffff)&&(u8Exp==0xff)&&(p_u40ACC.u8High==0xff))
     {
          SetFlag(*p_pStatReg, ALU_Invalid);         
          SetFlag(*p_pStatReg, ALU_AIS);
     }

	//2008.10.31.增加非数,做非数处理。非数：只要指数是全f，就是非数，标志设置
	//48位数..	中只要指数是全f
	//非规格化数，指数全f
    //A：
	if(u8Exp==0xff)
	{ 
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
	
	}

	//B：非规格化数
	if(u8Exp==0)
	{ 		
        return 0;
	
	}

	//C：不满足格式的数：指数不等于0 ，尾数的第bit[23-0]与符号位不同的
	if(u8Exp!=0)
	
	{
		
                
		AccIsNeg = p_u40ACC.u8High;
		AccIsNeg = AccIsNeg&0x80;

		//C1：正数,高16位是符号位，要么全0，要么全1
        //高16位为0，[23] = 0，不符合格式
		///A:[39] = 0 ,mag[39:23] !=17'h00001，当浮点0处理
		if(AccIsNeg == 0)
		{

			//u32TempFrac = (p_u40ACC.u8High<<9)|(p_u40ACC.u32Low >>23); 
			u32TempFrac = (p_u40ACC.u8High<<9)|(p_u40ACC.u32Low >>31); 
			////其它非法格式：高17位不为0x1，结果为0 
			
			if(u32TempFrac != 0x1)
			{    
				return 0;              
			}  
			

		}
	  //C2：负数,高16位是符号位，要么全0，要么全1
	  //高16位为1，先求补，再判断，位[23] = 0，不符合格式
	  ///B:mag[39]==1'b1（负数）的情况下，对mag[39:0]求补，
	  ///即neg_mag[39:0]= - mag[39:0],如果neg_mag[39:23] !=17'h00001，当浮点0处理。              
		if(AccIsNeg == 0x80)
		{    
			if(p_u40ACC.u32Low == 0)
			{              
				u32HaccLow = ~p_u40ACC.u32Low +1;///尾数只有在全f情况下才会出现加1后溢出； 
				u8HaccHigh = ~p_u40ACC.u8High +1;					
			}

			else
			{
				u32HaccLow = ~p_u40ACC.u32Low +1;
				u8HaccHigh = ~p_u40ACC.u8High ; //带符号求反 ，但是P_pACC的值没有变 ，只有 Hacc的值变了 					
			}
			

			//u32TempFrac = (u8HaccHigh<<9)|(u32HaccLow>>23);
			u32TempFrac = (u8HaccHigh<<9)|(u32HaccLow>>31);
			////高17位不为0x1，结果为0 
			
			if(u32TempFrac != 0x1)
			{
				return 0;
			}
			
			
		}
	
	}
	

    if (bolIsNAN)
    {
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    } 
    //return (DSPU32)bolFracSign << 31 | (DSPU32)u8Exp << 23 | (u32Frac & 0x007fffff); //尾数保留23位是 0x007fffff  
	return (DSPU32)bolFracSign << 31 | (DSPU32)u8Exp << 23 | ((u32Frac >> 8) & 0x007fffff); //尾数保留23位是 0x007fffff  
}



/*
DSPU16  ALU_Neg16(DSPU16 p_u16Src, DSPU32 *p_pStatReg)
{
    //取得操作数位数 
    int OpBits = sizeof(p_u16Src) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU16 uDest;
    if (p_u16Src == 0x8000)
    {
        uDest = MAX_SN(OpBits);
        SetFlag(*p_pStatReg, ALU_OverFlow);
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13);
    }
    else
    {
        uDest = ~p_u16Src + 1;
    }
    
    //全0时ALU_Carry置1（因为0x0取00000000反加1时产生进位） 
    
    return uDest;
    
} 
*/
/******************************************************************
	函数名：		ConjCFix16

	描述:			求16位定点复数的共轭。

	参数:			p_u32Src -- 16位定点复数（低16位虚部，高16位实部）。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	
					p_bolNeg -- 在求共轭的基础上是否还要求负。			

	返回值：		16位定点复数（低16位虚部，高16位实部）。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
 DSPU32 alu_ConjCFix16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolNeg)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);     
    DSP_CFix16 p_CFix16Src;
    p_CFix16Src.u32Value = p_u32Src;
    
    DSPU32 u32StatRegReal = 0, u32StatRegImag = 0;       
    DSP_CFix16 cf16Result;

    if (p_bolNeg)
    {
        cf16Result.split.u16Real = ALU_Neg16(p_CFix16Src.split.u16Real,  &u32StatRegReal);
        cf16Result.split.u16Imag = p_CFix16Src.split.u16Imag;
    }
    else
    {
        cf16Result.split.u16Real = p_CFix16Src.split.u16Real;
        cf16Result.split.u16Imag = ALU_Neg16(p_CFix16Src.split.u16Imag,  &u32StatRegImag); 
    }  
    
    bool bolRealOverflow = TestBit(u32StatRegReal, ALU_OverFlow);
    bool bolImagOverflow = TestBit(u32StatRegImag, ALU_OverFlow);
    
    bool bolDestOverflow = bolRealOverflow || bolImagOverflow;  
    
    if (bolDestOverflow)
    {
        SetFlag(*p_pStatReg, ALU_OverFlow);                
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13);
    }    
    
    return cf16Result.u32Value;    
} 
*/
/******************************************************************
	函数名：		PermuteCFix16

	描述:			16位定点复数实部虚部互换。

	参数:			p_u32Src -- 16位定点复数（低16位虚部，高16位实部）。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	
					p_bolNeg -- 在实部虚部互换的基础上是否还要求负。			

	返回值：		16位定点复数（低16位虚部，高16位实部）。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
 DSPU32 alu_PermuteCFix16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolNeg)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);     
    DSP_CFix16 p_CFix16Src;
    p_CFix16Src.u32Value = p_u32Src;       
       
    DSPU32 u32StatRegReal = 0, u32StatRegImag = 0;       
    DSP_CFix16 cf16Result;
    
    if (p_bolNeg)
    {
        cf16Result.split.u16Real = ALU_Neg16(p_CFix16Src.split.u16Imag,  &u32StatRegReal);
        cf16Result.split.u16Imag = ALU_Neg16(p_CFix16Src.split.u16Real,  &u32StatRegImag); 
    }
    else
    {
        cf16Result.split.u16Real = p_CFix16Src.split.u16Imag;
        cf16Result.split.u16Imag = p_CFix16Src.split.u16Real; 
    }
    
    bool bolRealOverflow = TestBit(u32StatRegReal, ALU_OverFlow);
    bool bolImagOverflow = TestBit(u32StatRegImag, ALU_OverFlow);
    
    bool bolDestOverflow = bolRealOverflow || bolImagOverflow;  
    
    if (bolDestOverflow)
    {
        SetFlag(*p_pStatReg, ALU_AOS);
        SetFlag(*p_pStatReg, ALU_OverFlow);
		SetFlag(*p_pStatReg, 5); 
        SetFlag(*p_pStatReg, 13);
    }    
    
    return cf16Result.u32Value;    
}   
*/
/******************************************************************
	函数名：		CountOne32

	描述:			确定p_u32Src中从低到高的p_u32Len位数据中1的个数。

	参数:			p_u32Src -- 源操作数。
					p_u32Len -- 位串长度。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		1的个数。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 CountOne32(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0         
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
    
    //p_u32Len 低五位有效 
    p_u32Len = p_u32Len & 0x1f;
    
    DSPU32 u32Result = 0;
    
    for ( DSPU32 i = 0; i < p_u32Len + 1; i ++)
    {
        if (TestBit(p_u32Src, i))
        {
            u32Result ++;
        }
    }  
    
    return u32Result;
}
*/
 /*
DSPU16 CountOne16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
    
    //  p_u32Len低4位有效 
    p_u32Len = p_u32Len & 0xf;
    
    DSPU16 u16Result = 0;
    
    for ( DSPU32 i = 0; i < p_u32Len + 1; i ++)
    {
        if (TestBit(p_u32Src, i))
        {
            u16Result ++;
        }
    }  
    
    return u16Result;
}
*/
/******************************************************************
	函数名：		CountOneD16

	描述:			确定p_u32Src中高低16位从低到高的p_u32Len位数据中1的个数。

	参数:			p_u32Src -- 源操作数，包括高低16位数据。
					p_u32Len -- 位串长度。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值;		1的个数。低16位的统计结果放在结果的低16位中；高16位的统计结果
					放在结果的高16位中。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 CountOneD16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Len);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Len);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = CountOne16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = CountOne16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;   
}       
*/
/******************************************************************
	函数名：		Float32

	描述:			将32位定点数据转变为32位浮点数据。

	参数:			p_u32Src -- 32位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		32位浮点结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
DSPU32 alu_Float32(DSPU32 p_u32Src, DSPU32 p_u32Adjust, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
  
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    
    
    // 正常情况  
    DSPU32 u32Src = (DSPU32)p_u32Src;
	DSPU8 ExpTemp = 0; 
	DSPU8 p_exp = 0;//指数位需要转换为有偏数，+127
	DSPU8 iCnt = 0;
	DSPU32 f32Dest = 0;
	DSPU32 p_frac = 0;
	DSPU32 i32ExpAdd = 0;
	DSPI32 i32ExpSum = 0;
    	
	bool u1Saturation = TestFlag(p_u32ALUCR ,ALU_Ctl_Saturation); //饱和控制位 
    bool SignTemp = u32Src>>31;//符号位
    
    
	if (SignTemp)//全部按照补码表示 
	{
		u32Src = ~u32Src+1;
	}
	
	
          
	for(int i = 31;i>-1;i--)//从第31位开始
	{
		//除符号位外最高位为0，接着右移测试
		//改为寻找最高位为1的数 ，0右移 
        if(!(u32Src>>i))
		{
			//从第31位到第1个为1的数的位数 
            ++ExpTemp; //指数加1
		}
       //1 stop 
	   else
	     {
			//最高位为1是第多少位计数 ，如31位：1 ，i=31，实际总位数应该是i+1 :32 
            i32ExpAdd = i; 			
            break;  //break 不能少 
		 }
		 
	}
	//最高位为1数的从左到右的位数，非之间的位数 
	iCnt = ExpTemp+1;
    
	///转换后的浮点指数 
	//p_u32Adjust是有符号数，bit[8]是符号位，2008.12.9
	//加
	if((p_u32Adjust&0x80)==0)
	{
		i32ExpSum = 0x7f + i32ExpAdd + (p_u32Adjust&0xff) ;
		
	}//指数和
	
   
	//减
	if((p_u32Adjust&0x80)==0x80)
	{
		i32ExpSum = 0x7f + i32ExpAdd -((~p_u32Adjust+1)&0xff);//测试2009.11.19 求补再与上0xff再被减 
	}//指数和 

	
	
    //A: 输入为0 ,输出为0 
    if(u32Src == 0) 
    {
       return 0; 
       
    }
	//B：<= 0
    if(i32ExpSum <= 0) 
    {
       //浮点下溢标志为1；
       SetFlag(*p_pStatReg, ALU_UnderFlow); 
       SetFlag(*p_pStatReg, ALU_AUS);
       //饱和：
       if(u1Saturation)
       return 0; 
       //不饱和：
       if(!u1Saturation)
       {
           p_exp = i32ExpSum & 0xff;
           p_frac = (u32Src<<iCnt)>>9; //截取剩下的高23位
       }
    
    }
	
	//C：> = 255 
    if(i32ExpSum >= 0xff) 
    {
       //浮点上溢标志为1；
       SetFlag(*p_pStatReg, ALU_FOverFlow); 
       SetFlag(*p_pStatReg, ALU_AVS);
       
       //饱和：
       if(u1Saturation)
       {
           p_exp = 0xfe; //浮点最大值 
           p_frac = 0x7fffff;
		   
       }
       
       //不饱和：
       if(!u1Saturation)
       {
           p_exp = i32ExpSum & 0xff;
           p_frac = (u32Src<<iCnt)>>9; //截取剩下的高23位
		   
       }
       
    }
    
    if((i32ExpSum > 0) &&(i32ExpSum < 0xff))
    {
           p_exp = i32ExpSum & 0xff;
           p_frac = (u32Src<<iCnt)>>9; //截取剩下的高23位
    }	
    
    //p_frac = (u32Src<<iCnt)>>9; //截取剩下的高23位
    f32Dest = (SignTemp<<31)| p_exp<<23 |p_frac;

	return f32Dest;
    
}     
  */

/******************************************************************
	函数名：		Float16

	描述:			将16位定点数据转变为32位浮点数据。

	参数:			p_u16Src -- 16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		32位浮点结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
 DSPU32 alu_Float16(DSPU16 p_u16Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);
    //对16位数进行符号扩展 
    
    DSPU16 u16Scr1 = p_u16Src;
    DSPU32 u32Scr1 = 0;
    DSPU32 f32Dest = 0;
    DSPU32 pStatReg = *p_pStatReg;
    bool Sign16Temp = u16Scr1>>15;//符号位
    
    if(!Sign16Temp)
    {
          u32Scr1 = (DSPU32)u16Scr1;
    }
    
    if(Sign16Temp)
    {
          ////将符号扩展到高16位 
          u32Scr1 = 0xffff0000|(DSPU32)u16Scr1;
    }
    
    
    f32Dest = alu_Float32(u32Scr1,0, &pStatReg,p_u32ALUCR);
    *p_pStatReg = pStatReg;
    
    
    return f32Dest;
	
	

}
*/
/******************************************************************
	函数名：		Fix32

	描述:			将32位浮点数据转变为32位定点数据。

	参数:			p_u32Src -- 32位定点数据。
					p_u32Exp -- 指数调整，详见指令集手册。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		32位定点结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	下列4种情况溢出

	(1) 正数 ： exp -sub >30
	(2) 负数 ： exp -sub >31 
	(3) 负数 ： exp -sub = 31 ,但原24位不等于800000
	(4) 正负并无穷大：
	
--------------------------------------
	日期			作者			修改处

*******************************************************************/
 /*
 DSPU32 alu_Fix32(DSPU32 p_u32Src, DSPU32 p_u32Adjust, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{   
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                      
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    ///我在看到这个数是有偏的，需要-127变成无偏 
    bool bolResultOverflow = false;
    bool bolResultUnderflow = false;
    bool u1Scr1Neg = false; 
    bool u1Saturation = false;//饱和控制位 
    
    u1Saturation = TestFlag(p_u32ALUCR,ALU_Ctl_Saturation); //饱和控制位 
    
    Cfloat32 u32Src1 (p_u32Src);
		
	DSPU32 u32Dest = 0; 
	DSPU32 u32Src1Tmp = 0;
	DSPU32 u24Src1TmpFrac = 0;//补0后的尾数位 ，以被不饱和直接截取，共24位 
	DSPU64 u64Scr1TmpFrac = 0;//将尾数扩展成64位 ，占时未用 
	
	u1Scr1Neg = u32Src1.GetNega();         //取scr1的符号位 
    u32Src1Tmp = p_u32Src&0x7fffff;        //取23位尾数 
    u32Src1Tmp = u32Src1Tmp|0x800000;      //将隐含位1包含到转换前的尾数中 
    u64Scr1TmpFrac = u32Src1Tmp;
	   
	
    DSPI32 i32Exp = (DSPI32)(u32Src1.GetExp());
    DSPI32 i32ExpAjust = (DSPI8)(p_u32Adjust&0xff);///C 低8位有符号数 
    
    ///指数差 
    ///2008.08.08 重新修改 
	DSPI32 i32DiffExp = i32Exp - i32ExpAjust -0x7f ;//减去无偏量       
    
    //2008.11.4放开         
    if (u32Src1.IsDNORM() || u32Src1.IsZero())
    {               
        return 0;                       
    }  
    
    if (u32Src1.IsNAN())
    {              
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);           
        return N_A_N;                      
    }     
    ///无穷大数,溢出  
   //2009。11.24再次修改 
   //(1)输入无穷大置标志位，并且不再清除 
   //(2) 输入无穷大置,饱和情况下，输出最大值，不饱和时，正常截位取得结果
    if((p_u32Src == 0xff800000)||(p_u32Src == 0x7f800000)) 
    {
        SetFlag(*p_pStatReg, ALU_OverFlow); //15-11-07 16:15 
        SetFlag(*p_pStatReg, ALU_AOS);
		SetFlag(*p_pStatReg, 6);
		SetFlag(*p_pStatReg, 14);
        //A 正无穷大 
        if(p_u32Src == 0x7f800000)
        {
           //A:饱和情况 
           if(u1Saturation) 
           u32Dest = 0x7fffffff;
           
           //B:不饱和情况 
           if(!u1Saturation) 
           {
                //2009.12.04
                
                if(i32DiffExp <=0)
                {
                  u32Dest = 0;
                }
                
                else if(i32DiffExp <=54)
                {
                  u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp) >>23;
                  u32Dest = (DSPU32)u64Scr1TmpFrac;
                }
                
                else if (i32DiffExp >54)
                {
                  u32Dest = 0;
                }            
             
           } 
                     
        }
        //B 负无穷大 
        if(p_u32Src == 0xff800000)
        {
           //A:饱和情况 
           if(u1Saturation) 
           {u32Dest = 0x80000000;}
           
           //B:不饱和情况 
           if(!u1Saturation) 
           {
                //2009.12.04
                
                if(i32DiffExp <=0)
                {
                  u32Dest = 0;
                }
                
                else if(i32DiffExp <=54)
                {
                 u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
                 u32Dest = (DSPU32)u64Scr1TmpFrac;
                 u32Dest = ~u32Dest + 1;//LXM 先左移再求补 
                }
                
                else if (i32DiffExp >54)
                {
                  u32Dest = 0;
                }           
             
             
           }
           
           
          
        }
        
        return u32Dest;	
    }
    
    
    /// 2008.08.15修改 
    //1 指数为0
    if(i32Exp == 0)
    {
       u32Dest = 0;
    } 
    
	//2
    if(i32DiffExp < 0)
    {      
      return 0; //uDest = 0
    }
    //3 =0
    else if (i32DiffExp == 0)
    {
         //1 正数
         if(!u1Scr1Neg) 
         return 0x1; //uDest = 1
         
         //2 负数 
         if(u1Scr1Neg)
         //uDest = ~1+1;
         return 0xffffffff;//-1  
    }
    //4 <= 30
    else if(i32DiffExp <= 30)
    {
         //1 正数
         if(!u1Scr1Neg) 
         {
             u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
             u32Dest = (DSPU32)u64Scr1TmpFrac;
         }
                  
         //2 负数 
         if(u1Scr1Neg)
         {
             u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
             u32Dest = (DSPU32)u64Scr1TmpFrac;
             u32Dest = ~u32Dest + 1;//LXM 先左移再求补 

			 
         }
    }
    
    ///5 >= 31
    else if((i32DiffExp >= 31)&&(i32DiffExp <= 55 )) 
    {
         //1 正数 ，溢出
         if(!u1Scr1Neg)
         {
              SetFlag(*p_pStatReg, ALU_OverFlow); //15-11-07 16:15 
              SetFlag(*p_pStatReg, ALU_AOS);
			  SetFlag(*p_pStatReg, 6);
			  SetFlag(*p_pStatReg, 14);
              
              //A:饱和情况 
              if(u1Saturation) 
              u32Dest = 0x7fffffff; 
              
              //B:不饱和
              if(!u1Saturation) 
               {
                     u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
                     u32Dest = (DSPU32)u64Scr1TmpFrac;
               }         
         }
         
         //2 负数 ，除diffexp＝31外溢出
         if(u1Scr1Neg)
         {             
              //A:源操作数是0x800000 -1
			  //2008.11.4 取消该情况，因为现在是定点整数，-1可以表示
              //if((u32Src1Tmp == 0x800000)&&(i32Exp != 0xff))
              //{
              //    u32Dest = 0x80000000; 
              //}              
              //B:其它饱和情况 
              if(u1Saturation)  
              {
                  u32Dest = 0x80000000;
                  SetFlag(*p_pStatReg, ALU_OverFlow); //15-11-07 16:15 
                  SetFlag(*p_pStatReg, ALU_AOS);
				  SetFlag(*p_pStatReg, 6);
				  SetFlag(*p_pStatReg, 14);

			  
              }              
              //C:其它不饱和情况 
              else if(!u1Saturation) 
              {
                    
                   u64Scr1TmpFrac = (u64Scr1TmpFrac << i32DiffExp)>>23;
                   u32Dest = (DSPU32)u64Scr1TmpFrac;        
                   u32Dest = ~u32Dest + 1;//LXM 先左移再求补                   
                   //2008.11.10,正常的截位结果是0x80000000，值是负1，可以表示，不溢出，LXM
				   //(1)负数求补时，如果被移去的全是符号位，即是全1，则不是定点溢出
				   //(2)负数求补时，如果被移去的全是符号位，即不全是1，则有益有效位被移出，定点溢出				   
				    SetFlag(*p_pStatReg, ALU_OverFlow); //15-11-07 16:15 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 6);
		            SetFlag(*p_pStatReg, 14);
 
              }
         }
    } 
    
    else if(i32DiffExp >= 55) 
    {
          //1 正数 ，溢出
         if(!u1Scr1Neg)
         {
              SetFlag(*p_pStatReg, ALU_OverFlow); //15-11-07 16:15 
              SetFlag(*p_pStatReg, ALU_AOS);
			  SetFlag(*p_pStatReg, 6);
		      SetFlag(*p_pStatReg, 14);
              
              //A:饱和情况 
              if(u1Saturation) 
              return 0x7fffffff; 
              
              //B:不饱和
              if(!u1Saturation) 
              return 0;          
         }
         
         //2 负数 ，除diffexp＝31外溢出
         if(u1Scr1Neg)
         {             
              //A:源操作数是0x800000 -1 除掉无穷大 
              //if((u32Src1Tmp == 0x800000)&&(i32Exp != 0xff))
              //{
              //    return 0x80000000; 
              //}
              //
              //B:其它饱和情况 
              if(u1Saturation) 
              {
                  
                  SetFlag(*p_pStatReg, ALU_OverFlow); 
                  SetFlag(*p_pStatReg, ALU_AOS);
				  SetFlag(*p_pStatReg, 6);
				  SetFlag(*p_pStatReg, 14);
                  return 0x80000000;
              }              
              //C:其它不饱和情况 
              if(!u1Saturation) 
              {
                   
                   SetFlag(*p_pStatReg, ALU_OverFlow); 
                   SetFlag(*p_pStatReg, ALU_AOS);
				   SetFlag(*p_pStatReg, 6);
		           SetFlag(*p_pStatReg, 14);
                   return 0; 
              }
         }
    
    
    }
      
    return u32Dest;   
}
*/
/******************************************************************
	函数名：		Not32

	描述:			将32位数据的非。

	参数:			p_u32Src -- 32位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 Not32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
   *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
   
   DSPU32 uDest = ~p_u32Src; 
    
    return uDest;
}
*/
/******************************************************************
	函数名：		Xor32

	描述:			求两个32位数据的异或。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 Xor32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
   *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
   
   DSPU32 uDest = p_u32Src1 ^ p_u32Src2;
    
    return uDest;
}
*/
/******************************************************************
	函数名：		NOr32

	描述:			求两个32位数据的或非。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 NOr32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
   *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
   
   DSPU32 uDest = ~(p_u32Src1 | p_u32Src2); 
    
    return uDest;
}
*/
/******************************************************************
	函数名：		NAnd32

	描述:			求两个32位数据的与非。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 NAnd32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
   *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
   
   DSPU32 uDest = ~(p_u32Src1 & p_u32Src2);
    
    return uDest;
}
*/
/******************************************************************
	函数名：		Or32

	描述:			求两个32位数据的或。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 Or32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
   *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
   
   DSPU32 uDest = p_u32Src1 | p_u32Src2;  
    
    return uDest;
}
*/
/******************************************************************
	函数名：		And32

	描述:			求两个32位数据的与。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 And32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
   *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
   
   DSPU32 uDest = p_u32Src1 & p_u32Src2;
    
    return uDest;
}
*/
/******************************************************************
	函数名：		CountZero32

	描述:			确定p_u32Src中从低到高的p_u32Len位数据中0的个数。

	参数:			p_u32Src -- 源操作数。
					p_u32Len -- 位串长度；即从低到高共p_u32Len位参与统计。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		0的个数。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 CountZero32(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
    
    //p_u32Len 低五位有效 
    p_u32Len = p_u32Len & 0x1f;
    
    DSPU32 u32Result = 0;
    
    for ( DSPU32 i = 0; i < p_u32Len + 1; i ++)
    {
        if (!TestBit(p_u32Src, i))
        {
            u32Result ++;
        }
    } 
    
    return u32Result;
}    
*/
/*
DSPU16 ALU_CountZero16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
    
    //  p_u32Len低4位有效 
    p_u32Len = p_u32Len & 0xf;
    
    DSPU16 u16Result = 0;
    
    for ( DSPU32 i = 0; i < p_u32Len + 1; i ++)
    {
        if (!TestBit(p_u32Src, i))
        {
            u16Result ++;
        }
    } 
    
    return u16Result;
}
*/
/******************************************************************
	函数名：		CountZeroD16

	描述:			确定p_u32Src中高低16位从低到高的p_u32Len位数据中0的个数。

	参数:			p_u32Src -- 源操作数，包括高低16位数据。
					p_u32Len -- 位串长度；即从低到高共p_u32Len位参与统计。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		0的个数。低16位的统计结果放在结果的低16位中；高16位的统计结果
					放在结果的高16位中。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 CountZeroD16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Len);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Len);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = ALU_CountZero16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = ALU_CountZero16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;   
}      
*/
/******************************************************************
	函数名：		OnePosi32

	描述:			确定p_u32Src中从低到高的p_u32Len位数据中为1的最高位。

	参数:			p_u32Src -- 源操作数。
					p_u32Len -- 位串长度；即从低到高共p_u32Len位参与统计。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		为1的最高位。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 OnePosi32(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);       
    
    //  p_u32Len低5位有效 
    p_u32Len = p_u32Len & 0x1f;
    
    DSPU32 u32Result = p_u32Len;
    DSPI32 i32Result = u32Result;
    //从高位开始 为0并且不是最低位时继续 
    while (!TestBit(p_u32Src, i32Result) && (i32Result >= 0) )
    {
        i32Result --;
    }     
    
    return i32Result;       
}
*/
/*
DSPU16 OnePosi16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);       
    
    //  p_u32Len低4位有效 
    p_u32Len = p_u32Len & 0xf;
    
    DSPU16 u16Result = (DSPU16)p_u32Len;
    DSPI16 i16Result = (DSPI16)u16Result;
    //从高位开始 为0并且不是最低位时继续 
    while (!TestBit(p_u32Src, i16Result) && (i16Result >= 0) )
    {
        i16Result --;
    }     
    
    return i16Result;         
}
*/
/******************************************************************
	函数名：		OnePosiD16

	描述:			确定p_u32Src中高低16位从低到高的p_u32Len位数据中为1的最高位。

	参数:			p_u32Src -- 源操作数，包括高低16位数据。
					p_u32Len -- 位串长度；即从低到高共p_u32Len位参与统计。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		为1的最高位。低16位的统计结果放在结果的低16位中；高16位的统计结果
					放在结果的高16位中。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 OnePosiD16(DSPU32 p_u32Src, DSPU32 p_u32Len, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Len);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Len);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = OnePosi16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = OnePosi16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;   
}   
*/
/******************************************************************
	函数名：		Max32

	描述:			求两个定点32位数据中的最大值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Max32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u32Src1;
    DSPU32 u32Src2Tmp = p_u32Src2;
    
    DSPU32 uDest;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool p_bolZero = false;
    if(bolSigned)
    {
        u32Src1Tmp ^= 1 << (OpBits - 1);
        u32Src2Tmp ^= 1 << (OpBits - 1);
    }
    
    if (u32Src1Tmp >= u32Src2Tmp)
    {
        uDest = p_u32Src1;
    }
    else 
    {
        if (p_bolZero)
        {
            uDest = 0;
        }
        else
        {
            uDest = p_u32Src2;
        }
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
} 

/******************************************************************
	函数名：		Min32

	描述:			求两个定点32位数据中的最小值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 Min32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u32Src1;
    DSPU32 u32Src2Tmp = p_u32Src2;
    
    DSPU32 uDest;
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool p_bolZero = false;    
    if(p_bolSigned)
    {
        u32Src1Tmp ^= 1 << (OpBits - 1);
        u32Src2Tmp ^= 1 << (OpBits - 1);
    }
    
    if (u32Src1Tmp <= u32Src2Tmp)
    {
        uDest = p_u32Src1;
    }
    else 
    {
        if (p_bolZero)
        {
            uDest = 0;
        }
        else
        {
            uDest = p_u32Src2;
        }
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
}

DSPU16 Max16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u16Src1;
    DSPU32 u32Src2Tmp = p_u16Src2;
    
    DSPU16 uDest;
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool p_bolZero = false;        
    if(p_bolSigned)
    {
        u32Src1Tmp ^= 1 << (OpBits - 1);
        u32Src2Tmp ^= 1 << (OpBits - 1);
    }
    
    if (u32Src1Tmp >= u32Src2Tmp)
    {
        uDest = p_u16Src1;
    }
    else 
    {
        if (p_bolZero)
        {
            uDest = 0;
        }
        else
        {
            uDest = p_u16Src2;
        }
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
}

DSPU16 Min16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u16Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u16Src1;
    DSPU32 u32Src2Tmp = p_u16Src2;
    
    DSPU16 uDest;
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool p_bolZero = false;        
    if(p_bolSigned)
    {
        u32Src1Tmp ^= 1 << (OpBits - 1);
        u32Src2Tmp ^= 1 << (OpBits - 1);
    }
    
    if (u32Src1Tmp <= u32Src2Tmp)
    {
        uDest = p_u16Src1;
    }
    else 
    {
        if (p_bolZero)
        {
            uDest = 0;
        }
        else
        {
            uDest = p_u16Src2;
        }
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
}

/******************************************************************
	函数名：		MaxD16

	描述:			分别求两个32位源操作数中高低16位的最大值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Max16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Max16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;   
}

/******************************************************************
	函数名：		MinD16

	描述:			分别求两个32位源操作数中高低16位的最小值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MinD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 u16UpperResult = Min16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Min16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 
    
    *p_pStatReg = UpperReg | LowerReg;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;   
}

/******************************************************************
	函数名：		MaxF32

	描述:			求两个浮点32位数据中的最大值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u32Src1;
    bool bolSrc1Sign = TestBit(p_u32Src1, 31);
    DSPU32 u32Src1Exponent = (p_u32Src1 & 0x7fffffff) >> 23;
    DSPU32 u32Src1Fraction = p_u32Src1 & 0x007fffff;
    bool bolSrc1IsNAN = ((u32Src1Exponent == 0xff) && ( u32Src1Fraction != 0));
    //bool bolSrc1IsINF = ((u32Src1Exponent == 0xff) && ( u32Src1Fraction == 0));
    
    DSPU32 u32Src2Tmp = p_u32Src2;
    bool bolSrc2Sign = TestBit(p_u32Src2, 31);
    DSPU32 u32Src2Exponent = (p_u32Src2 & 0x7fffffff) >> 23;
    DSPU32 u32Src2Fraction = p_u32Src2 & 0x007fffff;
    bool bolSrc2IsNAN = ((u32Src2Exponent == 0xff) && ( u32Src2Fraction != 0));
    //bool bolSrc2IsINF = ((u32Src2Exponent == 0xff) && ( u32Src2Fraction == 0));
    
    if (u32Src1Exponent == 0 && u32Src1Fraction != 0)
    {
        u32Src1Tmp = p_u32Src1 & 0x80000000;
        u32Src1Exponent = 0;
        u32Src1Fraction = 0;
    }  
     
    if (u32Src2Exponent == 0 && u32Src2Fraction != 0)
    {
        u32Src2Tmp = p_u32Src2 & 0x80000000; 
        u32Src2Exponent = 0;
        u32Src2Fraction = 0;  
    }
    
    DSPU32 uDest;
    if (bolSrc1Sign != bolSrc2Sign)
    {
        if (bolSrc1Sign == 0)
        {
            uDest = u32Src1Tmp;
        }
        else
        {
            uDest = u32Src2Tmp;
        }
    }
    else 
    {
        if (u32Src1Exponent != u32Src2Exponent)
        {
            if ((u32Src1Exponent > u32Src2Exponent) ^ bolSrc1Sign)
            {
                uDest = u32Src1Tmp;
            }
            else
            {
                uDest = u32Src2Tmp; 
            }
        }
        else 
        {
            if ((u32Src1Fraction >= u32Src2Fraction) ^ bolSrc1Sign)
            {
                uDest = u32Src1Tmp;
            }  
            else 
            {
                uDest = u32Src2Tmp;
            }
        }
    }
    
    if ( bolSrc1IsNAN || bolSrc2IsNAN )
    {
        uDest = N_A_N;   
    }

    bool bolDestSign = TestBit(uDest, 31);
    DSPU32 u32DestExponent = (uDest & 0x7fffffff) >> 23;
    DSPU32 u32DestFraction = uDest & 0x007fffff;
    bool bolDestIsNAN = ((u32DestExponent == 0xff) && (u32DestFraction != 0));
    //bool bolDestIsDNRM = ((u32DestExponent == 0x0) && (u32DestFraction != 0));
    bool bolDestIsZero = ((u32DestExponent == 0x0) && (u32DestFraction == 0));  
         
    if ( bolSrc1IsNAN || bolSrc2IsNAN )
    {
        uDest = N_A_N;   
        SetFlag(*p_pStatReg, ALU_Invalid);
        SetFlag(*p_pStatReg, ALU_AIS);
    }

    return uDest;
}   

/******************************************************************
	函数名：		MinF32

	描述:			求两个浮点32位数据中的最小值。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MinF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u32Src1;
    bool bolSrc1Sign = TestBit(p_u32Src1, 31);
    DSPU32 u32Src1Exponent = (p_u32Src1 & 0x7fffffff) >> 23;
    DSPU32 u32Src1Fraction = p_u32Src1 & 0x007fffff;
    bool bolSrc1IsNAN = ((u32Src1Exponent == 0xff) && ( u32Src1Fraction != 0));
    //bool bolSrc1IsINF = ((u32Src1Exponent == 0xff) && ( u32Src1Fraction == 0));
    
    DSPU32 u32Src2Tmp = p_u32Src2;
    bool bolSrc2Sign = TestBit(p_u32Src2, 31);
    DSPU32 u32Src2Exponent = (p_u32Src2 & 0x7fffffff) >> 23;
    DSPU32 u32Src2Fraction = p_u32Src2 & 0x007fffff;
    bool bolSrc2IsNAN = ((u32Src2Exponent == 0xff) && ( u32Src2Fraction != 0));
    //bool bolSrc2IsINF = ((u32Src2Exponent == 0xff) && ( u32Src2Fraction == 0));
    
    if (u32Src1Exponent == 0 && u32Src1Fraction != 0)
    {
        u32Src1Tmp = p_u32Src1 & 0x80000000;
        u32Src1Exponent = 0;
        u32Src1Fraction = 0;
    }  
     
    if (u32Src2Exponent == 0 && u32Src2Fraction != 0)
    {
        u32Src2Tmp = p_u32Src2 & 0x80000000; 
        u32Src2Exponent = 0;
        u32Src2Fraction = 0;  
    }
    
    DSPU32 uDest;
    if (bolSrc1Sign != bolSrc2Sign)
    {
        if (bolSrc1Sign)
        {
            uDest = u32Src1Tmp;
        }
        else
        {
            uDest = u32Src2Tmp;
        }
    }
    else 
    {
        if (u32Src1Exponent != u32Src2Exponent)
        {
            if ((u32Src1Exponent < u32Src2Exponent) ^ bolSrc1Sign)
            {
                uDest = u32Src1Tmp;
            }
            else
            {
                uDest = u32Src2Tmp; 
            }
        }
        else 
        {
            if ((u32Src1Fraction <= u32Src2Fraction) ^ bolSrc1Sign)
            {
                uDest = u32Src1Tmp;
            }  
            else 
            {
                uDest = u32Src2Tmp;
            }
        }
    }
    
    if ( bolSrc1IsNAN || bolSrc2IsNAN )
    {
        uDest = N_A_N;   
    }

    bool bolDestSign = TestBit(uDest, 31);
    DSPU32 u32DestExponent = (uDest & 0x7fffffff) >> 23;
    DSPU32 u32DestFraction = uDest & 0x007fffff;
    bool bolDestIsNAN = ((u32DestExponent == 0xff) && (u32DestFraction != 0));
    //bool bolDestIsDNRM = ((u32DestExponent == 0x0) && (u32DestFraction != 0));
    bool bolDestIsZero = ((u32DestExponent == 0x0) && (u32DestFraction == 0));  
         
    if ( bolSrc1IsNAN || bolSrc2IsNAN )
    {
        uDest = N_A_N;   
        SetFlag(*p_pStatReg, ALU_Invalid);
        SetFlag(*p_pStatReg, ALU_AIS);
    }

    return uDest;
}   


/******************************************************************
	函数名：		MaxMin16

	描述:			求浮点32位源操作数中高低16的最大值和最小值。

	参数:			p_u32Src -- 源操作数，包括高低16定点数据；
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	
					p_bolBigToH -- 结果的放置方式。
						true:  最大值放高16位，最小值放低16位；
						false: 最大值放低16位，最小值放高16位；						

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxMin16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolBigToH)
{
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    DSPU32 MaxReg = *p_pStatReg;
    DSPU32 MinReg = *p_pStatReg;
    
    DSPU16 u16MaxResult = Max16(u16UpperSrc, u16LowerSrc, &MaxReg, p_u32ALUCR);
    DSPU16 u16MinResult = Min16(u16UpperSrc, u16LowerSrc, &MinReg, p_u32ALUCR); 
    
    *p_pStatReg = MaxReg | MinReg;
     
    DSPU32 u32Result;
    if (p_bolBigToH)
    {
        u32Result  = (((DSPU32)u16MaxResult) << 16) | ((DSPU32)u16MinResult);
    }
    else
    {
        u32Result  = (((DSPU32)u16MinResult) << 16) | ((DSPU32)u16MaxResult);
    }

    return  u32Result;  
} 

/******************************************************************
	函数名：		IsHT32

	描述:			比较标志寄存器本身左移一位.
                    如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),	                 
                    然后比较标志寄存器的最低位置1；
					否则，返回0，然后比较标志寄存器最低位置0；
					

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHT32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)

//extern DSPU32 IsHT32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        bolRmIsBiger = (i32Src1 > i32Src2);
    }
    else
    {
        bolRmIsBiger = (p_u32Src1 > p_u32Src2);
    }
    20130809;
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；否则输出0
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return Sub32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }
}

DSPU16 IsHT16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU16 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16Src1 = (DSPI16)p_u16Src1 ;
    DSPI16 i16Src2 = (DSPI16)p_u16Src2 ;
    if (bolSigned)
    {
        bolRmIsBiger = (i16Src1 > i16Src2);
    }
    else
    {
        bolRmIsBiger = (p_u16Src1 > p_u16Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；否则输出0
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return Sub16(p_u16Src1, p_u16Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }
}

/******************************************************************
	函数名：		IsHTD16

	描述:			两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令手册中HRm=HRm>HRn? HRm-HRn:0{k}的说明。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
DSPU32 IsHTD16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) // GRui
//DSPU32 IsHTD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    DSPU16 u16UpperResult = IsHT16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    DSPU16 u16LowerResult = IsHT16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    
    *p_pStatReg = UpperReg | LowerReg;
    
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;          
}


/******************************************************************
	函数名：		IsHTF32 FRs=FRm>FRn? FRm-FRn:0

	描述:			如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:			p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) // GRui
//extern DSPU32 IsHTF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
     
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;      
    //有/无符号位在控制寄存器中设置 
    bool bolRmIsBiger;
    Cfloat32 f32Src1(p_u32Src1) ;
    if (f32Src1.IsDNORM())
    {               
        f32Src1.SetZero();                        
    }     
    Cfloat32 f32Src2(p_u32Src2) ;
    if (f32Src2.IsDNORM())
    {               
        f32Src2.SetZero();                        
    }    

    if(f32Src1.IsNAN() 
        || f32Src2.IsNAN() 
        || (f32Src1.IsINF() && f32Src2.IsINF() && ((f32Src1.IsNega() == f32Src2.IsNega())) ))
    {
         if (f32Src1.IsINF() && f32Src2.IsINF() && ((f32Src1.IsNega() == f32Src2.IsNega())) )
		{
			ClearBit(*p_pALUCFR , 0);
			return 0;
		}          
      SetFlag(*p_pStatReg, ALU_Invalid);
      SetFlag(*p_pStatReg, ALU_AIS);
	   
      return N_A_N;
    }
    
    bolRmIsBiger = (f32Src1.GetF32() > f32Src2.GetF32());
    
    //指令集与X86不一致的地方:+0>-0 
    if (f32Src1.GetU32() == 0x00000000 &&  f32Src2.GetU32() == 0x80000000)
    {
        bolRmIsBiger = true;
    }

  
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return SubF32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
            
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }

}

/******************************************************************
	函数名：		IsHE32

	描述:			如果p_u32Src1 >= p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHE32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) // GRui
//extern DSPU32 IsHE32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        bolRmIsBiger = (i32Src1 >= i32Src2);
    }
    else
    {
        bolRmIsBiger = (p_u32Src1 >= p_u32Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最低位置1；则，返回p_u32Src2
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 31);
        return p_u32Src1;
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return p_u32Src2;
    }
}

/*
DSPU16 IsHE16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU16 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16Src1 = (DSPI16)p_u16Src1 ;
    DSPI16 i16Src2 = (DSPI16)p_u16Src2 ;
    if (bolSigned)
    {
        bolRmIsBiger = (i16Src1 >= i16Src2);
    }
    else
    {
        bolRmIsBiger = (p_u16Src1 >= p_u16Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   //在外面强制执行循环，否则遇到非数不右移 
    
    //如果p_u16Src1 > p_u16Src2，返回p_u16Src1，同时比较标志寄存器的最高位置1；则，返回p_u16Src2 
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 15);
        return p_u16Src1;
    }
    else
    {
        ClearBit(*p_pALUCFR , 15);
        return p_u16Src2;
    }
}
*/
/******************************************************************
	函数名：		IsHED16

	描述:			两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令手册中HRm=HRm>=HRn? HRm:HRn{k}的说明。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 IsHED16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    
    *p_pStatReg = UpperReg | LowerReg;
    
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;          
}
*/
/******************************************************************
	函数名：		IsHEF32

	描述:			如果p_u32Src1 >= p_u32Src2，则输出p_u32Src1,同时将1移到ALUCFR的最低位，
					否则输出p_u32Src2, 同时将0移到ALUCFR的最低位,
					然后ALUCFR本身左移一位。

	参数:			p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
/*
extern DSPU32 IsHEF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
     //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
       
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    
    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        SetBit(*p_pALUCFR , 31); 
        if (cf32Src1.GetU32() == 0 || cf32Src2.GetU32() == 0)
        {
            if (cf32Src1.GetU32() == 0x80000000 && cf32Src2.GetU32() == 0)
            {
              ClearBit(*p_pALUCFR , 31);    
            }                   
          return 0;
        }
        else
        {
          return 0x80000000;//负0 
        }
    }      
    
    bool bolRmIsBiger;
   
    bolRmIsBiger = (cf32Src1.GetF32() >= cf32Src2.GetF32());//原来>= 结果不能实现＝功能 

   
        //在外面强制执行循环，否则结果遇到非数与全0等不右移 14-11-07 15:08
    
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return N_A_N;
    }     
    
    
    //如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger )//14-11-07 16:01
    {
        SetBit(*p_pALUCFR , 31);
        return cf32Src1.GetU32();
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return cf32Src2.GetU32();
    }
}
*/
/******************************************************************
	函数名：		IsHE16HL

	描述:			p_u32Src的高16位同低16位进行比较，如果高16位大于等于低16位，
					则返回高16位, 否则返回低16位。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHE16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16UpperSrc = (DSPI16)u16UpperSrc ;
    DSPI16 i16LowerSrc = (DSPI16)u16LowerSrc ;

	//先右移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   

    if (bolSigned)
    {
        bolRmIsBiger = (i16UpperSrc >= i16LowerSrc);
    }
    else
    {
        bolRmIsBiger = (u16UpperSrc >= u16LowerSrc);
    }
    
    if (bolRmIsBiger)
    {
		SetBit(*p_pALUCFR , 31);       
		return u16UpperSrc;
    }
    else
    {
		ClearBit(*p_pALUCFR , 31);        
		return u16LowerSrc;
    }


	
}

/******************************************************************
	函数名：		IsHE16LH

	描述:			p_u32Src的高16位同低16位进行比较，如果低16位大于等于高16位，
					则返回低16位, 否则返回高16位。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。
	             2.效果同上一条IsHE16HL指令.

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHE16LH(DSPU32 p_u32Src, DSPU32 *p_pStatReg,DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
     //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16UpperSrc = (DSPI16)u16UpperSrc ;
    DSPI16 i16LowerSrc = (DSPI16)u16LowerSrc ;

	//先右移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   

    if (bolSigned)
    {
        bolRmIsBiger = (i16LowerSrc >= i16UpperSrc);
    }
    else
    {
        bolRmIsBiger = (u16LowerSrc  >= u16UpperSrc);
    }
    
    if (bolRmIsBiger)
    {
		SetBit(*p_pALUCFR , 31);       
		return u16LowerSrc;
    }
    else
    {
		ClearBit(*p_pALUCFR , 31);        
		return u16UpperSrc;
    }
}

/******************************************************************
	函数名：		IsHT16HL

	描述:			p_u32Src的高16位同低16位进行比较，如果高16位大于低16位，
					则将高16位减低16位之差放入目的寄存器Rs的高16位, 否则输出0。
					参见指令集 6*32+21 

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHT16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16UpperSrc = (DSPI16)u16UpperSrc ;
    DSPI16 i16LowerSrc = (DSPI16)u16LowerSrc ;
	
	////2008.10.23 addd
	DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;

	DSPU32 Result = 0;
 
	///只是空的参数，没有实际效果
	DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);

	//先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   

    if (bolSigned)
    {
        bolRmIsBiger = (i16UpperSrc > i16LowerSrc);
		

    }
    else
    {
        bolRmIsBiger = (u16UpperSrc > u16LowerSrc);
    }
    
    if (bolRmIsBiger)
    {
		SetBit(*p_pALUCFR , 0);
		//大于输出差值到高16位
		if (bolSigned)
		{			
			Result = IsHT16(i16UpperSrc, i16LowerSrc, &LowerReg, &LowerCFR, p_u32ALUCR);		
		}
		else
		{
			Result =  IsHT16(u16UpperSrc, u16LowerSrc, &LowerReg, &LowerCFR, p_u32ALUCR);
		}
		
    }

    else
    {
		//小于输出0
		ClearBit(*p_pALUCFR , 0);        
		
		Result =  0;
		
		
    }

	*p_pStatReg =  LowerReg;

	return Result ;


}

/******************************************************************
	函数名：		IsHT16LH

	描述:			p_u32Src的高16位同低16位进行比较，如果低16位大于高16位，
					则将低16位减高16位之差放入目的寄存器Rs的高16位, 否则输出0。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsHT16LH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16UpperSrc = (DSPI16)u16UpperSrc ;
    DSPI16 i16LowerSrc = (DSPI16)u16LowerSrc ;

	////2008.10.23 addd
	DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;

	DSPU32 Result = 0;
 
	///只是空的参数，没有实际效果
	DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);

	//先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   

    if (bolSigned)
    {
        bolRmIsBiger = (i16LowerSrc > i16UpperSrc);
		

    }
    else
    {
        bolRmIsBiger = ( u16LowerSrc > u16UpperSrc);
    }
    
    if (bolRmIsBiger)
    {
		SetBit(*p_pALUCFR , 0);
		//大于输出差值到高16位
		if (bolSigned)
		{			
			Result = IsHT16( i16LowerSrc, i16UpperSrc,&LowerReg, &LowerCFR, p_u32ALUCR);		
		}
		else
		{
			Result =  IsHT16( u16LowerSrc,u16UpperSrc, &LowerReg, &LowerCFR, p_u32ALUCR);
		}
		
    }

    else
    {
		//小于输出0
		ClearBit(*p_pALUCFR , 0);        
		
		Result =  0;
		
		
    }

	*p_pStatReg =  LowerReg;

	return Result ;

}

/******************************************************************
	函数名：		ACC32OnCON

	描述:			32位定点累加或累减，受累加控制寄存器CON的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后
					CON左移一位。ALU4~ALU7每一个都配备一个32位累加结果寄存器。
					

	参数:			p_u32Src -- 源操作数，32位定点数据。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACC32OnCON(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR)
{
    bool bolSubCon = TestBit(*p_pCON, 31);
    
    if (bolSubCon)
    {
        ACCSub32(p_u32Src, p_pACC, p_pStatReg, p_u32ALUCR); 
    }
    else
    {
        ACCAdd32(p_u32Src, p_pACC, p_pStatReg, p_u32ALUCR); 
    } 
    
    *p_pCON = *p_pCON << 1;
    
    return;     
}      

/******************************************************************
	函数名：		ACCD16OnCON

	描述:			高低16位定点累加或累减，受累加控制寄存器CON高低16位的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后CON高低16位
					分别左移一位。ALU4~ALU7每一个都配备一个32位累加结果寄存器。
					

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCD16OnCON(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR)
{
    //标志位清0 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);   
    DSPU16 CONCHigh = (DSPU16)((*p_pCON) >> 16) ;
    DSPU16 CONCLow  = (DSPU16)(*p_pCON) ;
    
    bool bolHignSubCon = TestBit(CONCHigh, 15);
    bool bolLowSubCon  = TestBit(CONCLow, 15);
    
    DSPU32 u32SateTemp1 = *p_pStatReg, u32SateTemp2 = *p_pStatReg, u32SateTemp3 = *p_pStatReg, u32SateTemp4 = *p_pStatReg;
    if (bolHignSubCon)
    {
        ACCSubD16(p_u32Src & 0xffff0000, p_pACC, &u32SateTemp1, p_u32ALUCR); 
    }
    else 
    {
        ACCAddD16(p_u32Src & 0xffff0000, p_pACC, &u32SateTemp2, p_u32ALUCR); 
    } 
    
    if (bolLowSubCon)
    {
        ACCSubD16(p_u32Src & 0x0000ffff, p_pACC, &u32SateTemp3, p_u32ALUCR); 
    }
    else
    {
        ACCAddD16(p_u32Src& 0x0000ffff, p_pACC, &u32SateTemp4, p_u32ALUCR); 
    } 
    
    *p_pStatReg = u32SateTemp1 | u32SateTemp2 | u32SateTemp3 | u32SateTemp4;
    
    //按照硬件做法,控制字高低16位同时左移 ,语法有问题，没有实现分开右移的效果 
    *p_pCON = ((DSPU32)CONCHigh << 1 << 16) | (DSPU16)(CONCLow << 1);
       
}     

/******************************************************************
	函数名：		ACCF32OnCON

	描述:			32位浮点累加或累减，受累加控制寄存器CON的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后
					CON左移一位。ALU4~ALU7每一个都配备一个32位累加结果寄存器。
					

	参数:			p_u32Src -- 源操作数，32位浮点数据。
					p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCF32OnCON(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR)
{
	if ( p_u32Src == 0xff7fffff) 
	{
		//int i = 0;
	}
    bool bolSubCon = TestBit(*p_pCON, 31);
    
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    DSPU32 u32SateTemp1 = *p_pStatReg, u32SateTemp2 = *p_pStatReg;
    if (bolSubCon)
    {
        ACCSubF32(p_u32Src, p_pACC, p_pEXP,&u32SateTemp1, p_u32ALUCR); 
    }
    else
    {
        ACCAddF32(p_u32Src, p_pACC, p_pEXP, &u32SateTemp2, p_u32ALUCR); 
    } 
    *p_pStatReg = u32SateTemp1 | u32SateTemp2 ;
    *p_pCON = *p_pCON << 1;
       
}    

/******************************************************************
	函数名：		Neg32

	描述:			求32位定点数的负数。

	参数:			p_u32Src -- 源操作数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 Neg32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    SetFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    //02-11-07 09:48 根据硬件,只做有符号运算 
    SetFlag(p_u32ALUCR, ALU_Ctl_Signed);
    return Sub32(0, p_u32Src, p_pStatReg, p_u32ALUCR);
}

/******************************************************************
	函数名：		NegD16

	描述:			求高低16位定点数的负数。

	参数:			p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
/*
extern DSPU32 NegD16(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    SetFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    //02-11-07 09:48 根据硬件,只做有符号运算 
    SetFlag(p_u32ALUCR, ALU_Ctl_Signed);
    return SubD16(0, p_u32Src, p_pStatReg, p_u32ALUCR);
}
*/
/******************************************************************
	函数名：		NegF32

	描述:			求32位浮点数的负数。

	参数:			p_u32Src -- 32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 NegF32(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    SetFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    return SubF32(0, p_u32Src, p_pStatReg, p_u32ALUCR);
}

/******************************************************************
	函数名：		U32ToAcc

	描述:			32位浮点赋值到已清0的ACC上. 

	参数:			p_u32Src -- 32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。
					u8Exp--指数赋值 
					bolIsNAN--是否为非数标志带出来. 

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
/*
DSP_BIT40 U32ToAcc(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU8 *u8Exp, bool *bolIsNAN)
{
    Cfloat32 cf32Src(p_u32Src);
    
    DSP_BIT40 b40Acc;
    b40Acc.u32Low = 0;
    b40Acc.u8High = 0;   
    
    if (cf32Src.IsNAN())
    {
        *bolIsNAN = true;
        
        //20-10-07 10:17 根据要求,当输入为非数时,指数,ACC全置1 
        *u8Exp = 0xff;
        b40Acc.u32Low = 0xffffffff;
        b40Acc.u8High = 0xff;
        return b40Acc;
    }
    else
    {
        *bolIsNAN = false;
        
        *u8Exp = cf32Src.GetExp();
        
        DSPU32 u23Frac = cf32Src.GetFrac();
        DSPU40 u40Acc(u23Frac | 0x00800000); //加上隐藏位(第24位) 
        if(cf32Src.GetNega())
        {                   
            //如果 为负,转为补码(取反加1);              
            u40Acc.OverturnAll();
            u40Acc = u40Acc + 1;              
        }  
        
        if (cf32Src.IsZero()) 
        {
            u40Acc.u8High = 0;
            u40Acc.u32Low = 0;
            *u8Exp = 0;
        }
        
        return u40Acc.GetDSPBIT();   
    }                   
    
}
*/
/******************************************************************
	函数名：		InAdd16ToH

	描述:			32位数据内部的高低16位相加，结果存于32位结果的高16位，低16位清零。
						对应指令形式：HHRs = HHRm + LHRm; HHRs = (HHRm + LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放计算结果，低16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/

extern DSPU32 InAdd16ToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)

{
    //标志位清0 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);
    
    DSPU32 u32Result;   
    ////结果不除2     
    if(!p_bolHalf)
     {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16) p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        DSPU16 u16UpperResult = Add16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg ;
        
        u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
     }
    
    ////结果除以2 
    else
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        DSPU16 u16UpperResult = Add16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg; 
     
        u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16LowerResult);
    } 
        return  u32Result;

}

/******************************************************************
	函数名：		InAdd16ToL

	描述:			32位数据内部的高低16位相加，结果存于32位结果的低16位，高16位清零。
						对应指令形式：LHRs = HHRm + LHRm; LHRs = (HHRm + LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放计算结果，高16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAdd16ToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
           //标志位清0 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);
    
    DSPU32 u32Result;   
    ////结果不除2     
    if(!p_bolHalf)
     {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在低16位，高16位补0 
        DSPU16 u16LowerResult = Add16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = 0;
        *p_pStatReg = UpperReg ;
        
        u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
     }
    
    ////结果除以2 
    else
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在低16位，高16位补0 
        DSPU16 u16LowerResult = Add16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = 0;
        *p_pStatReg = UpperReg; 
     
        u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16LowerResult);
    } 
        return  u32Result;
}

/******************************************************************
	函数名：		InSub16ToH

	描述:			32位数据内部的高低16位相减，结果存于32位结果的高16位，低16位清零。
						对应指令形式：HHRs = HHRm - LHRm; HHRs = (HHRm - LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放计算结果，低16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16ToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
       //标志位清0 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);
    
    DSPU32 u32Result;   
    ////结果不除2     
    if(!p_bolHalf)
     {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        DSPU16 u16UpperResult = Sub16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg ;
        
        u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
     }
    
    ////结果除以2 
    else
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc =(DSPU16) p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        DSPU16 u16UpperResult = Sub16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg; 
     
        u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16LowerResult);
    } 
        return  u32Result;

}

/******************************************************************
	函数名：		InSub16ToL

	描述:			32位数据内部的高低16位相减，结果存于32位结果的低16位，高16位清零。
						对应指令形式：LHRs = HHRm - LHRm; LHRs = (HHRm - LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放计算结果，高16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16ToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
       //标志位清0 
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);
    
    DSPU32 u32Result;   
    ////结果不除2     
    if(!p_bolHalf)
     {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在低16位，高16位补0 
        DSPU16 u16LowerResult = Sub16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = 0;
        *p_pStatReg = UpperReg ;
        
        u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
     }
    
    ////结果除以2 
    else
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在低16位，高16位补0 
        DSPU16 u16LowerResult = Sub16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = 0;
        *p_pStatReg = UpperReg; 
     
        u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16LowerResult);
    } 
	u32Result = u32Result & 0xffff;
        return  u32Result;

}

/******************************************************************
	函数名：		InAddSub16ToHL

	描述:			32位数据内部的高低16位相加，结果存于32位结果的高16位。
						32位数据内部的高低16位相减，结果存于32位结果的低16位。
						对应指令形式：HHRs = HHRm +/- LHRm; HHRs = (HHRm +/- LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放相加的结果，低16位存放相减的结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16ToHL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
        //标志位清0 
      //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
      
     DSPU32 u32Result;
   ////结果不除2 
   if(!p_bolHalf) 
        {   
            DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
            DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
            DSPU32 UpperReg = *p_pStatReg;          
            DSPU32 LowerReg = *p_pStatReg;
        
            DSPU16 u16UpperResult = Add16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            DSPU16 u16LowerResult = Sub16(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位  
            
            *p_pStatReg = UpperReg | LowerReg;
         
            u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
       }  
     ////结果除2 
   else{ 
            DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
            DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
            DSPU32 UpperReg = *p_pStatReg;          
            DSPU32 LowerReg = *p_pStatReg;
        
            DSPU16 u16UpperResult = Add16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            DSPU16 u16LowerResult = Sub16Half(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位 
            *p_pStatReg = UpperReg | LowerReg;
         
            u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
        }
        return  u32Result; 
}

/******************************************************************
	函数名：		InAddSub16ToLH

	描述:			32位数据内部的高低16位相加，结果存于32位结果的低16位。
						32位数据内部的高低16位相减，结果存于32位结果的高16位。
						对应指令形式：LHRs = HHRm +/- LHRm; LHRs = (HHRm +/- LHRm) / 2

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器。
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放相加的结果，高16位存放相减的结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16ToLH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
        //标志位清0 
      //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
      
       DSPU32 u32Result;        
          ////结果不除2 
   if(!p_bolHalf) 
     { 
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
    
        DSPU16 u16UpperResult = Sub16(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR); //减的结果放在高16位 
        DSPU16 u16LowerResult = Add16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR); //加的结果放在低16位 
        
        
        *p_pStatReg = UpperReg | LowerReg;
     
        u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
        
    }
    else 
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;           
        DSPU32 LowerReg = *p_pStatReg;
     
        DSPU16 u16UpperResult = Sub16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//减的结果放在低16位 
        DSPU16 u16LowerResult = Add16Half(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//加的结果放在高16位 
       
        *p_pStatReg = UpperReg ;
     
        u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));      
         
         
         
    } 
    
    return  u32Result; 

}
/*
//---------------------------------------------------------------------------------
DSPU32 IsEQ32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) {
	//标志位清0 
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
	
	//先将比较标志寄存器本省右移一位
	*p_pALUCFR = *p_pALUCFR >> 1;

	//如果p_u32Src1=p_u32Src2，返回p_u32Src1，同时比较标志寄存器最高位置1，否则返回p_u32Src20，同时比较标志寄存器最高位置0
	if (p_u32Src1==p_u32Src2)
	{
		
		SetBit(*p_pALUCFR , 31);
		return p_u32Src1;
	}
	else if (p_u32Src1!=p_u32Src2)
	{
		ClearBit(*p_pALUCFR, 31);
		return p_u32Src2;
	}
	
}
*/
/*
void IsEQ32L(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) {

	//标志位清0 
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
	
	//先将比较标志寄存器本省左移一位
	*p_pALUCFR = *p_pALUCFR << 1;

	//如果p_u32Src1=p_u32Src2，比较标志寄存器最低位置1，否则比较标志寄存器最低位置0
	if (p_u32Src1==p_u32Src2)
	{
		
		SetBit(*p_pALUCFR , 0);
		
	}
	else 
	{
		ClearBit(*p_pALUCFR, 0);
		
	}
}
*/
/*
void IsHT32L(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) {
	//标志位清0 
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
	
	//先将比较标志寄存器本省左移一位
	*p_pALUCFR = *p_pALUCFR << 1;

	//如果p_u32Src1>p_u32Src2，比较标志寄存器最低位置1，否则比较标志寄存器最低位置0
	if (p_u32Src1>p_u32Src2)
	{
		
		SetBit(*p_pALUCFR , 0);
		
	}
	else 
	{
		ClearBit(*p_pALUCFR, 0);
		
	}
}
*/
/*
void IsHE32L(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg,
		DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR) {
	//标志位清0 
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
	
	//先将比较标志寄存器本省左移一位
	*p_pALUCFR = *p_pALUCFR << 1;

	//如果p_u32Src1>=p_u32Src2，比较标志寄存器最低位置1，否则比较标志寄存器最低位置0
	if (p_u32Src1>=p_u32Src2)
	{
		
		SetBit(*p_pALUCFR , 0);
		
	}
	else 
	{
		ClearBit(*p_pALUCFR, 0);
		
	}
}
*/
///////////2012-08-10 BWDSP1042 ///////////////////

/*1found*****************************************************************
	函数名：		InSub16LHToH
	
	对应指令形式: HHRs=LHRm-HHRm(U)
	              HHRs=LHRm-HHRm
	              HHRs=(LHRm-HHRm)/2(U)
	              HHRs=(LHRm-HHRm)/2

	描述:			32位数据内部的低高16位相减，结果存于32位结果的高16位，低16位清零。
						

	参数:			p_u32Src -- 32位数据，对应Rm，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		高16位存放计算结果，低16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16LHToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
//extern DSPU32 InSub16ToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
       //标志位清0 
    //*p_pStatReg &= BIT(8) | BIT(13) ;
    //p_u32ALUCR = 0x3;
    DSPU32 u32Result;
    ////结果不除2     
    if(!p_bolHalf)
     {
		
			DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
			DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
			
			DSPU32 UpperReg = *p_pStatReg;          
			DSPU32 LowerReg = *p_pStatReg;
	        
			////结果保存在高16位，低16位补0 
			//DSPU16 u16UpperResult = Sub16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
			DSPU16 u16UpperResult = Sub16( u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);
			DSPU16 u16LowerResult = 0;
			/*
			if ((p_u32ALUCR & 0x1) == 0)
			{
				if (u16LowerSrc < u16UpperSrc)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
			}
			if ((p_u32ALUCR & 0x1) == 1)
			{
				if (((u16UpperResult == 0x7fff)||(u16UpperResult == 0x8000))
					&&(p_u32Src != 0x7fffffff)
					)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
				
			}
			*/
			
			*p_pStatReg = UpperReg ;
	        
			u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
			u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16UpperResult);
		
	
        
     }
    
    ////结果除以2 
    else
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc =(DSPU16) p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        //DSPU16 u16UpperResult = Sub16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = Sub16Half( u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg; 
		
		if (u16LowerSrc < u16UpperSrc)
		{
			//*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
		}
        u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16LowerResult);
		u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16UpperResult);
		}
		u32Result = u32Result &0xffff0000;
        return  u32Result;
    
       
}


/*1found*****************************************************************
	函数名：		InSub16LHToL
	
	对应指令形式: LHRs=LHRm-HHRm(U)
	              LHRs=LHRm-HHRm
	              LHRs=(LHRm-HHRm)/2(U)
	              LHRs=(LHRm-HHRm)/2

	描述:				32位数据内部的低高16位相减，结果存于32位结果的低16位，高16位清零。						

	参数:				p_u32Src -- 32位数据，对应Rm，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		低16位存放计算结果，高16位清零。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InSub16LHToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS);
     //*p_pStatReg &= BIT(8) | BIT(13) ;
    DSPU32 u32Result;   
    ////结果不除2     
    if(!p_bolHalf)
     {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        //DSPU16 u16UpperResult = Sub16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = Sub16( u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg ;
		/*
        if ((p_u32ALUCR & 0x1) == 0)
			{
				if (u16LowerSrc < u16UpperSrc)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
			}
			if ((p_u32ALUCR & 0x1) == 1)
			{
				if (((u16UpperResult == 0x7fff)||(u16UpperResult == 0x8000))
					&&(p_u32Src != 0x7fffffff)
					)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
				
			}
			*/
		u32Result = (DSPU32)u16UpperResult ;
        u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
		u32Result = (DSPU32)u16UpperResult ;
     }
    
    ////结果除以2 
    else
    {
        DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
        DSPU16 u16LowerSrc =(DSPU16) p_u32Src;
        DSPU32 UpperReg = *p_pStatReg;          
        DSPU32 LowerReg = *p_pStatReg;
        
        ////结果保存在高16位，低16位补0 
        //DSPU16 u16UpperResult = Sub16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16UpperResult = Sub16Half( u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);
        DSPU16 u16LowerResult = 0;
        *p_pStatReg = UpperReg; 
		if (u16LowerSrc < u16UpperSrc)
		{
			//*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
		}
		u32Result = (DSPU32)u16UpperResult ;
        //u32Result = (((DSPU32)u16UpperResult) << 16) |( (DSPU32)u16LowerResult);
    } 
	u32Result = u32Result & 0xffff;
        return  u32Result;


}

/*1found*****************************************************************
	函数名：			InAddSub16LHToH

	对应指令形式:		HHRs=LHRm+/-HHRm (U) 	              
						HHRs=LHRm+/-HHRm 
						HHRs=(LHRm+/-HHRm)/2 (U) 
						HHRs=(LHRm+/-HHRm)/2 

	描述:				32位数据内部的低16位加高16位，结果存于32位结果的高16位；
						32位数据内部的低16位减高16位，结果存于32位结果的低16位。

	参数:				p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16LHToH(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
//extern DSPU32 InAddSub16ToHL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
        //标志位清0 
    // *p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
      //*p_pStatReg &= BIT(8) | BIT(13) ;
     DSPU32 u32Result;
   ////结果不除2 
	 //p_u32ALUCR = 3;
   if(!p_bolHalf) 
        {   
            DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
            DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
            DSPU32 UpperReg = *p_pStatReg;          
            DSPU32 LowerReg = *p_pStatReg;
        
            //DSPU16 u16UpperResult = Add16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            //DSPU16 u16LowerResult = Sub16(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位  
            DSPU16 u16UpperResult = Add16(u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            DSPU16 u16LowerResult = Sub16(u16LowerSrc, u16UpperSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位  

            *p_pStatReg = UpperReg | LowerReg;
			/*
			if ((p_u32ALUCR & 0x1) == 0)
			{
				if ((u16LowerSrc < u16UpperSrc)||((u16LowerSrc + u16UpperSrc)>0xffff))
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
			}
			if ((p_u32ALUCR & 0x1) == 1)
			{
				if (((u16LowerResult == 0x7fff)||(u16LowerResult == 0x8000))
					&&(p_u32Src != 0x7fffffff)
					)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
				if (((u16UpperResult == 0x7fff)||(u16UpperResult == 0x8000))
					&&(p_u32Src != 0x7fffffff)
					)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
			}
			*/
            u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
       }  
     ////结果除2 
   else{ 
            DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
            DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
            DSPU32 UpperReg = *p_pStatReg;          
            DSPU32 LowerReg = *p_pStatReg;
        
            //DSPU16 u16UpperResult = Add16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            //DSPU16 u16LowerResult = Sub16Half(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位 
			DSPU16 u16UpperResult = Add16Half(u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            DSPU16 u16LowerResult = Sub16Half(u16LowerSrc, u16UpperSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位 
            *p_pStatReg = UpperReg | LowerReg;
			if ((u16LowerSrc < u16UpperSrc))
			{
				//*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
			}
            u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
        }
        return  u32Result; 
}

/*1found*****************************************************************
	函数名：		InAddSub16LHToL

	对应指令形式: LHRs=LHRm+/-HHRm (U)	              
	              LHRs=LHRm+/-HHRm 
	              LHRs=(LHRm+/-HHRm)/2 (U) 
	              LHRs=(LHRm+/-HHRm)/2 

	描述:			32位数据内部的低16位加高16位，结果存于32位结果的低16位；
						32位数据内部的低16位减高16位，结果存于32位结果的高16位。

	参数:			p_u32Src -- 32位数据，包括高低16位定点数据。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
						p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
						p_bolHalf -- 结果是否除以2。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 InAddSub16LHToL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, bool p_bolHalf)
{
  //标志位清0 
      //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
      //*p_pStatReg &= BIT(8) | BIT(13) ;
     DSPU32 u32Result;
   ////结果不除2 
	 //p_u32ALUCR = 3;
   if(!p_bolHalf) 
        {   
            DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
            DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
            DSPU32 UpperReg = *p_pStatReg;          
            DSPU32 LowerReg = *p_pStatReg;
        
            //DSPU16 u16UpperResult = Add16(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            //DSPU16 u16LowerResult = Sub16(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位  
            DSPU16 u16UpperResult = Add16(u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            DSPU16 u16LowerResult = Sub16(u16LowerSrc, u16UpperSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位  

            *p_pStatReg = UpperReg | LowerReg;
			/*
			if ((p_u32ALUCR & 0x1) == 0)
			{
				if ((u16LowerSrc < u16UpperSrc)||((u16LowerSrc + u16UpperSrc)>0xffff))
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
			}
			if ((p_u32ALUCR & 0x1) == 1)
			{
				if (((u16LowerResult == 0x7fff)||(u16LowerResult == 0x8000))
					&&(p_u32Src != 0x7fffffff)
					)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
				if (((u16UpperResult == 0x7fff)||(u16UpperResult == 0x8000))
					&&(p_u32Src != 0x7fffffff)
					)
				{
					*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
				}
			}
			*/
            //u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
			u32Result = (((DSPU32)u16LowerResult) << 16) & (0xffff0000) | (((DSPU32)u16UpperResult)&(0x0000ffff));
       }  
     ////结果除2 
   else{ 
            DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
            DSPU16 u16LowerSrc = (DSPU16)p_u32Src;
            DSPU32 UpperReg = *p_pStatReg;          
            DSPU32 LowerReg = *p_pStatReg;
        
            //DSPU16 u16UpperResult = Add16Half(u16UpperSrc, u16LowerSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            //DSPU16 u16LowerResult = Sub16Half(u16UpperSrc, u16LowerSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位 
			DSPU16 u16UpperResult = Add16Half(u16LowerSrc, u16UpperSrc, &UpperReg, p_u32ALUCR);//加的结果放在高16位
            DSPU16 u16LowerResult = Sub16Half(u16LowerSrc, u16UpperSrc, &LowerReg, p_u32ALUCR);//减的结果放在低16位 
            *p_pStatReg = UpperReg | LowerReg;
			if ((u16LowerSrc < u16UpperSrc))
			{
				//*p_pStatReg  |= BIT(0) | BIT(5) | BIT(8) | BIT(13);
			}
            //u32Result = (((DSPU32)u16UpperResult) << 16) & (0xffff0000) | (((DSPU32)u16LowerResult)&(0x0000ffff));
			u32Result = (((DSPU32)u16LowerResult) << 16) & (0xffff0000) | (((DSPU32)u16UpperResult)&(0x0000ffff));
        }
        return  u32Result;

}




/*1found*****************************************************************
	函数名：		IsHE32_SZ
	
	对应指令形式:  Rm=Rm>=Rn?(Rm-Rn):0(U,k)
                 Rm=Rm>=Rn?(Rm-Rn):0(k)

	描述:		如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHE32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
//extern DSPU32 IsHT32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(8) | BIT(14) ;//| BIT(ALU_AOS)  | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 > i32Src2);
		bolRmIsBiger = (i32Src1 >= i32Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 > p_u32Src2);
		bolRmIsBiger = (p_u32Src1 >= p_u32Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；否则输出0
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return Sub32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }
}
/*1found*****************************************************************
	函数名：		IsEQ32_SZ
	
	对应指令形式:  Rm=Rm==Rn?(Rm-Rn):0(U,k)
                 Rm=Rm==Rn?(Rm-Rn):0(k)

	描述:		如果p_u32Src1 == p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQ32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{

	//*p_pStatReg &= BIT(8) | BIT(14) ;
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 > i32Src2);
		bolRmIsBiger = (i32Src1 == i32Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 > p_u32Src2);
		bolRmIsBiger = (p_u32Src1 == p_u32Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；否则输出0
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
		//DSPU32 stat;
        return Sub32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }
}
/*1found*****************************************************************
	函数名：		IsNEQ32_SZ
	
	对应指令形式:  Rm=Rm!=Rn?(Rm-Rn):0(U,k)
                 Rm=Rm!=Rn?(Rm-Rn):0(k)

	描述:		如果p_u32Src1 != p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQ32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{

	//*p_pStatReg &= BIT(8) | BIT(14) ;
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
	bool bolflg = 0;

    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 > i32Src2);
		bolRmIsBiger = (i32Src1 != i32Src2);
		if (i32Src1 < i32Src2)
		{
			bolflg = 1;
		}
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 > p_u32Src2);
		bolRmIsBiger = (p_u32Src1 != p_u32Src2);
		if (p_u32Src1 < p_u32Src2)
		{
			bolflg = 1;
		}
    }
    
	if (bolflg)
	{
		//*p_pStatReg |= BIT(0) | BIT(6) | BIT(8) | BIT(14) ;
	}
	
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；否则输出0
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
		//DSPU32 stat;
		DSPU32 result = Sub32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
		if (bolflg)
		{
			//*p_pStatReg |= BIT(0) | BIT(6) | BIT(8) | BIT(14) ;
		}
        return result;
    }
    else
    {
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }
}



/*1found*****************************************************************
	函数名：		IsHT32_MN
	
	对应指令形式:  Rm=Rm>Rn?Rm:Rn(U,k)
                 Rm=Rm>Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 > p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHT32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
//extern DSPU32 IsHE32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 >= i32Src2);
		bolRmIsBiger = (i32Src1 > i32Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 >= p_u32Src2);
		bolRmIsBiger = (p_u32Src1 > p_u32Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最低位置1；则，返回p_u32Src2
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 31);
        return p_u32Src1;
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return p_u32Src2;
    }
}

/*1found*****************************************************************
	函数名：		IsEQ32_MN
	
	对应指令形式:  Rm=Rm==Rn?Rm:Rn(U,k)
                 Rm=Rm==Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 == p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQ32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 >= i32Src2);
		bolRmIsBiger = (i32Src1 == i32Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 >= p_u32Src2);
		bolRmIsBiger = (p_u32Src1 == p_u32Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最低位置1；则，返回p_u32Src2
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 31);
        return p_u32Src1;
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return p_u32Src2;
    }
}
/*1found*****************************************************************
	函数名：		IsNEQ32_MN
	
	对应指令形式:  Rm=Rm!=Rn?Rm:Rn(U,k)
                 Rm=Rm!=Rn?Rm:Rn(k)

	描述:		如果p_u32Src1 != p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1。
					p_u32Src2 -- 源操作数2。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录:
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQ32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Src1 ;
    DSPI32 i32Src2 = (DSPI32)p_u32Src2 ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 >= i32Src2);
		bolRmIsBiger = (i32Src1 != i32Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 >= p_u32Src2);
		bolRmIsBiger = (p_u32Src1 != p_u32Src2);
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最低位置1；则，返回p_u32Src2
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 31);
        return p_u32Src1;
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return p_u32Src2;
    }
}

DSPU16 IsHT16_NEW(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU16 *p_pALUCFR, DSPU32 p_u32ALUCR,int oper)
{
	/*
		oper 1:>= 2== 3 !=   
	*/
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16Src1 = (DSPI16)p_u16Src1 ;
    DSPI16 i16Src2 = (DSPI16)p_u16Src2 ;
    if (bolSigned)
    {	if (oper == 1)
		{
			bolRmIsBiger = (i16Src1 >= i16Src2);
		}
		else if (oper == 2)
		{
			bolRmIsBiger = (i16Src1 == i16Src2);
		}
		else if (oper == 3)
		{
			bolRmIsBiger = (i16Src1 != i16Src2);
		}
        //bolRmIsBiger = (i16Src1 > i16Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u16Src1 > p_u16Src2);
		if (oper == 1)
		{
			bolRmIsBiger = (p_u16Src1 >= p_u16Src2);
		}
		else if (oper == 2)
		{
			bolRmIsBiger = (p_u16Src1 == p_u16Src2);
		}
		else if (oper == 3)
		{
			bolRmIsBiger = (p_u16Src1 != p_u16Src2);
		}
    }
    
   //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；否则输出0
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return Sub16(p_u16Src1, p_u16Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }
}

/*1found*****************************************************************
	函数名：		IsHED16_SZ

	对应指令形式: HRm=HRm>=HRn?(HRm-HRn):0(U,k)   
                  HRm=HRm>=HRn?(HRm-HRn):0(k) 

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHED16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHT16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHT16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    DSPU16 u16UpperResult = IsHT16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,1);
    DSPU16 u16LowerResult = IsHT16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,1);
    
    *p_pStatReg = UpperReg | LowerReg;
	//*p_pStatReg &= BIT(8) | BIT(13) ;//| BIT(ALU_AOS)  | BIT(ALU_AIS);
    

	DSPU32 u32acfhigh = (*p_pALUCFR) >> 16;
	DSPU32 u32acflow = (*p_pALUCFR) & 0xffff;
	
	if (u16UpperSrc1 >= u16UpperSrc2)
	{
		u32acfhigh = u32acfhigh << 1;
		u32acfhigh = u32acfhigh | 0x1;
	}
	else
	{
		u32acfhigh = u32acfhigh << 1;
	}
	if (u16LowerSrc1 >= u16LowerSrc2)
	{
		u32acflow = u32acflow << 1;
		u32acflow = u32acflow | 0x1;
	}
	else
	{
		u32acflow = u32acflow << 1;
	}
	
	//*p_pALUCFR = ((u32acfhigh << 16))|((u32acflow)&0xffff);
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;  

}
/*1found*****************************************************************
	函数名：		IsEQD16_SZ

	对应指令形式: HRm=HRm==HRn?(HRm-HRn):0(U,k)
                HRm=HRm==HRn?(HRm-HRn):0(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQD16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHT16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHT16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    DSPU16 u16UpperResult = IsHT16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,2);
    DSPU16 u16LowerResult = IsHT16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,2);
    *p_pStatReg = UpperReg | LowerReg;
    //*p_pStatReg &= BIT(8) | BIT(13) ;

    //*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
	
	DSPU32 u32acfhigh = (*p_pALUCFR) >> 16;
	DSPU32 u32acflow = (*p_pALUCFR) & 0xffff;
	
	
	if (u16UpperSrc1 == u16UpperSrc2)
	{
		u32acfhigh = u32acfhigh << 1;
		u32acfhigh = u32acfhigh | 0x1;
	}
	else
	{
		u32acfhigh = u32acfhigh << 1;
	}
	if (u16LowerSrc1 == u16LowerSrc2)
	{
		u32acflow = u32acflow << 1;
		u32acflow = u32acflow | 0x1;
	}
	else
	{
		u32acflow = u32acflow << 1;
	}
	
	//*p_pALUCFR = ((u32acfhigh << 16))|((u32acflow)&0xffff);
	*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
	//*p_pALUCFR = ((u32acfhigh << 16))|((u32acflow)&0xffff);

    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;  
}
/*1found*****************************************************************
	函数名：		IsNEQD16_SZ

	对应指令形式: HRm=HRm!=HRn?(HRm-HRn):0(U,k)
                HRm=HRm!=HRn?(HRm-HRn):0(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQD16_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
//DSPU32 IsHTD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHT16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHT16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    DSPU16 u16UpperResult = IsHT16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,3);
    DSPU16 u16LowerResult = IsHT16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,3);
    
	if ((u16UpperSrc1 < u16UpperSrc2)||(u16LowerSrc1 <u16LowerSrc2 ))
	{
		//*p_pStatReg |= BIT(8) | BIT(13) |BIT(5) | BIT(0) ;
	}
	*p_pStatReg = UpperReg | LowerReg;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
	
	DSPU32 u32acfhigh = (*p_pALUCFR) >> 16;
	DSPU32 u32acflow = (*p_pALUCFR) & 0xffff;
	
	
	if (u16UpperSrc1 != u16UpperSrc2)
	{
		u32acfhigh = u32acfhigh << 1;
		u32acfhigh = u32acfhigh | 0x1;
	}
	else
	{
		u32acfhigh = u32acfhigh << 1;
	}
	if (u16LowerSrc1 != u16LowerSrc2)
	{
		u32acflow = u32acflow << 1;
		u32acflow = u32acflow | 0x1;
	}
	else
	{
		u32acflow = u32acflow << 1;
	}
	
	//*p_pALUCFR = ((u32acfhigh << 16))|((u32acflow)&0xffff);
	*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
	//*p_pALUCFR = ((u32acfhigh << 16))|((u32acflow)&0xffff);
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;          
}

DSPU16 IsHE16_NEW(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU16 *p_pALUCFR, DSPU32 p_u32ALUCR,int oper)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
          
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16Src1 = (DSPI16)p_u16Src1 ;
    DSPI16 i16Src2 = (DSPI16)p_u16Src2 ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i16Src1 >= i16Src2);
		if (oper == 1)
		{
			bolRmIsBiger = (i16Src1 >= i16Src2);
		}
		else if (oper == 2)
		{
			bolRmIsBiger = (i16Src1 == i16Src2);
		}
		else if (oper == 3)
		{
			bolRmIsBiger = (i16Src1 != i16Src2);
		}
		else if (oper == 4)
		{
			bolRmIsBiger = (i16Src1 > i16Src2);
		}
    }
    else
    {
        //bolRmIsBiger = (p_u16Src1 >= p_u16Src2);
		if (oper == 1)
		{
			bolRmIsBiger = (p_u16Src1 >= p_u16Src2);
		}
		else if (oper == 2)
		{
			bolRmIsBiger = (p_u16Src1 == p_u16Src2);
		}
		else if (oper == 3)
		{
			bolRmIsBiger = (p_u16Src1 != p_u16Src2);
		}
		else if (oper == 4)
		{
			bolRmIsBiger = (p_u16Src1 > p_u16Src2);
		}
    }
    
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   //在外面强制执行循环，否则遇到非数不右移 
    
    //如果p_u16Src1 > p_u16Src2，返回p_u16Src1，同时比较标志寄存器的最高位置1；则，返回p_u16Src2 
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 15);
        return p_u16Src1;
    }
    else
    {
        ClearBit(*p_pALUCFR , 15);
        return p_u16Src2;
    }
}

/*1found*****************************************************************
	函数名：		IsHTD16_MN

	对应指令形式: HRm=HRm>HRn?HRm:HRn(U,k)
                HRm=HRm>HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTD16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{

    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
	DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,4);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,4);
    
    *p_pStatReg = UpperReg | LowerReg;
    
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 


}
/*1found*****************************************************************
	函数名：		IsHED16_MN

	对应指令形式: HRm=HRm>=HRn?HRm:HRn(U,k)
                HRm=HRm>=HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHED16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{


    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    	DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,1);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,1);
    *p_pStatReg = UpperReg | LowerReg;
    
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 



}
/*1found*****************************************************************
	函数名：		IsEQD16_MN

	对应指令形式: HRm=HRm==HRn?HRm:HRn(U,k)
                HRm=HRm==HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQD16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,2);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,2);
    *p_pStatReg = UpperReg | LowerReg;
    
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result; 

}
/*1found*****************************************************************
	函数名：		IsNEQD16_MN

	对应指令形式: HRm=HRm!=HRn?HRm:HRn(U,k)
                HRm=HRm!=HRn?HRm:HRn(k)

	描述:		两个源操作数的高16位同高16位，低16位同低16位分别比较；
					ALUCFR也相应分为高16位和低16位使用。
					详细内容参考指令集手册中的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQD16_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
//extern DSPU32 IsHED16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,3);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,3);
    *p_pStatReg = UpperReg | LowerReg;
    
    *p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    return  u32Result;          
}





/*1found*****************************************************************
	函数名：		IsHEF32_SZ

	对应指令形式: FRm=FRm>=FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHEF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
     
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;      
    //有/无符号位在控制寄存器中设置 
    bool bolRmIsBiger;
    Cfloat32 f32Src1(p_u32Src1) ;
    if (f32Src1.IsDNORM())
    {               
        f32Src1.SetZero();                        
    }     
    Cfloat32 f32Src2(p_u32Src2) ;
    if (f32Src2.IsDNORM())
    {               
        f32Src2.SetZero();                        
    }    
        

    if(f32Src1.IsNAN() 
        || f32Src2.IsNAN()
		)
        //|| (f32Src1.IsINF() && f32Src2.IsINF() && ((f32Src1.IsNega() == f32Src2.IsNega())) ))
    {
                
      SetFlag(*p_pStatReg, ALU_Invalid);
      SetFlag(*p_pStatReg, ALU_AIS);
      return N_A_N;
    }
   
    bolRmIsBiger = (f32Src1.GetF32() >= f32Src2.GetF32());
    
    //指令集与X86不一致的地方:+0>-0 
    if (f32Src1.GetU32() == 0x00000000 &&  f32Src2.GetU32() == 0x80000000)
    {
        bolRmIsBiger = true;
    }
	if (f32Src1.GetU32() == 0x80000000 &&  f32Src2.GetU32() == 0x00000000)
    {
        bolRmIsBiger = false;
    }
  
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return SubF32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
            
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }


}
/*1found*****************************************************************
	函数名：		IsEQF32_SZ

	对应指令形式: FRm=FRm== FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 == p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
     
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;      
    //有/无符号位在控制寄存器中设置 
    bool bolRmIsBiger;
    Cfloat32 f32Src1(p_u32Src1) ;
    if (f32Src1.IsDNORM())
    {               
        f32Src1.SetZero();                        
    }     
    Cfloat32 f32Src2(p_u32Src2) ;
    if (f32Src2.IsDNORM())
    {               
        f32Src2.SetZero();                        
    }    
       
    if(f32Src1.IsNAN() 
        || f32Src2.IsNAN() 
		)
        //|| (f32Src1.IsINF() && f32Src2.IsINF() && ((f32Src1.IsNega() == f32Src2.IsNega())) ))
    {
                
      SetFlag(*p_pStatReg, ALU_Invalid);
      SetFlag(*p_pStatReg, ALU_AIS);

	

      return N_A_N;
    }
    
    bolRmIsBiger = (f32Src1.GetF32() == f32Src2.GetF32());
    
    //指令集与X86不一致的地方:+0==-0 
   
	if ((f32Src1.IsDNORM()||f32Src1.IsZero())&&(f32Src2.IsDNORM()||f32Src2.IsZero())&&(f32Src1.IsNega() == f32Src2.IsNega()))
	{
		bolRmIsBiger = true;
	}
    if ((f32Src1.IsDNORM()||f32Src1.IsZero())&&(f32Src2.IsDNORM()||f32Src2.IsZero())&&(f32Src1.IsNega() != f32Src2.IsNega()))
	{
		bolRmIsBiger = false;
	}
	
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return SubF32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
            
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }

}
/*1found*****************************************************************
	函数名：		IsNEQF32_SZ

	对应指令形式: FRm=FRm!= FRn? (FRm-FRn):0{k}

	描述:		如果p_u32Src1 != p_u32Src2，返回(p_u32Src1 - p_u32Src2),同时比较标志寄存器的最低位置1；
					否则，返回0，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQF32_SZ(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     
     
    //先左移一位 
    *p_pALUCFR = *p_pALUCFR << 1;      
    //有/无符号位在控制寄存器中设置 
    bool bolRmIsBiger;
    Cfloat32 f32Src1(p_u32Src1) ;
    if (f32Src1.IsDNORM())
    {               
        f32Src1.SetZero();                        
    }     
    Cfloat32 f32Src2(p_u32Src2) ;
    if (f32Src2.IsDNORM())
    {               
        f32Src2.SetZero();                        
    }    
       
    if(f32Src1.IsNAN() 
        || f32Src2.IsNAN() 
        //|| (f32Src1.IsINF() && f32Src2.IsINF() && ((f32Src1.IsNega() == f32Src2.IsNega())) )
		)
    {
                
      SetFlag(*p_pStatReg, ALU_Invalid);
      SetFlag(*p_pStatReg, ALU_AIS);
      return N_A_N;
    }
    
    bolRmIsBiger = (f32Src1.GetF32() != f32Src2.GetF32());
    
    //指令集与X86不一致的地方:+0>-0 
    
	if ((f32Src1.IsDNORM()||f32Src1.IsZero())&&(f32Src2.IsDNORM()||f32Src2.IsZero())&&(f32Src1.IsNega() != f32Src2.IsNega()))
	{
		bolRmIsBiger = true;
	}
  
    
    //如果p_u32Src1 > p_u32Src2，返回(p_u32Src1 - p_u32Src2),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger)
    {
        SetBit(*p_pALUCFR , 0);
        return SubF32(p_u32Src1, p_u32Src2, p_pStatReg, p_u32ALUCR);
    }
    else
    {
            
        ClearBit(*p_pALUCFR , 0);
        return 0;
    }

}


/*1found*****************************************************************
	函数名：		IsHTF32_MN

	对应指令形式: FRm=FRm> FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 > p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHTF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)

{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
     //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
       
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    
	if ((p_u32Src1 == 0x80000001) &&(p_u32Src2 == 0x80000001))
	{
		//int i = 0;
	}

    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        ClearBit(*p_pALUCFR , 31); 
		if (cf32Src1.GetU32() == 0x80000000 && cf32Src2.GetU32() == 0x80000000)
        {
          //SetBit(*p_pALUCFR , 31);   
		  return 0x80000000;
        }
        if (cf32Src1.GetU32() == 0 || cf32Src2.GetU32() == 0)
        {
            if (cf32Src1.GetU32() == 0 && cf32Src2.GetU32() == 0x80000000)
            {
              SetBit(*p_pALUCFR , 31);   
			  return 0x0;
            }
			
			return 0x0;
        }
        else
        {
          return 0x0;//负0 
        }
    }      
    
    bool bolRmIsBiger;
   
    bolRmIsBiger = (cf32Src1.GetF32() > cf32Src2.GetF32());//原来>= 结果不能实现＝功能 

   
        //在外面强制执行循环，否则结果遇到非数与全0等不右移 14-11-07 15:08
    
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return N_A_N;
    }     
    
    
    //如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger )//14-11-07 16:01
    {
        SetBit(*p_pALUCFR , 31);
        return cf32Src1.GetU32();
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return cf32Src2.GetU32();
    }


}
/*1found*****************************************************************
	函数名：		IsHEF32_MN

	对应指令形式: FRm=FRm>= FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 >= p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsHEF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
     //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
       
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    
    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        SetBit(*p_pALUCFR , 31); 
        if (cf32Src1.GetU32() == 0 || cf32Src2.GetU32() == 0)
        {
            if (cf32Src1.GetU32() == 0x80000000 && cf32Src2.GetU32() == 0)
            {
              ClearBit(*p_pALUCFR , 31);    
            }                   
          return 0;
        }
        else
        {
          return 0x80000000;//负0 
        }
    }      
    
    bool bolRmIsBiger;
   
    bolRmIsBiger = (cf32Src1.GetF32() >= cf32Src2.GetF32());//原来>= 结果不能实现＝功能 

   
        //在外面强制执行循环，否则结果遇到非数与全0等不右移 14-11-07 15:08
    
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return N_A_N;
    }     
    
    
    //如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger )//14-11-07 16:01
    {
        SetBit(*p_pALUCFR , 31);
        return cf32Src1.GetU32();
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return cf32Src2.GetU32();
    }

}
/*1found*****************************************************************
	函数名：		IsEQF32_MN

	对应指令形式: FRm=FRm== FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 == p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsEQF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
     //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
       
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    
    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        SetBit(*p_pALUCFR , 31); 
        
        if (((cf32Src1.GetU32() == 0x80000000 && cf32Src2.GetU32() == 0))||((cf32Src1.GetU32() == 0x0)&&(cf32Src2.GetU32() == 0x80000000)))
        {
          ClearBit(*p_pALUCFR , 31);
		  if ( cf32Src2.GetU32() == 0)
		  {
			return 0x0;
		  }
		  else
		  {
		  
			return 0x80000000;
		  }
        }
		else
		{
			 if ( cf32Src2.GetU32() == 0)
		  {
			return 0x0;
		  }
		  else
		  {
		  
			return 0x80000000;
		  }
		}
        
	
    }      
    
    bool bolRmIsBiger;
   
    bolRmIsBiger = (cf32Src1.GetF32() == cf32Src2.GetF32());//原来>= 结果不能实现＝功能 

   
        //在外面强制执行循环，否则结果遇到非数与全0等不右移 14-11-07 15:08
    
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return N_A_N;
    }     
    
    
    //如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger )//14-11-07 16:01
    {
        SetBit(*p_pALUCFR , 31);
        return cf32Src1.GetU32();
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return cf32Src2.GetU32();
    }
}
/*1found*****************************************************************
	函数名：		IsNEQF32_MN

	对应指令形式: FRm=FRm!=FRn?FRm:FRn{k}

	描述:		如果p_u32Src1 != p_u32Src2，返回p_u32Src1,同时比较标志寄存器的最低位置1；
					否则，返回p_u32Src2，同时比较标志寄存器最低位置0；
					然后比较标志寄存器本身左移一位。

	参数:		p_u32Src1 -- 源操作数1，32位浮点数据。
					p_u32Src2 -- 源操作数2，32位浮点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 IsNEQF32_MN(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
     //先左移一位 
    *p_pALUCFR = *p_pALUCFR >> 1;   
       
    Cfloat32 cf32Src1(p_u32Src1);
    Cfloat32 cf32Src2(p_u32Src2);
    
    if (cf32Src1.IsDNORM())
    {               
        cf32Src1.SetZero();                        
    }         
    if (cf32Src2.IsDNORM())
    {               
        cf32Src2.SetZero();                        
    }  
    if ((p_u32Src1 == 0x80000001) &&(p_u32Src2 == 0x80000001))
	{
		//int i = 0;
	}

    //17-10-07 15:18  修改,认为正0比负0要大 负0比正0要小 
    if (cf32Src1.IsZero() && cf32Src2.IsZero())
    {
        ClearBit(*p_pALUCFR , 31); 
       
        if (cf32Src1.GetU32() == 0x80000000 && cf32Src2.GetU32() == 0)
        {
          SetBit(*p_pALUCFR , 31);
		  return 0x80000000;
        } 
		if (cf32Src2.GetU32() == 0x80000000 && cf32Src1.GetU32() == 0)
        {
          SetBit(*p_pALUCFR , 31);
		  return 0x0;//负0 
        }
		if (cf32Src2.GetU32() == cf32Src1.GetU32())
		{
			return cf32Src1.GetU32();
		}
        //return 0;
    }      
    
    bool bolRmIsBiger;
   
    bolRmIsBiger = (cf32Src1.GetF32() != cf32Src2.GetF32());//原来>= 结果不能实现＝功能 

   
        //在外面强制执行循环，否则结果遇到非数与全0等不右移 14-11-07 15:08
    
    if ( cf32Src1.IsNAN() || cf32Src2.IsNAN() )
    {
        SetFlag(*p_pStatReg, ALU_Invalid);   
        SetFlag(*p_pStatReg, ALU_AIS);  
        return N_A_N;
    }     
    
    
    //如果p_u32Src1 >= p_u32Src2，返回(p_u32Src1),然后比较标志寄存器的最低位置1；
    if (bolRmIsBiger )//14-11-07 16:01
    {
        SetBit(*p_pALUCFR , 31);
        return cf32Src1.GetU32();
    }
    else
    {
        ClearBit(*p_pALUCFR , 31);
        return cf32Src2.GetU32();
    }

}



/*1found*****************************************************************
	函数名：		ACFIsHT32
	
	对应指令形式: ACFs=Rm>Rn?1:0(U)
                ACFs=Rm>Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm > p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHT32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{
	//*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) | BIT(ALU_AIS); 
         
	/*
    //有/无符号位在控制寄存器中设置 
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
    DSPI32 i32Src2 = (DSPI32)p_u32Rn ;
    if (bolSigned)
    {
        //bolRmIsBiger = (i32Src1 >= i32Src2);
		bolRmIsBiger = (i32Src1 > i32Src2);
    }
    else
    {
        //bolRmIsBiger = (p_u32Src1 >= p_u32Src2);
		bolRmIsBiger = (p_u32Rm > p_u32Rn);
    }
    */
    //先左移一位 
    //*p_pALUCFR = *p_pALUCFR >> 1;   
    
    //如果p_u32Src1 > p_u32Src2，返回p_u32Src1，同时比较标志寄存器的最低位置1；则，返回p_u32Src2
    /*
	if (bolRmIsBiger)
    {
        //SetBit(*p_pALUCFR , 31);
        //return p_u32Src1;
    }
    else
    {
        //ClearBit(*p_pALUCFR , 31);
        //return p_u32Src2;
    }
	*/
	IsHT32_MN( p_u32Rm,  p_u32Rn,  p_pStatReg,  p_pALUCFR,  p_u32ALUCR);

}
/*1found*****************************************************************
	函数名：		ACFIsHE32
	
	对应指令形式: ACFs=Rm>=Rn?1:0(U)
                ACFs=Rm>=Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm >= p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHE32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{


	IsHE32_MN( p_u32Rm,  p_u32Rn, p_pStatReg, p_pALUCFR,  p_u32ALUCR); // GRui
}
/*1found*****************************************************************
	函数名：		ACFIsEQ32
	
	对应指令形式: ACFs=Rm==Rn?1:0(U)
                ACFs=Rm==Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm == p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQ32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{


	IsEQ32_MN( p_u32Rm,  p_u32Rn, p_pStatReg,p_pALUCFR,  p_u32ALUCR);
}

/*1found*****************************************************************
	函数名：		ACFIsNEQ32
	
	对应指令形式: ACFs=Rm!=Rn?1:0(U)
                ACFs=Rm!=Rn?1:0

	描述:		32位定点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm != p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQ32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{

	IsNEQ32_MN(p_u32Rm, p_u32Rn, p_pStatReg, p_pALUCFR,  p_u32ALUCR);
}


/*1found*****************************************************************
	函数名：		ACFIsHTD16

	对应指令形式: ACFs=HRm>HRn?1:0(U)
                ACFs=HRm>HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm>HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm>LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHTD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	/*
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
	DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,4);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,4);
    */
    //*p_pStatReg = UpperReg | LowerReg;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    //DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
	IsHTD16_MN(p_u32Src1, p_u32Src2, p_pStatReg, p_pALUCFR, p_u32ALUCR);
    //return  u32Result; 


}
/*1found*****************************************************************
	函数名：		ACFIsHED16

	对应指令形式: ACFs=HRm>=HRn?1:0(U)
                ACFs=HRm>=HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm>=HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm>=LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHED16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	/*
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    	DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,1);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,1);
    *p_pStatReg = UpperReg | LowerReg;
    */
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    //DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
	IsHED16_MN( p_u32Src1,  p_u32Src2, p_pStatReg, p_pALUCFR,  p_u32ALUCR);
    //return  u32Result; 


}
/*1found*****************************************************************
	函数名：		ACFIsEQD16

	对应指令形式: ACFs=HRm==HRn?1:0(U)
                ACFs=HRm==HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm==HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm==LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	/*
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    	DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,2);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,2);
	*/   
	//*p_pStatReg = UpperReg | LowerReg;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    //DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
	IsEQD16_MN( p_u32Src1,  p_u32Src2, p_pStatReg, p_pALUCFR,  p_u32ALUCR);
    //return  u32Result; 


}


/*1found*****************************************************************
	函数名：		ACFIsNEQD16

	对应指令形式: ACFs=HRm!=HRn?1:0(U)
                ACFs=HRm!=HRn?1:0

	描述:		双16位定点数据比较。比较结果只改变比较标志，将比较标志放入ACF寄存器。
          该指令对操作数的高低16位分别进行比较，比较标志寄存器也相应地分成高低16位，根据比较的结果分别置位比较标志寄存器的最低位。
          如果HHRm!=HHRn，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器高16位左移1位；
          如果LHRm!=LHRn，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器低16位左移1位。
          该指令的操作顺序是：
              先将比较标志寄存器低16位左移1位，然后再在比较标志寄存器的第[0]位置0或置1；
              再将比较标志寄存器的高16位左移1位，再在比较标志寄存器的第[16]位置0或置1。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	/*
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);    
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
    DSPU16 u16UpperResult = IsHE16_NEW(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR,3);
    DSPU16 u16LowerResult = IsHE16_NEW(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR,3);
    */
	//*p_pStatReg = UpperReg | LowerReg;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 16) | ((DSPU32)LowerCFR);
     
    //DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);
	IsNEQD16_MN( p_u32Src1,  p_u32Src2, p_pStatReg, p_pALUCFR,  p_u32ALUCR);
    //return  u32Result;  

}


/*1found*****************************************************************
	函数名：		ACFIsHTF32
	
	对应指令形式: ACFs=FRm>FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm > p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHTF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{

    IsHTF32_MN(p_u32Rm, p_u32Rn, p_pStatReg, p_pALUCFR, p_u32ALUCR);

}
/*1found*****************************************************************
	函数名：		ACFIsHEF32
	
	对应指令形式: ACFs=FRm>=FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm >= p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHEF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{


    IsHEF32_MN(p_u32Rm, p_u32Rn, p_pStatReg, p_pALUCFR,  p_u32ALUCR);

}
/*1found*****************************************************************
	函数名：		ACFIsEQF32
	
	对应指令形式: ACFs=FRm==FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm == p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{

	IsEQF32_MN( p_u32Rm,  p_u32Rn, p_pStatReg, p_pALUCFR,  p_u32ALUCR);
}

/*1found*****************************************************************
	函数名：		ACFIsNEQF32
	
	对应指令形式: ACFs=FRm!=FRn?1:0

	描述:		32位浮点数据比较。不改变源操作数的内容而只要得到比较标志，将比较标志放入ACF寄存器。
					如果p_u32Rm != p_u32Rn，比较标志寄存器的最低位置‘1’；否则，比较标志寄存器最低位置‘0’。
					比较标志寄存器本身左移一位。该指令的操作顺序是：先将比较标志寄存器左移，然后再在比较标志寄存器的最低位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQF32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{
	
	IsNEQF32_MN( p_u32Rm,  p_u32Rn, p_pStatReg, p_pALUCFR,  p_u32ALUCR);
}

/*1found*****************************************************************
	函数名：		Add32CA
	
	对应指令形式: ACCs=Rm+Rn+Ca
	              ACCs=Rm+Rn+Ca(U)
	              ACCs=Rm+Rn（U）
                  ACCs=Rm+Rn

	描述:			32位定点数进位加法指令，结果输出至ACC中，其中Ca是ACCs 中的进位标志位，Ca的取值为0或者1；
	          该指令运算结果影响溢出标志位。溢出时，标志寄存器中的溢出标志位设置为“1”，否则标志寄存器中的溢出标志位设置为“0”。
   					该指令运算结果影响进位标志位。当运算有进位时，Ca为1，否则为0。

	参数:			  p_u32Rm -- 源操作数1。
					  p_u32Rn -- 源操作数2。
					  p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					  p_u32ALUCR[0] == 1： 源操作数为有符号数
					  p_u32ALUCR[0] == 0： 源操作数为无符号数
					  
					  p_ACC -- 累加寄存器中的值，共48位。
					  p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					  p_u32CA -- ACC 中的进位标志寄存器，仅最低位有效。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern void Add32CA(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 &p_u32CA,DSPU32 p_CaIn)
{
	if (p_u32Rm == 0xbf205925)
	{
	int i= 9;
	}
	DSP_BIT40 bit40ACC;
	bit40ACC.u32Low = 0;
	bit40ACC.u8High = 0;
	//bit40ACC.u8Exp = 0;
	DSPU32 carry = 0;
	//DSPU32 tempp_pStatReg = 0;
	DSPU32 temp1 = 0;
	if (((p_u32Rm & 0x80000000) == 0x80000000)
		&&(p_CaIn == 1)
		)
	{
		temp1 = Add32(p_u32Rm, p_u32CA, p_pStatReg,  p_u32ALUCR);
	
		if (((*p_pStatReg)&0x1) == 0x1)
		{
			//p_u32CA = 1;
			carry = 1;
		}
	}
	else
	{
		temp1 = Add32(p_u32Rm, p_u32Rn, p_pStatReg,  p_u32ALUCR);
	
		if (((*p_pStatReg)&0x1) == 0x1)
		{
			//p_u32CA = 1;
			carry = 1;
		}
	}

	ACCAdd32(p_u32Rm, &bit40ACC, p_pStatReg,  p_u32ALUCR);
	ACCAdd32(p_u32Rn, &bit40ACC, p_pStatReg,  p_u32ALUCR);
	if (p_CaIn == 1)
	{
		ACCAdd32(p_u32CA, &bit40ACC, p_pStatReg,  p_u32ALUCR);
		if ((p_u32Rm & 0x80000000) == 0x80000000)
		{
			Add32(temp1, p_u32Rn, p_pStatReg,  p_u32ALUCR);
			if (((*p_pStatReg)&0x1) == 0x1)
			{
				//p_u32CA = 1;
				carry = 1;
			}
		}
		else
		{
			Add32(temp1, p_u32CA, p_pStatReg,  p_u32ALUCR);
			if (((*p_pStatReg)&0x1) == 0x1)
			{
				//p_u32CA = 1;
				carry = 1;
			}
		}
			
		
	}
	
	p_u32CA = carry;
	p_ACC.u32Low = bit40ACC.u32Low;
	p_ACC.u8Mid  = bit40ACC.u8High;
	p_ACC.u8High = 0x0;
	//*p_pStatReg = 0;
}

/*1found*****************************************************************
	函数名：		Sub32CA
	
	对应指令形式: ACCs=Rm-Rn-Ca(U)
                  ACCs=Rm-Rn-Ca
                  ACCs=Rm-Rn(U)
                  ACCs=Rm-Rn

	描述:			32位定点数进位减法指令，结果输出至ACC中，其中Ca是ACCs 中的进位标志位，Ca的取值为0或者1；  // GRQ：待新版指令集确定
	          该指令运算结果影响溢出标志位。溢出时，标志寄存器中的溢出标志位设置为“1”，否则标志寄存器中的溢出标志位设置为“0”。
   					该指令运算结果影响进位标志位。当运算有进位时，Ca为1，否则为0。  // GRQ

	参数:			  p_u32Rm -- 源操作数1。
					  p_u32Rn -- 源操作数2。
					  p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					  p_u32ALUCR[0] == 1： 源操作数为有符号数
					  p_u32ALUCR[0] == 0： 源操作数为无符号数
					  
					  p_ACC -- 累加寄存器中的值，共48位。
					  p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					  p_u32CA -- ACC 中的进位标志寄存器，仅最低位有效。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern void Sub32CA(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 &p_u32CA,DSPU32 p_CaIn)
{


	if ((p_u32Rm == 0x7fffffff)
		&&(p_u32Rn==0xffffffff)
		)
	{
		int i= 9;
	}
	DSP_BIT40 bit40ACC;
	bit40ACC.u32Low = 0;
	bit40ACC.u8High = 0;
	//bit40ACC.u8Exp = 0;
	DSPU32 carry = 0;
	//DSPU32 tempp_pStatReg = 0;
	//DSPU32 temp1 = Sub32(p_u32Rm, p_u32Rn, p_pStatReg,  p_u32ALUCR);
	
	DSPU32 temp1 = p_u32Rm;
	ACCAdd32(p_u32Rm, &bit40ACC, p_pStatReg,  p_u32ALUCR);
	if (p_CaIn == 1)
	{
		ACCSub32(p_u32CA, &bit40ACC, p_pStatReg,  p_u32ALUCR);
		//Sub32(temp1, p_u32CA, p_pStatReg,  p_u32ALUCR);
	}
	if ((p_u32Rm &0x80000000) == 0x0)
	{
		if (p_CaIn == 1)
		{
			temp1 = Sub32(p_u32Rm, p_u32CA, p_pStatReg,  p_u32ALUCR);
			if (((*p_pStatReg)&0x1) == 0x1)
			{
				//p_u32CA = 1;
				carry = 1;
			}
		}
		Sub32(temp1, p_u32Rn, p_pStatReg,  p_u32ALUCR);
		if (((*p_pStatReg)&0x1) == 0x1)
		{
			//p_u32CA = 1;
			carry = 1;
		}
	}
	else
	{
		temp1 = Sub32(p_u32Rm, p_u32Rn, p_pStatReg,  p_u32ALUCR);
		if (((*p_pStatReg)&0x1) == 0x1)
		{
			//p_u32CA = 1;
			carry = 1;
		}
		if (p_CaIn == 1)
		{
			 Sub32(temp1, p_u32CA, p_pStatReg,  p_u32ALUCR);
			if (((*p_pStatReg)&0x1) == 0x1)
			{
				//p_u32CA = 1;
				carry = 1;
			}
		}
		
	}
	ACCSub32(p_u32Rn, &bit40ACC, p_pStatReg,  p_u32ALUCR);
	
	p_u32CA = carry;
	
	p_ACC.u32Low = bit40ACC.u32Low;
	p_ACC.u8Mid  = bit40ACC.u8High;
	p_ACC.u8High = 0x0;
	if ((p_u32ALUCR & 0x1) == 0x1)
	{
		DSPI32 isrc1 = p_u32Rm;
		DSPI32 isrc2 = p_u32Rn;
		if (isrc1 < isrc2)
		{
			if ((p_ACC.u32Low &0x80000000) == 0x80000000 )
			{
				p_ACC.u8Mid = 0xFF;
			}
		}
	}
	//*p_pStatReg = 0;


}

/*1found*****************************************************************
	函数名：		IsEQ16SZ
	
	对应指令形式: HHRs=HHRm==LHRm?(HHRm-LHRm):0(U,k) 
	              HHRs=HHRm==LHRm?(HHRm-LHRm):0(k)
	              LHRs=HHRm==LHRm?(HHRm-LHRm):0(U,k) 
	              LHRs=HHRm==LHRm?(HHRm-LHRm):0(k)

	描述:			如果高16位等于低16位，则输出(HHRm-LHRm),并且ACF左移一位之后最低位置1；
	          否则输出0,并且ACF左移一位之后最低位置0。

	参数:		p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsEQ16SZ(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
//extern DSPU16 IsHT16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16UpperSrc = (DSPI16)u16UpperSrc ;
    DSPI16 i16LowerSrc = (DSPI16)u16LowerSrc ;
	
	////2008.10.23 addd
	//DSPU32 UpperReg = *p_pStatReg;
    //DSPU32 LowerReg = *p_pStatReg;
	DSPU32 UpperReg = 0;
    DSPU32 LowerReg = 0;
	DSPU32 Result = 0;
 
	///只是空的参数，没有实际效果
	DSPU16 LowerCFR = 0;

	//先左移一位
    *p_pALUCFR = *p_pALUCFR << 1;   // SetBit(*p_pALUCFR , 0); ClearBit(*p_pALUCFR , 0);   

    if (bolSigned)
    {
        //bolRmIsBiger = (i16UpperSrc > i16LowerSrc);
		bolRmIsBiger = (i16UpperSrc == i16LowerSrc);

    }
    else
    {
        //bolRmIsBiger = (u16UpperSrc > u16LowerSrc);
		bolRmIsBiger = (u16UpperSrc == u16LowerSrc);
    }
    
    if (bolRmIsBiger)
    {
		SetBit(*p_pALUCFR , 0);
		//大于输出差值到高16位
		
		Result =  IsHT16(u16UpperSrc, u16LowerSrc, p_pStatReg, &LowerCFR, p_u32ALUCR);
		
		
    }
    else
    {
		//小于输出0
		ClearBit(*p_pALUCFR , 0);        
		
		Result =  0;
		
		
    }

	//*p_pStatReg =  LowerReg;

	return Result ;


}
/*1found*****************************************************************
	函数名：		IsEQ16HL
	
	对应指令形式: HHRs=HHRm==LHRm?HHRm:LHRm(U,k)
	              HHRs=HHRm==LHRm?HHRm:LHRm(k)
                LHRs=HHRm==LHRm?HHRm:LHRm(U,k)                
                LHRs=HHRm==LHRm?HHRm:LHRm(k)

	描述:			如果高16位等于低16位，则输出(HHRm-LHRm),并且ACF左移一位之后最低位置1；
	          否则输出0,并且ACF左移一位之后最低位置0。

	参数:		p_u32Src -- 源操作数，包括高低16位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU16 IsEQ16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
//extern DSPU16 IsHE16HL(DSPU32 p_u32Src, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR,DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    
    
    DSPU16 u16UpperSrc = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc = (DSPU16)(p_u32Src);
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i16UpperSrc = (DSPI16)u16UpperSrc ;
    DSPI16 i16LowerSrc = (DSPI16)u16LowerSrc ;

	//先右移一位 
    *p_pALUCFR = (*p_pALUCFR) >> 1;   

    if (bolSigned)
    {
		bolRmIsBiger = (i16UpperSrc == i16LowerSrc);
    }
    else
    {
		bolRmIsBiger = (u16UpperSrc == u16LowerSrc);
    }
    
    if (bolRmIsBiger)
    {
		SetBit(*p_pALUCFR , 31);       
		return u16UpperSrc;
    }
    else
    {
		ClearBit(*p_pALUCFR , 31);        
		return u16LowerSrc;
    }

}


/*1found*****************************************************************
	函数名：		ACCToQ8
	
	对应指令形式: ORs=OACCm(U,cut=C)
                ORs=OACCm(cut=C)

	描述:			  累加结果寄存器ACC截位输出为4个8位定点数据。

	参数:			  p_u40ACC -- 40位累加结果。
					    p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					    p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
  					    p_u32ALUCR[0] == 1： 源操作数为有符号数
	  				    p_u32ALUCR[0] == 0： 源操作数为无符号数
					    p_intCutPos -- 截位信息。
					    
	
	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位；


	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/

extern DSPU32 ACCToQ8(const DSP_BIT48 &p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)  // 使用常引用提高传参效率
//extern DSPU32 ACCToD16(DSP_BIT40 p_u40ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, int p_intCutPos)    
{
	
	//*p_pStatReg &= BIT(8) | BIT(12) ;//| BIT(ALU_AOS) |  BIT(ALU_AOS) | BIT(ALU_AIS);    

	DSPU32 u32ACCHign = (DSPU32)p_u40ACC.u8Mid << 12 | p_u40ACC.u32Low >> 20;   //左边8位加上后边12个0共20位,右边32位右移20位剩高12位补左边的12位空 
    DSPU32 u32ACCLow  = p_u40ACC.u32Low & 0x000fffff; //低20位 
    //

	DSPU32 u32ACCHign1 = u32ACCHign & 0x000003ff; //低10位   
	DSPU32 u32ACCHign2 = (u32ACCHign & 0x000ffc00) >> 10; //低10位;   
    DSPU32 u32ACCLow1  = p_u40ACC.u32Low & 0x000003ff; //低10位
	DSPU32 u32ACCLow2  = (p_u40ACC.u32Low & 0x000ffc00) >> 10; //低10位
	//
    //DSPU20 uACCHign(u32ACCHign); 
    //DSPU20 uACCLow (u32ACCLow);
	
	//
	DSPU10 uACCHign1(u32ACCHign1); 
    DSPU10 uACCLow1 (u32ACCLow1);
	DSPU10 uACCHign2(u32ACCHign2); 
    DSPU10 uACCLow2 (u32ACCLow2);
	//
    //DSP_BIT20 u20ACCHign = uACCHign.GetDSPBIT();
    //DSP_BIT20 u20ACCLow  = uACCLow.GetDSPBIT();
    
	//
	DSP_BIT20 u20ACCHign1 = uACCHign1.GetDSP10BIT();
    DSP_BIT20 u20ACCLow1  = uACCLow1.GetDSP10BIT();
	DSP_BIT20 u20ACCHign2 = uACCHign2.GetDSP10BIT();
    DSP_BIT20 u20ACCLow2  = uACCLow2.GetDSP10BIT();
	//
    //DSPU32 UpperReg = *p_pStatReg;
    //DSPU32 LowerReg = *p_pStatReg;
	DSPU32 UpperReg1 = *p_pStatReg;
    DSPU32 LowerReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 LowerReg2 = *p_pStatReg;
    
    //DSPU16 u16UpperResult = ACCTo16(u20ACCHign, &UpperReg, p_u32ALUCR, p_intCutPos);
    //DSPU16 u16LowerResult = ACCTo16(u20ACCLow,  &LowerReg, p_u32ALUCR, p_intCutPos);
	if ((p_u40ACC.u32Low == 0x43f2c38c) && (p_u40ACC.u8Mid == 0x2a))
	{
		//int i = 0;
	}
	DSPU16 u16UpperResult1 = ACCTo8(u20ACCHign1, &UpperReg1, p_u32ALUCR, p_intCutPos);
    DSPU16 u16LowerResult1 = ACCTo8(u20ACCLow1,  &LowerReg1, p_u32ALUCR, p_intCutPos); 
	DSPU16 u16UpperResult2 = ACCTo8(u20ACCHign2, &UpperReg2, p_u32ALUCR, p_intCutPos);
    DSPU16 u16LowerResult2 = ACCTo8(u20ACCLow2,  &LowerReg2, p_u32ALUCR, p_intCutPos); 
    
	u16UpperResult1 = u16UpperResult1 & 0xff;
	u16LowerResult1 = u16LowerResult1 & 0xff;
	u16UpperResult2 = u16UpperResult2 & 0xff;
	u16LowerResult2 = u16LowerResult2 & 0xff;
    //*p_pStatReg = UpperReg1 | LowerReg1 |UpperReg2 | LowerReg2;
     
    DSPU32 u32Result =  (((DSPU32)u16UpperResult2) << 24) |(((DSPU32)u16UpperResult1) << 16) |(((DSPU32)u16LowerResult2) << 8) | ((DSPU32)u16LowerResult1);
    //added by flyu on 20130322
	DSPU32 src1 = p_u40ACC.u32Low & 0xff;
	DSPU32 src1y = p_u40ACC.u32Low & 0x300;
	DSPU32 src2 =  p_u40ACC.u32Low & 0x3fc00;
	DSPU32 src2y = p_u40ACC.u32Low & 0xc0000;
	DSPU32 src3 =  p_u40ACC.u32Low & 0xff00000;
	DSPU32 src3y = p_u40ACC.u32Low & 0x30000000;
	DSPU32 src4 =  (p_u40ACC.u32Low & 0xc0000000)>>30;
	src4 = src4 |  (p_u40ACC.u8High << 2);
	DSPU32 src4y = p_u40ACC.u8High & 0xc0;
	*p_pStatReg = UpperReg1 | LowerReg1 | UpperReg2 | LowerReg2;
	if ((src1y != 0x0)||(src2y != 0x0)||(src3y != 0x0)||(src4y != 0x0))
	{
		//*p_pStatReg |= BIT(8) | BIT(12) |BIT(0) | BIT(4) ;
	}
	u32Result = u16LowerResult1 |(u16LowerResult2 << 8 )|(DSPU32)(u16UpperResult1 << 16 )|(DSPU32)(u16UpperResult2 << 24 );
	//end
    return  u32Result;      
    
}

/*1found*****************************************************************
	函数名：		LShift32ACF
	
	对应指令形式: Rs=Rm shift ACFk(c)

	描述:		将寄存器Rm数据逻辑左移，低位移入ACFk中的值，移入的数据为ACFk[C:0]。并将移位结果存入Rs中。

	参数:		p_u32Rm -- 源操作数1。
					p_u32ALUCFR -- ACF寄存器。
					p_u32Len -- 移位数，即C。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。						
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 LShift32ACF(DSPU32 p_u32Rm, DSPU32 &p_u32ALUCFR, DSPU32 p_u32Len, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg)
{
	DSPU32 len = (p_u32Len & 0x3)+1;
	DSPU32 u32Hign = p_u32Rm  << len;
	DSPU32 u32Low  = 0;
	DSPU32 u32LenArr[32] = {0x1,0x3,0x7,0xf,
							0x1f,0x3f,0x7f,0xff,
							0x1ff,0x3ff,0x7ff,0xfff,
							0x1fff,0x3fff,0x7fff,0xffff,
							0x1ffff,0x3ffff,0x7ffff,0xfffff,
							0x1fffff,0x3fffff,0x7fffff,0xffffff,
							0x1ffffff,0x3ffffff,0x7ffffff,0xfffffff,
							0x1fffffff,0x3fffffff,0x7fffffff,0xffffffff,
							};
     u32Low  = p_u32ALUCFR & u32LenArr[len-1]; 

	return u32Hign | u32Low;

}
/*1found*****************************************************************
	函数名：		LShiftD16ACF
	
	对应指令形式: HRs=HRm shift ACFk(c)

	描述:		双16位无符号定点数移位，将寄存器Rm数据逻辑左移，低位移入ACFk中的值，移入的数据为ACFk[C:0]。并将移位结果存入Rs中。

	参数:		p_u32Rm -- 源操作数1。
					p_u32ALUCFR -- ACF寄存器。
					p_u32Len -- 移位数，即C。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。						
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
//
extern DSPU32 LShiftD16ACF(DSPU32 p_u32Rm, DSPU32 p_u32ALUCFR, DSPU32 p_u32Len, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg)
{

	if (p_u32Rm == 0x25b654f3)
	{
		int i =0 ;
	
	}
	DSPU32 u16RmH = p_u32Rm >> 16;
	DSPU32 u16RmL = p_u32Rm & 0xFFFF;

	DSPU32 u16AcfH = p_u32ALUCFR >> 16;
	DSPU32 u16AcfL = p_u32ALUCFR & 0xFFFF;
	
	DSPU32 resultH = LShift32ACF( u16RmH, u16AcfH,  p_u32Len,  p_u32ALUCR, p_pStatReg);
	DSPU32 resultL = LShift32ACF( u16RmL, u16AcfL,  p_u32Len,  p_u32ALUCR, p_pStatReg);
	//*p_pStatReg &= BIT(8) |BIT(9) | BIT(11)| BIT(12);
	resultH = resultH & 0xffff;
	resultL = resultL & 0xffff;
	DSPU32 result = 0; 
	result = (resultH << 16)|(resultL & 0xffff);
	
	return result;
}

/*1found*****************************************************************
	函数名：		AccAddHH32
	
	对应指令形式: Rs=HHACCm+Rm(U)

	描述:			将ACCm[31:16]与Rm中的32位无符号数据相加，结果赋给目的寄存器Rs。

	参数:		p_u32Src -- 源操作数1。
					p_ACC -- 48位累加结果寄存器中的值。 
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/

extern DSPU32 AccAddHH32(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	
	DSPU32 srcAcc = p_ACC.u32Low >> 16;
	//DSPU32 result = p_u32Src + srcAcc;
	DSPU32 result = Add32(p_u32Src, srcAcc, p_pStatReg,  p_u32ALUCR);
	return result;

}


/*1found*****************************************************************
	函数名：		ACFIsHTQ8
	
	对应指令形式: ACFk=ORm>ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]>Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]>Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]>Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]>Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHTQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{
	DSPU32 p_u32Src1 = p_u32Rm;
	DSPU32 p_u32Src2 = p_u32Rn;

	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
	//
	DSPU16 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU16 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU16 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU16 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);
    DSPU16 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU16 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU16 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU16 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);
	//
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    //
	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;
	//
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);  
	//
	DSPU16 UpperCFR1 = (DSPU8)(*p_pALUCFR );
    DSPU16 UpperCFR2 = (DSPU8)(*p_pALUCFR >> 8);
	DSPU16 UpperCFR3 = (DSPU8)(*p_pALUCFR >> 16);
    DSPU16 UpperCFR4 = (DSPU8)(*p_pALUCFR >> 24);
	//
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
	DSPU16 u16UpperResult = IsHE16_NEW(u16Upper1Src1, u16Lower1Src2, &UpperReg1, &UpperCFR1, p_u32ALUCR,4);
    DSPU16 u16LowerResult = IsHE16_NEW(u16Upper2Src1, u16Lower2Src2, &UpperReg2, &UpperCFR2, p_u32ALUCR,4);
		   u16UpperResult = IsHE16_NEW(u16Upper3Src1, u16Lower3Src2, &UpperReg3, &UpperCFR3, p_u32ALUCR,4);
		   u16LowerResult = IsHE16_NEW(u16Upper4Src1, u16Lower4Src2, &UpperReg4, &UpperCFR4, p_u32ALUCR,4);

    *p_pStatReg = UpperReg1 | UpperReg2 | UpperReg3 |UpperReg4;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 24) |(((DSPU32)UpperCFR) << 16) |(((DSPU32)UpperCFR) << 8) | ((DSPU32)LowerCFR);
     
    //added by flyu on 20130419
	DSPU8 alucfr1 = (*p_pALUCFR) & 0xff;
	DSPU8 alucfr2 = ((*p_pALUCFR) & (0xff00)) >> 8;
	DSPU8 alucfr3 = ((*p_pALUCFR) & (0xff0000)) >> 16;
	DSPU8 alucfr4 = ((*p_pALUCFR) & (0xff000000)) >> 24;
	if (u16Upper1Src1 > u16Lower1Src2)
	{
		alucfr1 = (alucfr1 >> 1) | 0x80;
	}
	else
	{
		alucfr1 = (alucfr1 >> 1);
	}
	if (u16Upper2Src1 > u16Lower2Src2)
	{
		alucfr2 = (alucfr2 >> 1) | 0x80;
	}
	else
	{
		alucfr2 = (alucfr2 >> 1);
	}
	if (u16Upper3Src1 > u16Lower3Src2)
	{
		alucfr3 = (alucfr3 >> 1) | 0x80;
	}
	else
	{
		alucfr3 = (alucfr3 >> 1);
	}
	if (u16Upper4Src1 > u16Lower4Src2)
	{
		alucfr4 = (alucfr4 >> 1) | 0x80;
	}
	else
	{
		alucfr4 = (alucfr4 >> 1);
	}

	*p_pALUCFR = (((DSPU32)alucfr4) << 24) |(((DSPU32)alucfr3) << 16) |(((DSPU32)alucfr2) << 8) | ((DSPU32)alucfr1);
	//end
	
	//DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    //return  u32Result; 


}
/*1found*****************************************************************
	函数名：		ACFIsHEQ8
	
	对应指令形式: ACFk=ORm>=ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]>=Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]>=Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]>=Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]>=Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsHEQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{
	DSPU32 p_u32Src1 = p_u32Rm;
	DSPU32 p_u32Src2 = p_u32Rn;
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
	//
	DSPU16 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU16 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU16 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU16 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);
    DSPU16 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU16 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU16 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU16 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);
	//
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    //
	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;
	//
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);  
	//
	DSPU16 UpperCFR1 = (DSPU8)(*p_pALUCFR );
    DSPU16 UpperCFR2 = (DSPU8)(*p_pALUCFR >> 8);
	DSPU16 UpperCFR3 = (DSPU8)(*p_pALUCFR >> 16);
    DSPU16 UpperCFR4 = (DSPU8)(*p_pALUCFR >> 24);
	//
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
	DSPU16 u16UpperResult = IsHE16_NEW(u16Upper1Src1, u16Lower1Src2, &UpperReg1, &UpperCFR1, p_u32ALUCR,3);
    DSPU16 u16LowerResult = IsHE16_NEW(u16Upper2Src1, u16Lower2Src2, &UpperReg2, &UpperCFR2, p_u32ALUCR,3);
		   u16UpperResult = IsHE16_NEW(u16Upper3Src1, u16Lower3Src2, &UpperReg3, &UpperCFR3, p_u32ALUCR,3);
		   u16LowerResult = IsHE16_NEW(u16Upper4Src1, u16Lower4Src2, &UpperReg4, &UpperCFR4, p_u32ALUCR,3);

    *p_pStatReg = UpperReg1 | UpperReg2 | UpperReg3 |UpperReg4;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 24) |(((DSPU32)UpperCFR) << 16) |(((DSPU32)UpperCFR) << 8) | ((DSPU32)LowerCFR);
    
    
	
	    //added by flyu on 20130419
	DSPU8 alucfr1 = (*p_pALUCFR) & 0xff;
	DSPU8 alucfr2 = ((*p_pALUCFR) & (0xff00)) >> 8;
	DSPU8 alucfr3 = ((*p_pALUCFR) & (0xff0000)) >> 16;
	DSPU8 alucfr4 = ((*p_pALUCFR) & (0xff000000)) >> 24;
	if (u16Upper1Src1 >= u16Lower1Src2)
	{
		alucfr1 = (alucfr1 >> 1) | 0x80;
	}
	else
	{
		alucfr1 = (alucfr1 >> 1);
	}
	if (u16Upper2Src1 >= u16Lower2Src2)
	{
		alucfr2 = (alucfr2 >> 1) | 0x80;
	}
	else
	{
		alucfr2 = (alucfr2 >> 1);
	}
	if (u16Upper3Src1 >= u16Lower3Src2)
	{
		alucfr3 = (alucfr3 >> 1) | 0x80;
	}
	else
	{
		alucfr3 = (alucfr3 >> 1);
	}
	if (u16Upper4Src1 >= u16Lower4Src2)
	{
		alucfr4 = (alucfr4 >> 1) | 0x80;
	}
	else
	{
		alucfr4 = (alucfr4 >> 1);
	}

	*p_pALUCFR = (((DSPU32)alucfr4) << 24) |(((DSPU32)alucfr3) << 16) |(((DSPU32)alucfr2) << 8) | ((DSPU32)alucfr1);
	//end
	
	
	
	
	
	//DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    //return  u32Result; 

}
/*1found*****************************************************************
	函数名：		ACFIsEQQ8
	
	对应指令形式: ACFk=ORm==ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]==Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]==Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]==Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]==Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsEQQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{
	DSPU32 p_u32Src1 = p_u32Rm;
	DSPU32 p_u32Src2 = p_u32Rn;
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
	//
	DSPU16 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU16 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU16 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU16 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);
    DSPU16 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU16 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU16 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU16 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);
	//
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    //
	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;
	//
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);  
	//
	DSPU16 UpperCFR1 = (DSPU8)(*p_pALUCFR );
    DSPU16 UpperCFR2 = (DSPU8)(*p_pALUCFR >> 8);
	DSPU16 UpperCFR3 = (DSPU8)(*p_pALUCFR >> 16);
    DSPU16 UpperCFR4 = (DSPU8)(*p_pALUCFR >> 24);
	//
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
	DSPU16 u16UpperResult = IsHE16_NEW(u16Upper1Src1, u16Lower1Src2, &UpperReg1, &UpperCFR1, p_u32ALUCR,2);
    DSPU16 u16LowerResult = IsHE16_NEW(u16Upper2Src1, u16Lower2Src2, &UpperReg2, &UpperCFR2, p_u32ALUCR,2);
		   u16UpperResult = IsHE16_NEW(u16Upper3Src1, u16Lower3Src2, &UpperReg3, &UpperCFR3, p_u32ALUCR,2);
		   u16LowerResult = IsHE16_NEW(u16Upper4Src1, u16Lower4Src2, &UpperReg4, &UpperCFR4, p_u32ALUCR,2);

    *p_pStatReg = UpperReg1 | UpperReg2 | UpperReg3 |UpperReg4;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 24) |(((DSPU32)UpperCFR) << 16) |(((DSPU32)UpperCFR) << 8) | ((DSPU32)LowerCFR);
     




	//added by flyu on 20130419
	DSPU8 alucfr1 = (*p_pALUCFR) & 0xff;
	DSPU8 alucfr2 = ((*p_pALUCFR) & (0xff00)) >> 8;
	DSPU8 alucfr3 = ((*p_pALUCFR) & (0xff0000)) >> 16;
	DSPU8 alucfr4 = ((*p_pALUCFR) & (0xff000000)) >> 24;
	if (u16Upper1Src1 == u16Lower1Src2)
	{
		alucfr1 = (alucfr1 >> 1) | 0x80;
	}
	else
	{
		alucfr1 = (alucfr1 >> 1);
	}
	if (u16Upper2Src1 == u16Lower2Src2)
	{
		alucfr2 = (alucfr2 >> 1) | 0x80;
	}
	else
	{
		alucfr2 = (alucfr2 >> 1);
	}
	if (u16Upper3Src1 == u16Lower3Src2)
	{
		alucfr3 = (alucfr3 >> 1) | 0x80;
	}
	else
	{
		alucfr3 = (alucfr3 >> 1);
	}
	if (u16Upper4Src1 == u16Lower4Src2)
	{
		alucfr4 = (alucfr4 >> 1) | 0x80;
	}
	else
	{
		alucfr4 = (alucfr4 >> 1);
	}

	*p_pALUCFR = (((DSPU32)alucfr4) << 24) |(((DSPU32)alucfr3) << 16) |(((DSPU32)alucfr2) << 8) | ((DSPU32)alucfr1);
	//end



    //DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    //return  u32Result; 

}
/*1found*****************************************************************
	函数名：		ACFIsNEQQ8
	
	对应指令形式: ACFk=ORm!=ORn?1:0(U)

	描述:		四组8位无符号定点数据比较。比较结果只改变比较标志寄存器。
          该指令对操作数的四组8位数分别进行比较，比较标志寄存器也相应地分成四个8位，根据比较的结果分别置位比较标志寄存器的相应位。
					如果Rm[7:0]!=Rn[7:0]，则比较标志寄存器的第[0]位置‘1’，否则置‘0’，比较标志寄存器ACF[7:0]左移1位；
          如果Rm[15:8]!=Rn[15:8]，则比较标志寄存器的第[8]位置‘1’，否则置‘0’，比较标志寄存器ACF[15:8]左移1位；
          如果Rm[23:16]!=Rn[23:16]，则比较标志寄存器的第[16]位置‘1’，否则置‘0’，比较标志寄存器ACF[23:16]左移1位；
          如果Rm[31:24]!=Rn[31:24]，则比较标志寄存器的第[24]位置‘1’，否则置‘0’，比较标志寄存器ACF[31:24]左移1位；
					该指令的操作顺序是：先将比较标志寄存器中某个8位数据左移1位，然后再在该8位数据的第[0]位置0或置1。

	参数:		p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_u32ALUCR -- ALU控制寄存器。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACFIsNEQQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR)
{

	DSPU32 p_u32Src1 = p_u32Rm;
	DSPU32 p_u32Src2 = p_u32Rn;
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
    
	//
	DSPU16 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU16 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU16 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU16 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);
    DSPU16 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU16 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU16 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU16 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);
	//
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    //
	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;
	//
    DSPU16 UpperCFR = (DSPU16)(*p_pALUCFR >> 16);
    DSPU16 LowerCFR = (DSPU16)(*p_pALUCFR);  
	//
	DSPU16 UpperCFR1 = (DSPU8)(*p_pALUCFR );
    DSPU16 UpperCFR2 = (DSPU8)(*p_pALUCFR >> 8);
	DSPU16 UpperCFR3 = (DSPU8)(*p_pALUCFR >> 16);
    DSPU16 UpperCFR4 = (DSPU8)(*p_pALUCFR >> 24);
	//
    
    //DSPU16 u16UpperResult = IsHE16(u16UpperSrc1, u16UpperSrc2, &UpperReg, &UpperCFR, p_u32ALUCR);
    //DSPU16 u16LowerResult = IsHE16(u16LowerSrc1, u16LowerSrc2, &LowerReg, &LowerCFR, p_u32ALUCR);
	DSPU16 u16UpperResult = IsHE16_NEW(u16Upper1Src1, u16Lower1Src2, &UpperReg1, &UpperCFR1, p_u32ALUCR,1);
    DSPU16 u16LowerResult = IsHE16_NEW(u16Upper2Src1, u16Lower2Src2, &UpperReg2, &UpperCFR2, p_u32ALUCR,1);
		   u16UpperResult = IsHE16_NEW(u16Upper3Src1, u16Lower3Src2, &UpperReg3, &UpperCFR3, p_u32ALUCR,1);
		   u16LowerResult = IsHE16_NEW(u16Upper4Src1, u16Lower4Src2, &UpperReg4, &UpperCFR4, p_u32ALUCR,1);

    *p_pStatReg = UpperReg1 | UpperReg2 | UpperReg3 |UpperReg4;
    
    //*p_pALUCFR = (((DSPU32)UpperCFR) << 24) |(((DSPU32)UpperCFR) << 16) |(((DSPU32)UpperCFR) << 8) | ((DSPU32)LowerCFR);
    










		//added by flyu on 20130419
	DSPU8 alucfr1 = (*p_pALUCFR) & 0xff;
	DSPU8 alucfr2 = ((*p_pALUCFR) & (0xff00)) >> 8;
	DSPU8 alucfr3 = ((*p_pALUCFR) & (0xff0000)) >> 16;
	DSPU8 alucfr4 = ((*p_pALUCFR) & (0xff000000)) >> 24;
	if (u16Upper1Src1 != u16Lower1Src2)
	{
		alucfr1 = (alucfr1 >> 1) | 0x80;
	}
	else
	{
		alucfr1 = (alucfr1 >> 1);
	}
	if (u16Upper2Src1 != u16Lower2Src2)
	{
		alucfr2 = (alucfr2 >> 1) | 0x80;
	}
	else
	{
		alucfr2 = (alucfr2 >> 1);
	}
	if (u16Upper3Src1 != u16Lower3Src2)
	{
		alucfr3 = (alucfr3 >> 1) | 0x80;
	}
	else
	{
		alucfr3 = (alucfr3 >> 1);
	}
	if (u16Upper4Src1 != u16Lower4Src2)
	{
		alucfr4 = (alucfr4 >> 1) | 0x80;
	}
	else
	{
		alucfr4 = (alucfr4 >> 1);
	}

	*p_pALUCFR = (((DSPU32)alucfr4) << 24) |(((DSPU32)alucfr3) << 16) |(((DSPU32)alucfr2) << 8) | ((DSPU32)alucfr1);
	//end





    //DSPU32 u32Result = (((DSPU32)u16UpperResult) << 16) | ((DSPU32)u16LowerResult);

    //return  u32Result; 

}


/*1found*****************************************************************
	函数名：		AccAnd32
	
	对应指令形式: ACCs=ACCs & Rm

	描述:			将ACCs[31:0]的值与Rm按位与后赋给ACCs[31:0],同时将ACCs的高位清零。

	参数:		p_u32Src -- 源操作数1。
					p_ACC -- 48位累加结果寄存器中的值。 
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。	

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccAnd32(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 result = p_u32Src & p_ACC.u32Low;
	p_ACC.u32Low = result;
	p_ACC.u8High &= 0x0;
	p_ACC.u8Mid  &= 0x0;
}

/*1found*****************************************************************
	函数名：		AccIsFix32MN
	
	对应指令形式: ACCs=Rm_Rn

	描述:		将Rm[6:0]送到ACC[38:32]，Rn送到ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccIsFix32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	p_ACC.u32Low = p_u32Rn;
	DSPU32 test1 = p_u32Rm & 0x7f;
	p_ACC.u8Mid = test1;
	p_ACC.u8High = 0;

}


/*1found*****************************************************************
	函数名：		AddQ8
	
	对应指令形式: ORs=ORm+ORn(U)

	描述:		4个8位无符号定点数分别相加。

	参数:		p_u32Src1 -- 源操作数1，对应Rm，包含四个8位定点数据。
					p_u32Src2 -- 源操作数2，对应Rn，包含四个8位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 AddQ8(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
//extern DSPU32 AddD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &=  BIT(8) |BIT(9) |BIT(11)| BIT(12) ;
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
	//
	DSPU8 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU8 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU8 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU8 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);

    DSPU8 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU8 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU8 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU8 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);

	//
    
    //DSPU32 UpperReg = *p_pStatReg;
    //DSPU32 LowerReg = *p_pStatReg;

	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;

    
    //DSPU16 u16UpperResult = Add16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    //DSPU16 u16LowerResult = Add16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 

	DSPU8 u16UpperResult1 = Add8_alu(u16Upper1Src1, u16Lower1Src2, &UpperReg1, p_u32ALUCR);
    DSPU8 u16UpperResult2 = Add8_alu(u16Upper2Src1, u16Lower2Src2, &UpperReg2, p_u32ALUCR); 
	DSPU8 u16UpperResult3 = Add8_alu(u16Upper3Src1, u16Lower3Src2, &UpperReg3, p_u32ALUCR);
    DSPU8 u16UpperResult4 = Add8_alu(u16Upper4Src1, u16Lower4Src2, &UpperReg4, p_u32ALUCR); 

    DSPU16 u16F1 = u16UpperResult1 &0x100;
	DSPU16 u16F2 = u16UpperResult2 &0x100;
	DSPU16 u16F3 = u16UpperResult3 &0x100;
	DSPU16 u16F4 = u16UpperResult4 &0x100;

    u16UpperResult1 = u16UpperResult1 &0xff;
	u16UpperResult2 = u16UpperResult2 &0xff;
	u16UpperResult3 = u16UpperResult3 &0xff;
	u16UpperResult4 = u16UpperResult4 &0xff;

	if ((u16F1 != 0)||(u16F2 != 0)||(u16F3 != 0)||(u16F4 != 0))
	{
		//*p_pStatReg |=  BIT(8) | BIT(12) | BIT(0) | BIT(4);
	}
    *p_pStatReg = UpperReg4 | UpperReg3 |UpperReg2 | UpperReg1;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult4) << 24) |(((DSPU32)u16UpperResult3) << 16) |(((DSPU32)u16UpperResult2) << 8) | ((DSPU32)u16UpperResult1);

    return  u32Result;      
}


/*1found*****************************************************************
	函数名：		SubQ8
	
	对应指令形式: ORs=ORm-ORn(U)

	描述:		4个8位无符号定点数分别相减。

	参数:			p_u32Src1 -- 源操作数1，对应Rm，包含四个8位定点数据。
					p_u32Src2 -- 源操作数2，对应Rn，包含四个8位定点数据。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 SubQ8(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &=  BIT(8) |BIT(9) |BIT(11) | BIT(12) ;
	
	//DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    //DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    //DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    //DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
	//

	DSPU8 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU8 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU8 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU8 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);

	//
    DSPU8 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU8 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU8 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU8 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);
	//
    
    //DSPU32 UpperReg = *p_pStatReg;
    //DSPU32 LowerReg = *p_pStatReg;

	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;

    
    //DSPU16 u16UpperResult = Add16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    //DSPU16 u16LowerResult = Add16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 

	DSPU8 u16UpperResult1 = Sub8_alu(u16Upper1Src1, u16Lower1Src2, &UpperReg1, p_u32ALUCR);
    DSPU8 u16UpperResult2 = Sub8_alu(u16Upper2Src1, u16Lower2Src2, &UpperReg2, p_u32ALUCR); 
	DSPU8 u16UpperResult3 = Sub8_alu(u16Upper3Src1, u16Lower3Src2, &UpperReg3, p_u32ALUCR);
    DSPU8 u16UpperResult4 = Sub8_alu(u16Upper4Src1, u16Lower4Src2, &UpperReg4, p_u32ALUCR); 

    //*p_pStatReg = UpperReg4 | UpperReg3 |UpperReg2 | UpperReg1;
    u16UpperResult1 = u16UpperResult1 & 0xff;
	u16UpperResult2 = u16UpperResult2 & 0xff;
	u16UpperResult3 = u16UpperResult3 & 0xff;
	u16UpperResult4 = u16UpperResult4 & 0xff;
	if (
		  (u16Upper1Src1 < u16Lower1Src2)
		||(u16Upper2Src1 < u16Lower2Src2)
		||(u16Upper3Src1 < u16Lower3Src2)
		||(u16Upper4Src1 < u16Lower4Src2)
		)
	{
		//*p_pStatReg |=  BIT(0) | BIT(4) | BIT(8) | BIT(12);
	}
	*p_pStatReg  = UpperReg1 | UpperReg2 | UpperReg3| UpperReg4;

    DSPU32 u32Result = (((DSPU32)u16UpperResult4) << 24) |(((DSPU32)u16UpperResult3) << 16) |(((DSPU32)u16UpperResult2) << 8) | ((DSPU32)u16UpperResult1);

    return  u32Result;  


}
extern DSPU32 SubQ8_abs(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src1 >> 16);
    DSPU16 u16UpperSrc2 = (DSPU16)(p_u32Src2 >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src1);
    DSPU16 u16LowerSrc2 = (DSPU16)(p_u32Src2);
	//
	DSPU16 u16Upper1Src1 = (DSPU8)(p_u32Src1);
    DSPU16 u16Upper2Src1 = (DSPU8)(p_u32Src1 >> 8);
	DSPU16 u16Upper3Src1 = (DSPU8)(p_u32Src1 >> 16);
    DSPU16 u16Upper4Src1 = (DSPU8)(p_u32Src1 >> 24);
    DSPU16 u16Lower1Src2 = (DSPU8)(p_u32Src2);
    DSPU16 u16Lower2Src2 = (DSPU8)(p_u32Src2 >> 8);
	DSPU16 u16Lower3Src2 = (DSPU8)(p_u32Src2 >> 16);
    DSPU16 u16Lower4Src2 = (DSPU8)(p_u32Src2 >> 24);

	//
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;

	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;

    DSPU16 u16UpperResult = Add16(u16UpperSrc1, u16UpperSrc2, &UpperReg, p_u32ALUCR);
    DSPU16 u16LowerResult = Add16(u16LowerSrc1, u16LowerSrc2, &LowerReg, p_u32ALUCR); 

	DSPU16 u16UpperResult1 = Sub8_abs(u16Upper1Src1, u16Lower1Src2, &UpperReg1, p_u32ALUCR);
    DSPU16 u16UpperResult2 = Sub8_abs(u16Upper2Src1, u16Lower2Src2, &UpperReg2, p_u32ALUCR); 
	DSPU16 u16UpperResult3 = Sub8_abs(u16Upper3Src1, u16Lower3Src2, &UpperReg3, p_u32ALUCR);
    DSPU16 u16UpperResult4 = Sub8_abs(u16Upper4Src1, u16Lower4Src2, &UpperReg4, p_u32ALUCR); 

    

    *p_pStatReg = UpperReg4 | UpperReg3 |UpperReg2 | UpperReg1;
     
    DSPU32 u32Result = (((DSPU32)u16UpperResult4) << 24) |(((DSPU32)u16UpperResult3) << 16) |(((DSPU32)u16UpperResult2) << 8) | ((DSPU32)u16UpperResult1);

    return  u32Result;  


}

/*1found*****************************************************************
	函数名：		AddAbs32
	
	对应指令形式: Rs=abs(Rm)+abs(Rn)

	描述:		将寄存器Rm、Rn中的32位定点有符号数分别求绝对值并相加，结果赋给目的寄存器Rs。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddAbs32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg &= BIT(8) | BIT(14) | BIT(13);
	DSPU32 stat = 0;
	if ((p_u32Src1 == 0x80000001)&& (p_u32Src2 == 0x80000000))
	{
	//int i = 0;
	}
	DSPU32 sr1 = alu_Abs32_NEW(p_u32Src1, &stat, p_u32ALUCR);
	DSPU32 sr2 = alu_Abs32_NEW(p_u32Src2, &stat, p_u32ALUCR);
	DSPU32 result = Add32(sr1, sr2, p_pStatReg,  p_u32ALUCR);
	DSPU32 resultz =  Add32(sr1,sr2,p_pStatReg,p_u32ALUCR & 0xfffffffe);
    if (
		((p_u32ALUCR & 0x1) == 0x1)
		)
	{
		if (resultz > 0x7fffffff)
		{
			if ((p_u32ALUCR & 0x2) == 0x2)
			{
				result = 0x7fffffff;
			}

			SetFlag(*p_pStatReg, ALU_OverFlow); 
			SetFlag(*p_pStatReg, ALU_AOS); 
			SetFlag(*p_pStatReg, 6); 
			SetFlag(*p_pStatReg, 14); 
		}
	}

	return result; 

}
/*1found*****************************************************************
	函数名：		AddAbsF32
	
	对应指令形式: FRs=abs(FRm)+abs(FRn) 

	描述:		将寄存器Rm、Rn中的32位浮点数分别求绝对值并相加，结果赋给目的寄存器Rs。

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。

	返回值：		计算结果。

	注意事项:		根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
*******************************************************************/
extern DSPU32 AddAbsF32(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 tempstat = 0;
	if ((p_u32Src1 == 0x00000001)&& (p_u32Src2 == 0x7f800000))
	{
		//int i = 0;
	}
	DSPU32 sr1 = alu_AbsFlo32(p_u32Src1, &tempstat, p_u32ALUCR);
	DSPU32 sr2 = alu_AbsFlo32(p_u32Src2, &tempstat, p_u32ALUCR);
	DSPU32 result = AddF32(sr1, sr2, p_pStatReg,  p_u32ALUCR); 
	return result;



}

/*1found*****************************************************************
	函数名：		ACCABSQ8
	
	对应指令形式: ACCs = ABS(ORm-ORn)(U)
                ACCs += ABS(ORm-ORn)(U)

	描述:		将Rm、Rn分别分成4个8位数，对应相减得到4个结果，分别与原ACC中的对应值累加后送入ALU对应的ACC中（ACC平均分成4段，每段12位）。
          

	参数:			p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_ACC -- 48位累加结果寄存器。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					

	返回值：		

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。                 // GRQ: 标志位设置？待新版指令集确定。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/

extern void ACCABSQ8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg)
{

	//ACCs = ABS(ORm-ORn)(U)
	/*
	DSPU32 result = SubQ8_abs( p_u32Rm,  p_u32Rn, p_pStatReg,  p_u32ALUCR);
	
	DSPU32 sr1 = result & 0xff;
	DSPU32 sr2 = result & 0xff00;
	DSPU32 sr3 = result & 0xff0000;
	DSPU32 sr4 = result & 0xff000000;
	p_ACC.u32Low = 0;
	p_ACC.u32Low = (sr1) | (sr2<<2) | (sr3<<4);
	p_ACC.u32Low = p_ACC.u32Low | (sr4<<6);
	p_ACC.u8Mid = 0;
	p_ACC.u8Mid = sr4 >> 26;
	*/

	//ACCs += ABS(ORm-ORn)(U)
	///*
	
	DSPU32 result = SubQ8_abs( p_u32Rm,  p_u32Rn, p_pStatReg,  p_u32ALUCR&0xfffffffe);
	
	ACCAddQ8( result, p_ACC, p_pStatReg,p_u32ALUCR &0xfffffffe);
	p_ACC.u8High = 0;
	/*
	DSPU32 sr1 = result & 0xff;
	DSPU32 sr2 = (result & 0xff00) >> 8;
	DSPU32 sr3 = (result & 0xff0000) >> 16;
	DSPU32 sr4 = (result & 0xff000000)>>24;
	//
	DSPU32 acc_sr1 = p_ACC.u32Low & 0x3ff;
	DSPU32 acc_sr2 = (p_ACC.u32Low & 0xffc00) >> 10;
	DSPU32 acc_sr3 = (p_ACC.u32Low & 0x3ff00000)>> 20;
	DSPU32 acc_sr4 = p_ACC.u8Mid;
	acc_sr4 = acc_sr4 << 2;
	acc_sr4 = acc_sr4  | ((p_ACC.u32Low & 0xC0000000) >> 30);
	//
	acc_sr1 = (acc_sr1 + sr1) & 0x3ff;
	
	acc_sr2 = (acc_sr2 + sr2) & 0x3ff;
	acc_sr3 = (acc_sr3 + sr3) & 0x3ff;
	acc_sr4 = (acc_sr4 + sr4) & 0x3ff;
	
	//

	//
	DSPU32 test = acc_sr4 << 30;
	p_ACC.u32Low = (acc_sr1) | (acc_sr2<<10) | (acc_sr3<<20) | (acc_sr4<<30);
	p_ACC.u8Mid = acc_sr4 >> 2;
	*/
	//*/
	
}

/*1found*****************************************************************
	函数名：		ACCABSD16
	
	对应指令形式: ACCs = ABS(HRm-HRn)
                  ACCs += ABS(HRm-HRn)

	描述:		将Rm、Rn分别分成2个16位数，对应相减得到2个结果，分别与原ACC中的对应值累加后送入ALU对应的ACC中
	       （使用ACC的低40位，平均分成2段，ACC高8位清零）。
          

	参数:		    p_u32Rm -- 源操作数1。
					p_u32Rn -- 源操作数2。
					p_ACC -- 48位累加结果寄存器。
					p_u32ALUCR -- ALU控制寄存器。	
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。  // 使用什么标志寄存器？待新版指令集确定。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
//找不到以前的HRm-HRn函数
extern void ACCABSD16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 *p_pStatReg)
{

	//if ()
	//
	DSPU16 u16Upper1Src1 = (DSPU16)(p_u32Rm);
    DSPU16 u16Upper2Src1 = (DSPU16)(p_u32Rm >> 16);

    DSPU16 u16Lower1Src2 = (DSPU16)(p_u32Rn);
    DSPU16 u16Lower2Src2 = (DSPU16)(p_u32Rn >> 16);

	//

	DSPU32 UpperReg1 = *p_pStatReg;
	DSPU32 UpperReg2 = *p_pStatReg;
    DSPU32 UpperReg3 = *p_pStatReg;
	DSPU32 UpperReg4 = *p_pStatReg;


	DSPU16 u16UpperResult1 = Sub16_abs(u16Upper1Src1, u16Lower1Src2, &UpperReg1, p_u32ALUCR);
    DSPU16 u16UpperResult2 = Sub16_abs(u16Upper2Src1, u16Lower2Src2, &UpperReg2, p_u32ALUCR); 

    //DSPU16 u16UpperResult1 = Sub16(u16Upper1Src1, u16Lower1Src2, &UpperReg1, p_u32ALUCR&0xfffffffd);
	//DSPU16 u16UpperResult2 = Sub16(u16Upper2Src1, u16Lower2Src2, &UpperReg2, p_u32ALUCR&0xfffffffd); 
		
	//u16UpperResult1 = ALU_Abs16(u16UpperResult1, p_pStatReg,  p_u32ALUCR);
	
	
	//u16UpperResult2 = ALU_Abs16(u16UpperResult2, p_pStatReg,  p_u32ALUCR);
	

    *p_pStatReg = UpperReg2 | UpperReg1;
	DSPU32 p_u32Src = u16UpperResult1 | (((DSPU32)u16UpperResult2) <<16);
	DSP_BIT40 p_ACC1;
	p_ACC1.u32Low = p_ACC.u32Low;
	p_ACC1.u8High = p_ACC.u8Mid;

	ACCAddD16( p_u32Src, &p_ACC1, p_pStatReg, p_u32ALUCR&0xfffffffe);
	p_ACC.u32Low = p_ACC1.u32Low;
	p_ACC.u8Mid  = p_ACC1.u8High;
	p_ACC.u8High = 0;
	/*//	ACCs = ABS(HRm-HRn)
	p_ACC.u32Low = 0;
	p_ACC.u32Low = (u16UpperResult1) | (u16UpperResult2<<20);
	p_ACC.u8Mid = 0;
	p_ACC.u8Mid = u16UpperResult2 >> 12;
	*/

	///*//	ACCs += ABS(HRm-HRn)
	/*
	DSPU32 acc_sr1 = p_ACC.u32Low & 0xfffff;
	DSPU32 acc_sr2 = p_ACC.u8Mid;
	acc_sr2 = (acc_sr2<<12) | ((p_ACC.u32Low & 0xfff00000) >> 20);

	acc_sr1 = (acc_sr1 + u16UpperResult1) & 0xfffff;
	acc_sr2 = (acc_sr2 + u16UpperResult2) & 0xfffff;

	p_ACC.u32Low = acc_sr1 |( acc_sr2 << 20);
	p_ACC.u8Mid = acc_sr2 >> 12;
	*/
	//*/
    return ; 

}

/*1found*****************************************************************
	函数名：		AccMaxFix32
	
	对应指令形式: ACCs=MAX_S(Rm,Rn,ACCs)
	              ACCs=MAX_S(Rm,Rn)
	              //ACCs=MAX_S(Rm,ACCs)

	描述:		有符号定点数选大，将Rm、Rn、ACCs[31..0]中的最大值放在ACC[31..0]，
	        同时将最大值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选大
					    1 -- Rm、Rn二者选大
					    2 -- Rm、ACCs[31..0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                   // 算法实现是否用到p_u32ALUCR？
                                                                       // 性能调优阶段各库函数均需进行清理p_u32ALUCR和p_pStatReg，明确是否用到这两个参数。
	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
//有问题见上
extern void AccMaxFix32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{
//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid & 0x7f;
//
	if (p_u32CompSel == 1)
	{
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_u32Rn;
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
		DSPI32 i32Src2 = (DSPI32)p_u32Rn ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 > i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u32Rm > p_u32Rn);
			
		}
		if (bolRmIsBiger )
		{
			p_ACC.u32Low = p_u32Rm;
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			p_ACC.u32Low = p_u32Rn;
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}

	}
	///////////////////////////////////////////

	if (p_u32CompSel == 0)
	{
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_u32Rn;
		DSPI32 iRMax = 0;
		DSPU32 uRMax = 0;
		DSPU32 uIdxMax = 0;
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
		DSPI32 i32Src2 = (DSPI32)p_u32Rn ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 > i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u32Rm > p_u32Rn);
			
		}
		if (bolRmIsBiger )
		{
			iRMax = iRm;
			uRMax = p_u32Rm;
			uIdxMax = p_u32RmIdx;
		}
		else
		{
			iRMax = iRn;
			uRMax = p_u32Rn;
			uIdxMax = p_u32RnIdx;
		}
		
		//////////////////////////
		DSPI32 iacc = p_ACC.u32Low;
		if (bolSigned)
		{
			bolRmIsBiger = (iRMax > iacc);
			
		}
		else
		{
			bolRmIsBiger = (uRMax > p_ACC.u32Low);
			
		}

		if (bolRmIsBiger )
		{
			p_ACC.u32Low = uRMax;
			p_ACC.u8Mid = uIdxMax;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			
		}

	}

	//待改
	if (p_u32CompSel == 2)
	{
		DSPU32 iRm = p_u32Rm;
		DSPU32 iRn = p_ACC.u32Low;
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
		DSPI32 i32Src2 = p_ACC.u32Low ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 > i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u32Rm > p_ACC.u32Low);
			
		}

		if (bolRmIsBiger )
		{
			p_ACC.u32Low = p_u32Rm;
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			/*
			p_ACC.u32Low = p_u32Rn;
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0xFF;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x7F;	
			}
			*/
		}

	}
p_ACC.u8High = 0;
}


/*1found*****************************************************************
	函数名：		AccMaxFlo32
	
	对应指令形式: ACCs=MAX_S(FRm,FRn,ACCs)
	              ACCs=MAX_S(FRm,FRn)
	              //ACCs=MAX_S(FRm,ACCs)

	描述:		浮点数选大，将Rm、Rn、ACCs[31..0]中的最大值放在ACC[31..0]，
	        同时将最大值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:			p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选大
					    1 -- Rm、Rn二者选大
					    2 -- Rm、ACCs[31..0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFlo32_old(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel,DSPU32 *p_pStatReg)
{

	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid  & 0x7f;
	//

	Cfloat32 fRnTmp(p_ACC.u32Low);
	if (fRnTmp.IsDNORM())
	{
		p_ACC.u32Low = p_ACC.u32Low & 0xff800000;
	}

	p_ACC.u8High = 0;
	if (p_u32CompSel == 1)
	{
		if ((p_u32Rm == 0x00000001)&&(p_u32Rn == 0x80000001))
		{
			//int i = 0;
		}
		Cfloat32 fRm(p_u32Rm);
		Cfloat32 fRn(p_u32Rn);
		//DSPI32 iRm = p_u32Rm;
		//DSPI32 iRn = p_u32Rn;
		if ((fRm.IsNAN())||fRn.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			SetFlag(*p_pStatReg, ALU_Invalid);         
            SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		
		if (fRm.IsDNORM())
		{
			DSPU32 temp = fRm.GetU32() & 0xff000000;
			fRm.SetU32( temp);
		}
		if (fRn.IsDNORM())
		{
			DSPU32 temp = fRn.GetU32() & 0xff000000;
			fRn.SetU32(temp);
		}
		float temp1 = fRm.GetF32();
		float temp2 = fRn.GetF32();

		if ((fRm.GetF32() > fRn.GetF32()) || ((!fRm.IsNega())&&(fRn.IsNega())))
		{
			
			p_ACC.u32Low = fRm.GetU32();
			
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			//p_ACC.u32Low = p_u32Rn;
			
			p_ACC.u32Low = fRn.GetU32();
			
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}

	}
	///////////////////////////////////////////

	if (p_u32CompSel == 0)
	{
		if (p_u32Rm == 0x25b654f3)
		{
			//int i = 0;
		}
		

		Cfloat32 fRm(p_u32Rm);
		Cfloat32 fRn(p_u32Rn);
		if ((fRm.IsNAN())||fRn.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			SetFlag(*p_pStatReg, ALU_Invalid);         
			SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_u32Rn;
		if (fRm.IsDNORM())
		{
			DSPU32 temp = fRm.GetU32() & 0xff000000;
			fRm.SetU32( temp);
		}
		if (fRn.IsDNORM())
		{
			DSPU32 temp = fRn.GetU32() & 0xff000000;
			fRn.SetU32(temp);
		}
		float temp1 = fRm.GetF32();
		float temp2 = fRn.GetF32();



		DSPI32 iRMax = 0;
		DSPU32 uIdxMax = 0;
		if ((fRm.GetF32() > fRn.GetF32()) || ((!fRm.IsNega())&&(fRn.IsNega())))
		{
			iRMax = fRm.GetU32();
			uIdxMax = p_u32RmIdx;
		}
		else
		{
			iRMax = fRn.GetU32();
			uIdxMax = p_u32RnIdx;
		}
		//////////////////////////
		
		DSPU32 uMax = iRMax;
		Cfloat32 fRax(uMax);
		Cfloat32 fRacc(p_ACC.u32Low);
		if (fRacc.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			SetFlag(*p_pStatReg, ALU_Invalid);         
			SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		//DSPI32 iacc = p_ACC.u32Low;
		if ((fRax.GetF32() > fRacc.GetF32()) || ((!fRax.IsNega())&&(fRacc.IsNega())))
		{
			p_ACC.u32Low = iRMax;
			p_ACC.u8Mid = uIdxMax;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			
		}

	}


	if (p_u32CompSel == 2)
	{
		if ((p_u32Rm == 0x00000001)&&(p_u32Rn == 0x80000001))
		{
			//int i = 0;
		}

		Cfloat32 fRm(p_u32Rm);
		//Cfloat32 fRn(p_u32Rn);
		Cfloat32 fRn(p_ACC.u32Low);
		//DSPI32 iRm = p_u32Rm;
		//DSPI32 iRn = p_u32Rn;
		if ((fRm.IsNAN())||fRn.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			SetFlag(*p_pStatReg, ALU_Invalid);         
            SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		
		if (fRm.IsDNORM())
		{
			DSPU32 temp = fRm.GetU32() & 0xff000000;
			fRm.SetU32( temp);
		}
		if (fRn.IsDNORM())
		{
			DSPU32 temp = fRn.GetU32() & 0xff000000;
			fRn.SetU32(temp);
		}
		float temp1 = fRm.GetF32();
		float temp2 = fRn.GetF32();

		if ((fRm.GetF32() > fRn.GetF32()) || ((!fRm.IsNega())&&(fRn.IsNega())))
		{
			
			p_ACC.u32Low = fRm.GetU32();
			
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		/*
		else
		{
			//p_ACC.u32Low = p_u32Rn;
			
			p_ACC.u32Low = fRn.GetU32();
			
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0xFF;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x7F;	
			}
		}
		*/

	}

}
extern void AccMaxFlo32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel,DSPU32 *p_pStatReg)
{

	AccMaxFlo32_old(p_u32Rm, p_u32Rn, p_u32RmIdx, p_u32RnIdx,  p_u32PageIdx, p_ACC, p_u32ALUCR,  p_u32CompSel,p_pStatReg);
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid  & 0x7f;
	//
}
/*1found*****************************************************************
	函数名：		AccMinFix32 
	
	对应指令形式: ACCs=MIN_S(Rm,Rn,ACCs)
	              ACCs=MIN_S(Rm,Rn)
	             // ACCs=MIN_S(Rm,ACCs)

	描述:		有符号定点数选小，将Rm、Rn、ACCs[31..0]中的最小值放在ACC[31..0]，
	        同时将最小值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选小的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选小
					    1 -- Rm、Rn二者选小
					    2 -- Rm、ACCs[31..0]二者选小
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？                 
                                                                       // 性能调优阶段各库函数均需进行清理p_u32ALUCR和p_pStatReg
	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFix32_old(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{

	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid  & 0x7f;
	//
	p_ACC.u8High = 0;
	if (p_u32CompSel == 1)
	{
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_u32Rn;
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
		DSPI32 i32Src2 = (DSPI32)p_u32Rn ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 < i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u32Rm < p_u32Rn);
			
		}

		if (bolRmIsBiger )
		{
			p_ACC.u32Low = p_u32Rm;
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			p_ACC.u32Low = p_u32Rn;
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}

	}
	///////////////////////////////////////////

	if (p_u32CompSel == 0)
	{
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_u32Rn;
		DSPI32 iRMax = 0;
		DSPU32 uRMax = 0;
		DSPU32 uIdxMax = 0;
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
		DSPI32 i32Src2 = (DSPI32)p_u32Rn ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 < i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u32Rm < p_u32Rn);
			
		}

		if (bolRmIsBiger )
		{
			iRMax = iRm;
			uRMax = p_u32Rm;
			uIdxMax = p_u32RmIdx;
		}
		else
		{
			iRMax = iRn;
			uRMax = p_u32Rn;
			uIdxMax = p_u32RnIdx;
		}
		//////////////////////////
		DSPI32 iacc = p_ACC.u32Low;
		if (bolSigned)
		{
			bolRmIsBiger = (iRMax < iacc);
			
		}
		else
		{
			bolRmIsBiger = (uRMax < p_ACC.u32Low);
			
		}

		if (bolRmIsBiger )
		{
			p_ACC.u32Low = uRMax;
			p_ACC.u8Mid = uIdxMax;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			p_ACC.u8Mid = p_ACC.u8Mid & 0x7F;
		}

	}
	if (p_u32CompSel == 2)
	{
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_ACC.u32Low;
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI32 i32Src1 = (DSPI32)p_u32Rm ;
		DSPI32 i32Src2 = (DSPI32)p_ACC.u32Low ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 < i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u32Rm < p_ACC.u32Low);
			
		}

		if (bolRmIsBiger )
		{
			p_ACC.u32Low = p_u32Rm;
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			p_ACC.u8Mid = p_ACC.u8Mid & 0x7F;
			/*
			p_ACC.u32Low = p_u32Rn;
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0xFF;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x7F;	
			}
			*/
		}
		

	}
	p_ACC.u8High = 0;
}
extern void AccMinFix32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{
	AccMinFix32_old(p_u32Rm, p_u32Rn, p_u32RmIdx, p_u32RnIdx, p_u32PageIdx, p_ACC, p_u32ALUCR, p_u32CompSel);
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid  & 0x7f;
	//
}
/*1found*****************************************************************
	函数名：		AccMinFlo32
	
	对应指令形式: ACCs=MIN_S(FRm,FRn,ACCs)
	              ACCs=MIN_S(FRm,FRn)
	              ACCs=Min_S(FRm,ACCs)

	描述:		有符号定点数选大，将Rm、Rn、ACCs[31..0]中的最大值放在ACC[31..0]，
	        同时将最大值对应的序号放在ACCs[38..32]；
	        ACC的高位清零；
	        该指令不影响标志位。
	        序号定义：
	        		ACCs[31:0]对应的序号为ACCs[38:32]中的原值；
	        		对于通用寄存器，当寄存器堆选择A面时，7位序号的最高位为0，否则7位序号的最高位为1；
              低6位序号按照如下定义：
                  Rm对应的低6位序号为 m
                  Rn对应的低6位序号为 n                 	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm、Rn、ACCs[31..0]三者选大
					    1 -- Rm、Rn二者选大
					    2 -- Rm、ACCs[31..0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFlo32_old(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel,DSPU32 *p_pStatReg)
{
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid  & 0x7f;
	//
	Cfloat32 fRnTmp(p_ACC.u32Low);
	if (fRnTmp.IsDNORM())
	{
		p_ACC.u32Low = p_ACC.u32Low & 0xff800000;
	}
	
    p_ACC.u8High = 0;
	if (p_u32CompSel == 1)
	{
		if ((p_u32Rm == 0x00000001)&&(p_u32Rn == 0x80000001))
		{
			//int i = 0;
		}
		Cfloat32 fRm(p_u32Rm);
		Cfloat32 fRn(p_u32Rn);
		//DSPI32 iRm = p_u32Rm;
		//DSPI32 iRn = p_u32Rn;
		if ((fRm.IsNAN())||fRn.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			SetFlag(*p_pStatReg, ALU_Invalid);         
            SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		
		if (fRm.IsDNORM())
		{
			DSPU32 temp = fRm.GetU32() & 0xff000000;
			fRm.SetU32( temp);
		}
		if (fRn.IsDNORM())
		{
			DSPU32 temp = fRn.GetU32() & 0xff000000;
			fRn.SetU32(temp);
		}
		float temp1 = fRm.GetF32();
		float temp2 = fRn.GetF32();

		if ((fRm.GetF32() < fRn.GetF32()) || ((fRm.IsNega())&&(!fRn.IsNega())))
		{
			
			p_ACC.u32Low = fRm.GetU32();
			
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			//p_ACC.u32Low = p_u32Rn;
			
			p_ACC.u32Low = fRn.GetU32();
			
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}

	}
	///////////////////////////////////////////

	if (p_u32CompSel == 0)
	{
		if (p_u32Rm == 0x25b654f3)
		{
			//int i = 0;
		}
		

		Cfloat32 fRm(p_u32Rm);
		Cfloat32 fRn(p_u32Rn);
		if ((fRm.IsNAN())||fRn.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		DSPI32 iRm = p_u32Rm;
		DSPI32 iRn = p_u32Rn;
		if (fRm.IsDNORM())
		{
			DSPU32 temp = fRm.GetU32() & 0xff000000;
			fRm.SetU32( temp);
		}
		if (fRn.IsDNORM())
		{
			DSPU32 temp = fRn.GetU32() & 0xff000000;
			fRn.SetU32(temp);
		}
		float temp1 = fRm.GetF32();
		float temp2 = fRn.GetF32();


		DSPI32 iRMax = 0;
		DSPU32 uIdxMax = 0;
		if ((fRm.GetF32() < fRn.GetF32()) || ((fRm.IsNega())&&(!fRn.IsNega())))
		{
			iRMax = fRm.GetU32();
			uIdxMax = p_u32RmIdx;
		}
		else
		{
			iRMax = fRn.GetU32();
			uIdxMax = p_u32RnIdx;
		}
		
		
		//////////////////////////
		
		DSPU32 uMax = iRMax;
		Cfloat32 fRax(uMax);
		Cfloat32 fRacc(p_ACC.u32Low);
		int iDNORM = 0;
		if (fRacc.IsDNORM())
		{
			DSPU32 temp = fRacc.GetU32() & 0xff000000;
			fRacc.SetU32(temp);
			iDNORM = 1;
		}
		if (fRacc.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			SetFlag(*p_pStatReg, ALU_Invalid);         
			SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		//DSPI32 iacc = p_ACC.u32Low;
		if ((fRax.GetF32() < fRacc.GetF32()) || ((fRax.IsNega())&&(!fRacc.IsNega())))
		{
			p_ACC.u32Low = iRMax;
			p_ACC.u8Mid = uIdxMax;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			if (iDNORM == 1)
			{
				DSPU32 temp = fRacc.GetU32() & 0xff000000;
				fRacc.SetU32(temp);
				p_ACC.u32Low = fRacc.GetU32();
			}
		}

	}

if (p_u32CompSel == 2)
	{
		if ((p_u32Rm == 0x00000001)&&(p_u32Rn == 0x80000001))
		{
			//int i = 0;
		}
		Cfloat32 fRm(p_u32Rm);
		//Cfloat32 fRn(p_u32Rn);
		Cfloat32 fRn(p_ACC.u32Low);
		//DSPI32 iRm = p_u32Rm;
		//DSPI32 iRn = p_u32Rn;
		if ((fRm.IsNAN())||fRn.IsNAN())
		{
			p_ACC.u32Low = 0xffffffff;
			p_ACC.u8Mid = 0xff;
			        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
			return;
		}
		
		if (fRm.IsDNORM())
		{
			DSPU32 temp = fRm.GetU32() & 0xff000000;
			fRm.SetU32( temp);
		}
		if (fRn.IsDNORM())
		{
			DSPU32 temp = fRn.GetU32() & 0xff000000;
			fRn.SetU32(temp);
		}
		float temp1 = fRm.GetF32();
		float temp2 = fRn.GetF32();

		if ((fRm.GetF32() < fRn.GetF32()) || ((fRm.IsNega())&&(!fRn.IsNega())))
		{
			p_ACC.u32Low = fRm.GetU32();
			p_ACC.u8Mid = p_u32RmIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = (p_ACC.u8Mid & 0x3F) | 0x40;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x3F;	
			}
		}
		else
		{
			p_ACC.u32Low = fRn.GetU32();
		}
		/*
		else
		{
			//p_ACC.u32Low = p_u32Rn;
			
			p_ACC.u32Low = fRn.GetU32();
			
			p_ACC.u8Mid = p_u32RnIdx;
			if (p_u32PageIdx == 1)
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0xFF;	
			}
			else
			{
				p_ACC.u8Mid = p_ACC.u8Mid & 0x7F;	
			}
		}
		*/

	}

}
extern void AccMinFlo32(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel,DSPU32 *p_pStatReg)
{
	AccMinFlo32_old(p_u32Rm, p_u32Rn,  p_u32RmIdx,  p_u32RnIdx,  p_u32PageIdx, p_ACC, p_u32ALUCR, p_u32CompSel,p_pStatReg);
		//
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid  & 0x7f;
	//
}
/*1found*****************************************************************
	函数名：		AccMaxFix8
	
	对应指令形式: LOACCs=MAX_S(ORm,ORn,LOACCs)(U)
	              LOACCs=MAX_S(ORm,ORn)(U)
	              //LOACCs=MAX_S(ORm,LOACCs)(U)

	描述:		无符号定点数选大，取Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]中的最大值放在ACC[7:0]；
					ACC的其他位清零；
	        该指令不影响标志位。
	        最大值对应序号放在ACCs[?:?]，对序号的定义如下；(GRQ)
	        		ACCs[7:0]对应的序号为ACCs[?:?]原来的值。
	        		当寄存器堆选择为A面时，9位序号的第[9]位为0，9位序号的第[9]位为1；
              Rm[31:24]对应序号的第[8:7]位为{2'b11}；Rm[23:16]对应序号的第[8:7]位为{2'b10}；
              Rm[15:8]对应序号的第[8:7]位为{2'b01}；Rm[7:0]对应序号的第[8:7]位为{2'b00}；
              Rn[31:24]对应序号的第[8:7]位为{2'b11}；Rn[23:16]对应序号的第[8:7]位为{2'b10}；
              Rn[15:8]对应序号的第[8:7]位为{2'b01}；Rn[7:0]对应序号的第[8:7]位为{2'b00}；
              Rm寄存器对应序号的低6位为m；Rn寄存器对应序号的低6位为n。              
	        

	参数:			p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]九者选大
					    1 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]八者选大
					    2 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、ACCs[7:0]五者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{
	if (p_u32CompSel == 1)
	{
		if ((p_u32Rm == 0x00010001)&&(p_u32Rn == 0x00010001))
		{
			int i = 9;
		}
		DSPU32 srcMax_m = 0;
		DSPU32 srcM1 =  p_u32Rm & 0xff;
		DSPU32 srcM2 = (p_u32Rm & 0xff00)     >> 8;
		DSPU32 srcM3 = (p_u32Rm & 0xff0000)   >> 16;
		DSPU32 srcM4 = (p_u32Rm & 0xff000000) >> 24;

		srcMax_m = srcM4 > srcM3 ? srcM4 : srcM3;
		srcMax_m = srcMax_m > srcM2 ? srcMax_m : srcM2;
		srcMax_m = srcMax_m > srcM1 ? srcMax_m : srcM1;
		
		DSPU32 idxm01 = 0;
		if (srcMax_m == srcM1)
		{
			idxm01 = 0x0;
		}
		else
		if (srcMax_m == srcM2)
		{
			idxm01 = 0x1;
		}else

		if (srcMax_m == srcM3)
		{
			idxm01 = 0x2;
		}else
		if (srcMax_m == srcM4)
		{
			idxm01 = 0x3;
		}
		DSPU32 srcMax_n = 0;
		DSPU32 srcN1 =  p_u32Rn & 0xff;
		DSPU32 srcN2 = (p_u32Rn & 0xff00)     >> 8;
		DSPU32 srcN3 = (p_u32Rn & 0xff0000)   >> 16;
		DSPU32 srcN4 = (p_u32Rn & 0xff000000) >> 24;

		srcMax_n = srcN4 > srcN3 ? srcN4 : srcN3;
		srcMax_n = srcMax_n > srcN2 ? srcMax_n : srcN2;
		srcMax_n = srcMax_n > srcN1 ? srcMax_n : srcN1;
		
		DSPU32 idxn01 = 0;
		if (srcMax_n == srcN1)
		{
			idxn01 = 0x0;
		}else
		if (srcMax_n == srcN2)
		{
			idxn01 = 0x1;
		}else
		if (srcMax_n == srcN3)
		{
			idxn01 = 0x2;
		}else
		if (srcMax_n == srcN4)
		{
			idxn01 = 0x3;
		}

		
		p_ACC.u32Low = srcMax_m > srcMax_n ? srcMax_m :srcMax_n ;
		
		DSPU32 idx26 =0;
		DSPU32 idx01 =0;
		if (srcMax_m > srcMax_n)
		{
			idx26 = p_u32RmIdx;
			idx01 = idxm01;
		}
		else
		{
			idx26 = p_u32RnIdx;
			idx01 = idxn01;
		}
		idx26 = (idx26 << 2) | idx01;

		if (p_u32PageIdx ==1)
		{
		idx26 = idx26 | 0x100;
		}
		p_ACC.u32Low = p_ACC.u32Low | (idx26 << 16);
	}
	else if (p_u32CompSel == 0)
	{
		if ((p_u32Rm == 0x00010001)&&(p_u32Rn == 0x00010001))
		{
			int i = 9;
		}
		DSPU32 srcMax_m = 0;
		DSPU32 srcM1 =  p_u32Rm & 0xff;
		DSPU32 srcM2 = (p_u32Rm & 0xff00)     >> 8;
		DSPU32 srcM3 = (p_u32Rm & 0xff0000)   >> 16;
		DSPU32 srcM4 = (p_u32Rm & 0xff000000) >> 24;

		srcMax_m = srcM4 > srcM3 ? srcM4 : srcM3;
		srcMax_m = srcMax_m > srcM2 ? srcMax_m : srcM2;
		srcMax_m = srcMax_m > srcM1 ? srcMax_m : srcM1;
		
		DSPU32 idxm01 = 0;
		if (srcMax_m == srcM1)
		{
			idxm01 = 0x0;
		}
		else
		if (srcMax_m == srcM2)
		{
			idxm01 = 0x1;
		}
		else
		if (srcMax_m == srcM3)
		{
			idxm01 = 0x2;
		}else
		if (srcMax_m == srcM4)
		{
			idxm01 = 0x3;
		}
		DSPU32 srcMax_n = 0;
		DSPU32 srcN1 =  p_u32Rn & 0xff;
		DSPU32 srcN2 = (p_u32Rn & 0xff00)     >> 8;
		DSPU32 srcN3 = (p_u32Rn & 0xff0000)   >> 16;
		DSPU32 srcN4 = (p_u32Rn & 0xff000000) >> 24;

		srcMax_n = srcN4 > srcN3 ? srcN4 : srcN3;
		srcMax_n = srcMax_n > srcN2 ? srcMax_n : srcN2;
		srcMax_n = srcMax_n > srcN1 ? srcMax_n : srcN1;
		
		DSPU32 idxn01 = 0;
		if (srcMax_n == srcN1)
		{
			idxn01 = 0x0;
		}else
		if (srcMax_n == srcN2)
		{
			idxn01 = 0x1;
		}else
		if (srcMax_n == srcN3)
		{
			idxn01 = 0x2;
		}else
		if (srcMax_n == srcN4)
		{
			idxn01 = 0x3;
		}

		
		//p_ACC.u32Low = srcMax_m > srcMax_n ? srcMax_m :srcMax_n ;
		DSPU32 umax = srcMax_m > srcMax_n ? srcMax_m :srcMax_n ;
		DSPU32 idx26 =0;
		DSPU32 idx01 =0;
		DSPU32 acc = p_ACC.u32Low & 0xff;

		if (umax > acc)
		{
			p_ACC.u32Low = umax;
			if (srcMax_m > srcMax_n)
			{
				idx26 = p_u32RmIdx;
				idx01 = idxm01;
			}
			else
			{
				idx26 = p_u32RnIdx;
				idx01 = idxn01;
			}
			idx26 = (idx26 << 2) | idx01;

			if (p_u32PageIdx ==1)
			{
			idx26 = idx26 | 0x100;
			}
			p_ACC.u32Low = p_ACC.u32Low | (idx26 << 16);
		}
	}

	else if (p_u32CompSel == 2)
	{
		if ((p_u32Rm == 0x00010001)&&(p_u32Rn == 0x00010001))
		{
			int i = 9;
		}
		DSPU32 srcMax_m = 0;
		DSPU32 srcM1 =  p_u32Rm & 0xff;
		DSPU32 srcM2 = (p_u32Rm & 0xff00)     >> 8;
		DSPU32 srcM3 = (p_u32Rm & 0xff0000)   >> 16;
		DSPU32 srcM4 = (p_u32Rm & 0xff000000) >> 24;

		srcMax_m = srcM4 > srcM3 ? srcM4 : srcM3;
		srcMax_m = srcMax_m > srcM2 ? srcMax_m : srcM2;
		srcMax_m = srcMax_m > srcM1 ? srcMax_m : srcM1;
		
		DSPU32 idxm01 = 0;
		if (srcMax_m == srcM1)
		{
			idxm01 = 0x0;
		}
		else
		if (srcMax_m == srcM2)
		{
			idxm01 = 0x1;
		}else

		if (srcMax_m == srcM3)
		{
			idxm01 = 0x2;
		}else
		if (srcMax_m == srcM4)
		{
			idxm01 = 0x3;
		}
		DSPU32 srcMax_n = 0;
		DSPU32 srcN1 =  p_u32Rn & 0xff;
		DSPU32 srcN2 = (p_u32Rn & 0xff00)     >> 8;
		DSPU32 srcN3 = (p_u32Rn & 0xff0000)   >> 16;
		DSPU32 srcN4 = (p_u32Rn & 0xff000000) >> 24;

		srcMax_n = srcN4 > srcN3 ? srcN4 : srcN3;
		srcMax_n = srcMax_n > srcN2 ? srcMax_n : srcN2;
		srcMax_n = srcMax_n > srcN1 ? srcMax_n : srcN1;
		
		DSPU32 idxn01 = 0;
		if (srcMax_n == srcN1)
		{
			idxn01 = 0x0;
		}else
		if (srcMax_n == srcN2)
		{
			idxn01 = 0x1;
		}else
		if (srcMax_n == srcN3)
		{
			idxn01 = 0x2;
		}else
		if (srcMax_n == srcN4)
		{
			idxn01 = 0x3;
		}

		srcMax_n = p_ACC.u32Low & 0xff;
		//p_ACC.u32Low = srcMax_m > srcMax_n ? srcMax_m :srcMax_n ;
		
		if (srcMax_m > srcMax_n)
		{
			p_ACC.u32Low = srcMax_m;
			DSPU32 idx26 =0;
			DSPU32 idx01 =0;
			if (srcMax_m > srcMax_n)
			{
				idx26 = p_u32RmIdx;
				idx01 = idxm01;
			}
			
		
			idx26 = (idx26 << 2) | idx01;

			if (p_u32PageIdx ==1)
			{
				idx26 = idx26 | 0x100;
			}
			p_ACC.u32Low = p_ACC.u32Low | (idx26 << 16);
		}
	}
	p_ACC.u32Low = p_ACC.u32Low & 0x1ff00ff;
	p_ACC.u8Mid  = 0x0;
	p_ACC.u8High = 0x0;
}
/*1found*****************************************************************
	函数名：		AccMinFix8
	
	对应指令形式: LOACCs=MIN_S(ORm,ORn,LOACCs)(U)
	              LOACCs=MIN_S(ORm,ORn)(U)
	              //LOACCs=Min_S(ORm,LOACCs)(U)

	描述:		无符号定点数选小，取Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]中的最小值放在ACC[7:0]；
					ACC的其他位清零；
	        该指令不影响标志位。
	        最小值对应序号放在ACCs[?:?]，对序号的定义如下；(GRQ)
	        		ACCs[7:0]对应的序号为ACCs[?:?]原来的值。
	        		当寄存器堆选择为A面时，9位序号的第[9]位为0，9位序号的第[9]位为1；
              Rm[31:24]对应序号的第[8:7]位为{2'b11}；Rm[23:16]对应序号的第[8:7]位为{2'b10}；
              Rm[15:8]对应序号的第[8:7]位为{2'b01}；Rm[7:0]对应序号的第[8:7]位为{2'b00}；
              Rn[31:24]对应序号的第[8:7]位为{2'b11}；Rn[23:16]对应序号的第[8:7]位为{2'b10}；
              Rn[15:8]对应序号的第[8:7]位为{2'b01}；Rn[7:0]对应序号的第[8:7]位为{2'b00}；
              Rm寄存器对应序号的低6位为m；Rn寄存器对应序号的低6位为n。              
	        

	参数:			p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]、ACCs[7:0]九者选大
					    1 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、Rn[31:24]、Rn[23:16]、Rn[15:8]、Rn[7:0]八者选大
					    2 -- Rm[31:24]、Rm[23:16]、Rm[15:8]、Rm[7:0]、ACCs[7:0]五者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/

extern void AccMinFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{

	if (p_u32CompSel == 1)
	{
		if ((p_u32Rm == 0x00010001)&&(p_u32Rn == 0x00010001))
		{
			int i = 9;
		}
		DSPU32 srcMax_m = 0;
		DSPU32 srcM1 =  p_u32Rm & 0xff;
		DSPU32 srcM2 = (p_u32Rm & 0xff00)     >> 8;
		DSPU32 srcM3 = (p_u32Rm & 0xff0000)   >> 16;
		DSPU32 srcM4 = (p_u32Rm & 0xff000000) >> 24;

		srcMax_m = srcM4 < srcM3 ? srcM4 : srcM3;
		srcMax_m = srcMax_m < srcM2 ? srcMax_m : srcM2;
		srcMax_m = srcMax_m < srcM1 ? srcMax_m : srcM1;
		
		DSPU32 idxm01 = 0;
		if (srcMax_m == srcM1)
		{
			idxm01 = 0x0;
		}
		else
		if (srcMax_m == srcM2)
		{
			idxm01 = 0x1;
		}else

		if (srcMax_m == srcM3)
		{
			idxm01 = 0x2;
		}else
		if (srcMax_m == srcM4)
		{
			idxm01 = 0x3;
		}
		DSPU32 srcMax_n = 0;
		DSPU32 srcN1 =  p_u32Rn & 0xff;
		DSPU32 srcN2 = (p_u32Rn & 0xff00)     >> 8;
		DSPU32 srcN3 = (p_u32Rn & 0xff0000)   >> 16;
		DSPU32 srcN4 = (p_u32Rn & 0xff000000) >> 24;

		srcMax_n = srcN4 < srcN3 ? srcN4 : srcN3;
		srcMax_n = srcMax_n < srcN2 ? srcMax_n : srcN2;
		srcMax_n = srcMax_n < srcN1 ? srcMax_n : srcN1;
		
		DSPU32 idxn01 = 0;
		if (srcMax_n == srcN1)
		{
			idxn01 = 0x0;
		}else
		if (srcMax_n == srcN2)
		{
			idxn01 = 0x1;
		}else
		if (srcMax_n == srcN3)
		{
			idxn01 = 0x2;
		}else
		if (srcMax_n == srcN4)
		{
			idxn01 = 0x3;
		}

		
		p_ACC.u32Low = srcMax_m < srcMax_n ? srcMax_m :srcMax_n ;
		
		DSPU32 idx26 =0;
		DSPU32 idx01 =0;
		if (srcMax_m < srcMax_n)
		{
			idx26 = p_u32RmIdx;
			idx01 = idxm01;
		}
		else
		{
			idx26 = p_u32RnIdx;
			idx01 = idxn01;
		}
		idx26 = (idx26 << 2) | idx01;

		if (p_u32PageIdx ==1)
		{
		idx26 = idx26 | 0x100;
		}
		p_ACC.u32Low = p_ACC.u32Low | (idx26 << 16);
	}
	else if (p_u32CompSel == 0)
	{
		if ((p_u32Rm == 0x00010001)&&(p_u32Rn == 0x00010001))
		{
			int i = 9;
		}
		DSPU32 srcMax_m = 0;
		DSPU32 srcM1 =  p_u32Rm & 0xff;
		DSPU32 srcM2 = (p_u32Rm & 0xff00)     >> 8;
		DSPU32 srcM3 = (p_u32Rm & 0xff0000)   >> 16;
		DSPU32 srcM4 = (p_u32Rm & 0xff000000) >> 24;

		srcMax_m = srcM4 < srcM3 ? srcM4 : srcM3;
		srcMax_m = srcMax_m < srcM2 ? srcMax_m : srcM2;
		srcMax_m = srcMax_m < srcM1 ? srcMax_m : srcM1;
		
		DSPU32 idxm01 = 0;
		if (srcMax_m == srcM1)
		{
			idxm01 = 0x0;
		}
		else
		if (srcMax_m == srcM2)
		{
			idxm01 = 0x1;
		}else

		if (srcMax_m == srcM3)
		{
			idxm01 = 0x2;
		}else
		if (srcMax_m == srcM4)
		{
			idxm01 = 0x3;
		}
		DSPU32 srcMax_n = 0;
		DSPU32 srcN1 =  p_u32Rn & 0xff;
		DSPU32 srcN2 = (p_u32Rn & 0xff00)     >> 8;
		DSPU32 srcN3 = (p_u32Rn & 0xff0000)   >> 16;
		DSPU32 srcN4 = (p_u32Rn & 0xff000000) >> 24;

		srcMax_n = srcN4 < srcN3 ? srcN4 : srcN3;
		srcMax_n = srcMax_n < srcN2 ? srcMax_n : srcN2;
		srcMax_n = srcMax_n < srcN1 ? srcMax_n : srcN1;
		
		DSPU32 idxn01 = 0;
		if (srcMax_n == srcN1)
		{
			idxn01 = 0x0;
		}else
		if (srcMax_n == srcN2)
		{
			idxn01 = 0x1;
		}else
		if (srcMax_n == srcN3)
		{
			idxn01 = 0x2;
		}else
		if (srcMax_n == srcN4)
		{
			idxn01 = 0x3;
		}

		
		//p_ACC.u32Low = srcMax_m > srcMax_n ? srcMax_m :srcMax_n ;
		DSPU32 umax = srcMax_m < srcMax_n ? srcMax_m :srcMax_n ;
		DSPU32 idx26 =0;
		DSPU32 idx01 =0;
		DSPU32 acc = p_ACC.u32Low & 0xff;

		if (umax < acc)
		{
			p_ACC.u32Low = umax;
			if (srcMax_m < srcMax_n)
			{
				idx26 = p_u32RmIdx;
				idx01 = idxm01;
			}
			else
			{
				idx26 = p_u32RnIdx;
				idx01 = idxn01;
			}
			idx26 = (idx26 << 2) | idx01;

			if (p_u32PageIdx ==1)
			{
			idx26 = idx26 | 0x100;
			}
			p_ACC.u32Low = p_ACC.u32Low | (idx26 << 16);
		}
	}

	if (p_u32CompSel == 2)
	{
		if ((p_u32Rm == 0x00010001)&&(p_u32Rn == 0x00010001))
		{
			int i = 9;
		}
		DSPU32 srcMax_m = 0;
		DSPU32 srcM1 =  p_u32Rm & 0xff;
		DSPU32 srcM2 = (p_u32Rm & 0xff00)     >> 8;
		DSPU32 srcM3 = (p_u32Rm & 0xff0000)   >> 16;
		DSPU32 srcM4 = (p_u32Rm & 0xff000000) >> 24;

		srcMax_m = srcM4 < srcM3 ? srcM4 : srcM3;
		srcMax_m = srcMax_m < srcM2 ? srcMax_m : srcM2;
		srcMax_m = srcMax_m < srcM1 ? srcMax_m : srcM1;
		
		DSPU32 idxm01 = 0;
		if (srcMax_m == srcM1)
		{
			idxm01 = 0x0;
		}
		else
		if (srcMax_m == srcM2)
		{
			idxm01 = 0x1;
		}else

		if (srcMax_m == srcM3)
		{
			idxm01 = 0x2;
		}else
		if (srcMax_m == srcM4)
		{
			idxm01 = 0x3;
		}
		DSPU32 srcMax_n = 0;
		DSPU32 srcN1 =  p_u32Rn & 0xff;
		DSPU32 srcN2 = (p_u32Rn & 0xff00)     >> 8;
		DSPU32 srcN3 = (p_u32Rn & 0xff0000)   >> 16;
		DSPU32 srcN4 = (p_u32Rn & 0xff000000) >> 24;

		srcMax_n = srcN4 < srcN3 ? srcN4 : srcN3;
		srcMax_n = srcMax_n < srcN2 ? srcMax_n : srcN2;
		srcMax_n = srcMax_n < srcN1 ? srcMax_n : srcN1;
		
		DSPU32 idxn01 = 0;
		if (srcMax_n == srcN1)
		{
			idxn01 = 0x0;
		}else
		if (srcMax_n == srcN2)
		{
			idxn01 = 0x1;
		}else
		if (srcMax_n == srcN3)
		{
			idxn01 = 0x2;
		}else
		if (srcMax_n == srcN4)
		{
			idxn01 = 0x3;
		}

		srcMax_n = p_ACC.u32Low & 0xff;
		//p_ACC.u32Low = srcMax_m < srcMax_n ? srcMax_m :srcMax_n ;
		
		DSPU32 idx26 =0;
		DSPU32 idx01 =0;
		if (srcMax_m < srcMax_n)
		{
			p_ACC.u32Low = srcMax_m;
			if (srcMax_m < srcMax_n)
			{
				idx26 = p_u32RmIdx;
				idx01 = idxm01;
			}

			idx26 = (idx26 << 2) | idx01;

			if (p_u32PageIdx ==1)
			{
				idx26 = idx26 | 0x100;
			}
			p_ACC.u32Low = p_ACC.u32Low | (idx26 << 16);
		}
	}

	p_ACC.u32Low = p_ACC.u32Low & 0x1ff00ff;
	p_ACC.u8Mid  = 0x0;
	p_ACC.u8High = 0x0;

}
bool MaxFix16_(DSPU16 p_u16Rm, DSPU16 p_u16Rn,DSPU32 p_u32ALUCR)
{
		bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
		bool bolRmIsBiger;
		DSPI16 i32Src1 = (DSPI16)p_u16Rm ;
		DSPI16 i32Src2 = (DSPI16)p_u16Rn ;
		if (bolSigned)
		{
			bolRmIsBiger = (i32Src1 > i32Src2);
			
		}
		else
		{
			bolRmIsBiger = (p_u16Rm > p_u16Rn);
			
		}
		return bolRmIsBiger;
}
/*1found*****************************************************************
	函数名：		AccMax5Fix16
	
	对应指令形式: LHACCs=MAX_S(HRm,HRn,LHACCs); 

	描述:		取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]
	        对序号的定义如下；
	        		ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
              Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；              
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax5Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid =  0;
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	//

	if ((p_u32Rm == 0x80018001)&&(p_u32Rn == 0x80018001))
	{
		//int i = 0;
	}
	DSP_BIT48 p_ACC_T;
	AccMax4Fix16( p_u32Rm,  p_u32Rn,  p_u32RmIdx,  p_u32RnIdx,  p_u32PageIdx,  p_ACC_T,  p_u32ALUCR);

	DSPU16 src1 = p_ACC_T.u32Low & 0xffff;
	DSPU16 src2 = p_ACC.u32Low & 0xffff;

	bool bmax = false;
	bmax = MaxFix16_(src1, src2, p_u32ALUCR);

	if (bmax)
	{
		p_ACC = p_ACC_T;
	}
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	p_ACC.u8Mid = 0x0;
	p_ACC.u8High = 0x0;
}
/*1found*****************************************************************
	函数名：		AccMin5Fix16
	
	对应指令形式: LHACCs=MIN_S(HRm,HRn,LHACCs)

	描述:		取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]
	        对序号的定义如下；
	        		ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
              Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；              
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin5Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid =  0;
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	//
	if ((p_u32Rm == 0x80018001)&&(p_u32Rn == 0x80018001))
	{
		//int i = 0;
	}
	DSP_BIT48 p_ACC_T;
	AccMin4Fix16( p_u32Rm,  p_u32Rn,  p_u32RmIdx,  p_u32RnIdx,  p_u32PageIdx,  p_ACC_T,  p_u32ALUCR);

	DSPU16 src1 = p_ACC_T.u32Low & 0xffff;
	DSPU16 src2 = p_ACC.u32Low & 0xffff;
	bool bmax = false;
	bmax = MaxFix16_(src2, src1, p_u32ALUCR);
	if (bmax)
	{
		p_ACC = p_ACC_T;
	}
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	p_ACC.u8Mid = 0x0;
	p_ACC.u8High = 0x0;
}


/*1found*****************************************************************
	函数名：		AccMax4Fix16
	
	对应指令形式: LHACCs=MAX_S(HRm,HRn)197 25

	描述:		有符号定点数选大，取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]
	        对序号的定义如下；
              Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；     
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMax4Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	//
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid =  0;
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	//
	//
	if ((p_u32Rm == 0x80018001)&&(p_u32Rn == 0x80018001))
	{
		//int i = 0;
	}
	DSPU16 srcmh = (p_u32Rm & 0xffff0000) >> 16;
	DSPU16 srcml = p_u32Rm & 0xffff;
	bool bmax = false;
	bmax = MaxFix16_(srcmh, srcml, p_u32ALUCR);
	DSPU32 midx6 = 0;
	DSPU16 srcm = bmax ? srcmh : srcml;
	
	if (bmax)
	{
		midx6 = 1;
	}
	DSPU16 srcnh = (p_u32Rn & 0xffff0000) >> 16;
	DSPU16 srcnl = p_u32Rn & 0xffff;
	DSPU32 nidx6 = 0;
	bmax = MaxFix16_(srcnh, srcnl, p_u32ALUCR);
	DSPU16 srcn = bmax ? srcnh : srcnl;
	if (bmax)
	{
		nidx6 = 1; 
	}
	DSPU32 idx6 = 0;
	DSPU16 srcmax = 0;
	DSPU16 srcidx = 0;
	bmax = MaxFix16_(srcm, srcn, p_u32ALUCR);

	if (bmax)
	{
		idx6 = midx6;
		srcmax = srcm;
		srcidx = p_u32RmIdx;
	}
	else
	{
		idx6 = nidx6;
		srcmax = srcn;
		srcidx = p_u32RnIdx;
	}
	p_ACC.u32Low = srcmax ;
	
	DSPU32 idx = srcidx & 0x3f;
	if (idx6 == 1)
	{
		idx = (idx<<1) | 0x1;
	}
	else
	{
		idx = (idx<<1);
	}
	if (p_u32PageIdx == 1)
	{
		idx = idx | 0x80;
	}
	p_ACC.u32Low = p_ACC.u32Low & 0xffff;
	p_ACC.u32Low = p_ACC.u32Low | (idx << 16);
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
}



/*1found*****************************************************************
	函数名：		AccMin4Fix16
	2632 
	对应指令形式: LHACCs=MIN_S(HRm,HRn); 

	描述:		有符号定点数选小，取Rm[31:16]、Rm[15:0]、Rn[31:16]、Rn[15:0]中的最小值及对应的序号放在ACCs中的指定位置；
	        对序号的定义如下；
	        		Rm[31:16]的序号：[5:0]位序号为m,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rm[15:0]的序号：[5:0]位序号为m,第[6]位为 0，第[7]位为 寄存器页面选择；
              Rn[31:16]的序号：[5:0]位序号为n,第[6]位为 1，第[7]位为 寄存器页面选择；
              Rn[15:0]的序号：[5:0]位序号为n,第[6]位为 0，第[7]位为 寄存器页面选择；     
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择，0或1。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMin4Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid =  0;
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	//
	if ((p_u32Rm == 0x80018001)&&(p_u32Rn == 0x80018001))
	{
		//int i = 0;
	}
	DSPU16 srcmh = (p_u32Rm & 0xffff0000) >> 16;
	DSPU16 srcml = p_u32Rm & 0xffff;
	bool bmax = false;
	bmax = MaxFix16_(srcml, srcmh, p_u32ALUCR);
	DSPU32 midx6 = 0;
	DSPU16 srcm = (bmax) ? srcmh : srcml;
	if (bmax)
	{
		midx6 = 1;
	}
	DSPU16 srcnh = (p_u32Rn & 0xffff0000) >> 16;
	DSPU16 srcnl = p_u32Rn & 0xffff;
	DSPU32 nidx6 = 0;
	bmax = MaxFix16_(srcnl, srcnh, p_u32ALUCR);
	DSPU16 srcn = (bmax) ? srcnh : srcnl;
	if (bmax)
	{
		nidx6 = 1; 
	}
	DSPU32 idx6 = 0;
	DSPU16 srcmax = 0;
	DSPU16 srcidx = 0;
	bmax = MaxFix16_(srcn, srcm, p_u32ALUCR);
	if (bmax)
	{
		idx6 = midx6;
		srcmax = srcm;
		srcidx = p_u32RmIdx;
	}
	else
	{
		idx6 = nidx6;
		srcmax = srcn;
		srcidx = p_u32RnIdx;
	}
	p_ACC.u32Low = srcmax ;
	
	DSPU32 idx = srcidx & 0x3f;
	if (idx6 == 1)
	{
		idx = (idx<<1) | 0x1;
	}
	else
	{
		idx = (idx<<1);
	}
	if (p_u32PageIdx == 1)
	{
		idx = idx | 0x80;
	}
	p_ACC.u32Low = p_ACC.u32Low & 0xffff;
	p_ACC.u32Low = p_ACC.u32Low | (idx << 16);
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
}
/*1found*****************************************************************
	函数名：		AccMaxFix16Manh
	
	对应指令形式: LHACCs=MAX_S(manh(CHRm),manh(CHRn))

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最大值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
		          abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxFix16Manh(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	
	if ((p_u32Rm == 0x00010001)&&(p_u32Rn ==0x80008000 ))
	{
		//int i = 0;
	}
	DSPU32 tmpStat= 0;
	DSPU32 m_Stat= 0;
	DSPU32 n_Stat= 0;
	DSPU32 srcm = alu_AbsD16( p_u32Rm,&tmpStat,p_u32ALUCR|0x1);
	DSPU32 srcmh = (srcm & 0xffff0000) >> 16;
	DSPU32 srcml = srcm & 0xffff;
	DSPU32 srcm32 = Add32( srcmh,srcml,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcm16 = Add16( srcmh,srcml,&m_Stat,p_u32ALUCR&0xfffffffe);
	
	
	

	DSPU32 srcn = alu_AbsD16( p_u32Rn,&tmpStat,p_u32ALUCR|0x1);
	DSPU32 srcnh = (srcn & 0xffff0000) >> 16;
	DSPU32 srcnl = srcn & 0xffff;
	DSPU32 srcn32 = Add32( srcnh,srcnl,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcn16 = Add16( srcnh,srcnl,&n_Stat,p_u32ALUCR&0xfffffffe);


	DSPU32 srcmin = 0;
	DSPU32 srcidx = 0;   //30 18
	if (srcm32 > srcn32)
	{
		srcmin = srcm16;
		srcidx = p_u32RmIdx;
		*p_pStatReg |= m_Stat;
	}
	else
	{
		srcmin = srcn16;
		srcidx = p_u32RnIdx;
		*p_pStatReg |= n_Stat;
	}
	
	{
		p_ACC.u32Low = srcmin;
		srcidx = (srcidx << 16) ;
		p_ACC.u32Low = p_ACC.u32Low | srcidx;
	}

	p_ACC.u32Low = p_ACC.u32Low & 0x7fffff;
	if (p_u32PageIdx == 1)
	{
		p_ACC.u32Low = p_ACC.u32Low | 0x400000;
	}
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
	
}
/*1found*****************************************************************
	函数名：		AccMinFix16Manh
	
	对应指令形式: LHACCs=MIN_S(manh(CHRm),manh(CHRn))

	描述:		有符号定点数选小，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、
	            ACCs[15:0]最小值存放在ACC[15:0]，最小值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
		          abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinFix16Manh(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	if ((p_u32Rm == 0x00010001)&&(p_u32Rn ==0x80008000 ))
	{
		//int i = 0;
	}
	DSPU32 tmpStat= 0;
	DSPU32 m_Stat= 0;
	DSPU32 n_Stat= 0;
	DSPU32 srcm = alu_AbsD16( p_u32Rm,&tmpStat,p_u32ALUCR);
	DSPU32 srcmh = (srcm & 0xffff0000) >> 16;
	DSPU32 srcml = srcm & 0xffff;
	DSPU32 srcm32 = Add32( srcmh,srcml,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcm16 = Add16( srcmh,srcml,&m_Stat,p_u32ALUCR&0xfffffffe);
	
	

	DSPU32 srcn = alu_AbsD16( p_u32Rn,&tmpStat,p_u32ALUCR);
	DSPU32 srcnh = (srcn & 0xffff0000) >> 16;
	DSPU32 srcnl = srcn & 0xffff;
	DSPU32 srcn32 = Add32( srcnh,srcnl,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcn16 = Add16( srcnh,srcnl,&n_Stat,p_u32ALUCR&0xfffffffe);


	DSPU32 srcmin = 0;
	DSPU32 srcidx = 0;   //30 18
	if (srcm32 < srcn32)
	{
		srcmin = srcm16;
		srcidx = p_u32RmIdx;
		*p_pStatReg |= m_Stat;
	}
	else
	{
		srcmin = srcn16;
		srcidx = p_u32RnIdx;
		*p_pStatReg |= n_Stat;
	}
	p_ACC.u32Low  = 0x0;
	
	p_ACC.u32Low = srcmin;
	srcidx = (srcidx << 16) ;
	p_ACC.u32Low = p_ACC.u32Low | srcidx;
	
	p_ACC.u32Low = p_ACC.u32Low & 0x7fffff;
	if (p_u32PageIdx == 1)
	{
		p_ACC.u32Low = p_ACC.u32Low | 0x400000;
	}
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
	
}


/*1found*****************************************************************
	函数名：		MaxManhRmRnACC
	
	对应指令形式: LHACCs=MAX_S(manh(CHRm),manh(CHRn),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最大值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	        		abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MaxManhRmRnACC(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 tmpStat= 0;
	DSPU32 m_Stat= 0;
	DSPU32 n_Stat= 0;
	DSPU32 max_Stat = 0;
	DSPU32 srcm = alu_AbsD16( p_u32Rm,&tmpStat,p_u32ALUCR);
	DSPU32 srcmh = (srcm & 0xffff0000) >> 16;
	DSPU32 srcml = srcm & 0xffff;
	DSPU32 srcm32 = Add32( srcmh,srcml,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcm16 = Add16( srcmh,srcml,&m_Stat,p_u32ALUCR&0xfffffffe);
	
	

	DSPU32 srcn = alu_AbsD16( p_u32Rn,&tmpStat,p_u32ALUCR);
	DSPU32 srcnh = (srcn & 0xffff0000) >> 16;
	DSPU32 srcnl = srcn & 0xffff;
	DSPU32 srcn32 = Add32( srcnh,srcnl,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcn16 = Add16( srcnh,srcnl,&n_Stat,p_u32ALUCR&0xfffffffe);


	DSPU32 srcmin = 0;
	DSPU32 srcmin32 = 0;
	DSPU32 srcidx = 0;   //30 18
	if (srcm32 > srcn32)
	{
		srcmin = srcm16;
		srcidx = p_u32RmIdx;
		max_Stat = m_Stat;
		srcmin32 = srcm32;
	}
	else
	{
		srcmin = srcn16;
		srcidx = p_u32RnIdx;
		max_Stat = n_Stat;
		srcmin32 = srcn32;
	}
	DSPU32 srcAcc = p_ACC.u32Low & 0xffff;

	//if (srcmin > srcAcc)
	if (srcmin32 > srcAcc)
	{
		p_ACC.u32Low = srcmin;
		srcidx = (srcidx << 16) ;
		p_ACC.u32Low = p_ACC.u32Low | srcidx;
		*p_pStatReg |= max_Stat;
	if (p_u32PageIdx == 1)
	{
		p_ACC.u32Low = p_ACC.u32Low | 0x400000;
	}
	}
	p_ACC.u32Low = p_ACC.u32Low & 0x7fffff;
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
}
/*1found*****************************************************************
	函数名：		MinManhRmRnACC
	
	对应指令形式: LHACCs=Min_S(manh(CHRm),manh(CHRn),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、abs(Rn[31:16])+abs(Rn[15:0])、ACCs[15:0]最小值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	        		abs(Rn[31:16])+abs(Rn[15:0])对应序号的[5:0]为n,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32RnIdx -- Rn的寄存器序号，即n。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MinManhRmRnACC(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSPU32 p_u32RmIdx, DSPU32 p_u32RnIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 tmpStat= 0;
	DSPU32 m_Stat= 0;
	DSPU32 n_Stat= 0;
	DSPU32 max_Stat = 0;
	DSPU32 srcm = alu_AbsD16( p_u32Rm,&tmpStat,p_u32ALUCR);
	DSPU32 srcmh = (srcm & 0xffff0000) >> 16;
	DSPU32 srcml = srcm & 0xffff;
	DSPU32 srcm32 = Add32( srcmh,srcml,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcm16 = Add16( srcmh,srcml,&m_Stat,p_u32ALUCR&0xfffffffe);
	
	

	DSPU32 srcn = alu_AbsD16( p_u32Rn,&tmpStat,p_u32ALUCR);
	DSPU32 srcnh = (srcn & 0xffff0000) >> 16;
	DSPU32 srcnl = srcn & 0xffff;
	DSPU32 srcn32 = Add32( srcnh,srcnl,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcn16 = Add16( srcnh,srcnl,&n_Stat,p_u32ALUCR&0xfffffffe);


	DSPU32 srcmin = 0;
	DSPU32 srcmin32 = 0;
	DSPU32 srcidx = 0;   //30 18
	if (srcm32 < srcn32)
	{
		srcmin = srcm16;
		srcidx = p_u32RmIdx;
		max_Stat =m_Stat;
		srcmin32 = srcm32;
	}
	else
	{
		srcmin = srcn16;
		srcidx = p_u32RnIdx;
		max_Stat =n_Stat;
		srcmin32 = srcn32;
	}
	DSPU32 srcAcc = p_ACC.u32Low & 0xffff;
	if (srcmin32 < srcAcc)
	{
		p_ACC.u32Low = srcmin;
		srcidx = (srcidx << 16) ;
		p_ACC.u32Low = p_ACC.u32Low | srcidx;
		*p_pStatReg |= max_Stat;
	if (p_u32PageIdx == 1)
	{
		p_ACC.u32Low = p_ACC.u32Low | 0x400000;
	}
	}
	p_ACC.u32Low = p_ACC.u32Low & 0x7fffff;
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
}


/*1found*****************************************************************
	函数名：		MaxManhRmACC
	
	对应指令形式: LHACCs=MAX_S(manh(CHRm),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、ACCs[15:0]最大值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MaxManhRmACC(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 tmpStat= 0;
	DSPU32 m_Stat= 0;
	DSPU32 srcm = alu_AbsD16( p_u32Rm,&tmpStat,p_u32ALUCR);
	DSPU32 srcmh = (srcm & 0xffff0000) >> 16;
	DSPU32 srcml = srcm & 0xffff;
	DSPU32 srcm32 = Add32( srcmh,srcml,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcm16 = Add16( srcmh,srcml,&m_Stat,p_u32ALUCR&0xfffffffe);
	
	

	//DSPU32 srcn = alu_AbsD16( p_u32Rn,p_pStatReg,p_u32ALUCR);
	//DSPU32 srcnh = (srcn & 0xffff0000) >> 16;
	//DSPU32 srcnl = srcn & 0xffff;
	//DSPU16 srcn16 = Add16( srcnh,srcnl,p_pStatReg,0);

	DSPU32 srcmin = 0;
	DSPU32 srcidx = 0;
	srcmin = srcm16;
	srcidx = p_u32RmIdx;
	/*
	DSPU32 srcmin = 0;
	DSPU32 srcidx = 0;   //30 18
	if (srcm16 > srcn16)
	{
		srcmin = srcm16;
		srcidx = p_u32RmIdx;
	}
	else
	{
		srcmin = srcn16;
		srcidx = p_u32RnIdx;
	}
	*/
	DSPU32 srcAcc = p_ACC.u32Low & 0xffff;
	//if (srcmin > srcAcc)
	if (srcm32 > srcAcc)
	{
		p_ACC.u32Low = srcmin;
		srcidx = (srcidx << 16) ;
		p_ACC.u32Low = p_ACC.u32Low | srcidx;
		*p_pStatReg |= m_Stat;
			if (p_u32PageIdx == 1)
	{
		p_ACC.u32Low = p_ACC.u32Low | 0x400000;
	}
	}
	p_ACC.u32Low = p_ACC.u32Low & 0x7fffff;
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
}
/*1found*****************************************************************
	函数名：		MinManhRmACC
	
	对应指令形式: LHACCs=Min_S(manh(CHRm),LHACCs)

	描述:		有符号定点数选大，取abs(Rm[31:16])+abs(Rm[15:0])、ACCs[15:0]最小值存放在ACC[15:0]，最大值对应序号放在ACCs[22:16]；
	        对序号的定义如下；
	        		abs(Rm[31:16])+abs(Rm[15:0])对应序号的[5:0]为m,序号的[6]为寄存器页面选择；
	      	ACC的其他位清零。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 寄存器页面选择。
					p_ACC -- 累加寄存器中的值，共48位。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void MinManhRmACC(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 tmpStat= 0;
	DSPU32 m_Stat= 0;
	DSPU32 srcm = alu_AbsD16( p_u32Rm,&tmpStat,p_u32ALUCR);
	DSPU32 srcmh = (srcm & 0xffff0000) >> 16;
	DSPU32 srcml = srcm & 0xffff;
	DSPU32 srcm32 = Add32( srcmh,srcml,&tmpStat,p_u32ALUCR&0xfffffffe);
	DSPU16 srcm16 = Add16( srcmh,srcml,&m_Stat,p_u32ALUCR&0xfffffffe);
	
	

	//DSPU32 srcn = alu_AbsD16( p_u32Rn,p_pStatReg,p_u32ALUCR);
	//DSPU32 srcnh = (srcn & 0xffff0000) >> 16;
	//DSPU32 srcnl = srcn & 0xffff;
	//DSPU16 srcn16 = Add16( srcnh,srcnl,p_pStatReg,0);

    DSPU32 srcmin = 0;
	DSPU32 srcidx = 0;
	srcmin = srcm16;
	srcidx = p_u32RmIdx;
	/*
	DSPU32 srcmin = 0;
	DSPU32 srcidx = 0;   //30 18
	if (srcm16 > srcn16)
	{
		srcmin = srcm16;
		srcidx = p_u32RmIdx;
	}
	else
	{
		srcmin = srcn16;
		srcidx = p_u32RnIdx;
	}
	*/
	DSPU32 srcAcc = p_ACC.u32Low & 0xffff;
	if (srcm32 < srcAcc)
	{
		p_ACC.u32Low = srcmin;
		srcidx = (srcidx << 16) ;
		p_ACC.u32Low = p_ACC.u32Low | srcidx;
		*p_pStatReg |= m_Stat;
			if (p_u32PageIdx == 1)
	{
		p_ACC.u32Low = p_ACC.u32Low | 0x400000;
	}
	}
	p_ACC.u32Low = p_ACC.u32Low & 0x7fffff;
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
}

extern bool Max32_BOOL(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u32Src1;
    DSPU32 u32Src2Tmp = p_u32Src2;
    
    bool uDest;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    //bool p_bolZero = false;
    if(bolSigned)
    {
        u32Src1Tmp ^= 1 << (OpBits - 1);
        u32Src2Tmp ^= 1 << (OpBits - 1);
    }
    
    if (u32Src1Tmp > u32Src2Tmp)
    {
        uDest = true;
    }
    else 
    {
        uDest = false;
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
} 
extern bool Min32_BOOL(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    int OpBits = sizeof(p_u32Src1) * 8;
    
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    
    DSPU32 u32Src1Tmp = p_u32Src1;
    DSPU32 u32Src2Tmp = p_u32Src2;
    
    bool uDest;
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    //bool p_bolZero = false;
    if(bolSigned)
    {
        u32Src1Tmp ^= 1 << (OpBits - 1);
        u32Src2Tmp ^= 1 << (OpBits - 1);
    }
    
    if (u32Src1Tmp < u32Src2Tmp)
    {
        uDest = true;
    }
    else 
    {
        uDest = false;
    }
    
    //一般情形 或饱和情形下根据饱和结果  最后设置状态寄存器AZ，AN            
    
    return uDest;
} 
/*1found*****************************************************************
	函数名：		AccMaxR2Fix32MN
	
	对应指令形式: ACCs=MAX_R(Rm_Rn,ACCs)

	描述:		有符号定点数选大，将Rn[31:0]值与ACCs[31:0]进行选大，如果ACCs值大，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，Rn[31:0]取代ACCs[31:0]；
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Fix32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	DSPU32 tmpStatReg = 0;
	//Max32(p_u32Rm, p_ACC.u32Low, &p_pStatReg,p_u32ALUCR);
	
	bool bDest = Max32_BOOL(p_u32Rn, p_ACC.u32Low, &tmpStatReg,p_u32ALUCR);
	if (bDest)
	{
		p_ACC.u32Low = p_u32Rn;
		p_ACC.u8Mid  = p_u32Rm & 0x7f;
	}
	
	p_ACC.u8High = 0;	
	p_ACC.u8Mid  = p_ACC.u8Mid & 0x7f;	


}
/*1found*****************************************************************
	函数名：		AccMinR2Fix32MN
	
	对应指令形式: ACCs=Min_R(Rm_Rn,ACCs) 

	描述:		有符号定点数选小，将Rn值与ACCs[31:0]进行选小，如果ACCs值小，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，Rn[31:0]取代ACCs[31:0]；
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                     

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Fix32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	DSPU32 tmpStatReg = 0;
	//Max32(p_u32Rm, p_ACC.u32Low, &p_pStatReg,p_u32ALUCR);
	
	bool bDest = Min32_BOOL(p_u32Rn, p_ACC.u32Low, &tmpStatReg,p_u32ALUCR);
	if (bDest)
	{
		p_ACC.u32Low = p_u32Rn;
		p_ACC.u8Mid  = p_u32Rm & 0x7f;
	}
	p_ACC.u8High = 0;
	p_ACC.u8Mid  = p_ACC.u8Mid & 0x7f;	
}

/*1found*****************************************************************
	函数名：		ACCAddQ8

	对应指令形式: OACCs =ORn (U)
                  OACCs =ORn{U,con=Rm}
                  OACCs+=ORn (U)
                  OACCs+=ORn{U,con=Rm}

	描述:		源操作数内的四个8位定点数据分别累加。
	        累加过程：累加结果寄存器分为四个?位寄存器以适应短字操作，源操作数内的8位数据扩展为?位数据，再与ACC中的?位数据累加。
	        GRQ: 累加过程待确认。

	参数:		p_u32Src -- 源操作数，对应Rn。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCAddQ8(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//*p_pStatReg = 0;
	DSPU32 src1 = p_u32Src & 0xff;
	DSPU32 src2 = (p_u32Src & 0xff00) >> 8;
	DSPU32 src3 = (p_u32Src & 0xff0000) >> 16;
	DSPU32 src4 = (p_u32Src & 0xff000000) >> 24;

	
	DSPU32 acc1 = (p_ACC.u32Low & 0x3ff);
	DSPU32 acc2 = ((p_ACC.u32Low>>10) & 0x3ff);
	DSPU32 acc3 = ((p_ACC.u32Low>>20) & 0x3ff);
	DSPU32 acc4 = p_ACC.u32Low >> 30 ;
    acc4 = acc4 | (p_ACC.u8Mid<<2);

	//acc1-=src1;
	DSPU10 p_pACC1(acc1);
	ACCAdd8Once(src1, &p_pACC1, p_pStatReg, p_u32ALUCR);
	acc1 = p_pACC1.GetU32();

	//acc2-=src2;
	DSPU10 p_pACC2(acc2);
	ACCAdd8Once(src2, &p_pACC2, p_pStatReg, p_u32ALUCR);
	acc2 = p_pACC2.GetU32();

	//acc3-=src3;
	DSPU10 p_pACC3(acc3);
	ACCAdd8Once(src3, &p_pACC3, p_pStatReg, p_u32ALUCR);
	acc3 = p_pACC3.GetU32();
	//acc4-=src4;

	DSPU10 p_pACC4(acc4);
	ACCAdd8Once(src4, &p_pACC4, p_pStatReg, p_u32ALUCR);
	acc4 = p_pACC4.GetU32();
	
	
		
	DSPU32 src32 = (acc1 & 0x3ff) | ((acc2&0x3ff) << 10) | ((acc3&0x3ff) << 20) | ((acc4&0x3ff) << 30);
    DSPU32 src8 = acc4>>2;
	
	p_ACC.u32Low = src32;
	p_ACC.u8Mid  = src8;
	
p_ACC.u8High = 0;



}
/*1found*****************************************************************
	函数名：		ACCSubQ8

	对应指令形式: OACCs-=0Rn (U)
                OACCs-=0Rn{U,con=Rm}

	描述:		源操作数内的四个8位定点数据分别累减。
	        累减过程：累加结果寄存器分为四个?位寄存器以适应短字操作，源操作数内的8位数据扩展为?位数据，再与ACC中的?位数据累减。
	        GRQ: 累减过程待确认。

	参数:		p_u32Src -- 源操作数，对应Rn。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。
					p_u32ALUCR -- ALU控制寄存器。		

	返回值：		无。
	

	修改记录
	--------------------------------------
	日期			作者			修改处
*******************************************************************/
extern void ACCSubQ8(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	if (p_u32Src == 0x0053208e)
	{
		//int i = 0;
	}


	DSPU32 src1 = p_u32Src & 0xff;
	DSPU32 src2 = (p_u32Src & 0xff00) >> 8;
	DSPU32 src3 = (p_u32Src & 0xff0000) >> 16;
	DSPU32 src4 = (p_u32Src & 0xff000000) >> 24;

	
	DSPU32 acc1 = (p_ACC.u32Low & 0x3ff);
	DSPU32 acc2 = ((p_ACC.u32Low>>10) & 0x3ff);
	DSPU32 acc3 = ((p_ACC.u32Low>>20) & 0x3ff);
	DSPU32 acc4 = p_ACC.u32Low >> 30 ;
    acc4 = acc4 | (p_ACC.u8Mid<<2);

	//acc1-=src1;
	DSPU10 p_pACC1(acc1);
	ACCSub8Once(src1, &p_pACC1, p_pStatReg, p_u32ALUCR);
	acc1 = p_pACC1.GetU32();

	//acc2-=src2;
	DSPU10 p_pACC2(acc2);
	ACCSub8Once(src2, &p_pACC2, p_pStatReg, p_u32ALUCR);
	acc2 = p_pACC2.GetU32();

	//acc3-=src3;
	DSPU10 p_pACC3(acc3);
	ACCSub8Once(src3, &p_pACC3, p_pStatReg, p_u32ALUCR);
	acc3 = p_pACC3.GetU32();
	//acc4-=src4;

	DSPU10 p_pACC4(acc4);
	ACCSub8Once(src4, &p_pACC4, p_pStatReg, p_u32ALUCR);
	acc4 = p_pACC4.GetU32();
		
	DSPU32 src32 = (acc1 & 0x3ff) | ((acc2&0x3ff) << 10) | ((acc3&0x3ff) << 20) | ((acc4&0x3ff) << 30);
    DSPU32 src8 = acc4>>2;
	
	p_ACC.u32Low = src32;
	p_ACC.u8Mid  = src8;
	p_ACC.u8High = 0;
}

/*1found*****************************************************************
	函数名：		ACCQ8OnCON
	
	对应指令形式: OACCs+=0Rn{conc}
                OACCs+=0Rn{U,conc,con=Rm}

	描述:		源操作数内的四个8位定点数分别累加或累减，受累加控制寄存器CON内四个8位字段的最高位控制，
					最高位为0表示累加，最高位为1表示累减；累加操作完成后CON内四个8位字段
					分别左移一位。ALU0~ALU7每一个都配备一个32位累加控制寄存器。
					

	参数:			p_u32Src -- 源操作数，包括四个8位定点数据。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pCON -- 指向累加控制寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果；
					    更新累加控制寄存器。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCQ8OnCON(DSPU32 p_u32Src, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 *p_pCON, DSPU32 p_u32ALUCR)
{
	DSPU32 src1 = p_u32Src & 0xff;
	DSPU32 src2 = (p_u32Src & 0xff00) >> 8;
	DSPU32 src3 = (p_u32Src & 0xff0000) >> 16;
	DSPU32 src4 = (p_u32Src & 0xff000000) >> 24;

	
	DSPU32 acc1 = (p_ACC.u32Low & 0x3ff);
	DSPU32 acc2 = ((p_ACC.u32Low>>10) & 0x3ff);
	DSPU32 acc3 = ((p_ACC.u32Low>>20) & 0x3ff);
	DSPU32 acc4 = p_ACC.u32Low >> 30 ;
    acc4 = acc4 | (p_ACC.u8Mid<<2);

	
	DSPU32 conc1 = (*p_pCON) & 0x80;
	DSPU32 conc2 = ((*p_pCON) & 0x8000) >> 8;
	DSPU32 conc3 = ((*p_pCON) & 0x800000) >> 16;
	DSPU32 conc4 = ((*p_pCON) & 0x80000000) >> 24;



	if (conc1 == 0x0)
	{
		DSPU10 p_pACC1(acc1);
		ACCAdd8Once(src1, &p_pACC1, p_pStatReg, p_u32ALUCR);
		acc1 = p_pACC1.GetU32();
		//acc1+=src1;
	}
	else if (conc1 == 0x80)
	{
		//acc1-=src1;
	DSPU10 p_pACC1(acc1);
	ACCSub8Once(src1, &p_pACC1, p_pStatReg, p_u32ALUCR);
	acc1 = p_pACC1.GetU32();
	}

	if (conc2 == 0x0)
	{
		//acc2+=src2;
		DSPU10 p_pACC2(acc2);
		ACCAdd8Once(src2, &p_pACC2, p_pStatReg, p_u32ALUCR);
		acc2 = p_pACC2.GetU32();

	}
	else if (conc2 == 0x80)
	{
		//acc2-=src2;
	DSPU10 p_pACC2(acc2);
	ACCSub8Once(src2, &p_pACC2, p_pStatReg, p_u32ALUCR);
	acc2 = p_pACC2.GetU32();
	}

	if (conc3 == 0x0)
	{
		//acc3+=src3;
		DSPU10 p_pACC3(acc3);
		ACCAdd8Once(src3, &p_pACC3, p_pStatReg, p_u32ALUCR);
		acc3 = p_pACC3.GetU32();
	}
	else if (conc3 == 0x80)
	{
		//acc3-=src3;
	DSPU10 p_pACC3(acc3);
	ACCSub8Once(src3, &p_pACC3, p_pStatReg, p_u32ALUCR);
	acc3 = p_pACC3.GetU32();
	}

	if (conc4 == 0x0)
	{
		//acc4+=src4;
		DSPU10 p_pACC4(acc4);
		ACCAdd8Once(src4, &p_pACC4, p_pStatReg, p_u32ALUCR);
		acc4 = p_pACC4.GetU32();
	}
	else if (conc4 == 0x80)
	{
		//acc4-=src4;
	DSPU10 p_pACC4(acc4);
	ACCSub8Once(src4, &p_pACC4, p_pStatReg, p_u32ALUCR);
	acc4 = p_pACC4.GetU32();
	}
	
		
	DSPU32 src32 = (acc1 & 0x3ff) | ((acc2&0x3ff) << 10) | ((acc3&0x3ff) << 20) | ((acc4&0x3ff) << 30);
    DSPU32 src8 = acc4>>2;
	
	p_ACC.u32Low = src32;
	p_ACC.u8Mid  = src8;
	conc1 = (*p_pCON) & 0xff;
	conc2 = ((*p_pCON) & 0xff00) >> 8;
	conc3 = ((*p_pCON) & 0xff0000) >> 16;
	conc4 = ((*p_pCON) & 0xff000000) >> 24;

	conc1 = (conc1 <<1) & 0xff;
	conc2 = (conc2 <<1) & 0xff;
	conc3 = (conc3 <<1) & 0xff;
	conc4 = (conc4 <<1) & 0xff;
	*p_pCON = conc1 | (conc2 << 8) | (conc3 <<16) | (conc4 <<24);
	p_ACC.u8High = 0;
}


/*1found*****************************************************************
	函数名：		AccMaxS3Fix16
	
	对应指令形式: LHACCs=MAX_S(HRm,LHACCs)

	描述:		16位定点有符号数选大操作：取Rm[31:16]、Rm[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号放在ACCs[23:16]；
	        8位序号按照如下定义：
              Rm[31:16]对应序号的[5:0]为m,第[6]位为 1,第[7]位为寄存器页面选择；
              Rm[15:0]对应序号的[5:0]为m,第[6]位为 0,第[7]位为寄存器页面选择；
              ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxS3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	//
	p_ACC.u8High = 0;
	p_ACC.u8Mid =  0;
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	//
	/*
	DSPU32 srch = (p_u32Rm & 0xffff0000) >> 16;
	DSPU32 srcl = p_u32Rm & 0xffff;
	DSPU32 test1 = p_ACC.u32Low;
	AccMaxR2Fix16(srch,p_ACC,p_u32ALUCR);
	if (srch == p_ACC.u32Low)
	{
		DSPU32 PageIdx = 0x0;
		if (p_u32PageIdx == 1)
		{
			PageIdx = 0x80;
		}
		else
		{
			PageIdx = 0x0;
		}
		DSPU32 test2 = (((p_u32RmIdx & 0x7F) | PageIdx) &0xff) << 16;
		p_ACC.u32Low = p_ACC.u32Low & 0xffff;
		p_ACC.u32Low = p_ACC.u32Low | test2;
	}
	test1 = p_ACC.u32Low;
	AccMaxR2Fix16(srcl, p_ACC, p_u32ALUCR);
	if (srcl == p_ACC.u32Low)
	{
		DSPU32 PageIdx = 0x0;
		if (p_u32PageIdx == 1)
		{
			PageIdx = 0x80;
		}
		else
		{
			PageIdx = 0x0;
		}
		DSPU32 test2 = (((p_u32RmIdx & 0x3F)| PageIdx) &0xff) << 16;
		p_ACC.u32Low = p_ACC.u32Low & 0xffff;
		p_ACC.u32Low = p_ACC.u32Low | test2;
	}
	*/

	if ((p_u32Rm == 0x80018001)&&(p_u32Rm == 0x80018001))
	{
		//int i = 0;
	}
	//DSP_BIT48 p_ACC_T;
	AccMax5Fix16( p_u32Rm,  p_u32Rm,  p_u32RmIdx,  p_u32RmIdx,  p_u32PageIdx,  p_ACC,  p_u32ALUCR);
	p_ACC.u8High = 0;
	/*
	DSPI16 src1 = p_ACC_T.u32Low & 0xffff;
	DSPI16 src2 = p_ACC.u32Low & 0xffff;

	if (src1>src2)
	{
		p_ACC = p_ACC_T;
	}
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	p_ACC.u8Mid = 0x0;*/


}
/*1found*****************************************************************
	函数名：		AccMinS3Fix16
	
	对应指令形式: LHACCs=Min_S(HRm,LHACCs)

	描述:		16位定点有符号数选小操作：取Rm[31:16]、Rm[15:0]、ACCs[15:0]最小值放在ACCs[15:0]，最小值对应序号放在ACCs[23:16]；
	        8位序号按照如下定义：
              Rm[31:16]对应序号的[5:0]为m,第[6]位为 1,第[7]位为寄存器页面选择；
              Rm[15:0]对应序号的[5:0]为m,第[6]位为 0,第[7]位为寄存器页面选择；
              ACCs[15:0]对应的序号为ACCs[23:16]中的原值。
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32RmIdx -- Rm的寄存器序号，即m。
					p_u32PageIdx -- 通用寄存器页面，0或1。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinS3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32RmIdx, DSPU32 p_u32PageIdx, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
		//
	p_ACC.u8High = 0;
	p_ACC.u8Mid =  0;
	p_ACC.u32Low = p_ACC.u32Low & 0xffffff;
	//
	/*
	DSPU32 srch = (p_u32Rm && 0xffff0000) >> 16;
	DSPU32 srcl = p_u32Rm && 0xffff;
	DSPU32 test1 = p_ACC.u32Low;
	AccMinR2Fix16(srch,p_ACC,p_u32ALUCR);
	if (srch == p_ACC.u32Low)
	{
		DSPU32 PageIdx = 0x0;
		if (p_u32PageIdx == 1)
		{
			PageIdx = 0xff;
		}
		else
		{
			PageIdx = 0x7f;
		}
		DSPU32 test2 = (((p_u32RmIdx || 0xc0) && PageIdx) &&0xff) << 16;
		p_ACC.u32Low = p_ACC.u32Low && 0xffff;
		p_ACC.u32Low = p_ACC.u32Low || test2;
	}
	test1 = p_ACC.u32Low;
	AccMinR2Fix16(srcl, p_ACC, p_u32ALUCR);
	if (srcl == p_ACC.u32Low)
	{
		DSPU32 PageIdx = 0x0;
		if (p_u32PageIdx == 1)
		{
			PageIdx = 0xff;
		}
		else
		{
			PageIdx = 0x7f;
		}
		DSPU32 test2 = (((p_u32RmIdx || 0xc0) && PageIdx) &&0xff) << 16;
		p_ACC.u32Low = p_ACC.u32Low && 0xffff;
		p_ACC.u32Low = p_ACC.u32Low || test2;
	}
*/

	AccMin5Fix16( p_u32Rm,  p_u32Rm,  p_u32RmIdx,  p_u32RmIdx,  p_u32PageIdx,  p_ACC,  p_u32ALUCR);
p_ACC.u8High = 0;
}

/*1found*****************************************************************
	函数名：		AccIsFlo32MN
	
	对应指令形式: FACCs=FRm_Rn

	描述:		将Rm[6:0]送到ACC[38:32]，FRn送到ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccIsFlo32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	p_ACC.u32Low = p_u32Rn;
	DSPU32 test1 = p_u32Rm & 0x7f;
	p_ACC.u8Mid = test1;
	p_ACC.u8High = 0;

}

/*1found*****************************************************************
	函数名：		AccMaxR2Flo32MN
	
	对应指令形式: FACCs=MAX_R(FRm_Rn,FACCs) 

	描述:		将FRn[31:0]值与ACCs[31:0]进行选大，如果ACCs值大，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，FRn[31:0]取代ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Flo32MN_old(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	p_ACC.u8High = 0;
	
	Cfloat32 fRnTmp(p_ACC.u32Low);
	if (fRnTmp.IsDNORM())
	{
		p_ACC.u32Low = p_ACC.u32Low & 0xff800000;
	}
	if ((p_u32Rm == 0xa7c8314b) &&( p_u32Rn == 0x805c5b1f))
	{
		//int i = 0;
	}
	DSPU32 p_pStatReg = 0;
	DSPU32 result = MaxF32(p_u32Rn,p_ACC.u32Low, &p_pStatReg, p_u32ALUCR);
	if (result == 0xffffffff)
	{
		p_ACC.u32Low = result;
		p_ACC.u8Mid = 0xff;
		return;
	}
	DSPU32 src = p_ACC.u32Low;
	Cfloat32 cfSrc1(src);
	Cfloat32 cfSrc2(p_u32Rn);
	if ((cfSrc1.IsZero()|| cfSrc1.IsDNORM())
		&&(cfSrc2.IsZero()|| cfSrc2.IsDNORM())
		&&(cfSrc1.IsNega()==  cfSrc2.IsNega())
		)
	{
		p_ACC.u32Low = result;
		p_ACC.u8High = 0;
		return;
	}

	if ((result != p_ACC.u32Low)&&(result == p_u32Rn))
	{
		p_ACC.u32Low = result;
		if (result == 0xffffffff)
		{
			p_ACC.u8Mid = 0xff;
			return;
		}else
		{
			p_ACC.u8Mid = p_u32Rm & 0x7f;
		}
	}
	else if ((result != p_ACC.u32Low)&&(result != p_u32Rn))
	{
		if (result == 0xffffffff)
		{
			p_ACC.u32Low = result;
			p_ACC.u8Mid = 0xff;
			return;
		}
		else
		{
			
			
			DSPU32 src = p_ACC.u32Low;
			Cfloat32 cfSrc1(src);
			Cfloat32 cfSrc2(p_u32Rn);
			if (!cfSrc1.IsNega() && cfSrc2.IsNega())
			{
				p_ACC.u32Low = result;
				return ;		
			}
			else if (cfSrc1.IsNega() && !cfSrc2.IsNega()) 
			{
				p_ACC.u8Mid = p_u32Rm & 0x7f;
				p_ACC.u32Low = result;
				return;
			}
			if (cfSrc1.IsZero() || cfSrc1.IsDNORM())
			{
				p_ACC.u32Low = result;
				return ;
			}else if (cfSrc2.IsZero()||cfSrc2.IsDNORM() )
			{
				p_ACC.u8Mid = p_u32Rm & 0x7f;
			}
			p_ACC.u32Low = result;
		}
		
	}
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid & 0x7f;
}
extern void AccMaxR2Flo32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	AccMaxR2Flo32MN_old(p_u32Rm, p_u32Rn, p_ACC, p_u32ALUCR);
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid & 0x7f;
}

/*1found*****************************************************************
	函数名：		AccMinR2Flo32MN
	
	对应指令形式: FACCs=MIN_R(FRm_Rn,FACCs) 

	描述:		将FRn值与ACCs[31:0]进行选小，如果ACCs值小，则ACCs值保持不变，否则将Rm[6:0]取代ACCs[38:32]，FRn[31:0]取代ACCs[31:0]
	      	ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Flo32MN_old(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	p_ACC.u8High = 0;
	
	Cfloat32 fRnTmp(p_ACC.u32Low);
	if (fRnTmp.IsDNORM())
	{
		p_ACC.u32Low = p_ACC.u32Low & 0xff800000;
	}

	if ((p_u32Rm == 0xa7c8314b) &&( p_u32Rn == 0x805c5b1f))
	{
		//int i = 0;
	}
	DSPU32 p_pStatReg = 0;
	DSPU32 result = MinF32(p_u32Rn,p_ACC.u32Low, &p_pStatReg, p_u32ALUCR);
	if (result == 0xffffffff)
	{
		p_ACC.u32Low = result;
		p_ACC.u8Mid = 0xff;
		return;
	}
		DSPU32 src = p_ACC.u32Low;
	Cfloat32 cfSrc1(src);
	Cfloat32 cfSrc2(p_u32Rn);
	if ((cfSrc1.IsZero()|| cfSrc1.IsDNORM())
		&&(cfSrc2.IsZero()|| cfSrc2.IsDNORM())
		&&(cfSrc1.IsNega()==  cfSrc2.IsNega())
		)
	{
		p_ACC.u32Low = result;
		return;
	}

	if ((result != p_ACC.u32Low)&&(result == p_u32Rn))
	{
		p_ACC.u32Low = result;
		if (result == 0xffffffff)
		{
			p_ACC.u8Mid = 0xff;
			return;
		}else
		{
			p_ACC.u8Mid = p_u32Rm & 0x7f;
		}
	}
	else if ((result != p_ACC.u32Low)&&(result != p_u32Rn))
	{
		if (result == 0xffffffff)
		{
			p_ACC.u32Low = result;
			p_ACC.u8Mid = 0xff;
			return;
		}
		else
		{
			
			DSPU32 src = p_ACC.u32Low;
			Cfloat32 cfSrc1(src);
			Cfloat32 cfSrc2(p_u32Rn);
			if (cfSrc1.IsNega() && !cfSrc2.IsNega())
			{
				p_ACC.u32Low = result;
				return ;		
			}
			else if (!cfSrc1.IsNega() && cfSrc2.IsNega()) 
			{
				p_ACC.u8Mid = p_u32Rm & 0x7f;
				p_ACC.u32Low = result;
				return;
			}
			if (cfSrc1.IsZero() || cfSrc1.IsDNORM())
			{
				p_ACC.u32Low = result;
				return;
			}else if (cfSrc2.IsZero()||cfSrc2.IsDNORM() )
			{
				p_ACC.u8Mid = p_u32Rm & 0x7f;
			}
			p_ACC.u32Low = result;
		}
	}
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid & 0x7f;
}
extern void AccMinR2Flo32MN(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	AccMinR2Flo32MN_old( p_u32Rm,  p_u32Rn, p_ACC, p_u32ALUCR);
	p_ACC.u8High = 0;
	p_ACC.u8Mid = p_ACC.u8Mid & 0x7f;
}

/*1found*****************************************************************
	函数名：		AccMaxR3Fix16
	
	对应指令形式: LHACCs=MAX_R(HRm,HRn,LHACCs)

	描述:		取Rm[15:0]、Rn[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号Rm[23:16]、Rn[23:16]或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	/*
	AccMaxR2Fix16(p_u32Rm,p_ACC,p_u32ALUCR);
	AccMaxR2Fix16(p_u32Rn, p_ACC, p_u32ALUCR);
	p_ACC.u8High = 0;
	p_ACC.u8Mid = 0;
	p_ACC.u32Low =p_ACC.u32Low & 0xffffff;
	*/
	//

	DSP_BIT48 tmp_p_ACC;
	tmp_p_ACC.u32Low = p_u32Rn & 0xffffff;;
	tmp_p_ACC.u8Mid  = 0;
	tmp_p_ACC.u8High = 0;
	AccMaxR2Fix16(p_u32Rm,tmp_p_ACC,p_u32ALUCR);
	DSPU32 tmpsrc = tmp_p_ACC.u32Low;

	AccMaxR2Fix16(tmpsrc, p_ACC, p_u32ALUCR);
	p_ACC.u32Low =p_ACC.u32Low & 0xffffff;

	/*
	AccMinR2Fix16(p_u32Rm,p_ACC,p_u32ALUCR);
	AccMinR2Fix16(p_u32Rn, p_ACC, p_u32ALUCR);
	p_ACC.u32Low =p_ACC.u32Low & 0xffffff;
	*/

}
bool Min16_BOOL(DSPU16 p_u32Rm, DSPU16 p_u32Rn, DSPU32 p_u32ALUCR)
{
	bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i32Src1 = (DSPI16)p_u32Rm ;
    DSPI16 i32Src2 = (DSPI16)p_u32Rn ;
    if (bolSigned)
    {
        bolRmIsBiger = (i32Src1 < i32Src2);
		
    }
    else
    {
        bolRmIsBiger = (p_u32Rm < p_u32Rn);
    }
	return bolRmIsBiger;
}
bool Max16_BOOL(DSPU16 p_u32Rm, DSPU16 p_u32Rn, DSPU32 p_u32ALUCR)
{
	bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed); 
    bool bolRmIsBiger;
    DSPI16 i32Src1 = (DSPI16)p_u32Rm ;
    DSPI16 i32Src2 = (DSPI16)p_u32Rn ;
    if (bolSigned)
    {
        bolRmIsBiger = (i32Src1 > i32Src2);
		
    }
    else
    {
        bolRmIsBiger = (p_u32Rm > p_u32Rn);
    }
	return bolRmIsBiger;
}

    
/*1found*****************************************************************
	函数名：		AccMinR2Fix16Reg
	
	对应指令形式: LHACCs=Min_R(HRm,HRn)

	描述:		取Rm[15:0]、Rn[15:0]最小值放在ACCs[15:0]，最小值对应序号Rm[23:16]或Rn[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Fix16Reg(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{

		DSPU16 srcRm = p_u32Rm & 0xffFF;
		DSPU16 srcRn = p_u32Rn & 0xffFF;
		bool bDest = Min16_BOOL( srcRm,  srcRn,  p_u32ALUCR);
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (bDest)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0xff0000;
		}
		else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_u32Rn & 0xff0000;
		}
		p_ACC.u32Low = srcMaxR;
		p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;
		p_ACC.u8Mid = 0;
		p_ACC.u8High = 0;
		p_ACC.u32Low =p_ACC.u32Low & 0xffffff;

}
/*1found*****************************************************************
	函数名：		AccMinR3Fix16
	
	对应指令形式: LHACCs=Min_R(HRm,HRn,LHACCs)

	描述:		取Rm[15:0]、Rn[15:0]、ACCs[15:0]最小值放在ACCs[15:0]，最小值对应序号Rm[23:16]、Rn[23:16]或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR3Fix16(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{
	DSP_BIT48 tmp_p_ACC;
	tmp_p_ACC.u32Low = p_u32Rn & 0xffffff;;
	tmp_p_ACC.u8Mid  = 0;
	tmp_p_ACC.u8High = 0;
	AccMinR2Fix16(p_u32Rm,tmp_p_ACC,p_u32ALUCR);
	DSPU32 tmpsrc = tmp_p_ACC.u32Low;

	AccMinR2Fix16(tmpsrc, p_ACC, p_u32ALUCR);
	p_ACC.u32Low =p_ACC.u32Low & 0xffffff;

	/*
	AccMinR2Fix16(p_u32Rm,p_ACC,p_u32ALUCR);
	AccMinR2Fix16(p_u32Rn, p_ACC, p_u32ALUCR);
	p_ACC.u32Low =p_ACC.u32Low & 0xffffff;
	*/
}
/*1found*****************************************************************
	函数名：		AccMaxRFix8
	
	对应指令形式: LOACCs=Max_R(ORm,ORn,LOACCs)(U)
	              LOACCs=MAX_R(ORm,ORn)(U)                
                LOACCs=Max_R(ORm,LOACCs)(U)

	描述:		将Rm[7:0]、Rn[7:0]、ACCs[7:0]的最大值放在ACCs[7:0]，最大值对应的Rm[?:?]、Rn[?:?]、ACCs[?:?]作为序号放在ACCs的[?:?]
					ACC的其他位清零；
	        该指令不影响标志位。          
	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32CompSel -- 选择参与选大的数据
					    0 -- Rm[7:0]、Rn[7:0]、ACCs[7:0]三者选大
					    1 -- Rm[7:0]、Rn[7:0]二者选大
					    2 -- Rm[7:0]、ACCs[7:0]二者选大
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxRFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{
	if (p_u32CompSel == 0)
	{

		DSPU32 srcRm = p_u32Rm & 0xff;
		DSPU32 srcRn = p_u32Rn & 0xff;
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (srcRm > srcRn)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0x1ff0000;
		}else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_u32Rn & 0x1ff0000;
		}
		DSPU32 srcAcc = p_ACC.u32Low & 0xff;

		if (srcMaxR > srcAcc)
		{
			p_ACC.u32Low = srcMaxR;
			p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;
		}
		else
		{
			p_ACC.u32Low =p_ACC.u32Low & 0x1ff00ff;
		}
		p_ACC.u8Mid = 0;
	}
	if (p_u32CompSel == 1)
	{
		DSPU32 srcRm = p_u32Rm & 0xff;
		DSPU32 srcRn = p_u32Rn & 0xff;
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (srcRm > srcRn)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0x1ff0000;
		}else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_u32Rn & 0x1ff0000;
		}
		p_ACC.u32Low = srcMaxR;
		p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;

	}
	if (p_u32CompSel == 2)
	{
		DSPU32 srcRm = p_u32Rm & 0xff;
		DSPU32 srcRn = p_ACC.u32Low & 0xff;
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (srcRm > srcRn)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0x1ff0000;
		}else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_ACC.u32Low & 0x1ff0000;
		}
		p_ACC.u32Low = srcMaxR;
		p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;

	}
	p_ACC.u32Low = p_ACC.u32Low & 0x1ff00ff;
	p_ACC.u8High = 0x0;
	p_ACC.u8Mid  = 0x0;


}
/*1found*****************************************************************
	函数名：		AccMinRFix8
	
	对应指令形式: LOACCs=Min_R(ORm,ORn,LOACCs)(U)
	              LOACCs=Min_R(ORm,ORn)(U)                
				  LOACCs=Min_R(ORm,LOACCs)(U)

	描述:		将Rm[7:0]、Rn[7:0]、ACCs[7:0]的最小值放在ACCs[7:0]，最小值对应的Rm[?:?]、Rn[?:?]、ACCs[?:?]作为序号放在ACCs的[?:?]
					ACC的其他位清零；
	        该指令不影响标志位。          
	        

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_u32CompSel -- 选择参与选小的数据
					    0 -- Rm[7:0]、Rn[7:0]、ACCs[7:0]三者选小
					    1 -- Rm[7:0]、Rn[7:0]二者选小
					    2 -- Rm[7:0]、ACCs[7:0]二者选小
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinRFix8(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR, DSPU32 p_u32CompSel)
{
	if (p_u32CompSel == 0)
	{

		DSPU32 srcRm = p_u32Rm & 0xff;
		DSPU32 srcRn = p_u32Rn & 0xff;
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (srcRm < srcRn)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0x1ff0000;
		}else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_u32Rn & 0x1ff0000;
		}
		DSPU32 srcAcc = p_ACC.u32Low & 0xff;

		if (srcMaxR < srcAcc)
		{
			p_ACC.u32Low = srcMaxR;
			p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;
		}
		else
		{
			p_ACC.u32Low =p_ACC.u32Low & 0x1ff00ff;
		}
		p_ACC.u8Mid = 0;

	}
	if (p_u32CompSel == 1)
	{
		DSPU32 srcRm = p_u32Rm & 0xff;
		DSPU32 srcRn = p_u32Rn & 0xff;
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (srcRm < srcRn)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0x1ff0000;
		}else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_u32Rn & 0x1ff0000;
		}
		p_ACC.u32Low = srcMaxR;
		p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;

	}
	if (p_u32CompSel == 2)
	{
		DSPU32 srcRm = p_u32Rm & 0xff;
		DSPU32 srcRn = p_ACC.u32Low & 0xff;
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (srcRm < srcRn)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0x1ff0000;
		}else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_ACC.u32Low & 0x1ff0000;
		}
		p_ACC.u32Low = srcMaxR;
		p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;

	}

	p_ACC.u32Low = p_ACC.u32Low & 0x1ff00ff;
	p_ACC.u8High = 0x0;
	p_ACC.u8Mid  = 0x0;

}

/*1found*****************************************************************
	函数名：		AccMaxR2Fix16Reg
	
	对应指令形式: LHACCs=MAX_R(HRm,HRn)

	描述:		取Rm[15:0]、Rn[15:0]最大值放在ACCs[15:0]，最大值对应序号Rm[23:16]或Rn[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_u32Rn -- 寄存器Rn中的值。
					p_ACC -- 累加寄存器中的值，共48位。					
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Fix16Reg(DSPU32 p_u32Rm, DSPU32 p_u32Rn, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{

		DSPU16 srcRm = p_u32Rm & 0xffFF;
		DSPU16 srcRn = p_u32Rn & 0xffFF;
		bool bDest = Max16_BOOL( srcRm,  srcRn,  p_u32ALUCR);
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (bDest)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0xff0000;
		}
		else
		{
			srcMaxR = srcRn;
			srcMaxIdx = p_u32Rn & 0xff0000;
		}
		p_ACC.u32Low = srcMaxR;
		p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;
		p_ACC.u8Mid = 0;
		p_ACC.u8High = 0;
		p_ACC.u32Low =p_ACC.u32Low & 0xffffff;

}
/*1found*****************************************************************
	函数名：		AccMaxR2Fix16
	
	对应指令形式: LHACCs=MAX_R(HRm,LHACCs)

	描述:		取Rm[15:0]、ACCs[15:0]最大值放在ACCs[15:0]，最大值对应序号Rm[23:16]、或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
					p_ACC -- 累加寄存器中的值，共48位。
					p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMaxR2Fix16(DSPU32 p_u32Rm, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
{

		DSPU16 srcRm = p_u32Rm & 0xffFF;
		DSPU16 srcRn = p_ACC.u32Low & 0xffff;
		bool bDest = Max16_BOOL( srcRm,  srcRn,  p_u32ALUCR);
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (bDest)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0xff0000;
			p_ACC.u32Low = srcMaxR;
			p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;
			p_ACC.u8Mid = 0;
		}
		
	p_ACC.u8Mid = 0;
	p_ACC.u8High = 0;
	p_ACC.u32Low =p_ACC.u32Low & 0xffffff;


}
/*1found*****************************************************************
	函数名：		AccMinR2Fix16
	
	对应指令形式: LHACCs=MIN_R(HRm,LHACCs)

	描述:		取Rm[15:0]、ACCs[15:0]最小值放在ACCs[15:0]，最小值对应序号Rm[23:16]、或ACCs[23:16]放在ACCs[23:16]
	        ACC的其他位清零；
	        该指令不影响标志位。

	参数:		p_u32Rm -- 寄存器Rm中的值。
				p_ACC -- 累加寄存器中的值，共48位。
				p_u32ALUCR -- ALU控制寄存器。	                               // 算法实现是否用到p_u32ALUCR？

	返回值：		无。

	注意事项:		

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void AccMinR2Fix16(DSPU32 p_u32Rm, DSP_BIT48 &p_ACC, DSPU32 p_u32ALUCR)
//DSPU32 MinD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
		DSPU16 srcRm = p_u32Rm & 0xffFF;
		DSPU16 srcRn = p_ACC.u32Low & 0xffff;
		bool bDest = Min16_BOOL( srcRm,  srcRn,  p_u32ALUCR);
		DSPU32 srcMaxR = 0;
		DSPU32 srcMaxIdx = 0;
		if (bDest)
		{
			srcMaxR = srcRm;
			srcMaxIdx = p_u32Rm & 0xff0000;
			p_ACC.u32Low = srcMaxR;
			p_ACC.u32Low = p_ACC.u32Low | srcMaxIdx;
			p_ACC.u8Mid = 0;
		}
		p_ACC.u8Mid = 0;
		p_ACC.u8High = 0;
		p_ACC.u32Low =p_ACC.u32Low & 0xffffff;
}

/*1found*****************************************************************
	函数名：		ACCAddSubD16
	
	对应指令形式: HACCs = LHRm_HHRn (U)
                HACCs = HHRm_LHRn (U)
                HACCs +/-= LHRm_HHRn (U)
                HACCs -/+= LHRm_HHRn (U)
                HACCs +/-= HHRm_LHRn (U)
                HACCs -/+= HHRm_LHRn (U)

	描述:		双16位拼接无符号定点数累加累减。运算结果放在累加结果寄存器(ACC)。
          

	参数:		p_u32Src1 -- 源操作数1，对应Rm。
					p_u32Src2 -- 源操作数2，对应Rn。
					p_ACC -- 48位累加结果寄存器中的值。                                   
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					p_u32Mode -- 模式选择。
			  0： Rm低16位数据放置在ACC高位，Rn高16位数据放置在ACC低位，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              1： Rm高16位数据放置在ACC高位，Rn低16位数据放置在ACC低位，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              2： Rm低16位数据与ACC高位累加，Rn高16位数据与ACC低位累减，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              3： Rm低16位数据与ACC高位累减，Rn高16位数据与ACC低位累加，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              4： Rm高16位数据与ACC高位累加，Rn低16位数据与ACC低位累减，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
              5： Rm高16位数据与ACC高位累减，Rn低16位数据与ACC低位累加，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern void ACCAddSubD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSP_BIT48 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR, DSPU32 p_u32Mode)
{
	//状态寄存器标志位除了ALU的粘性标志位外 全部清0 ,实际只清0 AI .而AC,AV,AZ,AN在下面设置   
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);   
	//*p_pStatReg &= BIT(8) | BIT(13) ;//| BIT(ALU_AOS)  | BIT(ALU_AIS);   
	/*
	0： Rm低16位数据放置在ACC高位，Rn高16位数据放置在ACC低位，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
    1： Rm高16位数据放置在ACC高位，Rn低16位数据放置在ACC低位，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
    2： Rm低16位数据与ACC高位累加，Rn高16位数据与ACC低位累减，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
    3： Rm低16位数据与ACC高位累减，Rn高16位数据与ACC低位累加，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
    4： Rm高16位数据与ACC高位累加，Rn低16位数据与ACC低位累减，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
    5： Rm高16位数据与ACC高位累减，Rn低16位数据与ACC低位累加，使用ACC的低40位，分高低20位使用，ACC的高8位清零。
	*/

	
	bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
	if (p_u32Mode == 0)
	{
		
		DSPU32 srcm  = p_u32Src1 & 0xffff;
		//
		DSPU20 u20srcm (srcm);
		if (p_bolSigned)
		{
			u20srcm.SignExtend();
			srcm = u20srcm.GetU32();
		}
		//
		p_ACC.u32Low = srcm << 20;
		p_ACC.u8Mid  = (srcm & 0xff000) >> 12; 
		DSPU32 srcn  = (p_u32Src2 & 0xffff0000) >> 16;
		//
		DSPU20 u20srcn (srcn);
		if (p_bolSigned)
		{
			u20srcn.SignExtend();
			srcn = u20srcn.GetU32();
		}
		//
		p_ACC.u32Low = p_ACC.u32Low  | (srcn & 0xfffff);
	}

	if (p_u32Mode == 1)
	{
		DSPU32 srcm  = (p_u32Src1 & 0xffff0000) >> 16;
			//
		DSPU20 u20srcm (srcm);
		if (p_bolSigned)
		{
			u20srcm.SignExtend();
			srcm = u20srcm.GetU32();
		}
		//

		p_ACC.u32Low = srcm << 20;
		p_ACC.u8Mid  = (srcm & 0xff000) >> 12; 
		DSPU32 srcn  = (p_u32Src2 & 0xffff);

			//
		DSPU20 u20srcn (srcn);
		if (p_bolSigned)
		{
			u20srcn.SignExtend();
			srcn = u20srcn.GetU32();
		}
		//

		p_ACC.u32Low = p_ACC.u32Low  | srcn;
	}
	if (p_u32Mode == 2)
	{
		DSPU32 srcm  = p_u32Src1 & 0xffff;
		DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;


		DSPU32 h_ACC = p_ACC.u32Low >> 20;
		h_ACC = h_ACC | ((p_ACC.u8Mid & 0xff) << 12);
		
		//h_ACC = h_ACC + srcm;
		DSPU20 u20UpperSrc1 ( h_ACC );//f726b //813a
		ACCAdd16Once( srcm, &u20UpperSrc1, p_pStatReg,  p_u32ALUCR);
		h_ACC = u20UpperSrc1.GetU32() & 0xfffff;

		p_ACC.u32Low = h_ACC << 20;
		p_ACC.u8Mid  = (h_ACC & 0xff000) >> 12;
		
		
		DSPU32 srcn  = (p_u32Src2 & 0xffff0000) >> 16;
		//DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;
		//l_ACC = l_ACC - srcn;
		//l_ACC = ~l_ACC + ~srcn + 2;
		DSPU20 u20UpperSrc2 ( l_ACC );
		
		ACCSub16Once(srcn, &u20UpperSrc2, p_pStatReg, p_u32ALUCR);
		
		l_ACC = u20UpperSrc2.GetU32() & 0xfffff;
		
		p_ACC.u32Low = p_ACC.u32Low  | l_ACC;
	}
	if (p_u32Mode == 3)
	{
		DSPU32 srcm  = p_u32Src1 & 0xffff;
		DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;


		DSPU32 h_ACC = p_ACC.u32Low >> 20;
		h_ACC = h_ACC | ((p_ACC.u8Mid & 0xff) << 12);
		//h_ACC = h_ACC - srcm;
		//h_ACC = ~h_ACC + ~srcm + 2;
		
		DSPU20 u20UpperSrc2 ( h_ACC );
		ACCSub16Once(srcm, &u20UpperSrc2, p_pStatReg, p_u32ALUCR);
		
		h_ACC = u20UpperSrc2.GetU32() & 0xfffff;

		p_ACC.u32Low = h_ACC << 20;
		p_ACC.u8Mid  = (h_ACC & 0xff000) >> 12;
		
		
		DSPU32 srcn  = (p_u32Src2 & 0xffff0000) >> 16;
		//DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;
		//l_ACC = l_ACC + srcn;
			
		DSPU20 u20UpperSrc1 ( l_ACC );//f726b //813a
		ACCAdd16Once( srcn, &u20UpperSrc1, p_pStatReg,  p_u32ALUCR);
		l_ACC = u20UpperSrc1.GetU32() & 0xfffff;

		p_ACC.u32Low = p_ACC.u32Low  | l_ACC;
	}
	if (p_u32Mode == 4)
	{
		DSPU32 srcm  = (p_u32Src1 & 0xffff0000) >> 16;
		DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;


		DSPU32 h_ACC = p_ACC.u32Low >> 20;
		h_ACC = h_ACC | ((p_ACC.u8Mid & 0xff) << 12);
		//h_ACC = h_ACC + srcm;
		DSPU20 u20UpperSrc1 ( h_ACC );//f726b //813a
		ACCAdd16Once( srcm, &u20UpperSrc1, p_pStatReg,  p_u32ALUCR);
		h_ACC = u20UpperSrc1.GetU32() & 0xfffff;

		p_ACC.u32Low = h_ACC << 20;
		p_ACC.u8Mid  = (h_ACC & 0xff000) >> 12;
		
		
		DSPU32 srcn  = p_u32Src2 & 0xffff;
		//DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;
		//l_ACC = l_ACC - srcn;
		//
  
		DSPU20 u20UpperSrc2 ( l_ACC );
		ACCSub16Once(srcn, &u20UpperSrc2, p_pStatReg, p_u32ALUCR);
		
		l_ACC = u20UpperSrc2.GetU32() & 0xfffff;
		
		p_ACC.u32Low = p_ACC.u32Low  | l_ACC;
		
	}
	if (p_u32Mode == 5)
	{
		DSPU32 srcm  = (p_u32Src1 & 0xffff0000) >> 16;
		DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;


		DSPU32 h_ACC = p_ACC.u32Low >> 20;
		h_ACC = h_ACC | ((p_ACC.u8Mid & 0xff) << 12);
		//h_ACC = h_ACC - srcm;
		//h_ACC = ~h_ACC +  ~srcm + 2;
		DSPU20 u20UpperSrc2 ( h_ACC );
		ACCSub16Once(srcm, &u20UpperSrc2, p_pStatReg, p_u32ALUCR);
		
		h_ACC = u20UpperSrc2.GetU32() & 0xfffff;

		p_ACC.u32Low = h_ACC << 20;
		p_ACC.u8Mid  = (h_ACC & 0xff000) >> 12;
		
		
		DSPU32 srcn  = p_u32Src2 & 0xffff;
		//DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;
		//l_ACC = l_ACC + srcn;
		DSPU20 u20UpperSrc1 ( l_ACC );//f726b //813a
		ACCAdd16Once( srcn, &u20UpperSrc1, p_pStatReg,  p_u32ALUCR);
		l_ACC = u20UpperSrc1.GetU32() & 0xfffff;

		//l_ACC = l_ACC & 0xfffff;
		p_ACC.u32Low = p_ACC.u32Low  | l_ACC;
	}
	/*
	if ((p_u32ALUCR & 0x1) == 0x1)
	{
		DSPU32 l_ACC =  p_ACC.u32Low & 0xfffff;
		DSPU32 h_ACC = p_ACC.u32Low >> 20;
		h_ACC = h_ACC | ((p_ACC.u8Mid & 0xff) << 12);
		if (((l_ACC & 0x8000)!=0)|| ((l_ACC & 0xf0000)!=0) )
		{
			l_ACC = l_ACC | 0xF0000;
		}
		if (((h_ACC & 0x8000)!=0) || ((h_ACC & 0xf0000)!=0))
		{
			h_ACC = h_ACC | 0xF0000;
		}

		p_ACC.u32Low = h_ACC << 20;
		p_ACC.u8Mid  = (h_ACC & 0xff000) >> 12;
		p_ACC.u32Low = p_ACC.u32Low  | l_ACC;
	}
	*/
p_ACC.u8High = 0;
}

/******************************************************************
	函数名：	  ACCAddF64H

	对应指令形式: DFHACCs=DFHRm+DFHRn

	描述:		完成两个64位浮点数据高32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		    p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/

//DSPU32 gu321H = 0;
//DSPU32 gu322H = 0;

extern void ACCAddF64H_ALU(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT80 &p_FACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
//extern void ACCAddF64H(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_DF64 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 gu321H = 0;
	DSPU32 gu322H = 0;
	//
	DSP_DF64 p_ACC;
	//
	gu321H = p_u32Src1H;
	gu322H = p_u32Src2H;
	if ((p_u32Src1H == 0x7ff00000)&&(p_u32Src2H == 0xfff00000))
	{
		//int i = 0;
	}
	
	
	DSPU32 expRm  = (p_u32Src1H & 0x7FF00000)>>20;
	DSPU32 expRmF = (p_u32Src1H & 0x80000000);

	DSPU32 expRn  = (p_u32Src2H & 0x7FF00000)>>20;
	DSPU32 expRnF = (p_u32Src2H & 0x80000000);
	
	DSPU32 expMax = 0;
	DSPU32 res20 = 0;
	if (expRm == 0)
	{
		p_u32Src1H = p_u32Src1H & 0xfff00000;
	}
	if (expRn == 0)
	{
		p_u32Src2H = p_u32Src2H & 0xfff00000;
	}
	Cfloat32 cfSrc1(p_u32Src1H);
    Cfloat32 cfSrc2(p_u32Src2H);
	if (((cfSrc1.Isf64INF())&&(cfSrc2.Isf64INF()))
		&&((cfSrc1.IsNega()) != (cfSrc2.IsNega()))
		)
	{
		p_ACC.u32High = 0xFFFFFFFF;
		p_ACC.u32Low = 0xFFFFFFFF;
		p_ACC.u11exp = 0x7ff;
					//
		DSPU64 u64_1 = p_ACC.u32High;
		u64_1 = u64_1 << 32;
		u64_1 = u64_1 | p_ACC.u32Low;

		p_FACC.u64Low = u64_1;
		p_FACC.u16High = p_ACC.u11exp;
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
		//
		return;
	}
	if ((cfSrc1.Isf64NAN())||(cfSrc2.Isf64NAN()))//(p_u32Src1H == 0xFFFFFFFF)||(p_u32Src2H == 0xFFFFFFFF)||(p_u32Src1H == 0x7FFFFFFF)||(p_u32Src2H == 0x7FFFFFFF)||(p_u32Src1H == 0x7FFF7FFF)||(p_u32Src2H == 0x7FFF7FFF))
	{
		p_ACC.u32High = 0xFFFFFFFF;
		p_ACC.u32Low = 0xFFFFFFFF;
		p_ACC.u11exp = 0x7ff;
			//
		DSPU64 u64_1 = p_ACC.u32High;
		u64_1 = u64_1 << 32;
		u64_1 = u64_1 | p_ACC.u32Low;

		p_FACC.u64Low = u64_1;
		p_FACC.u16High = p_ACC.u11exp;
		//
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
		return;
	
	}
	//----------------------------- + -
	if ((expRmF == 0x0)&&(expRnF == 0x80000000))
	{
		if (expRm > expRn)
		{
			expMax = expRm;
			DSPU32 src2 = 0;
			if (((expRm - expRn) < 32)&&(expRn !=0))
			{
				src2 = ((p_u32Src2H & 0xFFFFF)| 0x100000 ) >> (expRm - expRn);
			}
			DSPU32 src1 = (p_u32Src1H & 0xFFFFF)  | 0x100000 ;
			res20 = src1 + ~src2;
			p_ACC.u32High = res20;
			p_ACC.u32Low = res20 + 1;
			p_ACC.u11exp = expMax;
		} 
		else
		{
			expMax = expRn;
			if ((expRn == expRm)
				&&((p_u32Src2H & 0xFFFFF) == (p_u32Src1H & 0xFFFFF))
				)
			{
				//expMax=0;
			}
			DSPU32 src1 = 0;
			if (((expRn - expRm) < 32)&&(p_u32Src1H !=0))
			{
				src1 = ((p_u32Src1H & 0xFFFFF)| 0x100000 ) >> (expRn - expRm);
			}
			DSPU32 src2 = 0;
			if (((p_u32Src2H & 0xFFFFF) != 0x0 )|| (expRn != 0))
			{
				src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			}
			//DSPU32 src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			res20 = src1 + ~src2;
			p_ACC.u32High = res20;
			p_ACC.u32Low = res20 + 1;
			p_ACC.u11exp = expMax;
		}
	}

	//---------------------------------   ++ --
	
	if (((expRmF == 0x0)&&(expRnF == 0x0))
		||((expRmF == 0x80000000)&&(expRnF == 0x80000000))
		
		)
	{
		if (expRm > expRn)
		{
			expMax = expRm;
			DSPU32 src1 = 0;
			if (((expRm - expRn) < 32) && (expRn != 0))
			{
				src1 = ((p_u32Src2H & 0xFFFFF)| 0x100000 ) >> (expRm - expRn);
			}
			DSPU32 src2 = 0;
			if (((p_u32Src1H & 0xFFFFF) != 0x0) || (expRm != 0))
			{
				src2 = (p_u32Src1H & 0xFFFFF)  | 0x100000 ;
			}
			res20 = src1 - ~src2 - 1;
			p_ACC.u32High = res20;
			p_ACC.u32Low = res20 + 1;
			p_ACC.u11exp = expMax;
		}
		else
		{
			expMax = expRn;
			DSPU32 src1 = 0;
			if (((expRn - expRm) < 32) && (expRn !=0) && (expRm != 0))
			{
				src1 = ((p_u32Src1H & 0xFFFFF)| 0x100000 ) >> (expRn - expRm);
			}
			//DSPU32 src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			DSPU32 src2 = 0;
			if (((p_u32Src2H & 0xFFFFF) != 0x0 || (expRn != 0)))
			{
				src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			}
			res20 = src1 - ~src2 -1 ;
			p_ACC.u32High = res20;
			p_ACC.u32Low = res20 + 1;
			p_ACC.u11exp = expMax;
		}
	}


	//----------------------------------- -+ 

	if ((expRmF == 0x80000000)&&(expRnF == 0x0))
	{
		if (expRm > expRn)
		{
			expMax = expRm;
			
			DSPU32 src1 = 0;
			if (((expRm - expRn) < 32)&&(expRn !=0))
			{
				src1 = ((p_u32Src2H & 0xFFFFF)| 0x100000 ) >> (expRm - expRn);
			}
			DSPU32 src2 = (p_u32Src1H & 0xFFFFF)  | 0x100000 ;
			res20 = src1 + ~src2;
			p_ACC.u32High = res20;
			p_ACC.u32Low = res20 + 1;
			p_ACC.u11exp = expMax;
		}
		else
		{

			expMax = expRn;
			if ((expRn == expRm)
				&&((p_u32Src2H & 0xFFFFF) == (p_u32Src1H & 0xFFFFF))
				)
			{
				//expMax=0;
			}
			DSPU32 src1 = 0;
			if (((expRn - expRm) < 32)&&(expRm !=0))
			{
				src1 = ((p_u32Src1H & 0xFFFFF)| 0x100000 ) >> (expRn - expRm);
			}
			DSPU32 src2 = 0;
			if (expRn != 0 )
			{
				src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			}
			//DSPU32 src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			res20 = ~src1 + src2;
			p_ACC.u32High = res20;
			p_ACC.u32Low = res20 + 1;
			p_ACC.u11exp = expMax;
		}
	}
	//
	
	DSPU64 u64_1 = p_ACC.u32High;
	u64_1 = u64_1 << 32;
	u64_1 = u64_1 | (p_ACC.u32Low & 0xffffffff);
	if (p_u32Src1H == 0x92345678)
	{
	//cout<<hex<<p_ACC.u32High <<" "<<p_ACC.u32Low <<" "<<u64_1<<endl;
	}
	p_FACC.u64Low = u64_1;
	p_FACC.u16High = p_ACC.u11exp;
	//
	DSPU32 u32df_inf = 0;
	if ((cfSrc1.Isf64INF())&&(!cfSrc2.Isf64INF()))
	{
		u32df_inf = 1;
	}
	if ((!cfSrc1.Isf64INF())&&(cfSrc2.Isf64INF()))
	{
		u32df_inf = 1;
	}
	if (((cfSrc1.Isf64INF())&&(cfSrc2.Isf64INF()))
		&&((cfSrc1.IsNega()) == (cfSrc2.IsNega()))
		)
	{
		u32df_inf = 1;
	}
	if (u32df_inf == 1)
	{
		SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);
	}

}
extern void ACCAddF64H(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT80 &p_FACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
//extern void ACCAddF64H(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_DF64 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	ACCAddF64H_ALU( p_u32Src1H,  p_u32Src2H, p_FACC, p_pStatReg, p_u32ALUCR);
	p_FACC.u64Low = p_FACC.u64Low & 0xffffffffffffffull;
}
//DSPU32 gu321L = 0;
//DSPU32 gu322L = 0;
/******************************************************************
	函数名：	  ACCAddF64L

	对应指令形式: DFLACCs=DFLRm+DFLRn

	描述:		完成两个64位浮点数据低32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64L_OLD(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_u64HSrc, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

//extern void ACCAddF64L(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_DF64 &p_ACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 gu321L = 0;
    DSPU32 gu322L = 0;
	gu321L = p_u32Src1L;
	gu322L = p_u32Src2L;
	DSPU32 gu321H = 0;
	DSPU32 gu322H = 0;
	gu321H = p_u64HSrc.u32High;
	gu322H = p_u64HSrc.u32Low;

	DSP_DF64 p_ACC;

	DSPU64 p_u64Src1L = 0;
	DSPU64 p_u64Src2L = 0;
	p_u64Src1L = gu321H;
	p_u64Src1L = (p_u64Src1L << 32) | p_u32Src1L;
	p_u64Src2L = gu322H;
	p_u64Src2L = (p_u64Src2L << 32) | p_u32Src2L;


	if ((p_u32Src1L == 0xff800001)&&(p_u32Src2L == 0x7f800000))
	{
		//int i = 0;
	}
	
	DSPU64 expRm  = (p_u64Src1L & 0x7FF0000000000000ull)>>52;
	DSPU64 expRmF = (p_u64Src1L & 0x8000000000000000ull);

	DSPU64 expRn  = (p_u64Src2L & 0x7FF0000000000000ull)>>52;
	DSPU64 expRnF = (p_u64Src2L & 0x8000000000000000ull);
	
	DSPU64 expMax = 0;
	DSPU64 res20 = 0;
	if (expRm == 0)
	{
		p_u64Src1L = p_u64Src1L & 0xfff0000000000000ull;
	}
	if (expRn == 0)
	{
		p_u64Src2L = p_u64Src2L & 0xfff0000000000000ull;
	}
	
	if ((p_u64Src1L == 0xFFFFFFFFFFFFFFFFull)||(p_u64Src2L == 0xFFFFFFFFFFFFFFFFull)||(p_u64Src1L == 0x7FFFFFFFFFFFFFFFull)||(p_u64Src2L == 0x7FFFFFFFFFFFFFFFull)||(p_u64Src1L == 0x7FFF7FFF)||(p_u64Src2L == 0x7FFF7FFF))
	{
		p_ACC.u32High = 0xFFFFFFFF;
		p_ACC.u32Low = 0xFFFFFFFF;
		p_ACC.u11exp = 0x7ff;
		//
		DSPU64 u64_1 = p_ACC.u32High;
		u64_1 = u64_1 << 32;
		u64_1 = u64_1 | p_ACC.u32Low;

		p_FACC.u64Low = u64_1;
		p_FACC.u16High = p_ACC.u11exp;
		//
		return;
	
	}
	if (((expRm == 0x7ff )&&((p_u64Src1L & 0xfffffffffffffull) != 0))
		||((expRn == 0x7ff )&&((p_u64Src2L & 0xfffffffffffffull) != 0))
		)
	{
		p_ACC.u32High = 0xFFFFFFFF;
		p_ACC.u32Low = 0xFFFFFFFF;
		p_ACC.u11exp = 0x7ff;
		//
		DSPU64 u64_1 = p_ACC.u32High;
		u64_1 = u64_1 << 32;
		u64_1 = u64_1 | p_ACC.u32Low;

		p_FACC.u64Low = u64_1;
		p_FACC.u16High = p_ACC.u11exp;
		//
		return;
	}
	
	//----------------------------- + -
	if ((expRmF == 0x0)&&(expRnF == 0x8000000000000000ull))
	{
		if (expRm > expRn)
		{
			expMax = expRm;
			DSPU64 src2 = 0;
			if (((expRm - expRn) < 64)&&(expRn !=0))
			{
				src2 = ((p_u64Src2L & 0xFFFFFFFFFFFFFull)| 0x10000000000000ull ) >> (expRm - expRn);
			}
			DSPU64 src1 = (p_u64Src1L & 0xFFFFFFFFFFFFFull)  | 0x10000000000000ull ;
			res20 = src1 + ~src2 + 1;
			//p_ACC.u32High = res20;
			//p_ACC.u32Low = res20 + 1;
			//p_ACC.u11exp = expMax;
		}
		else
		{
			expMax = expRn;
			if ((expRn == expRm)
				&&((p_u64Src1L & 0xFFFFFFFFFFFFFull ) == (p_u64Src2L & 0xFFFFFFFFFFFFFull))
				)
			{
				expMax=0;
			}
			DSPU64 src1 = 0;
			if (((expRn - expRm) < 64)&&(p_u64Src1L !=0))
			{
				src1 = ((p_u64Src1L & 0xFFFFFFFFFFFFFull)| 0x10000000000000ull ) >> (expRn - expRm);
			}
			DSPU64 src2 = 0;
			if (((p_u64Src2L & 0xFFFFFFFFFFFFFull) != 0x0 )|| (expRn != 0))
			{
				src2 = (p_u64Src2L & 0xFFFFFFFFFFFFFull)  | 0x10000000000000ull ;
			}
			//DSPU32 src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			res20 = src1 + ~src2 + 1;
			//p_ACC.u32High = res20;
			//p_ACC.u32Low = res20 + 1;
			//p_ACC.u11exp = expMax;
		}
	}

	//---------------------------------   ++ --
	
	if (((expRmF == 0x0)&&(expRnF == 0x0))
		||((expRmF == 0x8000000000000000ull)&&(expRnF == 0x8000000000000000ull))
		
		)
	{
		if (expRm > expRn)
		{
			expMax = expRm;
			DSPU64 src1 = 0;
			if (((expRm - expRn) < 64) && (expRn != 0))
			{
				src1 = ((p_u64Src2L & 0xFFFFFFFFFFFFFull)| 0x10000000000000ull ) >> (expRm - expRn);
			}
			DSPU64 src2 = 0;
			if (((p_u64Src1L & 0xFFFFFFFFFFFFFull) != 0x0) || (expRm != 0))
			{
				src2 = (p_u64Src1L & 0xFFFFFFFFFFFFFull)  | 0x10000000000000ull ;
			}
			res20 = src1 - ~src2 - 1;
			//p_ACC.u32High = res20;
			//p_ACC.u32Low = res20 + 1;
			//p_ACC.u11exp = expMax;
		}
		else
		{
			expMax = expRn;
			DSPU64 src1 = 0;
			if (((expRn - expRm) < 64) && (expRn !=0) && (expRm != 0))
			{
				src1 = ((p_u64Src1L & 0xFFFFFFFFFFFFFull)| 0x10000000000000ull ) >> (expRn - expRm);
			}
			//DSPU32 src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			DSPU64 src2 = 0;
			if (((p_u64Src2L & 0xFFFFFFFFFFFFFull) != 0x0 || (expRn != 0)))
			{
				src2 = (p_u64Src2L & 0xFFFFFFFFFFFFFull)  | 0x10000000000000ull ;
			}
			res20 = src1 - ~src2 -1 ;
			//p_ACC.u32High = res20;
			//p_ACC.u32Low = res20 + 1;
			//p_ACC.u11exp = expMax;
		}
	}


	//----------------------------------- -+ 

	if ((expRmF == 0x8000000000000000ull)&&(expRnF == 0x0))
	{
		if (expRm > expRn)
		{
			expMax = expRm;
			DSPU64 src1 = 0;
			if (((expRm - expRn) < 64)&&(expRn !=0))
			{
				src1 = ((p_u64Src2L & 0xFFFFFFFFFFFFFull)| 0x10000000000000ull ) >> (expRm - expRn);
			}
			DSPU64 src2 = (p_u64Src1L & 0xFFFFFFFFFFFFFull)  | 0x10000000000000ull ;
			res20 = src1 + ~src2 + 1;
			//p_ACC.u32High = res20;
			//p_ACC.u32Low = res20 + 1;
			//p_ACC.u11exp = expMax;
		}
		else
		{
			expMax = expRn;
			if ((expRn == expRm)
				&&((p_u64Src1L & 0xFFFFFFFFFFFFFull ) == (p_u64Src2L & 0xFFFFFFFFFFFFFull))
				)
			{
				expMax=0;
			}
			DSPU64 src1 = 0;
			if (((expRn - expRm) < 64)&&(expRm !=0))
			{
				src1 = ((p_u64Src1L & 0xFFFFFFFFFFFFFull)| 0x10000000000000ull ) >> (expRn - expRm);
			}
			DSPU64 src2 = 0;
			if (expRn != 0 )
			{
				src2 = (p_u64Src2L & 0xFFFFFFFFFFFFFull)  | 0x10000000000000ull ;
			}
			//DSPU32 src2 = (p_u32Src2H & 0xFFFFF)  | 0x100000 ;
			res20 = ~src1 + src2 + 1;
			//p_ACC.u32High = res20;
			//p_ACC.u32Low = res20 + 1;
			//p_ACC.u11exp = expMax;
		}
	}


			p_ACC.u32High = (res20 >> 32);
			p_ACC.u32Low = res20;
			p_ACC.u11exp = expMax;

//
	DSPU64 u64_1 = p_ACC.u32High;
	u64_1 = u64_1 << 32;
	//u64_1 = u64_1 | p_ACC.u32Low;
	u64_1 = u64_1 | (p_ACC.u32Low & 0xffffffff);

	p_FACC.u64Low = u64_1;
	p_FACC.u16High = p_ACC.u11exp;
	//


	
}



/******************************************************************
	函数名：	  ACCToF64L

	对应指令形式: DFLRs=DFLACCm

	描述:		输出64位浮点数据相加结果的低32位。与其他指令组合共同完成64位浮点相加运算。

	参数:		
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；					

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToF64L_OLD(const DSP_BIT80 p_FACC, DSP_BIT64 p_u64HSrc,DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 gu321H = 0;
	DSPU32 gu322H = 0;
	gu321H = p_u64HSrc.u32High;
	gu322H = p_u64HSrc.u32Low;

		if ((p_FACC.u64Low == 0xfff0000000000000ull) 
		&&((p_FACC.u16High &0x7ff) == 0x7ff)
		)
	{
		//int i = 0;
	}

	DSP_DF64 p_ACC;
	p_ACC.u32High = (p_FACC.u64Low) >> 32;
	p_ACC.u32Low  = p_FACC.u64Low;
	p_ACC.u11exp  = p_FACC.u16High ;



	DSPU64 expRm  = (gu321H & 0x7FF00000)>>20;
	DSPU64 expRmF = (gu321H & 0x80000000);

	DSPU64 expRn  = (gu322H & 0x7FF00000)>>20;
	DSPU64 expRnF = (gu322H & 0x80000000);

	
	DSPU64 Accexp  = p_ACC.u11exp;
	DSPU64 Acchigh = p_ACC.u32High;
	DSPU64 Acclow  = p_ACC.u32Low;
	
	if ((Acchigh == 0xffffffff)&&(Acclow == 0x80000000)&&(Accexp == 0x00000007)&&(gu321H ==	0x807fffff)&&(gu322H == 0x007fffff))
	{
		int id = 0;
	}
	DSPU64 AccHL   = (Acchigh << 32 ) | Acclow;

	if ((AccHL >> 63)!=0)
	{
		AccHL = - AccHL;
	}
	////////////////////////////////
	DSPU64 flag = 0;
	if (Accexp == expRm)
	{
		flag = expRmF;
	}
	else if ( Accexp == expRn )
	{
		flag = expRnF;
	}

	if (expRm == expRn)
	{
		if ((gu321H & 0xfffff) > (gu322H & 0xfffff))
		{
			flag = expRmF;
		}
		else
		{
			flag = expRnF;
		}
	}
	if (((Acchigh == 0) && (Acclow == 0))
		&& (expRmF != expRnF)
		)
	{
		flag = 0;
	}


	//////////////

	if ((Accexp == 0x7ff)&&(Acchigh == 0xffffffff)&&(Acclow == 0xffffffff))
	{
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
		return 0xffffffff;
	}

		
	
	if ((Accexp == 0x0)&&(Acchigh == 0x0)&&(Acclow == 0x0))
	{
		if ((expRmF == 0x80000000)&&(expRnF == 0x80000000))
		{
			return 0x0;	
		}
		else
		{
			return 0x0;
		}
		
	}
	///////////
	DSPU64 u20bit = 0;
	//////////////////////////////////
	DSPU64 u53 = AccHL & 0x20000000000000ull;
	DSPU64 u52 = AccHL & 0x10000000000000ull;
	
	if ((u53 == 0)&&(u52 !=0))
	{
		u20bit = (AccHL & 0xffffffff);
	}
	if (u53 != 0)
	{
		u20bit = (AccHL & 0x1fffffffeull) >> 1;
		Accexp = Accexp + 1;
	}
	if ((u53 == 0)&&(u52 ==0))
	{
		int i = 51;
		for(;i>=0;i--)
		{
			if (((AccHL >> i)&0x1) == 0x1)
			{
				break;
			}
		}
		//if (i > 20)
		{
			//bitset<20> b20temp(AccHL, i-20, 20);
			
			u20bit = (AccHL << (51- i +1)) & 0xffffffff;
		}//else
		{
			//u20bit = AccHL & 0xfffff;
		}
		DSPI32 tmpExp = (DSPI32)(Accexp - (51-i)- 1);
		if ( tmpExp < 0)
		{
			Accexp = Accexp - (51-i) -1;
			if ((p_u32ALUCR & 0x2) == 0x2)
			{
				
				Accexp = 0;
				u20bit = 0;
			}
			//added by flyu on 20140120
			SetFlag(*p_pStatReg, ALU_UnderFlow);         
            SetFlag(*p_pStatReg, ALU_AUS);
		}
		else
		{
			Accexp = Accexp - (51-i) - 1;
		}
		Accexp = Accexp & 0x7ff;
	}

	//////////////////////////////////
	
	DSPU32 result = u20bit;

	if ( (Accexp == 0x7ff)
		&&((Acchigh != 0x0)||(Acclow != 0x0))
		)
	{
		SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);
		if (
		((p_u32ALUCR & 0x2) == 0x2)
		&&(Accexp == 0x7ff)
		)
		{
			return 0xffffffff;
		}
		//return 0x0;//deleted on 20140304
	}
	return result;


	


	

}
DSPU64 alusuanshuyouyi(DSPU64 src,DSPU32 len)
{
	DSPU64 u64sign = src & 0x8000000000000000ull;
	DSPU64 u64tmp = src;
	//added by flyu on 20150511
	if (len> 0x35)
	{
		
		if(u64sign == 0x8000000000000000ull )
		{
			return 0xffffffff;
		}else
		{
			return 0;
		}
	}
	//end
	for(int i =0 ;i<len ;i++)
	{
		u64tmp = u64tmp >> 1;
		u64tmp = u64tmp | u64sign;
	}
	return u64tmp;
}
extern void ACCAddF64L_ALU(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 df_augend_nan = 0;//被加数为非数，1有效
	DSPU32 df_addend_nan = 0;//加数为非数
	DSPU32 df_augend_infinite = 0;//被加数为无穷大
	DSPU32 df_addend_infinite = 0;//加数为无穷大
	DSPU32 df_augend_zero = 0;//被加数为零
	DSPU32 df_addend_zero = 0;//加数为零
	DSPU32 df_augend_sign = 0;//被加数为负数    56
	DSPU32 df_addend_sign = 0;//加数为负数      55
	DSPU32 df_exp_gr = 0;//被加数为指数大于加数 54
	DSPU32 df_larger_exp11= 0;//较大的指数值[10:0] 
	DSPU32 df_diff_of_exp11= 0;//较大的指数值与较小指数值的差[10:0] 
	DSPU32 dfr_pri_rshift_mag_update32 = 0;//较小浮点数的尾数[31:0]
	
	dfr_pri_rshift_mag_update32 = p_DFIRR.u32Low;
	df_diff_of_exp11 = p_DFIRR.u32High & 0x7ff;
	df_larger_exp11  = (p_DFIRR.u32High >> 11) & 0x7ff;
	df_exp_gr  = (p_DFIRR.u32High >> 22) & 0x1;
	df_addend_sign = (p_DFIRR.u32High >> 23) & 0x1;
	df_augend_sign = (p_DFIRR.u32High >> 24) & 0x1;
	df_addend_zero = (p_DFIRR.u32High >> 25) & 0x1;
	df_augend_zero = (p_DFIRR.u32High >> 26) & 0x1;
	df_addend_infinite = (p_DFIRR.u32High >> 27) & 0x1;
	df_augend_infinite = (p_DFIRR.u32High >> 28) & 0x1;
	df_addend_nan = (p_DFIRR.u32High >> 29) & 0x1;
	df_augend_nan = (p_DFIRR.u32High >> 30) & 0x1;

	DSPU32 u32_aug = p_u32Src1L;
	DSPU32 u32_add = p_u32Src2L;
	DSPU32 co_h = 0;
	DSPU32 co_l = 0;
	DSPU32 df_h32_acc_mid = 0;
	DSPU32 df_l32_acc_mid = 0;
	DSPU32 df_aug_mag = 0;
	DSPU32 df_add_mag = 0;
	if (df_augend_zero == 1)
	{
		u32_aug = 0;
	}
	if (df_addend_zero == 1)
	{
		u32_add = 0;
	}
/*
	assign {co_h,df_h32_acc_mid}=df_aug_mag+df_add_mag;
           {溢出标志1，加法结果1}
	上式df_aug_mag：
		1：中间结果寄存器(dfr)中第54位为1，即高32位aug指数大于高32位add指数
		1)	中间结果寄存器符号位相等时，即第56=55位 选低32位输入的操作数1（aug）
		2)	中间结果寄存器符号位不相等时，即第56！=55位，且第56=1’b1即高32位输入aug为负数， 
		选低32位输入的操作数1（aug）的反码（非补码）
		2：中间结果寄存器中第54位为0，即高32位aug指数小于高32位add指数
		3)	中间结果寄存器符号位相等时，即第56=55位 选输入的{dfr[31:0]+ 低32位输入操作数1（aug）}与高32位add指数对齐的结果（右移）。
		4)	中间结果寄存器符号位不相等时，即第56！=55位，且第56=1’b1即高32位输入aug为负数，
		选{dfr[31:0]+ 低32位输入的操作数1（aug）的反码（非补码）}与高32位add指数对齐的结果（右移）。
	上式df_add_mag：
		1：中间结果寄存器中第54位为1，即高32位aug指数大于高32位add指数
		
		1)	中间结果寄存器符号位相等时，即第56=55位 选输入的
		{dfr[31:0]， 低32位输入操作数2（add）}与高32位aug指数对齐的结果（右移）。
		2)	中间结果寄存器符号位不相等时，即第56！=55位，且第55=1’b1即高32位输入add为负数， 
		选{dfr[31:0]+ 低32位输入的操作数2（add）的反码（非补码）}与高32位aug指数对齐的结果（右移）。
		
		2：中间结果寄存器中第54位为0，即高32位aug指数小于高32位add指数
		
		1)	中间结果寄存器符号位相等时，即第56=55位 选低32位输入的操作数2（add）
		2)	中间结果寄存器符号位不相等时，即第56！=55位，且第55=1’b1即高32位输入add为负数， 
		选低32位输入的操作数2（add）的反码（非补码）
		assign {co_l,df_l32_acc_mid}=df_aug_mag+df_add_mag+1'b1;	
				   溢出标志2，加法结果2
		df_aug_mag与df_add_mag的说明同上

*/
	
	if (df_exp_gr == 1)
	{
		
		if (df_addend_sign == df_augend_sign)
		{
			df_aug_mag = u32_aug;
		}
		else if ((df_addend_sign != df_augend_sign)&&(df_augend_sign == 1))
		{
			df_aug_mag = ~u32_aug;
		}
		else
		{
			df_aug_mag = u32_aug;
		}
	}
	else if (df_exp_gr == 0)
	{
		if (df_addend_sign == df_augend_sign)
		{
			DSPU64 u64df_aug_mag = dfr_pri_rshift_mag_update32;
			u64df_aug_mag = u64df_aug_mag << 32;
			u64df_aug_mag = u64df_aug_mag | u32_aug;
			df_aug_mag = alusuanshuyouyi (u64df_aug_mag,df_diff_of_exp11);//u64df_aug_mag >>df_diff_of_exp11;
			
		}
		else if ((df_addend_sign != df_augend_sign)&&(df_augend_sign == 1))
		{
			DSPU64 u64df_aug_mag = dfr_pri_rshift_mag_update32;
			u64df_aug_mag = u64df_aug_mag << 32;
			u64df_aug_mag = u64df_aug_mag | (~u32_aug);
			df_aug_mag = alusuanshuyouyi(u64df_aug_mag,df_diff_of_exp11);// u64df_aug_mag >>df_diff_of_exp11;
			
		}
		else
		{
			DSPU64 u64df_aug_mag = dfr_pri_rshift_mag_update32;
			u64df_aug_mag = u64df_aug_mag << 32;
			u64df_aug_mag = u64df_aug_mag | u32_aug;
			df_aug_mag = alusuanshuyouyi(u64df_aug_mag,df_diff_of_exp11);//u64df_aug_mag >>df_diff_of_exp11;
						
		}
	}

	if (df_exp_gr == 1)
	{
		if (df_addend_sign == df_augend_sign)
		{
			DSPU64 u64df_add_mag = dfr_pri_rshift_mag_update32;
			u64df_add_mag = u64df_add_mag << 32;
			u64df_add_mag = u64df_add_mag | u32_add;
			df_add_mag = alusuanshuyouyi(u64df_add_mag,df_diff_of_exp11);//u64df_add_mag >> df_diff_of_exp11;
			

		}
		else if ((df_addend_sign != df_augend_sign)&&(df_addend_sign == 1))
		{
			DSPU64 u64df_add_mag = dfr_pri_rshift_mag_update32;
			u64df_add_mag = u64df_add_mag << 32;
			u64df_add_mag = u64df_add_mag | (~u32_add);
			df_add_mag = alusuanshuyouyi(u64df_add_mag,df_diff_of_exp11);//u64df_add_mag >>df_diff_of_exp11;
			
		}
		else
		{
			DSPU64 u64df_add_mag = dfr_pri_rshift_mag_update32;
			u64df_add_mag = u64df_add_mag << 32;
			u64df_add_mag = u64df_add_mag | u32_add;
			df_add_mag = alusuanshuyouyi(u64df_add_mag,df_diff_of_exp11);//u64df_add_mag >> df_diff_of_exp11;
			
		}
	}
	else if (df_exp_gr == 0)
	{
		if (df_addend_sign == df_augend_sign)
		{
			
			df_add_mag = u32_add;
		}
		else if ((df_addend_sign != df_augend_sign)&&(df_addend_sign == 1))
		{
			df_add_mag = ~u32_add;
		}
		else
		{
			df_add_mag = u32_add;
		}
	}

	DSPU32 tmpStatReg = 0;
	df_h32_acc_mid = Add32(df_aug_mag,df_add_mag,&tmpStatReg,0);
	if ((tmpStatReg & 0x1) == 0x1)
	{
		co_h = 1;
	}
	tmpStatReg = 0;
	df_l32_acc_mid = Add32(df_aug_mag,df_add_mag,&tmpStatReg,0);
	if ((tmpStatReg & 0x1) == 0x1)
	{
		co_l = 1;
	}
	tmpStatReg = 0;
	df_l32_acc_mid = Add32(df_l32_acc_mid,1,&tmpStatReg,0);
	if ((tmpStatReg & 0x1) == 0x1)
	{
		co_l = 1;
	}
/*
			always @(*)
				begin 
					df_acc_sign_update[1:0]={dfr_augend_sign,dfr_addend_sign};
										  中间结果寄存器符号位，即第56和55位
					df_acc_exp_update[10:0]=dfr_larger_exp;
										  中间结果寄存器浮点指数，即第53~43位
					if(df_h32_add || df_h32_sub) 
						df_acc_update[63:0]={df_h32_acc_mid,df_l32_acc_mid};				
					else if(df_l32_add || df_l32_sub) 
						begin
							if(dfr_augend_sign == dfr_addend_sign)
							 两个操作数的符号位相等
								if(co_h) 溢出标志1
									df_acc_update[63:0]={df_acc[31:0],df_h32_acc_mid};
									acc更新	           dfacc低32位，加法结果1 
								else
									df_acc_update[63:0]={df_acc[63:32],df_h32_acc_mid};	
									acc更新				dfacc高32位，加法结果1
							else 	
								if(co_l) 溢出标志2
									df_acc_update[63:0]={df_acc[31:0],df_l32_acc_mid};
									acc更新			   dfacc低32位，加法结果2
								else
									df_acc_update[63:0]={df_acc[63:32],df_l32_acc_mid};
									acc更新				dfacc高32位，加法结果2
						end	
					else
						df_acc_update[63:0]=64'b0;	
				end	

*/
	DSPU32 df_acc_sign_update1_0 = (df_augend_sign << 1)  | df_addend_sign ;
	//中间结果寄存器符号位，即第56和55位
	DSPU32 df_acc_exp_update10_0=df_larger_exp11;
	//中间结果寄存器浮点指数，即第53~43位
	DSPU64 df_acc_update63_0 = 0;
	
	if(df_augend_sign == df_addend_sign)
	{
	 //两个操作数的符号位相等
		if(co_h) //溢出标志1
		{
			df_acc_update63_0 = p_FACC.u64Low & 0xffffffff; 
			df_acc_update63_0 = df_acc_update63_0 << 32;
			df_acc_update63_0 = df_acc_update63_0 | df_h32_acc_mid;
			//df_acc_update[63:0]={df_acc[31:0],df_h32_acc_mid};
			//acc更新	           dfacc低32位，加法结果1
		}
		else
		{
			df_acc_update63_0 = p_FACC.u64Low & 0xffffffff00000000ull; 
			df_acc_update63_0 = df_acc_update63_0 | df_h32_acc_mid;
		}
			//df_acc_update[63:0]={df_acc[63:32],df_h32_acc_mid};	
			//acc更新				dfacc高32位，加法结果1
	}
	else
	{
		if(co_l) //溢出标志2
		{
			df_acc_update63_0 = p_FACC.u64Low & 0xffffffff; 
			df_acc_update63_0 = df_acc_update63_0 << 32;
			df_acc_update63_0 = df_acc_update63_0 | df_l32_acc_mid;
			//df_acc_update[63:0]={df_acc[31:0],df_l32_acc_mid};
			//acc更新			   dfacc低32位，加法结果2
		}
		else
		{
			df_acc_update63_0 = p_FACC.u64Low & 0xffffffff00000000ull; 
			df_acc_update63_0 = df_acc_update63_0 | df_l32_acc_mid;
		}
			//df_acc_update[63:0]={df_acc[63:32],df_l32_acc_mid};
			//acc更新				dfacc高32位，加法结果2
	}
	p_FACC.u64Low = df_acc_update63_0;
	p_FACC.u16High = df_acc_exp_update10_0;
	/*
	if(dfr_augend_nan || dfr_addend_nan)
				df_acc_nan_temp=1'b1;
			else if(dfr_augend_infinite && dfr_addend_infinite && (df_acc_sign_update[1]!=df_acc_sign_update[0]))
				df_acc_nan_temp=1'b1; 
			else
				df_acc_nan_temp=1'b0; 
	*/
	DSPU32 df_acc_nan_temp = 0; 
	if((df_augend_nan == 1) || (df_addend_nan == 1))
	{
		df_acc_nan_temp=1;
	}
	else if((df_augend_infinite == 1) && (df_addend_infinite == 1) && (df_augend_sign != df_addend_sign))		
	{
		df_acc_nan_temp=1; 
	}		
	else
	{
		df_acc_nan_temp=0; 
	}
	
	if ((df_augend_zero == 1)&&(df_addend_zero == 1))
	{
		p_FACC.u64Low = 0x0;
		p_FACC.u16High = 0x0;
	}
	
	if (p_FACC.u64Low == 0x0)
	{
		p_FACC.u16High = 0x0;
	}

	if (df_acc_nan_temp == 1)
	{
		p_FACC.u64Low = 0xffffffffffffffffull;
		p_FACC.u16High = 0x7ff;
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
	}
	/*
	if ((df_augend_zero == 1)&&(df_addend_zero == 1))
	{
		p_FACC.u64Low = 0x0;
		p_FACC.u16High = 0x0;
	}
	*/
	/*
	if (p_FACC.u64Low == 0x0)
	{
		p_FACC.u16High = 0x0;
	}
	*/
	DSPU32 df_acc_overf = 0;
	if((df_augend_infinite == 1) && (df_addend_infinite == 1) && (df_augend_sign == df_addend_sign))
	{
		df_acc_overf = 1;
	}
	if((df_augend_infinite == 1) && (df_addend_infinite == 0))
	{
		df_acc_overf = 1;
	}
	if((df_augend_infinite == 0) && (df_addend_infinite == 1))
	{
		df_acc_overf = 1;
	}
	if ((df_acc_overf  == 1)&& (df_acc_nan_temp == 0))
	{
		SetFlag(*p_pStatReg, ALU_FOverFlow);         
		SetFlag(*p_pStatReg, ALU_AVS);
	}
	//df_acc_nan_temp
	//
	
}
extern void ACCAddF64L(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	ACCAddF64L_ALU( p_u32Src1L,  p_u32Src2L, p_FACC, p_DFIRR, p_pStatReg,  p_u32ALUCR);
	p_FACC.u64Low = p_FACC.u64Low & 0xffffffffffffffull;
}

extern DSPU64 ACCToF64HL_NEW(const DSP_BIT80 p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 df_augend_nan = 0;//被加数为非数，1有效
	DSPU32 df_addend_nan = 0;//加数为非数
	DSPU32 df_augend_infinite = 0;//被加数为无穷大
	DSPU32 df_addend_infinite = 0;//加数为无穷大
	DSPU32 df_augend_zero = 0;//被加数为零
	DSPU32 df_addend_zero = 0;//加数为零
	DSPU32 df_augend_sign = 0;//被加数为负数    56
	DSPU32 df_addend_sign = 0;//加数为负数      55
	DSPU32 df_exp_gr = 0;//被加数为指数大于加数 54
	DSPU32 df_larger_exp11= 0;//较大的指数值[10:0] 
	DSPU32 df_diff_of_exp11= 0;//较大的指数值与较小指数值的差[10:0] 
	DSPU32 dfr_pri_rshift_mag_update32 = 0;//较小浮点数的尾数[31:0]
	
	dfr_pri_rshift_mag_update32 = p_DFIRR.u32Low;
	df_diff_of_exp11 = p_DFIRR.u32High & 0x7ff;
	df_larger_exp11  = (p_DFIRR.u32High >> 11) & 0x7ff;
	df_exp_gr  = (p_DFIRR.u32High >> 22) & 0x1;
	df_addend_sign = (p_DFIRR.u32High >> 23) & 0x1;
	df_augend_sign = (p_DFIRR.u32High >> 24) & 0x1;
	df_addend_zero = (p_DFIRR.u32High >> 25) & 0x1;
	df_augend_zero = (p_DFIRR.u32High >> 26) & 0x1;
	df_addend_infinite = (p_DFIRR.u32High >> 27) & 0x1;
	df_augend_infinite = (p_DFIRR.u32High >> 28) & 0x1;
	df_addend_nan = (p_DFIRR.u32High >> 29) & 0x1;
	df_augend_nan = (p_DFIRR.u32High >> 30) & 0x1;
	/*
	always @(*)
		begin 
			if(df_acc_sign[1]!=df_acc_sign[0])
				if(df_acc[63]==1'b1)
					begin
						acc_normalize_temp=-df_acc;
						acc_sign_normalize=1'b1;
					end
				else
					begin
						acc_normalize_temp=df_acc;
						acc_sign_normalize=1'b0;
					end	
			else 
				begin
					acc_normalize_temp=df_acc;
					acc_sign_normalize=df_acc_sign[1];
				end
		end			
	always @(*)
		begin 
			zero0=acc_normalize_temp[7:0]==8'b0 ? 1'b1 : 1'b0;
			zero1=acc_normalize_temp[15:8]==8'b0 ? 1'b1 : 1'b0;
			zero2=acc_normalize_temp[23:16]==8'b0 ? 1'b1 : 1'b0;
			zero3=acc_normalize_temp[31:24]==8'b0 ? 1'b1 : 1'b0;
			zero4=acc_normalize_temp[39:32]==8'b0 ? 1'b1 : 1'b0;
			zero5=acc_normalize_temp[47:40]==8'b0 ? 1'b1 : 1'b0;
			zero6=acc_normalize_temp[55:48]==8'b0 ? 1'b1 : 1'b0;			
			if(zero6==1'b0)
				begin
					acc_normalize_temp1=acc_normalize_temp[55:0];
					num[6:0]=7'h7c;
				end
			else if(zero5==1'b0) 
				begin
					acc_normalize_temp1={acc_normalize_temp[47:0],8'b0};	
					num[6:0]=7'h74;
				end
			else if(zero4==1'b0) 
				begin
					acc_normalize_temp1={acc_normalize_temp[39:0],16'b0};
					num[6:0]=7'h6c;
				end
			else if(zero3==1'b0)
				begin
					acc_normalize_temp1={acc_normalize_temp[31:0],24'b0};
					num[6:0]=7'h64;
				end
			else if(zero2==1'b0) 
				begin
					acc_normalize_temp1={acc_normalize_temp[23:0],32'b0};
					num[6:0]=7'h5c;
				end
			else if(zero1==1'b0) 
				begin
					acc_normalize_temp1={acc_normalize_temp[15:0],40'b0};
					num[6:0]=7'h54;
				end
			else if(zero0==1'b0)
				begin
					acc_normalize_temp1={acc_normalize_temp[7:0],48'b0};
					num[6:0]=7'h4c;
				end
			else 
				begin
					acc_normalize_temp1=56'b0;
					num[6:0]=7'h00;
				end		
			casez(acc_normalize_temp1[55:48])
				8'b1???????:mv_exp=3'h7;
				8'b01??????:mv_exp=3'h6;
				8'b001?????:mv_exp=3'h5;
				8'b0001????:mv_exp=3'h4;
				8'b00001???:mv_exp=3'h3;
				8'b000001??:mv_exp=3'h2;
				8'b0000001?:mv_exp=3'h1;
				8'b00000001:mv_exp=3'h0;
				default:mv_exp=3'h0;
			endcase
			case(mv_exp[2:0])
				3'h7:acc_normalize=acc_normalize_temp1[55:0];
				3'h6:acc_normalize={acc_normalize_temp1[54:0],1'b0};
				3'h5:acc_normalize={acc_normalize_temp1[53:0],2'b0};
				3'h4:acc_normalize={acc_normalize_temp1[52:0],3'b0};
				3'h3:acc_normalize={acc_normalize_temp1[51:0],4'b0};
				3'h2:acc_normalize={acc_normalize_temp1[50:0],5'b0};
				3'h1:acc_normalize={acc_normalize_temp1[49:0],6'b0};
				default:acc_normalize={acc_normalize_temp1[48:0],7'b0}; 				
			endcase				
			{acc_co_h,acc_co_l,acc_exp_normalize}={2'h0,df_acc_exp}+{{6{num[6]}},num}+{10'h0,mv_exp};
		end	 
	
	always @(*)
		begin  
			if(dfr_augend_nan || dfr_addend_nan)
				df_acc_nan_temp=1'b1;
			else if(dfr_augend_infinite && dfr_addend_infinite && (df_acc_sign_update[1]!=df_acc_sign_update[0]))
				df_acc_nan_temp=1'b1; 
			else
				df_acc_nan_temp=1'b0; 
			
			if(dfr_augend_infinite && !dfr_addend_infinite)
				df_acc_infinite_temp=1'b1;
			else if(!dfr_augend_infinite && dfr_addend_infinite)
				df_acc_infinite_temp=1'b1;
			else if(dfr_augend_infinite && dfr_addend_infinite && (df_acc_sign_update[1]==df_acc_sign_update[0]))
				df_acc_infinite_temp=1'b1;
			else
				df_acc_infinite_temp=1'b0;		
			
			
			if(!acc_co_h && acc_co_l && !df_acc_nan_temp)
				df_acc_of_temp=1'b1;		
			else if(!acc_co_h && !acc_co_l && (acc_exp_normalize==11'h7ff))
				df_acc_of_temp=1'b1;
			else
				df_acc_of_temp=1'b0;				
			
			
			if(acc_co_h)
				df_acc_uf_temp=1'b1; 	
			else if((df_acc_exp!=11'h0) && (df_acc[52:0]!=53'b0) &&(acc_exp_normalize==11'h0))
				df_acc_uf_temp=1'b1; 	
			else
				df_acc_uf_temp=1'b0;
			
			
		end	

	*/
			DSPU32 acc_sign_normalize = 0;
			DSPU64 acc_normalize_temp = 0;
			DSPU64 acc_normalize_temp1 = 0;
			DSPU32 num = 0;
			DSPU64 df_acc = 0;
			df_acc = p_FACC.u64Low;
			
			if(df_augend_sign !=df_addend_sign)
			{
				//if(((df_acc >> 63)&0x1)==1)
				if(((df_acc >> 55)&0x1)==1)//20151010
				{
					
						acc_normalize_temp = ~df_acc + 1;
						acc_sign_normalize = 1;
					
				}
				else
				{
						acc_normalize_temp = df_acc;
						acc_sign_normalize = 0; 
				}
			}
			else
			{
					acc_normalize_temp = df_acc;
					acc_sign_normalize = df_augend_sign;
			}		
	
		 
			DSPU32 zero0=((acc_normalize_temp & 0xff) == 0) ? 1 : 0;
			DSPU32 zero1=(((acc_normalize_temp >> 8) & 0xff) == 0) ? 1 : 0;
			DSPU32 zero2=(((acc_normalize_temp >> 16) & 0xff) == 0) ? 1 : 0;
			DSPU32 zero3=(((acc_normalize_temp >> 24) & 0xff) == 0) ? 1 : 0;
			DSPU32 zero4=(((acc_normalize_temp >> 32) & 0xff) == 0) ? 1 : 0;
			DSPU32 zero5=(((acc_normalize_temp >> 40) & 0xff) == 0) ? 1 : 0;
			DSPU32 zero6=(((acc_normalize_temp >> 48) & 0xff) == 0) ? 1 : 0;

			
			if(zero6 == 0)
			{
					acc_normalize_temp1=acc_normalize_temp  & 0xffffffffffffffull;//[55:0];
					num=0x7c;
			}
			else if(zero5 == 0) 
			{
					acc_normalize_temp1=(acc_normalize_temp  & 0xffffffffffffull) << 8;//{acc_normalize_temp[47:0],8'b0};	
					num=0x74;
			}
			else if(zero4 == 0) 
			{
					acc_normalize_temp1=(acc_normalize_temp  & 0xffffffffffull) << 16;//{acc_normalize_temp[39:0],16'b0};
					num=0x6c;
			}
			else if(zero3 == 0)
			{
					acc_normalize_temp1=(acc_normalize_temp  & 0xffffffff) << 24;//{acc_normalize_temp[31:0],24'b0};
					num=0x64;
			}
			else if(zero2 == 0) 
			{
					acc_normalize_temp1=(acc_normalize_temp  & 0xffffff) << 32;//{acc_normalize_temp[23:0],32'b0};
					num=0x5c;
			}
			else if(zero1 == 0) 
			{
					acc_normalize_temp1=(acc_normalize_temp  & 0xffff) << 40;//{acc_normalize_temp[15:0],40'b0};
					num=0x54;
			}
			else if(zero0 == 0)
			{
					acc_normalize_temp1=(acc_normalize_temp  & 0xff) << 48;//{acc_normalize_temp[7:0],48'b0};
					num=0x4c;
			}
			else 
			{
					acc_normalize_temp1=0x0;
					num=0x00;
			}
			
			DSPU32 u32src55_48 = 0;
			DSPU32 mv_exp = 0;
			u32src55_48 = (acc_normalize_temp1 >> 48) & 0xff;
			if (((u32src55_48 >> 7) & 0x1) == 0x1)
			{
				mv_exp = 0x7;
			}
			else if (((u32src55_48 >> 6) & 0x1) == 0x1)
			{
				mv_exp = 0x6;
			}
			else if (((u32src55_48 >> 5) & 0x1) == 0x1)
			{
				mv_exp = 0x5;
			}
			else if (((u32src55_48 >> 4) & 0x1) == 0x1)
			{
				mv_exp = 0x4;
			}
			else if (((u32src55_48 >> 3) & 0x1) == 0x1)
			{
				mv_exp = 0x3;
			}
			else if (((u32src55_48 >> 2) & 0x1) == 0x1)
			{
				mv_exp = 0x2;
			}
			else if (((u32src55_48 >> 1) & 0x1) == 0x1)
			{
				mv_exp = 0x1;
			}
			else if (((u32src55_48) & 0x1) == 0x1)
			{
				mv_exp = 0x0;
			}
			DSPU64 acc_normalize = 0;
			acc_normalize = (acc_normalize_temp1 & 0x1ffffffffffffull) << 7;//[48:0],7'b0}; 	
			if (mv_exp == 7)
			{
				acc_normalize = (acc_normalize_temp1 & 0xffffffffffffffull);//[55:0]; 
			}
			if (mv_exp == 6)
			{
				acc_normalize = (acc_normalize_temp1 & 0x7fffffffffffffull) << 1;
			}
			if (mv_exp == 5)
			{
				acc_normalize = (acc_normalize_temp1 & 0x3fffffffffffffull) << 2;
			}
			if (mv_exp == 4)
			{
				acc_normalize = (acc_normalize_temp1 & 0x1fffffffffffffull) << 3;
			}
			if (mv_exp == 3)
			{
				acc_normalize = (acc_normalize_temp1 & 0xfffffffffffffull) << 4;
			}
			if (mv_exp == 2)
			{
				acc_normalize = (acc_normalize_temp1 & 0x7ffffffffffffull) << 5;
			}
			if (mv_exp == 1)
			{
				acc_normalize = (acc_normalize_temp1 & 0x3ffffffffffffull) << 6;
			}
			/*
			casez(acc_normalize_temp1[55:48])
				8'b1???????:mv_exp=3'h7;
				8'b01??????:mv_exp=3'h6;
				8'b001?????:mv_exp=3'h5;
				8'b0001????:mv_exp=3'h4;
				8'b00001???:mv_exp=3'h3;
				8'b000001??:mv_exp=3'h2;
				8'b0000001?:mv_exp=3'h1;
				8'b00000001:mv_exp=3'h0;
				default:mv_exp=3'h0;
			endcase
			case(mv_exp[2:0])
				3'h7:acc_normalize=acc_normalize_temp1[55:0];
				3'h6:acc_normalize={acc_normalize_temp1[54:0],1'b0};
				3'h5:acc_normalize={acc_normalize_temp1[53:0],2'b0};
				3'h4:acc_normalize={acc_normalize_temp1[52:0],3'b0};
				3'h3:acc_normalize={acc_normalize_temp1[51:0],4'b0};
				3'h2:acc_normalize={acc_normalize_temp1[50:0],5'b0};
				3'h1:acc_normalize={acc_normalize_temp1[49:0],6'b0};
				default:acc_normalize={acc_normalize_temp1[48:0],7'b0}; 				
			endcase
			*/
		
			DSPU32 acc_co_h = 0;
			DSPU32 acc_co_l = 0;
			DSPU32 acc_exp_normalize = 0;
			DSPU32 num_ex = num;
			DSPU32 df_acc_exp = 0;
			df_acc_exp = p_FACC.u16High & 0x7ff;
			if ((num & 0x40) == 0x40)
			{
				num_ex = num | 0x1f80;
			}
			acc_exp_normalize = df_acc_exp + num_ex + mv_exp ;
			if ((acc_exp_normalize & 0x800) == 0x800)
			{
				acc_co_l = 0x1;
			}
			if ((acc_exp_normalize & 0x1000) == 0x1000)
			{
				acc_co_h = 0x1;
			}
			//{acc_co_h,acc_co_l,acc_exp_normalize}={2'h0,df_acc_exp}+{{6{num[6]}},num}+{10'h0,mv_exp};
			
		    DSPU32 df_acc_nan_temp = 0;
			DSPU32 df_acc_infinite_temp = 0;
			DSPU32 df_acc_of_temp = 0;
			DSPU32 df_acc_uf_temp = 0;
			if(df_augend_nan || df_addend_nan)
			{
				df_acc_nan_temp=1;
			}
			else if((df_augend_infinite == 1) && (df_addend_infinite == 1) && (df_augend_sign!=df_addend_sign))
			{
				df_acc_nan_temp=1; 
			}
			else
			{
				df_acc_nan_temp=0; 
			}

			if((df_augend_infinite == 1) && (df_addend_infinite == 0))
			{
				df_acc_infinite_temp=1;
			}
			else if((df_augend_infinite == 0) && (df_addend_infinite ==1))
			{
				df_acc_infinite_temp=1;
			}
			else if((df_augend_infinite == 1) && (df_addend_infinite==1) && (df_augend_sign==df_addend_sign))
			{
				df_acc_infinite_temp=1;
			}
			else
			{
				df_acc_infinite_temp=0;		
			}
			
			if((acc_co_h == 0) && (acc_co_l == 1) && (df_acc_nan_temp == 0))
			{
				df_acc_of_temp=1;		
			}
			else if((acc_co_h == 0) && (acc_co_l ==0) && ((acc_exp_normalize &0x7ff) == 0x7ff))
			{	
				df_acc_of_temp=1;
			}
			else
			{
				df_acc_of_temp=0;				
			}
			
			if(acc_co_h == 1)
			{
				df_acc_uf_temp=1; 	
			}
			else if((df_acc_exp!=0x0) && ((df_acc & 0x1fffffffffffffull)!=0x0) &&((acc_exp_normalize & 0x7ff)==0x0))
			{
				df_acc_uf_temp=1; 	
			}
			else
			{
				df_acc_uf_temp=0;
			}

			DSPU32  df_acc_of = 0;
			DSPU32  df_acc_uf = 0;
			DSPU64 acc_normalize_ex = 0;
			DSPU64 acc_exp_normalize_ex = 0;
			DSPU32 acc_sign_normalize_ex = 0;
			df_acc_of= (df_acc_nan_temp == 1) ?  0 : df_acc_of_temp;
			df_acc_uf= (df_acc_nan_temp == 1) ?  0 : df_acc_uf_temp;
			acc_normalize_ex = acc_normalize >> 3;

			acc_exp_normalize_ex  =((df_acc & 0x3fffffffffffffull) == 0) ?  0:acc_exp_normalize;
			acc_sign_normalize_ex = acc_sign_normalize;				
			
			
			DSPU64 u64result = (acc_sign_normalize_ex & 0x1);
			u64result = u64result << 63;
			acc_exp_normalize_ex  = acc_exp_normalize_ex & 0x7ff;
			acc_exp_normalize_ex  = acc_exp_normalize_ex << 52;
			u64result =u64result |acc_exp_normalize_ex;
			u64result =u64result |(acc_normalize_ex & 0xfffffffffffffull) ;
			

			//df_acc_of  df_acc_uf df_acc_nan_temp
			if ((df_acc_uf == 1)
				&&(df_acc_nan_temp == 0)
				)
			{
				SetFlag(*p_pStatReg, ALU_UnderFlow);         
				SetFlag(*p_pStatReg, ALU_AUS);
				if ((p_u32ALUCR & 0x2) == 0x2)
				{
					if ((acc_sign_normalize_ex & 0x1) == 0x1)
					{
						u64result = 0x8000000000000000ull ;
					}
					else
					{
						u64result = 0;
					}
				}
			}

			if (((df_acc_of == 1) || (df_acc_infinite_temp == 1))
				&&(df_acc_nan_temp == 0)
				)
			{
				SetFlag(*p_pStatReg, ALU_FOverFlow);         
				SetFlag(*p_pStatReg, ALU_AVS);
				if ((p_u32ALUCR & 0x2) == 0x2)
				{
					if ((acc_sign_normalize_ex & 0x1) == 0x0)
					{
						u64result = 0x7fefffffffffffffull  ;
					}else
					{
						
						u64result = 0xffefffffffffffffull  ;
					}
				
				}
				else
				{
					if ((acc_sign_normalize_ex & 0x1) == 0x0)
					{
						u64result = 0x7ff0000000000000ull  ;
					}else
					{
						
						u64result = 0xfff0000000000000ull  ;
					}
				}

			}
			
			if (df_acc_nan_temp)
			{
				SetFlag(*p_pStatReg, ALU_Invalid);         
				SetFlag(*p_pStatReg, ALU_AIS);
				u64result = 0xffffffffffffffffull;
			}
			return u64result;

}
extern DSPU32 ACCToF64H(const DSP_BIT80 p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{

	DSPU64 U64SRC = ACCToF64HL_NEW(p_FACC, p_DFIRR, p_pStatReg,  p_u32ALUCR);
	DSPU32 u32h = U64SRC >> 32;
	return u32h;
}

extern DSPU32 ACCToF64L(const DSP_BIT80 p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{

	DSPU64 U64SRC = ACCToF64HL_NEW(p_FACC, p_DFIRR, p_pStatReg,  p_u32ALUCR);
	DSPU32 u32l = U64SRC & 0xffffffff;
	return u32l;
}

/******************************************************************
	函数名：	  ACCToF64H

	对应指令形式: DFHRs=DFHACCm

	描述:		输出64位浮点数据相加结果的高32位。与其他指令组合共同完成64位浮点相加运算。

	参数:		
					p_ACC -- 48位累加结果寄存器中的值。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；					

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern DSPU32 ACCToF64H_OLD(const DSP_BIT80 p_FACC,DSP_BIT64 p_u64HSrc,DSP_BIT64 p_u64LSrc, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

{
	DSPU32 gu321H = 0;
	DSPU32 gu322H = 0;
	gu321H = p_u64HSrc.u32High;
	gu322H = p_u64HSrc.u32Low;
	DSPU32 gu321L = p_u64LSrc.u32High;
	DSPU32 gu322L = p_u64LSrc.u32Low;
	
	if ((p_FACC.u64Low == 0xffffffffffffffffull) 
		&&((p_FACC.u16High &0x7ff) == 0x7ff)
		)
	{
		//int i = 0;
	}
	DSP_DF64 p_ACC;
	p_ACC.u32High = (p_FACC.u64Low) >> 32;
	p_ACC.u32Low  = p_FACC.u64Low;
	p_ACC.u11exp  = p_FACC.u16High ;


	DSPU64 expRm  = (gu321H & 0x7FF00000)>>20;
	DSPU64 expRmF = (gu321H & 0x80000000);

	DSPU64 expRn  = (gu322H & 0x7FF00000)>>20;
	DSPU64 expRnF = (gu322H & 0x80000000);

	
	DSPU64 Accexp  = p_ACC.u11exp;
	DSPU64 Acchigh = p_ACC.u32High;
	DSPU64 Acclow  = p_ACC.u32Low;
	
	if ((Acchigh == 0xffffffff)&&(Acclow == 0x80000000)&&(Accexp == 0x00000007)&&(gu321H ==	0x807fffff)&&(gu322H == 0x007fffff))
	{
		int id = 0;
	}
	DSPU64 AccHL   = (Acchigh << 32 ) | Acclow;

	if ((AccHL >> 63)!=0)
	{
		AccHL = - AccHL;
	}
	////////////////////////////////
	DSPU64 flag = 0;
	if (Accexp == expRm)
	{
		flag = expRmF;
	}
	else if ( Accexp == expRn )
	{
		flag = expRnF;
	}

	DSPU64 frac1 =  gu321H & 0xfffff;
	frac1 = (frac1<<32) | gu321L;
	DSPU64 frac2 =  gu322H & 0xfffff;
	frac2 = (frac2<<32) | gu322L;
	if (expRm == expRn)
	{
		if (frac1 > frac2)
			
		{
			flag = expRmF;
		}
		else
		{
			flag = expRnF;
		}
	}
	if (((Acchigh == 0) && (Acclow == 0))
		&& (expRmF != expRnF)
		)
	{
		flag = 0;
	}


	//////////////
	if ((Accexp == 0x7ff)&&(Acchigh == 0xffffffff)&&(Acclow == 0xffffffff))
	{
		SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
		return 0xffffffff;
	}

	if ((Accexp == 0x0)&&(Acchigh == 0x0)&&(Acclow == 0x0))
	{
		if ((expRmF == 0x80000000)&&(expRnF == 0x80000000))
		{
			return 0x80000000;	
		}
		else
		{
			return 0x0;
		}
		
	}
	///////////
	DSPU64 u20bit = 0;
	//////////////////////////////////
	DSPU64 u53 = AccHL & 0x20000000000000ull;
	DSPU64 u52 = AccHL & 0x10000000000000ull;
	
	if ((u53 == 0)&&(u52 !=0))
	{
		u20bit = (AccHL & 0xfffff00000000ull)>>32;
	}
	if (u53 != 0)
	{
		u20bit = (AccHL & 0x1ffffe00000000ull) >> 33;
		Accexp = Accexp + 1;
	}
	if ((u53 == 0)&&(u52 ==0))
	{
		int i = 51;
		for(;i>=0;i--)
		{
			if (((AccHL >> i)&0x1) == 0x1)
			{
				break;
			}
		}
		if (i > 20)
		{
			//bitset<20> b20temp(AccHL, i-20, 20);
			
			u20bit = (AccHL >> (i - 20)) & 0xfffff;
		}else
		{
			u20bit = AccHL & 0xfffff;
		}
		DSPI32 tmpExp = (DSPI32)(Accexp - (51-i)- 1);
		if (tmpExp < 0)
		{
			Accexp = Accexp - (51-i) -1;
			if ((p_u32ALUCR & 0x2) == 0x2)
			{
				
				Accexp = 0;
				u20bit = 0;
			}
			//added by flyu on 20140120
			SetFlag(*p_pStatReg, ALU_UnderFlow);         
            SetFlag(*p_pStatReg, ALU_AUS);
		}
		else
		{
			Accexp = Accexp - (51-i) - 1;
		}
		Accexp = Accexp & 0x7ff;
	}

	//////////////////////////////////
	//flag = p_ACC.u32High & 0x80000000;
	DSPU32 result = u20bit | flag | (Accexp << 20);
	
	if ( (Accexp == 0x7ff)
		&&((Acchigh != 0x0)||(Acclow != 0x0))
		)
	{
		SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);
			if (
		((p_u32ALUCR & 0x2) == 0x2)
		&&(Accexp == 0x7ff)
		)
		{
			if (flag !=0)
			{
				return 0xffefffff;
			}
			else
			{
				return 0x7fefffff;
			}
			
		}
		/*if (flag !=0)
		{
			return 0xfff00000;
		}
		else
		{
			return 0x7ff00000;
		}*/
		//return 0xfff00000;
	}
	return result;

}


/*found*****************************************************************
	函数名：		MaxACC

	对应指令形式: HHRs=max(LACCk,HACCk)(U,cut=C)
								HHRs=max(LACCk,HACCk)(cut=C)

								LHRs= max(LACCk,HACCk)(U,cut=C)
								LHRs= max(LACCk,HACCk)(cut=C)

	描述:		16位条件赋值运算。
					详细内容参考指令集手册20130402中双字指令7的说明。

	参数:		p_ACC -- 累加寄存器中的值，共48位。
					p_u32Imm -- 立即数,对应指令中的C。
					p_Mode -- 模式选择
									0:	HHRs=max(LACCk,HACCk)(U,cut=C)
											HHRs=max(LACCk,HACCk)(cut=C)

									1:	LHRs= max(LACCk,HACCk)(U,cut=C)
											LHRs= max(LACCk,HACCk)(cut=C)
					
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，第0位为1表示有符号数，为0表示无符号数。		
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MaxACC(const DSP_BIT48 &p_ACC, DSPU32 p_u32Imm, DSPU32 p_Mode, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	if (p_ACC.u32Low == 0x9f0052)
	{
		//int i = 0;
	}
	DSPU32 lcc20 = p_ACC.u32Low & 0xfffff;
	DSPU32 hcc20 = p_ACC.u32Low >> 20;
	DSPU32 htest = p_ACC.u8Mid;
	hcc20 = hcc20 | (htest << 12);
	DSPU32 result = 0;
	DSPU32 cut = p_u32Imm & 0x7;
	if (cut > 4)
	{
		cut = 4;
	}
	DSPU20 u20hcc(hcc20);
	DSPU20 u20lcc(lcc20);
	if ((p_u32ALUCR & 0x1) == 0x1)
	{
		bool bMax1 = false;
		if (u20hcc.Sign() && u20lcc.Sign())
		{
			DSPU32 hccT20;
			DSPU32 lccT20;
			hccT20 = hcc20;
			lccT20 = lcc20;
			hccT20 = ~hccT20 + 1;
			hccT20 = hccT20 & 0xfffff;
			lccT20 = ~lccT20 + 1;
			lccT20 = lccT20 & 0xfffff;
			
			if (hccT20 < lccT20)
			{
				bMax1 = true;
			}
		}

	if (((!u20hcc.Sign()) && u20lcc.Sign())
		||((!u20hcc.Sign()) && (!u20lcc.Sign())&&(hcc20 > lcc20))
		||bMax1
		)
	{
		result = ((hcc20 >> cut) & 0xffff) | (((hcc20 >> cut) & 0xffff)<<16);
		if (cut < 4)
		{
			//DSPU32 u32t = hcc20 >>19;
			DSPU32 u32t = (hcc20 >> (15+cut)) ;
			
			if (
				(  ((u32t != 0x3) && (cut == 3))
				||((u32t != 0x7) && (cut == 2))
				||((u32t != 0xf) && (cut == 1))
				||((u32t != 0x1f) && (cut == 0))
				)
				&&(u32t != 0x0)
				)
			{
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if (u20hcc.Sign())
						{
							result = 0x80008000;
						}
						else
						{
							result = 0x7fff7fff;
						}
					}
			}
		}
	}
	else
	{
		result = ((lcc20 >> cut) & 0xffff) | (((lcc20 >> cut) & 0xffff)<<16);
		if (cut < 4)
		{
			//DSPU32 u32t = (lcc20 >> (20-(4-cut))) & 0x1;
			//DSPU32 u32t = lcc20 >> 19;
			DSPU32 u32t = (lcc20 >> (15+cut)) ;
			
			if (
				(  ((u32t != 0x3) && (cut == 3))
				||((u32t != 0x7) && (cut == 2))
				||((u32t != 0xf) && (cut == 1))
				||((u32t != 0x1f) && (cut == 0))
				)
				&&(u32t != 0x0)
				)
			{
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if (u20lcc.Sign())
						{
							result = 0x80008000;
						}
						else
						{
							result = 0x7fff7fff;
						}
					}
			}
		}
	}
	}
	else
	{
		if (hcc20 > lcc20)
		
	{
		result = ((hcc20 >> cut) & 0xffff) | (((hcc20 >> cut) & 0xffff)<<16);
		if (cut < 4)
		{
			DSPU32 u32t = hcc20 >> (20-(4-cut));
			if (u32t !=0)
			{
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if ((p_u32ALUCR & 0x1) == 0x1)
						{
							result = 0x7fff7fff;
						}
						else
						{
							result = 0xffffffff;
						}
					}
			}
		}
	}
	else
	{
		result = ((lcc20 >> cut) & 0xffff) | (((lcc20 >> cut) & 0xffff)<<16);
		if (cut < 4)
		{
			DSPU32 u32t = lcc20 >> (20-(4-cut));
			if (u32t !=0)
			{
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if ((p_u32ALUCR & 0x1) == 0x1)
						{
							result = 0x7fff7fff;
						}
						else
						{
							result = 0xffffffff;
						}
					}
			}
		}
	}
	}
	/*
	if (p_ACC.u32Low == 0xFFFFFFFF)
	{
		result = 0xFFFFFFFF;
	}
	*/
	//result = 0xFFFFFFFF;
	//p_ACC.u8High = 0;
	return result;
}
/*found*****************************************************************
	函数名：		MinACC

	对应指令形式: HHRs=min(LACCk,HACCk)(U,cut=C)
								HHRs=min(LACCk,HACCk)(cut=C)

								LHRs=min(LACCk,HACCk)(U,cut=C)
								LHRs=min(LACCk,HACCk)(cut=C)

	描述:		16位条件赋值运算。
					详细内容参考指令集手册20130402中双字指令7的说明。

	参数:		p_ACC -- 累加寄存器中的值，共48位。
					p_u32Imm -- 立即数,对应指令中的C。
					p_Mode -- 模式选择
									2:	HHRs=min(LACCk,HACCk)(U,cut=C)
											HHRs=min(LACCk,HACCk)(cut=C)

									3:	LHRs= min(LACCk,HACCk)(U,cut=C)
											LHRs= min(LACCk,HACCk)(cut=C)
					
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，第0位为1表示有符号数，为0表示无符号数。		
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 MinACC(const DSP_BIT48 &p_ACC, DSPU32 p_u32Imm, DSPU32 p_Mode, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	DSPU32 lcc20 = p_ACC.u32Low & 0xfffff;
	DSPU32 hcc20 = p_ACC.u32Low >> 20;
	DSPU32 htest = p_ACC.u8Mid;
	hcc20 = hcc20 | (htest << 12);
	DSPU32 result = 0;
	DSPU32 cut = p_u32Imm & 0x7;
	if (cut > 4)
	{
		cut = 4;
	}
	DSPU20 u20hcc(hcc20);
	DSPU20 u20lcc(lcc20);
	if ((p_u32ALUCR & 0x1) == 0x1)
	{
				bool bMin1 = false;
		if (u20hcc.Sign() && u20lcc.Sign())
		{
			DSPU32 hccT20;
			DSPU32 lccT20;
			hccT20 = hcc20;
			lccT20 = lcc20;
			hccT20 = ~hccT20 + 1;
			hccT20 = hccT20 & 0xfffff;
			lccT20 = ~lccT20 + 1;
			lccT20 = lccT20 & 0xfffff;
			
			if (hccT20 > lccT20)
			{
				bMin1 = true;
			}
		}

		if (((u20hcc.Sign()) && (!u20lcc.Sign()))
			||((!u20hcc.Sign()) && (!u20lcc.Sign())&&(hcc20 < lcc20))
			||bMin1
			)
		{
			result = ((hcc20 >> cut) & 0xffff) | (((hcc20 >> cut) & 0xffff)<<16);
			if (cut < 4)
		{
			DSPU32 u32t = (hcc20 >> (15+cut)) ;
			
			if (
				(  ((u32t != 0x3) && (cut == 3))
				||((u32t != 0x7) && (cut == 2))
				||((u32t != 0xf) && (cut == 1))
				||((u32t != 0x1f) && (cut == 0))
				)
				&&(u32t != 0x0)
				)
			{
				
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if (u20hcc.Sign())
						{
							result = 0x80008000;
						}
						else
						{
							result = 0x7fff7fff;
						}
						
					}
					
			}
		}
		}
		else
		{
			result = ((lcc20 >> cut) & 0xffff) | (((lcc20 >> cut) & 0xffff)<<16);
			if (cut < 4)
		{
			//DSPU32 u32t = lcc20 >> 19;
			DSPU32 u32t = (lcc20 >> (15+cut)) ;
			
			if (
				(  ((u32t != 0x3) && (cut == 3))
				||((u32t != 0x7) && (cut == 2))
				||((u32t != 0xf) && (cut == 1))
				||((u32t != 0x1f) && (cut == 0))
				)
				&&(u32t != 0x0)
				)
			{
				
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if (u20lcc.Sign())
						{
							result = 0x80008000;
						}
						else
						{
							result = 0x7fff7fff;
						}
					}
					
			}
		}
		}
	}
	else
	{	/*
		if (((u20hcc.Sign()) && (!u20lcc.Sign()))
			||((!u20hcc.Sign()) && (!u20lcc.Sign())&&(hcc20 < lcc20))
			||((u20hcc.Sign()) && (u20lcc.Sign())&&(hcc20 > lcc20))
			)
			*/
		if (hcc20 < lcc20)
		{
			result = ((hcc20 >> cut) & 0xffff) | (((hcc20 >> cut) & 0xffff)<<16);
			if (cut < 4)
		{
			DSPU32 u32t = hcc20 >> (20-(4-cut));
			if (u32t !=0)
			{
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if ((p_u32ALUCR & 0x1) == 0x1)
						{
							result = 0x7fff7fff;
						}
						else
						{
							result = 0xffffffff;
						}
					}
			}
		}
		}
		else
		{
			result = ((lcc20 >> cut) & 0xffff) | (((lcc20 >> cut) & 0xffff)<<16);
				if (cut < 4)
		{
			DSPU32 u32t = lcc20 >> (20-(4-cut));
			if (u32t !=0)
			{
				  SetFlag(*p_pStatReg, ALU_OverFlow); 
					SetFlag(*p_pStatReg, ALU_AOS);
					SetFlag(*p_pStatReg, 5); 
					SetFlag(*p_pStatReg, 13); 
					if ((p_u32ALUCR & 0x2) == 0x2)
					{
						if ((p_u32ALUCR & 0x1) == 0x1)
						{
							result = 0x7fff7fff;
						}
						else
						{
							result = 0xffffffff;
						}
					}
			}
		}
		}
	}

	/*
	if (p_ACC.u32Low == 0xFFFFFFFF)
	{
		result = 0xFFFFFFFF;
	}
	*/
	//result = 0xFFFFFFFF;
	//p_ACC.u8High = 0;
	return result;
}


/*found*****************************************************************
	函数名：		ConditionalAssignD16

	对应指令形式:				LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0
								HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0
								LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0
								HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0
								LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0
								HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0
								LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0
								HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0

	描述:		16位条件赋值运算。
					详细内容参考指令集手册20130402中双字指令7的说明。

	参数:		p_u32Src1 -- 源操作数1,对应指令中Rm的值。
					p_u32Src2 -- 源操作数2,对应指令中Rn的值。
					p_Mode -- 模式选择，与8条指令依次对应0~7。
								0:	LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=LHRm> HHRn +LHRn ?(LHRm- HHRn):0
								1:	HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=LHRm> HHRn +LHRn ?(HHRm- HHRn):0
								2:	LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=LHRm> LHRn +HHRn ?(LHRm- LHRn):0
								3:	HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn):0
								4:	LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0(U)，LHRs=HHRm> HHRn +LHRn ?(LHRm- HHRn):0
								5:	HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0(U)，HHRs=HHRm> HHRn +LHRn ?(HHRm- HHRn):0
								6:	LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0(U)，LHRs=HHRm> LHRn +HHRn ?(LHRm- LHRn):0
								7:	HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0(U)，HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_pALUCFR -- 指向ALU比较标志寄存器的指针。
					p_u32ALUCR -- ALU控制寄存器。		
					

	返回值：		计算结果。

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。
							2. 根据计算结果设置ACF寄存器.

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 ConditionalAssignD16(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_Mode, DSPU32 *p_pStatReg, DSPU32 *p_pALUCFR, DSPU32 p_u32ALUCR)
{
	*p_pALUCFR = *p_pALUCFR << 1;   // SetBit(*p_pALUCFR , 0); ClearBit(*p_pALUCFR , 0);   
	DSPU32 tmpstat = 0;
	DSPU32 result = 0;
	bool bMAX = false;
	if (p_Mode == 0)
	{
		DSPU32 lhrm  = p_u32Src1 & 0xffff;
		DSPU32 lhrn  = p_u32Src2 & 0xffff;
		DSPU32 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( lhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		//if (lhrm > ( lhrn + hhrn))
		if (bDest)
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( lhrm,  hhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}
	
	if (p_Mode == 1)
	{
		DSPU32 lhrm  = p_u32Src1 & 0xffff;
		DSPU32 hhrm  = p_u32Src1 >> 16;

		DSPU32 lhrn  = p_u32Src2 & 0xffff;
		DSPU32 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( lhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (lhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( hhrm,  hhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}

	if (p_Mode == 2)
	{
		DSPI16 lhrm  = p_u32Src1 & 0xffff;
		DSPI16 hhrm  = p_u32Src1 >> 16;

		DSPI16 lhrn  = p_u32Src2 & 0xffff;
		DSPI16 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
	    DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( lhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (lhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( lhrm,  lhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}
	if (p_Mode == 3)//HHRs=LHRm> LHRn +HHRn ?(HHRm- LHRn)
	{
		DSPI16 lhrm  = p_u32Src1 & 0xffff;
		DSPI16 hhrm  = p_u32Src1 >> 16;

		DSPI16 lhrn  = p_u32Src2 & 0xffff;
		DSPI16 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( lhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (lhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( hhrm,  lhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}

	if (p_Mode == 4)
	{
		DSPI16 lhrm  = p_u32Src1 & 0xffff;
		DSPI16 hhrm  = p_u32Src1 >> 16;

		DSPI16 lhrn  = p_u32Src2 & 0xffff;
		DSPI16 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( hhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (hhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( lhrm,  hhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}	
	
		if (p_Mode == 5)
	{
		DSPI16 lhrm  = p_u32Src1 & 0xffff;
		DSPI16 hhrm  = p_u32Src1 >> 16;

		DSPI16 lhrn  = p_u32Src2 & 0xffff;
		DSPI16 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( hhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (hhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( hhrm,  hhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}
	
	if (p_Mode == 6)
	{
		DSPI16 lhrm  = p_u32Src1 & 0xffff;
		DSPI16 hhrm  = p_u32Src1 >> 16;

		DSPI16 lhrn  = p_u32Src2 & 0xffff;
		DSPI16 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( hhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (hhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( lhrm,  lhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}

		if (p_Mode == 7)//HHRs=HHRm> LHRn +HHRn ?(HHRm- LHRn):0
	{
		DSPI16 lhrm  = p_u32Src1 & 0xffff;
		DSPI16 hhrm  = p_u32Src1 >> 16;

		DSPI16 lhrn  = p_u32Src2 & 0xffff;
		DSPI16 hhrn  = p_u32Src2 >> 16;
		//DSPU32 result = 0;
		DSPU16 srcadd = Add16( lhrn,  hhrn, &tmpstat, p_u32ALUCR|0x2);
		bool bDest = Max16_BOOL( hhrm,  srcadd,  p_u32ALUCR);
		if ((srcadd == 0x8000)
			&& ((tmpstat & 0x1) == 0x1)
			)
		{
			bDest = true;
		}
		if (bDest)
		//if (hhrm > ( lhrn + hhrn))
		{
			bMAX = true;
			DSPU16 srcsub = Sub16( hhrm,  lhrn, p_pStatReg, p_u32ALUCR);
			result = ((srcsub)&0xffff)|(((srcsub)&0xffff)<<16);
		}
	}
	if (bMAX)
	{
		SetBit(*p_pALUCFR , 0);
	}else
	{
		ClearBit(*p_pALUCFR , 0);   
	}
	return result;

}

/******************************************************************
	函数名：		BIsMCnd16

	描述:			    多个条件执行同时满足才进行跳转。可以把多个条件判断语句的结果放到Rm中的固定某些位上，
						比较这些位是否满足等于C，完成多个条件同时满足才进行跳转的功能。
						详见指令集20130507.
	对应指令形式：
							If {x,y,z,t}HHRm[HHRn]==C BN <pro>
							If {x,y,z,t}LHRm[LHRn]==C BN <pro>

	参数:			  p_u16Src1 -- 源操作数1，16位定点数据，对应HHRm或LHRm。
					  p_u16Src2 -- 源操作数2，16位定点数据，对应HHRn或LHRn。
					  p_u16Imm -- 立即数C，16位定点数据。

	返回值：		若HHRm[HHRn]==C，返回true，	否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BIsMCnd16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU16 p_u16Imm)
{
	DSPU16 src1 = p_u16Src1;
	DSPU16 src2 = p_u16Src2;
	DSPU16 newsrc = 0;
	DSPU16 temp = 1;
	DSPU32 i = 0;
	DSPU32 j = 1;
	DSPU32 k = 0;
	while(i<=15)
	{
		i++;
		if ((src2 & 0x1)== 0x1)
		{
			DSPU32 src1temp = src1 & 0x1;	
			k++;
			if ((k == 1)&&(src1temp != 0) )
			{
				newsrc = 1;
			}
			if ((k > 1)&&(src1temp != 0) )
			{
				newsrc = newsrc + j;
				
			}
			j= j*2;
		}
		src1 = src1 >> 1;
		src2 = src2 >> 1;
		
	}


	if (p_u16Src2 == 0)
	{
		return 0;
	}
	if (k == 0)
	{
		return 0;
	}
	DSPU32 mar[16] = {0x1,0x3,0x7,0xf, 0x1f,0x3f,0x7f,0xff, 0x1ff,0x3ff,0x7ff,0xfff,0x1fff,0x3fff,0x7fff,0xffff};
	p_u16Imm =p_u16Imm & mar[k-1];

	if (newsrc == p_u16Imm)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

/******************************************************************
	函数名：		BnotIsMCnd16

	描述:			    多个条件执行同时满足才进行跳转。可以把多个条件判断语句的结果放到Rm中的固定某些位上，
						比较这些位是否满足等于C，完成多个条件同时满足才进行跳转的功能。
						详见指令集20130507.
	对应指令形式：
							If {x,y,z,t}HHRm[HHRn]!=C BN <pro>
							If {x,y,z,t}LHRm[LHRn]!=C BN <pro>

	参数:			  p_u16Src1 -- 源操作数1，16位定点数据，对应HHRm或LHRm。
					  p_u16Src2 -- 源操作数2，16位定点数据，对应HHRn或LHRn。
					  p_u16Imm -- 立即数C，16位定点数据。

	返回值：		若HHRm[HHRn]==C，返回true，	否则返回false。

	注意事项:	

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern bool BNotIsMCnd16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU16 p_u16Imm)
{
	DSPU16 src1 = p_u16Src1;
	DSPU16 src2 = p_u16Src2;
	DSPU16 newsrc = 0;
	DSPU16 temp = 1;
	DSPU32 i = 0;
	DSPU32 j = 1;
	DSPU32 k = 0;
	while(i<=15)
	{
		i++;
		if ((src2 & 0x1)== 0x1)
		{
			DSPU32 src1temp = src1 & 0x1;	
			k++;
			if ((k == 1)&&(src1temp != 0) )
			{
				newsrc = 1;
			}
			if ((k > 1)&&(src1temp != 0) )
			{
				newsrc = newsrc + j;
				
			}
			j= j*2;
		}
		src1 = src1 >> 1;
		src2 = src2 >> 1;
		
	}


	if (p_u16Src2 == 0)
	{
		return 0;
	}
	if (k == 0)
	{
		return 0;
	}
	DSPU32 mar[16] = {0x1,0x3,0x7,0xf, 0x1f,0x3f,0x7f,0xff, 0x1ff,0x3ff,0x7ff,0xfff,0x1fff,0x3fff,0x7fff,0xffff};
	p_u16Imm =p_u16Imm & mar[k-1];

	if (newsrc != p_u16Imm)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

/******************************************************************
	函数名：	  ACCAddF64HToDFIRR

	对应指令形式: DFHACCs=DFHRm+DFHRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据高32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64HToDFIRR(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT64 &p_DFIRR)
{
	DSPU32 df_augend_nan = 0;//被加数为非数，1有效
	DSPU32 df_addend_nan = 0;//加数为非数
	DSPU32 df_augend_infinite = 0;//被加数为无穷大
	DSPU32 df_addend_infinite = 0;//加数为无穷大
	DSPU32 df_augend_zero = 0;//被加数为零
	DSPU32 df_addend_zero = 0;//加数为零
	DSPU32 df_augend_sign = 0;//被加数为负数
	DSPU32 df_addend_sign = 0;//加数为负数
	DSPU32 df_exp_gr = 0;//被加数为指数大于加数
	DSPU32 df_larger_exp11= 0;//较大的指数值[10:0] 
	DSPU32 df_diff_of_exp11= 0;//较大的指数值与较小指数值的差[10:0] 
	DSPU32 dfr_pri_rshift_mag_update32 = 0;//较小浮点数的尾数[31:0]
	
	Cfloat32 cfSrc1(p_u32Src1H);
    Cfloat32 cfSrc2(p_u32Src2H);
	
	if (cfSrc1.Isf64NAN())
	{
		df_augend_nan = 1;
	}
	if (cfSrc2.Isf64NAN())
	{
		df_addend_nan = 1;
	}
	if (cfSrc1.Isf64INF())
	{
		df_augend_infinite = 1;
	}
	if (cfSrc2.Isf64INF())
	{
		df_addend_infinite = 1;
	}
	if (cfSrc1.IsZero())
	{
		df_augend_zero =1;
	}
	if (cfSrc2.IsZero())
	{
		df_addend_zero =1;
	}
	if (cfSrc1.Isf64DNORM())
	{
		df_augend_zero =1;
		p_u32Src1H = p_u32Src1H & 0x80000000;

	}
	if (cfSrc2.Isf64DNORM())
	{
		df_addend_zero =1;
		p_u32Src2H = p_u32Src2H & 0x80000000;
	}
	if (cfSrc1.IsNega())
	{
		df_augend_sign =1;
	}
	if (cfSrc2.IsNega())
	{
		df_addend_sign =1;
	}
	
	DSPU32 exp1 = (p_u32Src1H & 0x7ff00000) >> 20;
	DSPU32 exp2 = (p_u32Src2H & 0x7ff00000) >> 20;
	
	if (exp1 > exp2)
	{
		df_exp_gr = 1;
		df_larger_exp11 = exp1;
		df_diff_of_exp11 = exp1 - exp2;
		if (!cfSrc2.IsZero() && !cfSrc2.Isf64DNORM())
		{
			dfr_pri_rshift_mag_update32 = (p_u32Src2H & 0xfffff) | 0x100000;
		}
		if (cfSrc2.IsNega() &&((cfSrc2.IsNega())!=(cfSrc1.IsNega()))) 
		{
			dfr_pri_rshift_mag_update32 = ~dfr_pri_rshift_mag_update32 ;
		}
	}
	else
	{
		df_exp_gr = 0;
		df_larger_exp11 = exp2;
		df_diff_of_exp11 = exp2 - exp1;
		if (!cfSrc1.IsZero() && !cfSrc1.Isf64DNORM())
		{
			dfr_pri_rshift_mag_update32 = (p_u32Src1H & 0xfffff) | 0x100000;
		}
		if (cfSrc1.IsNega()&&((cfSrc2.IsNega())!=(cfSrc1.IsNega())))  
		{
			dfr_pri_rshift_mag_update32 = ~dfr_pri_rshift_mag_update32 ;
		}
	}
	//------------
	p_DFIRR.u32Low  = dfr_pri_rshift_mag_update32;
	p_DFIRR.u32High = df_diff_of_exp11;
	p_DFIRR.u32High =p_DFIRR.u32High | (df_larger_exp11 << 11);

	p_DFIRR.u32High =p_DFIRR.u32High | (df_exp_gr << 22);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_addend_sign << 23);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_augend_sign << 24);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_addend_zero << 25);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_augend_zero << 26);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_addend_infinite << 27);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_augend_infinite << 28);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_addend_nan << 29);
	p_DFIRR.u32High =p_DFIRR.u32High | (df_augend_nan << 30);

}
/******************************************************************
	函数名：	  ACCAddF64LToDFIRR

	对应指令形式: DFLACCs=DFLRm+DFLRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据低32位相加。与其他指令组合共同完成64位浮点相加运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddF64LToDFIRR(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT64 &p_DFIRR)
{
	DSPU32 df_augend_nan = 0;//被加数为非数，1有效
	DSPU32 df_addend_nan = 0;//加数为非数
	DSPU32 df_augend_infinite = 0;//被加数为无穷大
	DSPU32 df_addend_infinite = 0;//加数为无穷大	
	DSPU32 temp  = p_DFIRR.u32High;
	
	df_augend_nan = temp & 0x40000000;
	df_addend_nan = temp & 0x20000000;
	df_augend_infinite = temp & 0x10000000;
	df_addend_infinite = temp & 0x8000000;
	
	if ((df_augend_nan == 0)&& (df_augend_infinite == 0x10000000)&&(p_u32Src1L != 0))
	{
		temp = temp | 0x40000000;
	}
	if ((df_addend_nan == 0)&& (df_addend_infinite == 0x8000000)&&(p_u32Src2L != 0))
	{
		temp = temp | 0x20000000;
	}
	
	if (((df_augend_infinite == 0x10000000) &&(p_u32Src1L != 0))
		|| (df_augend_nan != 0)
		)
	{
		temp = temp &0xefffffff;
	}
	if (((df_addend_infinite == 0x8000000) &&(p_u32Src2L != 0))
		|| (df_addend_nan != 0)
		
		)
	{
		temp =temp & 0xf7ffffff;
	}
	p_DFIRR.u32High = temp;	
}

/******************************************************************
	函数名：	  ACCSubF64H

	对应指令形式: DFHACCs=DFHRm-DFHRn

	描述:		完成两个64位浮点数据高32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_FACC -- 64位浮点数累加结果寄存器，其中高16位只用11位做指数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64H(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT80 &p_FACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	 ACCAddF64H(p_u32Src1H,  p_u32Src2H ^ 0x80000000 , p_FACC, p_pStatReg,  p_u32ALUCR);
}
/******************************************************************
	函数名：	  ACCSubF64L

	对应指令形式: DFLACCs=DFLRm-DFLRn

	描述:		完成两个64位浮点数据低32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_FACC -- 64位浮点数累加结果寄存器，其中高16位只用11位做指数。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64L_OLD(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_u64HSrc, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//p_u64HSrc.u32Low = p_u64HSrc.u32Low ^ 0x80000000;
	ACCAddF64L( p_u32Src1L,  p_u32Src2L , p_FACC,p_u64HSrc, p_pStatReg,  p_u32ALUCR);
}

extern void ACCSubF64L(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT80 &p_FACC,DSP_BIT64 p_DFIRR, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	//p_u64HSrc.u32Low = p_u64HSrc.u32Low ^ 0x80000000;
	ACCAddF64L( p_u32Src1L,  p_u32Src2L , p_FACC,p_DFIRR, p_pStatReg,  p_u32ALUCR);
}

/******************************************************************
	函数名：	  ACCSubF64HToDFIRR

	对应指令形式: DFHACCs=DFHRm-DFHRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据高32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1H -- 第一个64位浮点数据的高32位。
					p_u32Src2H -- 第二个64位浮点数据的高32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64HToDFIRR(DSPU32 p_u32Src1H, DSPU32 p_u32Src2H, DSP_BIT64 &p_DFIRR)
{
	 ACCAddF64HToDFIRR( p_u32Src1H,  p_u32Src2H ^ 0x80000000, p_DFIRR);
}
/******************************************************************
	函数名：	  ACCSubF64LToDFIRR

	对应指令形式: DFLACCs=DFLRm-DFLRn

	描述:		用于更新DFIRR寄存器，完成两个64位浮点数据低32位相减。与其他指令组合共同完成64位浮点相减运算。

	参数:		p_u32Src1L -- 第一个64位浮点数据的低32位。
					p_u32Src2L -- 第二个64位浮点数据的低32位。
					p_DFIRR -- 64位浮点数累加中间结果寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubF64LToDFIRR(DSPU32 p_u32Src1L, DSPU32 p_u32Src2L, DSP_BIT64 &p_DFIRR)
{
	ACCAddF64LToDFIRR( p_u32Src1L,  p_u32Src2L, p_DFIRR);
}
//DSPU32 AddF32InAcc_new_40(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u8Src3 ,DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,DSP_BIT40 *p_pACC, DSPU8 *p_pEXP)
DSPU32 AddF32InAcc_40(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u8Src3 ,DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,DSP_BIT40 *p_pACC, DSPU8 *p_pEXP)

{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);  
        if (bolSatu)
        {
					
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;

            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);                        
        if (bolSatu)
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM();//u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM();//指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
    }  
    
    DSPU32 u32Src1Fra = cfSrc1.GetFrac();
   
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
    if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    }     
    DSPU32 u32Src2Fra = cfSrc2.GetFrac();    
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}    
    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI32 i32Src1Frac = (DSPI32)u32Src1Fra;
    DSPI32 i32Src2Frac = (DSPI32)u32Src2Fra;
    
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (cfSrc1.GetFrac() != cfSrc2.GetFrac())
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
      
        return 0;
	}

    Cfloat32 cfTemp;
	DSPI32 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		i32Src2Frac = i32Temp;
	}
    DSPI32 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
   
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1; 
		i32Src2Frac = i32Src2Frac >> 1;
		 if (i > 31)
         break;
   }
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   i32DestExp = cfSrc1.GetExp();//01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI32 i32CodeDestFrac = i32DestFrac;

   if (i32DestNeg != 0)
   {
	  
       //i32CodeDestFrac = ~i32DestFrac + 1;
	   //2008.10.6修改为带保护位左移
	   //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
        //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }

   //移位时,包括符号位.
   //这里使用的是原码进行判断
   bool bolFacOvf = ((i32CodeDestFrac >> 24) != 0x0);
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i32CodeDestFrac,23))
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }

	/*
   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }
	*/
    Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
		 cfDest.SetExp((DSPU32)i32DestExp);
		 cfDest.SetFrac((DSPU32)i32DestFrac);
		 *p_pEXP = (DSPU32)i32DestExp;
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
		*p_pEXP = (DSPU32)0;
	}
	//p_pACC->u32Low = ((DSPU32)i32DestFrac) << 8 ;
	p_pACC->u32Low = (((DSPU32)i32DestFrac) << 8) |  (p_u8Src3);
	
	if (i32DestNeg != 0)
   {
	    p_pACC->u8High = 0xff;
	}
	else
	{
		p_pACC->u8High = 0x0;
	}
	return (((DSPU32)(i32DestFrac<<8)));
    //return cfDest.GetU32();       
}

DSPU32 AddF32InAcc_new_40(DSPU32 p_u32Src1, DSPU32 p_u32Src2, DSPU32 p_u8Src3 ,DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,DSP_BIT40 *p_pACC, DSPU8 *p_pEXP)

{
    //状态寄存器标志位除了ALU的粘性标志位外 全部清0                  
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS);
    DSPU32 bunderflow = 0;
	Cfloat32 cfSrc1(p_u32Src1);
    Cfloat32 cfSrc2(p_u32Src2);
        
    if (cfSrc1.IsNAN() 
        || cfSrc2.IsNAN()
        || (cfSrc1.IsINF() && cfSrc2.IsINF() && (cfSrc1.IsNega() != cfSrc2.IsNega())) )
    {
               
        SetFlag(*p_pStatReg, ALU_Invalid);         
        SetFlag(*p_pStatReg, ALU_AIS);
		p_pACC->u32Low = 0xffffffff ;
		p_pACC->u8High = 0xff;
		*p_pEXP = 0xff;
        return N_A_N;
    }      
    bool bolSatu = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);

    if (cfSrc1.IsINF())
    {
        //按照硬件,改为有一个数为无穷,饱和也为最大非规格化数 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);  
        if (bolSatu)
        {
			
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;
            return MAX_NORM | (cfSrc1.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc1.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc1.GetNega() << 31);
        }
    }

    if (cfSrc2.IsINF())
    {
                 
        SetFlag(*p_pStatReg, ALU_FOverFlow);         
        SetFlag(*p_pStatReg, ALU_AVS);                        
        if (bolSatu)
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;
            return MAX_NORM | (cfSrc2.GetNega() << 31);
        }
        else
        {
			
					if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;
            return POS_INF | (cfSrc2.GetNega() << 31);
        }
    } 

	bool bolSrc1IsDNORM = cfSrc1.IsDNORM();//u8Exp == 0 && u23Frac != 0,
    
	if (bolSrc1IsDNORM)
    {
        cfSrc1.SetZero();
    }
    
    bool bolSrc2IsDNORM = cfSrc2.IsDNORM();//指数为0 ，尾数不为0 
    if (bolSrc2IsDNORM)
    {
        cfSrc2.SetZero();
		/*
		p_pACC->u32Low = 0;
		p_pACC->u8High = 0;
		*p_pEXP = 0;
		return 0x0;
		*/
    }  
    
    //DSPU32 u32Src1Fra = cfSrc1.GetFrac();
	DSPU64 u32Src1Fra = p_pACC->u32Low;
	DSPU64 tmp64 = p_pACC->u8High;
	u32Src1Fra = u32Src1Fra | (tmp64 << 32);
	/*
	if (cfSrc1.IsNORM())
	{
        SetBit(u32Src1Fra, 23); 
	}
	*/
    /*
	if (cfSrc1.IsNega())
    {
        u32Src1Fra = ~u32Src1Fra + 1;
    } 
	*/
    //DSPU32 u32Src2Fra = cfSrc2.GetFrac();
	DSPU64 u32Src2Fra = cfSrc2.GetFrac();
	if (cfSrc2.IsNORM())
	{
        SetBit(u32Src2Fra, 23); 
        
	}   
	//u32Src2Fra = u32Src2Fra << 8;
	DSPU32 u8frac = p_u8Src3 & 0xff;
	u32Src2Fra = (u32Src2Fra << 8) | u8frac;//尾数补8个0

    if (cfSrc2.IsNega())
    {
        u32Src2Fra = ~u32Src2Fra + 1; //23位尾数,1位隐藏位,剩下8位符号位 ff800000 
    } 
    
    DSPI32 i32ExpDiff = 0;
    DSPI64 i32Src1Frac = (DSPI64)u32Src1Fra;
    DSPI64 i32Src2Frac = (DSPI64)u32Src2Fra;
    //
	DSPU32 u32newFrac1 = 0;
	DSPU32 u32newFrac2 = u32Src2Fra;//cfSrc2.GetFrac();
	//u32newFrac2 = u32newFrac2 << 8;//尾数补8个0
	//DSPU32 u8frac = p_u8Src3 & 0xff;
	//u32newFrac2 = (u32newFrac2 << 8) | u8frac;//尾数补8个0
	
	bool bolnewFracSign1 = (p_pACC->u8High & 0x80) != 0;
    if (bolnewFracSign1)
    {
        u32newFrac1 = ~(p_pACC->u32Low) + 1;  
    }
    else
    {
        u32newFrac1 = p_pACC->u32Low;
    }
	u32newFrac1 = u32newFrac1 & 0x7fffffff;
	//
    bool RmExpIsBiger = true;
	if(cfSrc1.GetExp() != cfSrc2.GetExp())
	{
		RmExpIsBiger = cfSrc1.GetExp() > cfSrc2.GetExp();
	}
	else if (u32newFrac1 != u32newFrac2)
	{
		RmExpIsBiger = cfSrc1.GetFrac() > cfSrc2.GetFrac(); //1 
		
	}
	else if (cfSrc1.GetNega() != cfSrc2.GetNega())
	{
		p_pACC->u32Low = 0;
		p_pACC->u8High = 0;
		*p_pEXP = 0;
        return 0;
	}
		if (cfSrc2.IsZero())
	{
		return 0;
	}
    Cfloat32 cfTemp;
	DSPI64 i32Temp;
	if (!RmExpIsBiger)
	{
        cfTemp = cfSrc1;
        cfSrc1 = cfSrc2;
        cfSrc2 = cfTemp;

        i32Temp = i32Src1Frac;
		i32Src1Frac = i32Src2Frac;
		//i32Src1Frac = i32Src1Frac << 8;
		i32Src2Frac = i32Temp;
		if (cfSrc2.IsNega())
		{
			//i32Src2Frac = ~i32Src2Frac + 1;
		}
	}
	if (cfSrc2.IsNega())
	{
		i32Src2Frac = i32Src2Frac | 0xffffffff00000000ull;
	}
	if (cfSrc1.IsNega())
	{
		i32Src1Frac = i32Src1Frac | 0xffffffff00000000ull;
	}
    DSPI64 i32DestFrac = 0;
    DSPI32 i32DestExp = 0;
    DSPI32 i32DestNeg = 0;
	bool bolProteckBit = false;

    i32ExpDiff = cfSrc1.GetExp() - cfSrc2.GetExp();
    //cout<<hex<<i32Src2Frac<<endl;
    ////2008.10.10 求较小数的保护位 
   for ( int i = 0; i < i32ExpDiff; i++)
   {
		bolProteckBit = i32Src2Frac & 0x1;
		if (cfSrc2.IsNega())
		{
			i32Src2Frac = i32Src2Frac | 0x8000000000000000ull;
		}
		i32Src2Frac = i32Src2Frac >> 1;
		

		 if (i > 63)//31
         break;
   }
   //cout<<hex<<i32Src2Frac<<endl;
   i32DestFrac = i32Src1Frac + i32Src2Frac;//实现的是尾数相加！！
   i32DestExp = cfSrc1.GetExp();//01 
   i32DestNeg = cfSrc1.GetNega();//0 

   //由补码求原码,用来判断需不需要左规或右规
   DSPI64 i32CodeDestFrac = i32DestFrac;
	/*
   if (i32DestNeg != 0)
   {
	  
       //i32CodeDestFrac = ~i32DestFrac + 1;
	   //2008.10.6修改为带保护位左移
	   //2008.10.10 主任要求先修改：指数差1 带保护位，指数不是差1，不带保护位 
        //2008.10.13 指数相差1是特殊情况
       DSPU32  i32tempFrac = 0; 
       if(i32ExpDiff == 0x1) 
       {
           i32tempFrac = i32DestFrac&0x80000000 ;
           if(i32tempFrac == 0x80000000) 
           {
                i32tempFrac = 0; 
                          
           }
           
           else  i32tempFrac = 0x80000000;
           
           i32CodeDestFrac = ((~((i32DestFrac<<1)|(DSPI32)bolProteckBit) + 1)>>1)|i32tempFrac;
           
           
       } 
       
       else       
       {
           i32CodeDestFrac = ~i32DestFrac + 1;
           
       }      
   }
	*/

	bool bolFacOvf = true;
   DSPI64 i64CodeDestFrac = i32CodeDestFrac;

	//if (cfSrc1.IsNega())
   if (i64CodeDestFrac < 0)
	{
		i64CodeDestFrac = ~i64CodeDestFrac + 1;
	}
	 bolFacOvf = ((i64CodeDestFrac >> 32) != 0x0);

	if (bolFacOvf)
	{
		i32DestExp ++ ;
		 if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);

				if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xfe;

                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
				if (cfSrc2.IsNega())
					{
						p_pACC->u8High = 0xff;
						p_pACC->u32Low = 0x1;
					}
					else
					{
						p_pACC->u8High = 0;
						p_pACC->u32Low = 0xffffffff;
					}
					*p_pEXP = 0xff;

                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32CodeDestFrac = i32CodeDestFrac >> 1;  //移动补码 
	}
	else
	{
		     //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i64CodeDestFrac,31))//23
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
				bunderflow = 1;
				if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
				{
					    p_pACC->u8High = 0x0;
						p_pACC->u32Low = 0x0;
				}
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   //i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    //i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   i32CodeDestFrac = i32CodeDestFrac << 1;  //移动补码
		   i64CodeDestFrac = i64CodeDestFrac << 1;

		 while (!TestBit(i64CodeDestFrac,31) && (i64CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
					bunderflow = 1;
				if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
				{
					    p_pACC->u8High = 0x0;
						p_pACC->u32Low = 0x0;
				}
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				//i32DestFrac = i32DestFrac << 1;
				//i32CodeDestFrac = i32CodeDestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;  //移动补码
				i64CodeDestFrac = i64CodeDestFrac << 1;
		   }
	   }
	}
   //移位时,包括符号位.
   //这里使用的是原码进行判断 24
   //bool bolFacOvf = ((i32CodeDestFrac >> 32) != 0x0);//24
   //如果尾数溢出,再右规一次. (记住 ,使用原码进行判断,再移动补码,要改)
   /*
    if(bolFacOvf) 
   {  
       i32DestExp ++ ;     
       if(i32DestExp >= 0xff)
       {
            if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
            {
                SetFlag(*p_pStatReg,ALU_FOverFlow);//饱和控制，结果大于最大有效值，输出最大有效值，标志位设定溢出 baohua07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return MAX_NORM | (i32DestNeg << 31);
            }
            else
            {
            	SetFlag(*p_pStatReg,ALU_FOverFlow);//不饱和控制，如果结果大于最大有效值，输出无穷大值，标志位设定溢出 baohua 07-11-07 11:42
                SetFlag(*p_pStatReg,ALU_AVS);
                return POS_INF |(i32DestNeg << 31);
            }
       }             
       i32DestFrac = i32DestFrac >> 1;  //移动补码 
       
   }  
   //除了尾数溢出情形,还有需要左规N位的情形
   else
   {
	   
       //隐藏位为0,左规N位
	   ////这里使用的是原码进行判断
	   
	   if(!TestBit(i32CodeDestFrac,31))//23
	   {
		    
		   //2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
		   //2008.10.23，如果尾数为0 ，则不下溢出
			if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
			{
				SetFlag(*p_pStatReg,ALU_UnderFlow);  
				SetFlag(*p_pStatReg,ALU_AUS);
			}
		   i32DestExp --;
		   //移动补码,带保护位
		  
		   i32DestFrac = i32DestFrac << 1 | (DSPI32)bolProteckBit;
		   //左规判断的依据:原码也随之左移一位,用于下次判断.
		    i32CodeDestFrac = i32CodeDestFrac << 1 | (DSPI32)bolProteckBit;
		   //继续左移,直到出现第一个1或原码移至全为0 
		   
		 while (!TestBit(i32CodeDestFrac,23) && (i32CodeDestFrac != 0))
		   {
				//2008.10.17.结果指数值小于等于左移的尾数，会出现左规后指数无法表示，即下溢出
				//2008.10.23，如果尾数为0 ，则不下溢出
				if(((i32DestExp == 0x0)||(i32DestExp == 0x1))&&(i32CodeDestFrac != 0))
				{
					SetFlag(*p_pStatReg,ALU_UnderFlow);  
					SetFlag(*p_pStatReg,ALU_AUS);
				}			   
			   
			    i32DestExp --;
				//移动补码,不带保护位
				i32DestFrac = i32DestFrac << 1;
				i32CodeDestFrac = i32CodeDestFrac << 1;		
		   }
	   }

   }
	*/
	/*
   if (i32DestNeg != 0)
   {
	   i32DestFrac = ~i32DestFrac + 1; //最终求回原码,用于组合32位浮点数 
   }
	*/
    Cfloat32 cfDest((DSPU32)0);
    if(i32DestNeg != 0)
    {
   		 cfDest.SetNeg();
    }
    if(i32DestExp > 0)
	{
		 cfDest.SetExp((DSPU32)i32DestExp);
		 cfDest.SetFrac((DSPU32)i32DestFrac);
		 *p_pEXP = (DSPU32)i32DestExp;
	}
	else
	{ 
        cfDest.SetExp((DSPU32)0);
		cfDest.SetFrac((DSPU32)0);
		*p_pEXP = (DSPU32)0;
	}
	p_pACC->u32Low = ((DSPU32)i32CodeDestFrac) ;
	p_pACC->u8High = ((DSPU64)i32CodeDestFrac) >> 32;
	
	if (TestFlag(p_u32ALUCR,ALU_Ctl_Saturation))
	{
		   if (bunderflow == 1)
		   {
			p_pACC->u8High = 0x0;
			p_pACC->u32Low = 0x0;
		   }
	}
	if (i32CodeDestFrac == 0)
	{
		*p_pEXP = (DSPU32)0;
	}
	
	return (((DSPU32)(i32DestFrac)));
    //return cfDest.GetU32();       
}

extern void ACCAddF32_40(DSPU32 p_u32Src, DSPU32 p_u8Src2, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{


    //
	if ((p_u32Src == 0x7f800000)
		&& (p_pACC->u32Low == 0x0)
		&& (p_pACC->u8High == 0x0)
		)
	{
		//int i = 0;
	}
	DSP_BIT40 Tmp_pACC = *p_pACC;
	DSPU8     Tmp_exp = *p_pEXP;
	DSPU32    Tmp_src = p_u32Src;
	if (p_u32Src == 0x7fa228fc)
	{
		//int i = 0;
	}
	//
     //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS); 
     //2008.10.30,LXM规定不再分饱和和不饱和，都置标志位     
     //结果强制做饱和 
	 SetFlag(p_u32ALUCR,ALU_Ctl_Saturation);
     //先取控制信号 
	 bool bolStau =  TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
	 DSPU32 U32StatReg = 0; 
     U32StatReg = *p_pStatReg &0x200; 
     
     ////add 2008-07-31 
     DSPU8  u8HaccHigh = 0;    
     DSPU32 u32HaccLow = 0;
     DSPU32 u32TempFrac = 0;

	Cfloat32 tmp13(p_u32Src);

	if (tmp13.IsNAN())
	{
		SetFlag(*p_pStatReg, ALU_Invalid);         
		SetFlag(*p_pStatReg, ALU_AIS);

		*p_pEXP = 0xff;
		p_pACC->u32Low = 0xffffffff;
		p_pACC->u8High = 0xff; 	

		return;
	}
    //added by flyu on 20150420
	if ((tmp13.IsINF())  && ( p_u8Src2 != 0x0))
	{
		SetFlag(*p_pStatReg, ALU_Invalid);         
		SetFlag(*p_pStatReg, ALU_AIS);

		*p_pEXP = 0xff;
		p_pACC->u32Low = 0xffffffff;
		p_pACC->u8High = 0xff; 	

		return;
	}


	//
	 
	
     //只是针对定点累加结果转为浮点运算时，指数为0情况
     //2008.07.30指数为0 ，累加输入就是为0 ，无效数LXM规定 
     ////将40尾数为0视为指数为0 的情况，2008-07-31

	 //(1)指数为0
     if(*p_pEXP == 0)
     //if((*p_pEXP == 0) || ((p_pACC->u8High == 0)&&(p_pACC->u32Low == 0)))    
     {
        DSPU32 u32StatTemp = 0; 
		DSPU32 u32Frac = 0;
		
        bool bolAccIsNaN = (*p_pEXP == 0xff) && (p_pACC->u32Low == 0xffffffff) && (p_pACC->u8High == 0xff);

        //实际尾数共25位,23位数位,1位隐藏位,1位符号位,其它为符号位扩展 
        bool bolFracSign = (p_pACC->u8High & 0x80) != 0;
        
        if (bolAccIsNaN)
        {
            SetFlag(*p_pStatReg, ALU_Invalid);         
            SetFlag(*p_pStatReg, ALU_AIS);
            return;
        }
        
         ///如果指数为0，无效数，就是该累加输入为0,当作浮点0处理，其它都不变 
        p_pACC->u8High = 0;
        p_pACC->u32Low = 0; 
         
        //
        Cfloat32 cf32Src (p_u32Src);
    	
    	DSPU8 iExp = cf32Src.GetExp()-*p_pEXP;//取原操作数与ACC指数的差值
    	DSPU32 u8HignLSB = 0;
    	if (*p_pEXP <= cf32Src.GetExp())//如果ACC指数小于等于原操作数的指数(加上一个等于号，解决结果在指数都为0时的差异) 
    	{
        	           
 	        int i = 1;//循环计数，最大数不能超过31即32次
			int i_cnt= iExp; //差值作为右移次数值
          	{  
        	
					while (i_cnt && i <= 31)
    				{
    					i++;
						i_cnt--;

						//如果指数差值大于0，ACC40位数带符号右移，为负左补1
    					u8HignLSB = p_pACC->u8High & 0x01;
    					p_pACC->u32Low =  p_pACC->u32Low >> 1 | u8HignLSB << 31;
    					p_pACC->u8High = (DSPI8)p_pACC->u8High >> 1;//带符号右移，为负左补1

						////指数不用加1？2008.09.26,应该加上？
						//*p_pEXP ++;
		    			
    				}	

			}

//        	//只有指数为0时才会出现定点结果转换为浮点累加源操作数时会发生错误，下面可能用不到 21-11-07 16:45
//           else
//        	{
//        		while (*p_pEXP < cf32Src.GetExp() && i <= 31)
//        		{
//        			i++;
//        			u8HignLSB = p_pACC->u8High & 0x01;
//        			p_pACC->u32Low =  p_pACC->u32Low >> 1 | u8HignLSB << 31;
//       			p_pACC->u8High = (DSPI8)p_pACC->u8High >> 1;
//       			*p_pEXP ++;
//       		}
//        	}
        ////如果指数差小于等于1，截取25位值 
			if(iExp<=1)
			{
				p_pACC->u8High = 0;
				p_pACC->u32Low &=0x03ffffff;//截取26位 
			} 
			
			 DSPU32 u32AccFValue = ACCToF32_new(*p_pACC, &u32StatTemp, p_u32ALUCR, *p_pEXP, bolAccIsNaN);//0x007ffff

			 DSPU32 u32FinalResult = AddF32InAcc_new_40(u32AccFValue, p_u32Src,p_u8Src2, p_pStatReg, p_u32ALUCR,p_pACC,p_pEXP);//0
			 bool bolIsNAN = TestFlag(*p_pStatReg, ALU_Invalid);
			 //*p_pACC = U32ToAcc(u32FinalResult, p_pStatReg, p_u32ALUCR, p_pEXP, &bolIsNAN);
			 //p_pACC->u32Low = u32FinalResult;
		}                    
         
    }


  
     
   //(3)其它，最开始即原来的算法，amend 2008.09.25
   //当不是定点累加结果转为浮点输入时，按照正常浮点累加结果进行运算22-11-07 10:59
   //如果40位尾数不为0 ，按照指数不为0 情况处理 

   else	
    {
        //在分段赋值后出现 ，指数不为0，尾数不符合格式时尾数为0 
        //2008-09-16 正确的数据格式：指数有值，符号位全为0(正数.负数先对40位数求补)，位[23]位数为1；
        //2008-09-16 其它格式被作为非法格式，全按0数处理，LXM。
    	 //(2)指数不为0
    	 if(*p_pEXP != 0)
         {		
    			DSPU32 u32StatTemp = 0;//add 2008.09.25
    			///C:非数直接返回
    		    //2008.10.06 与LXM约定，在做浮点累加时，只要指数为ff，直接返回非数值
				bool bolAccIsNaN = *p_pEXP == 0xff; 
    			if (bolAccIsNaN)
    			{
    				SetFlag(*p_pStatReg, ALU_Invalid);         
    				SetFlag(*p_pStatReg, ALU_AIS);

					*p_pEXP = 0xff;
					p_pACC->u32Low = 0xffffffff;
					p_pACC->u8High = 0xff; 	

    				return;
    			}
    			DSPU32 AccIsNeg = p_pACC->u8High;
    			AccIsNeg = AccIsNeg&0x80;
    			///A:[39] = 0 ,mag[39:23] !=17'h00001，当浮点0处理
				///A:[39] = 0 ,mag[39:31] !=9'h00001，当浮点0处理
    			if(AccIsNeg == 0)
    			{
    
    				u32TempFrac = (p_pACC->u8High<<1)|(p_pACC->u32Low >>31); 
    				////其它非法格式：高17位不为0x1，结果为0 
    				
					if(u32TempFrac != 0x1)
    				{    
    					*p_pEXP = 0;
    					p_pACC->u8High = 0; 
    					p_pACC->u32Low = 0;              
    				}
					
	    			}    
				
              ///B:mag[39]==1'b1（负数）的情况下，对mag[39:0]求补，
              ///即neg_mag[39:0]= - mag[39:0],如果neg_mag[39:23] !=17'h00001，当浮点0处理。
				
              ///B:mag[39]==1'b1（负数）的情况下，对mag[39:0]求补，
              ///即neg_mag[39:0]= - mag[39:0],如果neg_mag[39:31] !=9'h00001，当浮点0处理。 

    			if(AccIsNeg == 0x80)
    			{    
    				if(p_pACC->u32Low == 0)
    				{              
    					u32HaccLow = ~p_pACC->u32Low +1;///尾数只有在全f情况下才会出现加1后溢出； 
    					u8HaccHigh = ~p_pACC->u8High +1;					
    				}
    				else
    				{
    					u32HaccLow = ~p_pACC->u32Low +1;
    					u8HaccHigh = ~p_pACC->u8High ; //带符号求反 ，但是P_pACC的值没有变 ，只有 Hacc的值变了 					
    				}
    				
    
    				u32TempFrac = (u8HaccHigh<<1)|(u32HaccLow>>31);
    				////高17位不为0x1，结果为0 
    				
					if(u32TempFrac != 0x1)
    				{
    					*p_pEXP = 0;
    					p_pACC->u8High = 0; 
    					p_pACC->u32Low = 0;
    				}
					
					
    			}
    			 
    		
          }
         DSPU32 u32StatTemp = 0;  
         bool bolAccIsNaN = (*p_pEXP == 0xff) && (p_pACC->u32Low == 0xffffffff) && (p_pACC->u8High == 0xff);
         
		 DSPU32 u32AccFValue = ACCToF32_new(*p_pACC, &u32StatTemp, p_u32ALUCR, *p_pEXP, bolAccIsNaN);
		 DSPU32 u32FinalResult = AddF32InAcc_new_40(u32AccFValue, p_u32Src,p_u8Src2, p_pStatReg, p_u32ALUCR,p_pACC,p_pEXP);//0
		 //DSPU32 u32FinalResult = AddF32(p_u32Src, u32AccFValue, p_pStatReg, p_u32ALUCR);
         bool bolIsNAN = TestFlag(*p_pStatReg, ALU_Invalid);
        // *p_pACC = U32ToAcc(u32FinalResult, p_pStatReg, p_u32ALUCR, p_pEXP, &bolIsNAN); 


    }
}

/******************************************************************
	函数名：		ACCAddAMACC

	描述:			第s个ALU的累加器ACC中的40位浮点数与第s个乘法器中的40位浮点数寄存器AMACC中的浮点数进行40位浮点累加。
					ACCs+=AMACC

	参数:		p_AMACC -- 乘法器中的40位浮点数寄存器
					p_pACC -- 指向40位累加结果的指针。
					p_pEXP -- 指向8位指数的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddAMACC(DSP_BIT40 p_AMACC, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	
	DSPU32 u32high = p_AMACC.u8High;
	DSPU32 u32sr1 = (u32high<< 24) | (p_AMACC.u32Low >> 8);
	DSPU32 u8frc1 = p_AMACC.u32Low & 0xff;
	ACCAddF32_40( u32sr1,  u8frc1, p_pACC, p_pEXP, p_pStatReg, p_u32ALUCR);

}


/******************************************************************
	函数名：		ACCSubAMACC

	描述:			第s个ALU的累加器ACC中的40位浮点数与第s个乘法器中的40位浮点数寄存器AMACC中的浮点数进行40位浮点累减。
					ACCs-=AMACC

	参数:		p_AMACC -- 乘法器中的40位浮点数寄存器
					p_pACC -- 指向40位累加结果的指针。
					p_pEXP -- 指向8位指数的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					根据计算结果更新累加结果；
					作累加操作时饱和模式始终有效。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSubAMACC(DSP_BIT40 p_AMACC, DSP_BIT40 *p_pACC, DSPU8 *p_pEXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	SetFlag(p_u32ALUCR,ALU_Ctl_Saturation);


	DSPU32 u32high = p_AMACC.u8High;
	DSPU32 u32sr1 = (u32high<< 24) | (p_AMACC.u32Low >> 8);
	DSPU32 u8frc1 = p_AMACC.u32Low& 0xff;

	ACCAddF32_40( u32sr1 ^ 0x80000000,  u8frc1, p_pACC, p_pEXP, p_pStatReg, p_u32ALUCR);

}



/*found*****************************************************************
	函数名：		AddOReg

	指令形式：      HRs+1:s=ORm+ORn
	                HRs+1:s=ORm+ORn(U)

	描述:			8位有符号/无符号数相加,存入4个16位数中，
					Rm[7:0]与Rn[7:0]进行有符号数相加，结果存入函数返回值Rs[15:0]中；
					Rm[15:8]与Rn[15:8]进行有符号数相加，结果存入函数返回值Rs[31:16]中；
					详细说明见指令集20141226。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 AddOReg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	 DSPU16 u16rmlow = p_u32SrcRm & 0xff;
	 DSPU16 u16rnlow = p_u32SrcRn & 0xff;

	 DSPU16 u16rmhigh = (p_u32SrcRm & 0xff00) >> 8;
	 DSPU16 u16rnhign = (p_u32SrcRn & 0xff00) >> 8;


	 bool bolSrcSign = p_u32ALUCR & 0x1;

	 if ( bolSrcSign )
	 {
		DSPU16 u16rmsign = u16rmlow & 0x80;
		DSPU16 u16rnsign = u16rnlow & 0x80;
		if (u16rmsign == 0x80)
		{
			u16rmlow = u16rmlow | 0xff00 ; 
		}
		if (u16rnsign == 0x80)
		{
			u16rnlow = u16rnlow | 0xff00 ; 
		}
		

		DSPU16 u16rmsignh = u16rmhigh & 0x80;
		DSPU16 u16rnsignh = u16rnhign & 0x80;
		if (u16rmsignh == 0x80)
		{
			u16rmhigh = u16rmhigh | 0xff00 ; 
		}
		if (u16rnsignh == 0x80)
		{
			u16rnhign = u16rnhign | 0xff00 ; 
		}
	 }
	
	DSPU16 u16resultlow = Add16( u16rmlow,  u16rnlow,  p_pStatReg,  p_u32ALUCR  | 0x1);
	DSPU16 u16resulthigh =Add16( u16rmhigh, u16rnhign, p_pStatReg,  p_u32ALUCR  | 0x1);

	DSPU32 u32result = u16resulthigh;
	u32result = u32result << 16;
	u32result = (u32result & 0xffff0000) | (u16resultlow & 0xffff);

	return u32result;
	 //extern DSPU16 Add16(DSPU16 p_u16Src1, DSPU16 p_u16Src2, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)

}
/*found*****************************************************************
	函数名：		AddD16Reg

	指令形式：      Rs+1:s =HRm+HRn
	                Rs+1:s =HRm+HRn(U)

	描述:			16位有符号/无符号数相加，
					Rm[15:0]与Rn[15:0]由16位有符号数扩展为32位有符号数后，进行有符号数相加，结果存入Rs中
					详细说明见指令集20141211。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		Rs

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 AddD16Reg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	 DSPU32 u32rmlow = p_u32SrcRm & 0xffff;
	 DSPU32 u32rnlow = p_u32SrcRn & 0xffff;




	 bool bolSrcSign = p_u32ALUCR & 0x1;

	 if ( bolSrcSign )
	 {
		DSPU16 u16rmsign = u32rmlow & 0x8000;
		DSPU16 u16rnsign = u32rnlow & 0x8000;
		if (u16rmsign == 0x8000)
		{
			u32rmlow = u32rmlow | 0xffff0000 ; 
		}
		if (u16rnsign == 0x8000)
		{
			u32rnlow = u32rnlow | 0xffff0000 ; 
		}
		
	 }
	
	DSPU32 u32result = Add32( u32rmlow,  u32rnlow,  p_pStatReg,  p_u32ALUCR  | 0x1);


	return u32result;
}
/*found*****************************************************************
	函数名：		SubOReg

	指令形式：      HRs+1:s=ORm-ORn
	                HRs+1:s=ORm-ORn(U)

	描述:			8位有符号/无符号数相减,存入4个16位数中，
					Rm[7:0]与Rn[7:0]进行有符号数相减，结果存入函数返回值Rs[15:0]中；
					Rm[15:8]与Rn[15:8]进行有符号数相减，结果存入函数返回值Rs[31:16]中；
					详细说明见指令集20141226。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 SubOReg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	 DSPU16 u16rmlow = p_u32SrcRm & 0xff;
	 DSPU16 u16rnlow = p_u32SrcRn & 0xff;

	 DSPU16 u16rmhigh = (p_u32SrcRm & 0xff00) >> 8;
	 DSPU16 u16rnhign = (p_u32SrcRn & 0xff00) >> 8;


	 bool bolSrcSign = p_u32ALUCR & 0x1;

	 if ( bolSrcSign )
	 {
		DSPU16 u16rmsign = u16rmlow & 0x80;
		DSPU16 u16rnsign = u16rnlow & 0x80;
		if (u16rmsign == 0x80)
		{
			u16rmlow = u16rmlow | 0xff00 ; 
		}
		if (u16rnsign == 0x80)
		{
			u16rnlow = u16rnlow | 0xff00 ; 
		}
		

		DSPU16 u16rmsignh = u16rmhigh & 0x80;
		DSPU16 u16rnsignh = u16rnhign & 0x80;
		if (u16rmsignh == 0x80)
		{
			u16rmhigh = u16rmhigh | 0xff00 ; 
		}
		if (u16rnsignh == 0x80)
		{
			u16rnhign = u16rnhign | 0xff00 ; 
		}
	 }
	
	DSPU16 u16resultlow = Sub16( u16rmlow,  u16rnlow,  p_pStatReg,  p_u32ALUCR  | 0x1);
	DSPU16 u16resulthigh =Sub16( u16rmhigh, u16rnhign, p_pStatReg,  p_u32ALUCR  | 0x1);

	DSPU32 u32result = u16resulthigh;
	u32result = u32result << 16;
	u32result = (u32result & 0xffff0000) | (u16resultlow & 0xffff);

	return u32result;
}
/*found*****************************************************************
	函数名：		SubD16Reg

	指令形式：      Rs+1:s =HRm-HRn
	                Rs+1:s =HRm-HRn(U)

	描述:			16位有符号/无符号数相减，
					Rm[15:0]与Rn[15:0]由16位有符号数扩展为32位有符号数后，进行有符号数相减，结果存入Rs中
					详细说明见指令集20141211。

	参数:			
						p_u32SrcRm -- 源操作数Rm。
						p_u32SrcRn -- 源操作数Rn。
						p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
						p_u32ALUCR -- ALU控制寄存器,第0位为1表示有符号数加，第0位为0表示无符号数加。

	返回值：		Rs

	注意事项:		1. 根据计算结果设置标志寄存器中属于ALU的标志位。

	修改记录
--------------------------------------
	日期			作者			修改处

*******************************************************************/
extern DSPU32 SubD16Reg(DSPU32 p_u32SrcRm, DSPU32 p_u32SrcRn, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	 DSPU32 u32rmlow = p_u32SrcRm & 0xffff;
	 DSPU32 u32rnlow = p_u32SrcRn & 0xffff;




	 bool bolSrcSign = p_u32ALUCR & 0x1;

	 if ( bolSrcSign )
	 {
		DSPU16 u16rmsign = u32rmlow & 0x8000;
		DSPU16 u16rnsign = u32rnlow & 0x8000;
		if (u16rmsign == 0x8000)
		{
			u32rmlow = u32rmlow | 0xffff0000 ; 
		}
		if (u16rnsign == 0x8000)
		{
			u32rnlow = u32rnlow | 0xffff0000 ; 
		}
		
	 }
	
	DSPU32 u32result = Sub32( u32rmlow,  u32rnlow,  p_pStatReg,  p_u32ALUCR  | 0x1);


	return u32result;
}


//added by flyu on 20150604
void ACCAdd16Once_01(DSPU16 p_u16Src, DSPU20 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS) | BIT(13); 
     
    DSPU20 Src1(p_u16Src);
    
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    ///添加080718 按照主任要求累加/累减受饱和控制位 控制 
    bool p_bolStau   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    if (p_u16Src != 0x8000)
	{
		if (p_bolSigned)
		{
			Src1.SignExtend();
		}
	}
    DSPU20 Src2 = *p_pACC;
    DSPU20 u20Result;
    u20Result = Src1 + Src2;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u20Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u20Result.Sign();                        
    
    bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u20Result.Sign()) 
                        || (Src1.Sign() && Src2.Sign());        
    
    bool bolUnsignedOverflow = bolCarryFlag;   
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolOvfFlag = bolOverflow  || bolUnderflow;    
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsignedOverflow) ) //26-10-07 08:54
    {
        ///只有饱和才会置位标志位 
        if(p_bolStau) 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS);  
			SetFlag(*p_pStatReg, 5); 
            SetFlag(*p_pStatReg, 13);  
        }                 
    }    
    
    
    if (p_bolSigned)
    { 
        ///0722添加受饱和控制 
        if (bolOverflow&&p_bolStau)
        {
            u20Result.SetToMAX_SN_20();
        }
        ///0722添加受饱和控制 
        if (bolUnderflow&&p_bolStau)
        {
            u20Result.SetToMIN_SN_20();
        }   
    } 
    else         
        {
            ///0722添加受饱和控制 
            if (bolUnsignedOverflow&&p_bolStau)
            {                    
                 u20Result.SetToMAX_UN_20();   
            }   
        }
    
    *p_pACC = u20Result;       
}


extern void ACCAddD16_01(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    DSPU16 u16UpperSrc1 = (DSPU16)(p_u32Src >> 16);
    DSPU16 u16LowerSrc1 = (DSPU16)(p_u32Src);    
    
    DSPU20 u20UpperSrc2 ((DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) ));
    DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low)); 
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    
    ACCAdd16Once_01(u16UpperSrc1, &u20UpperSrc2, &UpperReg, p_u32ALUCR);
    ACCAdd16Once_01(u16LowerSrc1, &u20LowerSrc2, &LowerReg, p_u32ALUCR);

    DSP_BIT40 u40Result;
    u40Result.u32Low = u20UpperSrc2.GetU32() << 20 | u20LowerSrc2.GetU32();
    u40Result.u8High = (DSPU8)(u20UpperSrc2.GetU32() >> 12);
    
    *p_pACC = u40Result;
    *p_pStatReg = UpperReg | LowerReg;
    
}
/******************************************************************
	函数名：	  ACCAddAbs16

	对应指令形式: HACCm=ABS(HRn)
	              HACCm+=ABS(HRn)

	描述:		将Rn寄存器的高低16位分别取绝对值，赋给ACCm的高低20位。若16位数据是0x8000，取绝对值后认为是正的0x08000，再赋到ACC中。

	参数:		p_u32Src -- 对应指令中的Rn。
					p_pACC -- p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器。
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCAddAbs16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU8 *p_EXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
//extern void ACCAddAbs16(DSPU32 p_u32Src, DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
	*p_EXP = 0;
	DSPU16 u16src1 = p_u32Src & 0xffff;
	DSPU16 u16src2 = (p_u32Src >> 16) & 0xffff;
	
	DSPU32 pStatReg = 0;
	u16src1 = ALU_Abs16_new(u16src1, &pStatReg,p_u32ALUCR);
	u16src2 = ALU_Abs16_new(u16src2, &pStatReg,p_u32ALUCR);
	
	DSPU32 u32src = u16src2;
	u32src = u32src << 16 ;
	u32src = (u32src & 0xffff0000) | ( u16src1 & 0xffff);
	//p_u32ALUCR = p_u32ALUCR & 0xfffffffe;
	ACCAddD16_01( u32src, p_pACC, p_pStatReg, p_u32ALUCR);

}

/*******************************************************************/
void ACCAdd20Once(DSPU32 p_u16Src, DSPU20 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
    //*p_pStatReg &= BIT(ALU_AUS) | BIT(ALU_AVS) | BIT(ALU_AOS)  | BIT(ALU_AIS) | BIT(13); 
     
    DSPU20 Src1(p_u16Src);
    
    bool p_bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    
    ///添加080718 按照主任要求累加/累减受饱和控制位 控制 
    bool p_bolStau   = TestFlag(p_u32ALUCR, ALU_Ctl_Saturation);
    /*
    if (p_bolSigned)
    {
        Src1.SignExtend();
    }
	*/
    DSPU20 Src2 = *p_pACC;
    DSPU20 u20Result;
    u20Result = Src1 + Src2;
    
    bool bolOverflow = !Src1.Sign() && !Src2.Sign() && u20Result.Sign();
    bool bolUnderflow = Src1.Sign() && Src2.Sign() && !u20Result.Sign();                        
    
    bool bolCarryFlag = ((Src1.Sign() != Src2.Sign()) && !u20Result.Sign()) 
                        || (Src1.Sign() && Src2.Sign());        
    
    bool bolUnsignedOverflow = bolCarryFlag;   
    
    bool bolSigned = TestFlag(p_u32ALUCR, ALU_Ctl_Signed);
    bool bolOvfFlag = bolOverflow  || bolUnderflow;    
    if ((bolSigned && bolOvfFlag) || (!bolSigned && bolUnsignedOverflow) ) //26-10-07 08:54
    {
        ///只有饱和才会置位标志位 
        if(p_bolStau) 
        {
            SetFlag(*p_pStatReg, ALU_OverFlow); 
            SetFlag(*p_pStatReg, ALU_AOS);  
			SetFlag(*p_pStatReg, 5); 
            SetFlag(*p_pStatReg, 13);  
        }                 
    }    
    
    
    if (p_bolSigned)
    { 
        ///0722添加受饱和控制 
        if (bolOverflow&&p_bolStau)
        {
            u20Result.SetToMAX_SN_20();
        }
        ///0722添加受饱和控制 
        if (bolUnderflow&&p_bolStau)
        {
            u20Result.SetToMIN_SN_20();
        }   
    } 
    else         
        {
            ///0722添加受饱和控制 
            if (bolUnsignedOverflow&&p_bolStau)
            {                    
                 u20Result.SetToMAX_UN_20();   
            }   
        }
    
    *p_pACC = u20Result;       
}

/******************************************************************
	函数名：	  ACCSelfAdd

	对应指令形式: LHACCm=HHACC+LHACC
				  LHACCm=HHACC+LHACC(U)

	描述:		将ACC的高低20位相加，结果存入ACC低20位，高20位保持不变。

	参数:		p_pACC -- p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSelfAdd(DSP_BIT40 *p_pACC, DSPU8 *p_EXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
//extern void ACCSelfAdd(DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR)
{
   
    *p_EXP = 0;

    DSPU20 u20UpperSrc2 ((DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) ));
    DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low)); 
    
    DSPU32 UpperReg = *p_pStatReg;
    DSPU32 LowerReg = *p_pStatReg;
    DSPU32 u32src = (DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) );

    ACCAdd20Once(u32src, &u20LowerSrc2, &LowerReg, p_u32ALUCR);

    DSP_BIT40 u40Result;
    u40Result.u32Low = u20LowerSrc2.GetU32();
    u40Result.u8High = 0x0;
    
    *p_pACC = u40Result;
    *p_pStatReg = LowerReg;


}


/******************************************************************
	函数名：	  ACCSelfAdd

	对应指令形式: LHACCm=HHACC-LHACC
				  LHACCm=LHACC-HHACC
                  LHACCm=-HHACC-LHACC
				  

	描述:		将ACC的高低20位相加，结果存入ACC低20位，高20位保持不变。

	参数:		p_pACC -- p_pACC -- 指向40位累加结果的指针。
					p_pStatReg -- 指向标志寄存器输出缓存的指针，所指内存区域初始为0。	
					p_u32ALUCR -- ALU控制寄存器，其第0位被算法库扩展用于表示源操作数是否为有符号数。
					    p_u32ALUCR[0] == 1： 源操作数为有符号数
					    p_u32ALUCR[0] == 0： 源操作数为无符号数
					

	返回值：		无。

	注意事项:		根据计算结果设置标志寄存器中的相关标志位；
					    根据计算结果更新累加结果。

	修改记录
	--------------------------------------
	日期			作者			修改处
	
	*******************************************************************/
extern void ACCSelfSub(DSP_BIT40 *p_pACC, DSPU8 *p_EXP, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,int flag)
//extern void ACCSelfSub(DSP_BIT40 *p_pACC, DSPU32 *p_pStatReg, DSPU32 p_u32ALUCR,int flag)//1 2 3
{
   
    *p_EXP = 0;
    //1 LHACCm=HHACC-LHACC
	if (flag == 1)
	{
		    DSPU20 u20UpperSrc2 ((DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) ));

			DSPU32 u32Lacc = p_pACC->u32Low & 0xfffff;
			u32Lacc = (~u32Lacc + 1) & 0xfffff;
			

			//DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low));
			DSPU20 u20LowerSrc2 ((DSPU32)(u32Lacc)); 
		    
			DSPU32 UpperReg = *p_pStatReg;
			DSPU32 LowerReg = *p_pStatReg;
			DSPU32 u32src = (DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) );

			ACCAdd20Once(u32src, &u20LowerSrc2, &LowerReg, p_u32ALUCR);

			DSP_BIT40 u40Result;
			u40Result.u32Low = u20LowerSrc2.GetU32();
			u40Result.u8High = 0x0;
		    
			*p_pACC = u40Result;
			*p_pStatReg = LowerReg;
		

		
	}

	//2 LHACCm=LHACC-HHACC
	if (flag == 2)
	{
		    DSPU20 u20UpperSrc2 ((DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) ));
			DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low)); 
		    
			DSPU32 UpperReg = *p_pStatReg;
			DSPU32 LowerReg = *p_pStatReg;
			DSPU32 u32src = (DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) );
			u32src = (~u32src + 1) & 0xfffff; 

			ACCAdd20Once(u32src, &u20LowerSrc2, &LowerReg, p_u32ALUCR);

			DSP_BIT40 u40Result;
			u40Result.u32Low = u20LowerSrc2.GetU32();
			u40Result.u8High = 0x0;
		    
			*p_pACC = u40Result;
			*p_pStatReg = LowerReg;
		
	}

	//3 LHACCm=-HHACC-LHACC

	if (flag == 3)
	{
		    DSPU20 u20UpperSrc2 ((DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) ));
			//DSPU20 u20LowerSrc2 ((DSPU32)(p_pACC->u32Low)); 
		    DSPU32 u32Lacc = p_pACC->u32Low & 0xfffff;
			u32Lacc = (~u32Lacc + 1) & 0xfffff;
			DSPU20 u20LowerSrc2 ((DSPU32)(u32Lacc)); 

			DSPU32 UpperReg = *p_pStatReg;
			DSPU32 LowerReg = *p_pStatReg;
			DSPU32 u32src = (DSPU32)( (((DSPU32)p_pACC->u8High) << 12) | (p_pACC->u32Low >> 20) );
			u32src = (~u32src + 1) & 0xfffff; 

			ACCAdd20Once(u32src, &u20LowerSrc2, &LowerReg, p_u32ALUCR);

			DSP_BIT40 u40Result;
			u40Result.u32Low = u20LowerSrc2.GetU32();
			u40Result.u8High = 0x0;
		    
			*p_pACC = u40Result;
			*p_pStatReg = LowerReg;
		
	}

}

